{
  "courseId": 4,
  "version": 1,
  "courseName": "Programmazione 2",
  "lectures": [
    {
      "lectureId": 46,
      "lectureTitle": "Event Handling in Java FX",
      "questions": [
        {
          "questionId": 4312,
          "asker": {
            "courseId": 4,
            "askerId": 480,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi o svantaggi comporta l'utilizzo di un EventHandler definito internamente piuttosto che la creazione di una classe ed esso dedicata estremamente? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " visibilità "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4325,
          "asker": {
            "courseId": 4,
            "askerId": 426,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa è un event handling?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": "handling"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4268,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Per definire le conseguenze, ad esempio, di un bottone, risulta più conveniente implementare una classe Listener esterna (o rispettivamente interna) alla classe originale o, come fa NetBeans di default, implementare un metodo che crei un EventHandler per ogni bottone? (col comando button.setOnAction(new eventHandler<ActionEvent>() {...});",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Netbeans"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4335,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "se l'azione è ripetitiva e simile per ogni bottone è molto più semplice e intuitivo implementare una classe listener. Invece se hai pochi bottoni e magari che svolgono funzioni diverse, è più semplice implementare un listener relativo solamente a quel bottone proprio come fa netbeans col comando button.setOnAction",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4289,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 523,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per definire le conseguenze è più conveniente implementare una classe Listener esterna/interna. In questo modo potremo modificare la nostra classe senza aver problemi che si possono scontrare utilizzando eventHandler creato di default da NetBeans.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4319,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 590,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Partendo dal presupposto che dipende principalmente dall'implementazione del programma: se ci sono pochi eventi è consigliabile usare un EventHandler per ogni bottone, altrimenti per gestire grandi quantità di eventi è meglio avere una classe Listener.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4375,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Risulta più facile implementare un metodo che crei un EventHandler per ogni bottone con il comando setOnAcrion.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4341,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo vengono gestiti gli ascoltatori in Java FX?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interno"
            },
            {
              "keyword": "esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4254,
          "asker": {
            "courseId": 4,
            "askerId": 537,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la classe Listener?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ascoltatore"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4280,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile creare un campo TextField che non sia modificabile dall'utente?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "TextField"
            },
            {
              "keyword": " campo"
            },
            {
              "keyword": " campi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4354,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Sì. TextField è sottoclasse di TextInputControl e quindi ne eredita tutti i metodi; in TextInputControl è presente il metodo \"setEditable(boolean value)\", che permette di specificare se il campo può essere modificato o meno dall'utente. Quindi si può rendere non modificabile un campo TextField utilizzando l'istruzione (supponendo \"field\" oggetto di tipo TextField):\r\nfield.setEditable(false);\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4295,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 454,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "é possibile creare un campo non modificabile dall'utente con un testo prefissato grazie ad un particolare costruttore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4378,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Si, basta specificare all'interno del codice \"nomeListener.setEditable(false)\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4337,
          "asker": {
            "courseId": 4,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come può essere definito un event? Fornire anche qualche esempio",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4249,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un'eccezione e come si trappa? Perché è fondamentale trappare le eccezioni?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eccezioni"
            },
            {
              "keyword": " java FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4323,
          "asker": {
            "courseId": 4,
            "askerId": 527,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono Group, Shape e Circle?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Group"
            },
            {
              "keyword": " Shape"
            },
            {
              "keyword": " Circle"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4295,
          "asker": {
            "courseId": 4,
            "askerId": 473,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella slide n°14 del 15 aprile viene definito un self listener. Coma mai quando si invoca il metodo addEventHandler il secondo parametro è this?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " self"
            },
            {
              "keyword": " this"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4350,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè si usa Java FX?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java FX"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4282,
          "asker": {
            "courseId": 4,
            "askerId": 559,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra listener interno ed esterno? In base a cosa si preferisce l'uno all'altro?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": "interno"
            },
            {
              "keyword": "esterno"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4356,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 593,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Sono dei metodi che servono per organizzare gli ascoltatori. Il listener interno va a risparmiare alcune righe di codice.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4303,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Un listener interno rispetto ad un listener esterno viene definito all'interno della classe principale mentre quello esterno viene definito separatamente. Si preferisce usare un listener interno nel caso si voglia avere accesso alle variabili d'istanza ( anche private ) della classe dell'applicazione. In caso contrario si consiglia l'uso di un listener esterno per rendere meno pesante la classe principale.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4307,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Come dicono i rispettivi nomi, i listener interni vengono definiti all'interno della main class, mentre quelli esterni esternamente. \r\nNel caso di quelli esterni, per ogni oggetto che richieda un osservatore, sarà necessario passare al listener i diversi riferimenti, impegnando così processi di troppo. \r\nIn genere quindi, si preferisce usare i listener interni, che si implementano direttamente nelle classi di gestione interfaccia utente, ovvero dove è necessario! Inoltre si può scegliere se usare listener interni anonimi, che non impongono la creazione di un costruttore per essi, che dunque rendono più scorrevole la lettura del codice.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4296,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il listener interno è contenuto nella classe che lo usa, quello esterno è una classe a parte.\r\n\r\nIl listener interno è da preferire a quello esterno in quanto è più semplice e veloce da scrivere e non va ad inquinare inutilmente lo spazio dei nomi (meno cose hai in giro meglio è).",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4310,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono vantaggi e svantaggi dell'utilizzo di un listener interno invece di uno esterno?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Differenze"
            },
            {
              "keyword": " listener"
            },
            {
              "keyword": " interno"
            },
            {
              "keyword": " esterno"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4297,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "svantaggi INTERNO risp all'ESTERNO\r\n- per molti bottoni ad esempio bisogna creare un sacco di listener\r\n  mentre per quello esterno ne crei uno e lo passi ai vari bottoni.\r\n\r\nvantaggi INTERNO risp all'ESTERNO\r\n- non devi creare una classe per implementare solo uno stupido metodo\r\ninoltre hai molta \"localita' del codice\" perche' il codice del bottone e'\r\n\"esiste ed e' unico [cit. Ghiloni]\" solo li dove crei il bottone :D\r\n\r\n<b><u>Cia Cia</u></b>",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4287,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 578,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Maggior leggibilità del codice della classe Listener, collegamento immediato con le azioni da eseguire. Possono esserci svantaggi di avere un codice lungo e ci vuole più tempo a ricercare la classe Listener per modificarla, ovviamente definirla esterna implica una maggior lunghezza del codice della classe",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4327,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Implementare un listener interno rende il codice più compatto e di conseguenza una visione più ampia. Con un listener esterno dovrei aprire la classe del listener e andare a capire cosa fa quella classe per poi tornare al codice in cui viene usato il listener. D'altra parte un listener esterno è preferibile (imho) quando il codice legato all'evento inizia a essere articolato. Per esempio in un programma per giocare a scacchi all'evento \"muovi pezzo\" seguirebbero dei metodi del tipo \"controlla se lo spostamento è lecito\",\"sposta il pezzo\",\"controlla se il re è in scacco\" etc. per cui appesantirebbero la lettura del codice riguardante la parte grafica.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4298,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 547,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Usare classi interne per i Listener ne rende lo scopo molto chiaro, e ha il vantaggio di un accesso diretto a tutti gli oggetti e i loro metodi. Richiede però un approccio di 'metodo dentro a un metodo' (con l'handler chiamato dall'interno) e ciò tende a risultare in copiose quantità di codice e molteplici event handlers (uno per ogni bottone, componente....)",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4304,
          "asker": {
            "courseId": 4,
            "askerId": 591,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "a cosa serve la circle class?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4263,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale tipo di Listener conviene usare?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " conviene"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4265,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un evento?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "cosa"
            },
            {
              "keyword": "evento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4247,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci sono delle librerie che javaFX non puo importare in automatico?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pulsanti"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4253,
          "asker": {
            "courseId": 4,
            "askerId": 548,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi ottengo se utilizzo la tecnica delle subclassi per gestire gli eventi?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "subclass"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4319,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali tipi di eventi che possono essere associati ad un componente (button, image, ...) di un programma JavaFX?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " eventhandler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4317,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Da un punto di vista generale, basta dire che la maggior parte degli Event e EventHandler sono integrati con i componenti al livello della classe Node. Parlare di eventi specifici per un componente sarebbe sì forse una selezione naturale, ma non molto veritiera.\r\nCerto, da un punto di vista intuitivo, è normale associare un componente come un Button alla sua naturale funzione di essere premuto dall'utente, tuttavia si può monitorare anche solo se il mouse viene spostato su o fuori di esso.\r\nDa un punto di vista pratico/utlitaristico, se non si hanno grandi esigenze, è più semplice consultarsi la documentazione di ciascun componente di volta in volta, al momento del bisogno (provare con mano è un buon metodo d'apprendimento).\r\nSe si vuole approfondire, la documentazione di JavaFX contiene diverse (tante) pagine sugli Event, EventHandler e EventFilter. Il discorso è vasto almeno quanto quello dedicato ai componenti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4336,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il tipo di un'istanza di una sottoclasse di Event, che viene generata durante l'esecuzione di un programma, viene registrato nel campo eventType di tipo EventType dell'istanza stessa. I tipi di evento salvati in eventType sono organizzati in maniera gerarchica in modo che ogni singolo tipo di evento, come MouseEvent.MOUSE_PRESSED, possa essere riconosciuto anche come un tipo di evento più generale appartenete però alla stessa catena di ereditarietà. MouseEvent.MOUSE_PRESSED può infatti essere riconosciuto anche come MouseEvent.ANY, InputEvent.ANY o come Event.ANY. Esaminando in dettaglio l'albero della gerarchia, a partire dalla radice Event.ANY si originano tre rami: InputEvent.ANY, ActionEvent.ACTION (senza ulteriori ramificazioni) e WindowEvent.ANY (visibilità e modifica della finestra). Da InputEvent.ANY si dipanano ulteriori rami tra cui MouseEvent.ANY, da cui si originano tutti gli eventi correlati con il mouse, e KeyEvent.ANY, per tutti gli eventi collegati alla tastiera.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4322,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 592,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Dato che i componenti in JavaFX implementano l'interfaccia \"EventTarget\" che comporta l'implementazione dei vari metodi che gestiscono vari eventi, ad esempio la gestione degli input dell'utente e la gestione del visualizzazione sullo schermo.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4368,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 503,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Gli eventi sono definiti nella classe EventObject del package java.util. In particolare, gli eventi che occorrono nelle interfacce grafiche fanno capo alla classe astratta AWTEvent del package java.awt, raggruppati in classi sulla base della tipologia dei componenti che li hanno generati. Per le finestre ad esempio abbiamo gli eventi closed, opened, ecc.\r\n(Dalla documentazione dell'Oracle).",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4347,
          "asker": {
            "courseId": 4,
            "askerId": 584,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestita la gestione di eventi con javaFx",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": " gestione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4313,
          "asker": {
            "courseId": 4,
            "askerId": 557,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "A lezione si è visto come si può far compiere determinate azioni a delle strutture mediante event handlers. Come posso creare un bottone che una volta premuto stampi (non per forza in un text, anche con println) ad esempio \"click\"?\r\n(basta la parte di codice relativa al bottone)",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event handler"
            },
            {
              "keyword": " bottone"
            },
            {
              "keyword": " action"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4276,
          "asker": {
            "courseId": 4,
            "askerId": 568,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'event Handling in Java FX? <3",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": " handling"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4251,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "quali sono i vantaggi e svantaggi di creare il listener interno?:)",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": "ups"
            },
            {
              "keyword": "downs"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4279,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "spiega cos'è java fx",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " fx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4328,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e/o gli svantaggi derivanti dall'utilizzo di un Listener INTERNO rispetto ad un Listener ESTERNO?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "event handling"
            },
            {
              "keyword": " listener"
            },
            {
              "keyword": " ascoltatore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4362,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Si parla di Listener ESTERNO quando l'applicazione e il Listener sono due classi separate, per cui, per poter accedere alle variabili d'istanza dell'Applicazione, il Listener deve avere una variabile d'istanza di tipo Applicazione, e un costruttore che la inizializzi ad una Applicazione presa come parametro, al quale, quando il Listener viene istanziato nella classe Applicazione, viene passata l'Applicazione this. Si parla invece di Listener INTERNO quando la classe Listener è definita all'interno dello scope della classe Applicazione; per questo motivo, il Listener può accedere alle variabili d'istanza dell'Applicazione stessa, senza bisogno di variabili d'istanza e costruttori ausiliari nella classe Listener. Il vantaggio di un Listener interno è quello di avere una struttura più snella rispetto ad un listener Esterno, il quale però potrebbe essere condiviso da più applicazioni, a differenza di un listener interno, che è utilizzabile solo dall'Applicazione in cui è definito.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4324,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il vantaggio principale è che puoi utilizzare all'interno del Listener (Interno) le variabili dichiarate nella classe principale, lo svantaggio è quello di dover gestire tutto all'interno della classe principale, quindi è più uno svantaggio che riguarda l'ordine del codice.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4320,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 529,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "...",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4284,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "I vantaggi sono soprattutto nella migliore creazione del codice in quanto nella creazione del listino interno è possibile vedere immediatamente la sua funzione.  Invece, con un listino esterno,  potendo essere dedicato a più utilizzi,  ci si potrebbe confondere sul suo effettivo ruolo.  Questo ultimo però permette di creare codici che possono adempiere a più funzioni in quanto il listino esterno può prendere in input le azioni eseguite su più elementi della gui ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4291,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "La differenza sostanziale tra un listener interno ed un listener esterno consiste nel fatto che ad un listener esterno è necessario passare come parametro un riferimento alla classe in cui si sta operando se si ha la necessità di modificare oggetti o variabili contenuti all'interno della classe stessa. Il riferimento passato infatti serve per poter accedere agli oggetti privati della classe. Un listener interno invece non necessità di questo accorgimento in quanto è contenuto nella classe in cui si opera e di conseguenza ha accesso hai suoi oggetti.\r\nDi fatto non esistono dei veri e propri vantaggi e/o svantaggi ma solo la scelta di voler mantenere o no i listener separati dalla classe in cui operano.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4308,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Se Listener e' una classe che implementa EventHandler (come sulle slide del prof):\r\nSia A una classe e L un \"suo\" Listener:\r\nSe L interno ad A è definito ed esiste al suo interno, L ha quindi visibilita' ridotta alla sola classe A inoltre, essendo interno, vede le var. d'istanza della stessa.\r\nSe L esterno ad A esiste fuori dalla classe quindi puo' essere usato per gestire eventi su elem. appartenenti diverse classi, pero' e' necessario qualche accorgimento in piu'per mod. variab. d'istanza e operare sulla classe in risposta a eventi. \r\nL deve agire su A, quindi deve avere come var. d'istanza un ogg. di tipo A (L has a A), tale var. verra' inizializz. dal costrutt. di L, cosi' creiamo una associaz. tra L e un ogg. di tipo A. Ora nel metodo handle di L chiamiamo un metodo di A che permette di mod. le var. d'istanza di A per ottenere l'effetto voluto (vedi slide JavaFx2 pag. 27)\r\nInterno: \"comodo\" ma non riutilizzabile\r\nEsterno: + \"scomodo\" ma riutilizzabile",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4266,
          "asker": {
            "courseId": 4,
            "askerId": 445,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "come si usa e a cosa serve il TilePane?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "TilePane"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4383,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "TilePane è una classe Java che dispone tutti i suoi nodi figli in una griglia uniforme di \"mattonelle\" di forma rettangolare, la grandezza delle quali si adatta automaticamente a quella del nodo più grande che deve contenere. Questa griglia può essere orientata in verticale o in orizzontale, a seconda delle necessità. TilePane è dotato di quattro metodi costruttori, che si differenziano a seconda del tipo dei loro argomenti.\r\nLa lista completa dei metodi di questa classe è consultabile online, ma fra quelli più popolari troviamo add (per aggiungere un nodo), getChildren (per ottenere una lista dei nodi figli di un TilePane), setVgap/setHgap (per fissare la spaziatura verticale/orizzontale tra due mattonelle), setPrefRows/setPrefColumns (per indicare il numero preferito di righe/colonne della griglia) e setAlignment (per fissare l'allineamento di un nodo figlio).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4366,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 581,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il TilePane serve per impostare il layout di un'applicazione java, disponendo elementi al suo interno in celle scalabili in base alla dimensione dell'elemento stesso, che si dividono in base alla larghezza della finestra, nel caso di TilePane orizzontale, o all'altezza, in caso di TilePane verticale. Per utilizzarlo bisogna crearne un'istanza, impostare eventuali preferenze, quali ad esempio gap tra le celle, ed aggiungere elementi all'interno di celle tramite il metodo .add() dell'elemento restituito da .getChildren() del TilePane stesso.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4339,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 460,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "TilePane è una public class, estensione di Pane che dispone i suoi figli (nodi) in una struttura a griglia, composta da \"mattonelle\" (tiles), tutte di uguale dimensione, stabilita in automatico in modo da poter contenere il nodo più grande. Le tiles sono ordinate di default per righe (horizontal TilePane) a partire dalla posiz. TOP_LEFT, ma si possono disporre anche per colonne (vertical TilePane; concretamente si scriverà TilePane tp=new TilePane(Orientation.VERTICAL)) e/o a partire da un'altra posizione. È buona norma inizializzare le dimensioni preferite delle tiles, tramite setprefTileWidth e setprefTileHeight, il numero di elementi contenuti in ogni riga (in horizontal TilePane) o colonna (in vertical TilePane) risp. con setprefColumns e setprefRows, e lo spazio fra ogni riga/colonna con setHgap e setVgap: tali valori verranno rispettati solo quando possibile. TilePane si presta ottimamente alla creazione di \"tabelle\" con molti comandi e vari tipi di nodi (per es la calcolatrice).",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4271,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa ci permette di fare l'interfaccia EventHandler??",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Event"
            },
            {
              "keyword": " Handler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4310,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "The EventHandler class provides support for dynamically generating event listeners whose methods execute a simple statement involving an incoming event object and a target object.\r\n\r\nThe EventHandler class is intended to be used by interactive tools, such as application builders, that allow developers to make connections between beans. Typically connections are made from a user interface bean (the event source) to an application logic bean (the target). The most effective connections of this kind isolate the application logic from the user interface. For example, the EventHandler for a connection from a JCheckBox to a method that accepts a boolean value can deal with extracting the state of the check box and passing it directly to the method so that the method is isolated from the user interface layer.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4340,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "EventHandler consente di implementare il supporto per listener di eventi generati dinamicamente. \r\nAd esempio il seguente pezzo di codice\r\n bottone.addActionListener(\r\n    (ActionListener)EventHandler.create(ActionListener.class, frame, \"toFront\"));\r\n\r\nfa in modo che quando io prema il bottone venga invocato il metodo toFront() della istanza javax.swing.JFrame.\r\nAllo stesso modo, posso invocare altri metodi, compresi listener creati dal programmatore stesso. Posso così gestire più eventi con un solo listener (ad esempio, nella calcolatrice, posso gestire i 4 bottoni con un solo metodo invece di dover scrivere un metodo per ogni bottone).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4276,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 470,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Ci permette di usare gli eventi come il click, lo spostamento del mouse ecc",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4302,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "L'interfaccia EventHandler ci permette in generale di gestire gli eventi. Una volta che si scrive la funzione handle, e una volta che si definisce con quale evento deve esser chiamata un certo Listener, il programma javafx gestisce da solo l'utilizzo della funzione ogni volta che avviene l'evento.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4325,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 496,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "L'interfaccia EventHandler ci permette di definire un gestore di eventi in grado di associare a degli eventi (come il click del mouse, il passaggio del mouse in una determinata zona, ecc...) delle specifiche azioni da eseguire.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4338,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione del Listener in Java FX?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Java FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4275,
          "asker": {
            "courseId": 4,
            "askerId": 437,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si implementano degli eventhandler nei programmi è preferibile fare uso di molti Listener differenti per le varie tipologie di eventi nei quali si può incorrere durante l'esecuzione oppure racchiuderli tutti in un unico Listener?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener "
            },
            {
              "keyword": " eventhandling"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4285,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "hm, bella domanda) ma penso, che meglio scrivere ogni listener nella classe dove si usa quel eventhandler, cosi si sa che la classe di listener interno deve gestire gli eventi solo di quella particolare classe e si riferisce solo a lei:)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4331,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "È meglio differenziare i diversi tipi di eventi in cui si incorre, cercando ovviamente di non esagerare con i numeri. Chiaramente più specifico è il trattamento a seconda dell'evento in cui si incorre, meglio funzionerà il programma",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4318,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Dipende dal tipo di eventi e dai controlli associati:\r\nSe possibile è preferibile usare un unico Listener facile da individuare/modificare senza creare disordine nel codice. In genere però risultano comodi più Listener specializzati che rendono il programma diviso per funzioni e più leggibile. Inoltre viene più facile individuare gli errori e non è necessario creare scrivere un Listener unico complesso",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4307,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra:\r\n-Listener Interno\r\n-Listener Esterno\r\n-Listener Esterno Anonimo\r\n-Self Listener",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ListenerInt"
            },
            {
              "keyword": "ListenerEst"
            },
            {
              "keyword": "ListenerAnonim"
            },
            {
              "keyword": "SelfListener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4349,
          "asker": {
            "courseId": 4,
            "askerId": 555,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra un listener esterno ed uno interno?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener esterno"
            },
            {
              "keyword": " listener interno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4270,
          "asker": {
            "courseId": 4,
            "askerId": 565,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è pa differenza tra un Listener interno ed uno esterno?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " ascoltatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4336,
          "asker": {
            "courseId": 4,
            "askerId": 593,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "a cosa serve la seguente riga di codice? Listener a=new Listener(this);",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " fx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4327,
          "asker": {
            "courseId": 4,
            "askerId": 430,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenze ci sono tra la definizione di una classe listener tramite tipo anonimo o \"inline\" e tramite definizione normale? Perché e quando si usa una o l'altra? :)",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tipi anonimi"
            },
            {
              "keyword": " inline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4288,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Listener interno ed esterno?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4314,
          "asker": {
            "courseId": 4,
            "askerId": 477,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile registrare un EventHandler su un nodo affinché gestisca tutti gli eventi che riguardano il mouse, tranne l'evento di MouseClick, senza specificare in dettaglio il tipo di eventi uno ad uno?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "mouse"
            },
            {
              "keyword": " eventhandler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4287,
          "asker": {
            "courseId": 4,
            "askerId": 576,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è fra un listener esterno e un listener interno",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener interno"
            },
            {
              "keyword": " listener esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4259,
          "asker": {
            "courseId": 4,
            "askerId": 523,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono gli eventi? E qual'è la loro funzionalità?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "evento"
            },
            {
              "keyword": " funzionalità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4344,
          "asker": {
            "courseId": 4,
            "askerId": 516,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un Listener Interno Anonimo?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Interno"
            },
            {
              "keyword": " Anonimo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4335,
          "asker": {
            "courseId": 4,
            "askerId": 463,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si usano i Listener?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4261,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i tipi di listener visti a lezione? indicare anche le principali differenze a livello di scrittura del codice.",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EVENT"
            },
            {
              "keyword": " LISTENER"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4332,
          "asker": {
            "courseId": 4,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa s'intende per scene, stage, parent e node in javaFX?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "events"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4346,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "La gerarchia corretta è Stage(Finestra) che contiene una Scene(Contenitore); una Scene ha dei Parent(Contenuti) e un Parent è un Node (quindi eredita da Node). Lo Stage è la finestra vera e propria che verrà creata durante l'esecuzione della nostra Applicazione. Lo Stage contiene una Scene che verrà usata per posizionare i Parent (per esempio Circle, Text, Button e altre SottoClassi derivanti dalla classe Shape). Parent eredita da Node dei comportamenti; in quanto Node è la classe base per la grafica di JavaFX ed è abstract.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4364,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 489,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Quando si programma in javaFX è importante distinguere i vari elementi su cui si lavora per modellare la grafica. Lo stage rappresenta la finestra ed è quindi lo spazio totale in cui si va ad operare. La scena è invece il nostro \"contenitore\", dentro a cui mettiamo tutti gli oggetti che vogliamo inserire e che vogliamo far apparire all'interno dello stage. Il node è l'unità più piccola e su questa andiamo a lavorare nello specifico, quindi un node potrà essere, ad esempio, un bottone o una casella di testo. Il parent è un node e può contenere più node all'interno di esso, un esempio di parent è Group.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4353,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 422,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Sono i componenti base per la costruzione di UI con JavaFX. Sono strettamente legati tra di loro a causa delle loro relazioni di parentela.\r\n* Stage è una finestra.\r\n* Scene è un oggetto contenuto in uno Stage.\r\n* Qualiasi Scene ha un Parent\r\n* Il Parent è un Node\r\n\r\nSono in ordine dal contenitore al contenuto.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4381,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "The JavaFX Scene class is the container for all content in a scene graph. The JavaFX Stage class is the top level JavaFX container. Parent :the base class for all nodes that have children in the scene graph.Each item in the scene graph is called a Node. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4309,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè gestire immagini con javafx è così complicato? \r\ncome si crea  un istanziazione della classe Image affinchè apri per esempio il file \"pippo.png\" contenuto nella stessa directory dell'eseguibile?\r\nes: Image immagine=new Image (\"????\")",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Image"
            },
            {
              "keyword": " Javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4324,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra Listener interno e Listener esterno a una classe?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Event Handling"
            },
            {
              "keyword": " Listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4285,
          "asker": {
            "courseId": 4,
            "askerId": 444,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il multilistener?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Multilistener"
            },
            {
              "keyword": " Event Handling"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4353,
          "asker": {
            "courseId": 4,
            "askerId": 422,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Dovendo dichiarare un generico event handler, qual è il miglior modo per averne sempre un riferimento, di modo da evitare che il garbage collector non lo rimuova dalla memoria?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": "gc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4346,
          "asker": {
            "courseId": 4,
            "askerId": 530,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "L'Events è una classe che permette di interagire con il Sistema Operativo?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Events"
            },
            {
              "keyword": " "
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4311,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono gli eventi?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4316,
          "asker": {
            "courseId": 4,
            "askerId": 573,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali informazioni racchiude la classe MouseEvent?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "mouse"
            },
            {
              "keyword": " event"
            },
            {
              "keyword": " informazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4339,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che caratteristiche ha uno Stage?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stage"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4289,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra il comparatore == e equals?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "=="
            },
            {
              "keyword": " equals"
            },
            {
              "keyword": " comparatore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4299,
          "asker": {
            "courseId": 4,
            "askerId": 595,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano e che compito svolgono gli event handler in java fx?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Event Handler"
            },
            {
              "keyword": " java fx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4318,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile risalire a quale componente ha generato l'evento all'interno di una classe di ascolto che implementa EventHandler?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "events"
            },
            {
              "keyword": " javaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4351,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 542,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Event Handler implementa alcuni metodi, come getAction o getTarget, che permettono di sapere appunto il target, il tipo di azione che innesca eccetera. ",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 4361,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "tramite listener",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4352,
          "asker": {
            "courseId": 4,
            "askerId": 578,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione del TilePane?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "TilePane"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4290,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "permetterci di lavorare con layouts in java",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4278,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "La funzione del TilePane è quella di creare un'interfaccia suddivisa in colonne in modo da poter disporre gli elementi ordinatamente e facendo in modo che si auto-riposizionino quando la finestra viene ridimensionata.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4304,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": ".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4350,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 469,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il Tile pane e' un contenitore definito in java fx, e' usato per mettere elementi in righe e colonne definite dal programmatore in celle di grandezza uguale.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4377,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 457,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il TilePane permette di definire delle colonne in cui instanziare oggetti, come dei bottoni. Questa funzione permette di definire varie cose tra cui il numero di colonne, la loro larghezza e lo spazio che deve inrercorrere tra i vari oggetti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4294,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "la funzione del TilePane è quella che crea il TilePane",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4298,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Fornire una classificazione quantitativa e una qualitativa che una calcolatice implementata in Java dovrebbe avere.",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "implementazione"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4292,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come gestisce gli eventi Java?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " gestione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4269,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si implementa l'interfaccia grafica di un' applicazione in xml?",
          "totalDifficultyLevel": 22,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "xml"
            },
            {
              "keyword": " interfaccia"
            },
            {
              "keyword": " grafica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4297,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega le principali differenze tra listener interno ed esterno",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4321,
          "asker": {
            "courseId": 4,
            "askerId": 517,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli strumenti per gestire gli Eventi in FX?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "strumenti"
            },
            {
              "keyword": " Eventi"
            },
            {
              "keyword": " FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4315,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale strumento si può utilizzare per catturare gli eventi sulle componenti grafiche, come lo schiacciarsi di un bottone; quale logica utilizza?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4305,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "è meglio utilizzare un listener intero o esterno ? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " evento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4267,
          "asker": {
            "courseId": 4,
            "askerId": 488,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "è possibile accedere a variabili interne alla classe principale utilizzando un \"Listner\" esterno ad essa?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listner"
            },
            {
              "keyword": " esterno"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4337,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "A parte che si scrive\" Listener\", si è possibile ma sconsigliabile poichè la comodità di avere un \"listener\" interno si evince dal fatto che tutto ciò che è dichiarato all'interno della classe main può essere tranquillamente utilizzato da un \"listener\" interno, cosa invece non possibile nel caso di una classe \"Listener\" esterna che dovrebbe essere implementata a dovere (con conseguente perdita di tempo e leggibilità).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4382,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 567,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Si, è possibile accedere a variabili interne ad una classe principale utilizzando variabili esterne, purché la variabili a cui voglio accedere siano dichiarate FINAL. Questa strategia infatti non obbliga le variabili ad assumere un valore costante come si potrebbe sospettare. Essa in realtà mantiene fisso l'indirizzo a cui si trovare il contenuto cercato.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4332,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 500,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Si, basta trattarlo come una qualunque altra classe esterna cioè allocando il Listener nella classe principale cosi che possa accedere alle variabili interne del main.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4379,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 477,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Sì, ammesso che il listener conosca l'istanza della classe principale e che le variabili di questa siano visibili nel contesto del listener.\r\n\r\nAd esempio un listener può avere un costruttore che prende come parametro l'istanza della classe principale e la salva in una sua variabile interna, cosicché nel suo metodo \"handle\" possa accedere alle variabili della classe principale usando la consueta notazione \"<identificatore>.<variabile_di_istanza>\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4351,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Si si dovesse implementare un Listener Interno alla classe estesa come Application, le variabili all'interno dell'Listener sarebbero visibili dall'Application?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " inner class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4274,
          "asker": {
            "courseId": 4,
            "askerId": 592,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale evento deve gestire il KeyEventHandle e da quale dispositivo viene creato?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "EventHandling"
            },
            {
              "keyword": "JavaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4348,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Un KeyEvent viene generato alla pressione e rilascio di un carattere della tastiera e per intercettarlo bisogna implementare l'intefaccia KeyListener.\r\nEsempio:\r\n\r\nPer sapere cosa è stato premuto bisogna controllare e.getKeyChar().\r\n\r\ntextField1.addKeyListener(new KeyListener()\r\n{\r\n    @Override \r\n    public void keyPressed(KeyEvent e)\r\n    {\r\n          //codice che si vuole implementare\r\n    }\r\n\r\n    @Override\r\n    public void keyReleased(KeyEvent e)\r\n    {\r\n       //codice che si vuole implementare\r\n    }\r\n              \r\n    @Override\r\n    public void keyTyped(KeyEvent e)\r\n    {\r\n       //codice che si vuole implementare\r\n    }\r\n});",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4277,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La libreria apoosita se ne occupa estendendo l evento",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4315,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La classe keyevent fornisce una costante per ognuno dei tasti presenti sulla tastiera. Queste costanti possono essere utilizzate dai gestori degli eventi di tastiera per determinare se è stato premuto un determinato tasto.\r\nOltre a ciò per determinare se sono stati premuti i tasti, ci sono dei metodi che permettono questo, dove ognuno ritorna un valore booleano che indica se quel tasto è stato premuto o meno durante l'evento della tastiera.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4363,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Il KeyEventHandler deve gestire l'evento che viene lanciato quando l'utente preme un tasto della tastiera. Questa espressione viene usata principalmente in C# , invece in java fx si utilizza semplicemente l' EventHandler dopo di che si procede a verificare, con gli opportuni \"if\",quale evento è stato lanciato.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4281,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Non lo so",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4376,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Deve gestire gli eventi creati dalla tastiera e dal mouse, quali la digitazione di testo, lo spostamento del mouse ed il click di quest'ultimo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4284,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Una classe che implementa un determinato oggetto, se creo una classe differente con varie implementazioni, questa classe devo estenderla all'oggetto creato o posso passargli direttamente alcune istanze con una super o un cast anche se non fanno parte della stessa ereditarietà?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": " oggetto"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4343,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè usare un Listener esterno?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " listener esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4277,
          "asker": {
            "courseId": 4,
            "askerId": 533,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la peculiarità dell'AncorPane?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "caratteristiche"
            },
            {
              "keyword": "AncorPane"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4292,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "L'AnchorPane permette di ancorare i vari elementi del layout in alto, in basso, a destra, a sinistra o al centro rispetto al pane in cui sono contenuti. Gli elementi possono essere ancorati anche a più di una posizione, ma è anche possibile ancorare più di un elemento alla stessa posizione. Se la finestra in è contenuto un AnchorPane viene ridimensionata, gli elementi manterranno la loro posizione relativa, cioè si sposteranno rimanendo ancorati alla posizione stabilita.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4299,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il layout AnchorPane (perché sì, ci va l'\"h\") permette di \"ancorare\" degli oggetti (come, ad esempio, dei pulsanti) in un punto della finestra (in alto, in basso, a destra, a sinistra o al centro). In questo modo si evita che, ridimensionando la finestra, l'oggetto si sposti o, addirittura, esca dal campo visivo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4283,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "l'AnchorPane è una classe che permette ai nodi figli di essere ancorati al bordo del riquadro. Figli diversi possono essere ancorati in posizioni diverse e una volta fissata la distanza del figlio dal bordo, questa rimane inveriata anche dopo il ridimensionamento della finestra.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4286,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "AnchorPane (e non AncorPane) permette di sistemare degli oggetti figli nei suoi rispettivi bordi. Quindi posso, per esempio, definire un Button che stia sempre 'ancorato' al bordo sinistro del mio AnchorPane, oppure un TextField che stia sempre ancorato al bordo in basso. Stessa cosa può essere fatta per i bordi in alto e a destra.\r\nInoltre si può anche specificare la proprietà di padding per avere una certa spaziatura tra gli oggetti ancora e l'effettivo bordo dell'AnchorPane.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4301,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 518,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Semplicemente permette agli oggetti(node) al'interno della tua finestra di mantenere il layout(proporzione) prescelto anche se essa combia dimensione e formato, questo avviene grazie ad un controllo di tipo ricorsivo delle proporzioni degli oggetti nella finestra.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4371,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 549,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'AnchorPane permette ai bordi dei nodi figlio di essere ancorati a un offset dei bordi dell'anchorpane. Se l'anchorpane ha un bordo e/o un set di spessori, gli spostamenti saranno misurati dal bordo interno di tali inserti. \r\nInoltre delinea ogni figlio gestito indipendentemente dal valore della proprietà visibile da esso; i figli non gestiti vengono ignorati per tutti i calcoli di layout. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4326,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega la gestione base degli eventi in JavaFX.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4264,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali possono essere i casi in cui è meglio usare un listener interno, invece di uno esterno?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4293,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "A livello di prestazioni è meglio implementare un EventHandler esterno,interno,interno anonimo oppure un self eventHandler?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " prestazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4345,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "C'è qualche differenza, oltre che nella scrittura del codice, tra un listener interno e un listener interno anonimo? Se si fare un esempio di situazione in cui deve essere utilizzato il secondo.",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener interno"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4317,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "come funziona java fx?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzionamento"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4333,
          "asker": {
            "courseId": 4,
            "askerId": 518,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo si possono gestire più finestre contemporaneamente con java FX ?!",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " fx"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4359,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "La gestione di più finestre in java FX è resa possibile mediante la creazione di più stages, associando a questi ultimi gli \"elementi\" basilari dello schema di \"sviluppo\" impiegato da java FX (Scene,Parent,Node).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4313,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "In JavaFX, ogni finestra corrisponde a un oggetto di tipo Stage. Lo Stage \"principale\" è passato come argomento al metodo start della sottoclasse di Application. Il metodo start è invocato immediatamente nel main di questa classe. Per costruire la finestra principale è sufficiente aggiungere ciò che si vuole alla istanza di Stage argomento del metodo start e invocare su di essa il metodo 'show()'. Per costruire le altre finestre basta creare degli altri oggetti Stage e invocare su di essi il metodo show(), per esempio dalla finestra principale quando viene premuto un certo pulsante.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 4338,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Semplicemente creando tanti stage quante sono le finestre che voglio gestire.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4355,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 461,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "è possibile creare più finestre contemporaneamente i java fx, creando due diversi stage e indicandone la posizione in cui vogliamo che appaiano. Inoltre è importante ricordare che il processo termina quando l'ultima finestra creata viene chiusa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4343,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 516,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Se per gestire si intende il visualizzare più finestre contemporaneamente è sufficiente creare più istanze di finestre.\r\n\r\nEsempio creazione/visualizzazione Stage:\r\n\r\npublic void start(Stage primaryStage) \r\n{\r\n  primaryStage.setTitle(\"Test Stage\");        \r\n        primaryStage.show();\r\n}\r\n\r\nEsempio creazione Scene:\r\n\r\nGroup root = new Group();\r\nScene s = new Scene(root, 300, 300, Color.BLACK);",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4257,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponendo di utilizzare un listener esterno, come si può agire su un oggetto che fa parte della classe principale ma non è quello a cui il listener in questione è stato associato?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4302,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "descrivere la \"node hierarchy\"",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "node"
            },
            {
              "keyword": " javaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4340,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano gli ascoltatori?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ascoltatori"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4255,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile estendere la classe Button in modo da creare un bottone personalizzato/specifico per degli scopi specifici????",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Event"
            },
            {
              "keyword": " Button"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4282,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Non è possibile estendere una classe Botton con una proprietà.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4345,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Estendendo la classe Button i bottoni possono essere personalizzati per quanto riguarda la parte grafica (testo, ecc.), mentre se si vogliono creare bottoni per un uso specifico (ad esempio dei checkBox) bisogna estendere la classe Component. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4385,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Certamente. Teoricamente, tutte le implementazioni di control possono essere estese.\r\nSe per esempio ti servisse un bottone con una etichetta contenete un intero casuale, la seguente classe potrebbe esserti d'aiuto:\r\n\r\npublic class RandButton extends Button {\r\n\r\n\t\r\n\tpublic RandButton () {\r\n\t\t\r\n\t\t//chiamata al costruttore superiore\r\n\t\tsuper (((int) (Math.random () * 100)) + \"\");\t\r\n\t\t\t\r\n\t}\t\r\n}\r\n\r\nUna volta inseriti gli include corretti puoi usare il Control nel tuo codice allo stesso modo di un Button",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4316,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 435,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "E' possibile creare bottoni personalizzati, non estendendo la classe Button ma estendendo la classe Custom Node, anche se è abbastanza complicato e richiede conoscenze più approfondite.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4311,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 541,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "sì.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4331,
          "asker": {
            "courseId": 4,
            "askerId": 489,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza fra listener interno, listener esterno e self-listener?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4300,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "A quali oggetti oltre al tipo Button si può associare un EventHandler?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventhandler"
            },
            {
              "keyword": "button"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4258,
          "asker": {
            "courseId": 4,
            "askerId": 558,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vari tipi di ascoltatori¿",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ascoltatori"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4290,
          "asker": {
            "courseId": 4,
            "askerId": 470,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si gestisce un evento?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gestire"
            },
            {
              "keyword": "evento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4256,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve istanziare una variabile Listener usando il costrutto \r\n\"Listener l = new Listener(this);\" invece di usare il normale \"new Listener();\" ?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": "EventHandler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4306,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": ".",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4305,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "la domanda non è completa. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4280,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "A cosa serve istanziare una variabile Listener usando il costrutto \r\n\"Listener l = new Listener(this);\" invece di usare il normale \"new Listener();\" ?",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4372,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 433,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Il primo costrutto richiede un oggetto come parametro, e come si nota nelle slide, serve per poter richiamare delle funzioni che possano effettuare delle modifiche, come modificare il valore di una Text, mentre nel secondo caso non si può fare niente",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4329,
          "asker": {
            "courseId": 4,
            "askerId": 575,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può collegare un gestore di eventi a qualcosa che non sia un Button?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " Button"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4365,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 548,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Certamente, è ad esempio possibile collegare un gestore di eventi al focus su una TextArea così potremo gestire la situazione in cui l' utente clicchi sulla TextArea ed eseguire una funzione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4321,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 444,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "No un gestore di eventi si può collegare a qualsiasi cosa, button, check box, choice box, list , tool bar, text field, progress bar, simple label etc etc",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4370,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 487,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Un Listener può essere collegato attraverso l'utilizzo del metodo \"addEventHandler(Event, Listener)\" a qualsiasi elemento che compone la scena, ad esempio una figura geometrica, alla scena stessa ed anche allo stage, nel caso in cui si vogliano percepire ad esempio dei KeyEvent, quindi tasti premuti, rilasciati, ecc... In questo modo è possibile gestire un maggior numero di eventi e non solo i semplici click del mouse.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4352,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un gestore si eventi può essere applicato a tutta la gerarchia di classi  package java.awt.event.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4373,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 566,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il gestore di eventi serve per definire le azioni che devono essere svolte quando accade uno specifico evento come per esempio il click del mouse o di un pulsante della tastiera (in questo caso si userà Button) ma anche il trascinamento di una scrollbar. In generale, come visto negli esempi a lezione, il gestore di eventi si richiama in questo modo: btn.addEventHandler(ActionEvent.ACTION, a);\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4326,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 458,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "No.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4306,
          "asker": {
            "courseId": 4,
            "askerId": 541,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare brevemente la gerarchia delle classi Node, Parent, Scene e Stage.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Node"
            },
            {
              "keyword": " Parent"
            },
            {
              "keyword": " Scene"
            },
            {
              "keyword": " Stage"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4288,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Uno stage, cioè una finestra, contiene una Scene (contenitore). Una Scene ha un Parent che rappresenta il contenuto. Un Parent è un Node e contiene dei Node.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4347,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 497,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "La gerarchia di queste classi è molto semplice: la classe \"principale\" è chiamata \"Stage\", e rappresenta la finestra di base del programma che stiamo creando. \r\nUno Stage CONTIENE una \"Scene\", che può essere immaginato come un contenitore, il quale contiene i vari elementi (bottoni, immagini, scroll bar ecc.). \r\nIl contenuto della scena è chiamato \"Parent\" (quindi una Scene HA un \"Parent\"). \r\nInfine un Parent E' un \"Node\" (e contiene un \"Node\").",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4334,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 558,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Lo Stage è il contenitore top-level di un?applicazione JavaFX, che contiene una Scene. \r\nUna Scene è il ?contenitore? per gli elementi gra&#64257;ci della UI (nodi), ha background (&#64257;ll), dimensioni (width, height), e una sequenza di nodi (content). \r\nUna Scena ha un Parent che è un Node. \r\nNode è la classe astratta degli elementi di una Scena, ogni nodo può essere foglia o ramo.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4369,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Gli Stage sono il livello piu alto di contenitori, subito dopo ci sono le Scene che a loro volta sono contenitori, infine ci sono i contenuti: i Parent i quali sono dei Node.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4283,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come posso inserire il Listener all'interno della classe che lancia gli eventi?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": "Eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4262,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè può essere utile settare l'ID di un Button?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Event"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4374,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perchè in questo modo è possibile identificare un Button chiedendogli la sua istanza dell'id, ovvero chiedendogli il suo id stesso. \r\nInoltre se si creano numerosi Button quasi uguali per funzionamento, l'ID è un parametro ulteriore che permette di discernere tra di essi. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4341,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Associare un ID  ad un oggetto significa fornire un criterio per identificarlo univocamente e, di conseguenza, avere un metodo aggiuntivo per cercarlo e modificarlo. Pensa al seguente esempio:Button sum = new Button(\"PIU\"); sum.setId(\"+\"); myButton=document.getElementById(\"+\") ( cerca l'elemento partendo dal suo ID) ; myButton.setText(\"PLUS\");  Questo ti da anche l'occasione di riflettere su un reale vantaggio: se io decidessi un giorno di utilizzare la lingua francese per la mia calcolatrice dovrei certamente cambiare il testo nei bottoni delle operazioni (e potrei farlo come di esempio senza conoscere il loro nome nella lingua italiana) ma non vorrei mai che questo comportasse anche modificare il codice più del necessario. Sto dicendo che,nella logica di scrivere un codice che permetta una modifica dell'\"aspetto\" della nostra applicazione operando un cambiamento minimo su questo stesso, ha senso identificare l'operazione con il suo simbolo e far riferimento ad esso nei metodi.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4279,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "L'ID è un valore che definiamo ad un oggetto (elemento grafico di JavaFX, in questo caso) che lo rappresenta univocamente tra gli altri.\r\nSettare un ID (non esclusivamente ai Button) può servire a questo scopo, come si può vedere dalla slide JavaFX4: implementando un'unica classe derivata dall'interfaccia EventHandler, e creandone un'unica istanza, all'interno di handle(Event) possiamo ottenere l'oggetto che ha generato tale Event ed ottenerne l'ID per agire di conseguenza.\r\nPraticamente: Event contiene il metodo getTarget() che ritorna l'oggetto che lo ha generato e quindi, applicandogli un casting alla classe Node, possiamo accedere al metodo getId() il cui valore lo passiamo ad uno switch per gestire la casistica.\r\nIn questo modo gestiamo dei comportamenti simili localizzandoli in un unica porzione di codice, più facilmente gestibile.\r\nUn'altra applicazione di ID è quando vogliamo applicare un CSS ad un programma JavaFX, al fine di cambiare l'aspetto solamente di un certo elemento.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4384,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Settare l'ID di un bottone può essere utile per identificarlo tra gli altri componenti, nel caso in cui dovessi gestire eventi o personalizzazioni a run time.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4300,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 439,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "¿Settare un ID ad un pulsante semplifica la ricerca del suo nodo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4380,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 585,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perché in questo modo si può controllare meglio l'implementazione del button; la grafica e l'action possono in tal modo essere interamente utilizzabili al meglio. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4278,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Nelle slide, a pag 18, c'è una riga commentata così:\r\nfileChooser.setInitialDirectory(f); // bugged on MacOsX\r\nIn cosa consiste il bug e come si gestisce questa operazione per farla funzionare anche su MacOsX?\r\n\r\n",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "fileChooser"
            },
            {
              "keyword": " bug"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4334,
          "asker": {
            "courseId": 4,
            "askerId": 566,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona \"EventHandler\"?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4320,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come potremmo sfruttare il Listener\tInterno Anonimo?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": "Interno"
            },
            {
              "keyword": "Anonimo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4296,
          "asker": {
            "courseId": 4,
            "askerId": 590,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè dobbiamo usare una classe listner (cit.slides lezione)",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listner"
            },
            {
              "keyword": " events"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4301,
          "asker": {
            "courseId": 4,
            "askerId": 425,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra listener interno, esterno, interno anonimo e self listener?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " interno"
            },
            {
              "keyword": " esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4260,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che ruolo ha la Scene nella gerarchia di JavaFX?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "scene"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4308,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché quando provo a mettere un Hbox in un BorderPane e cerco di mettere l'HBox centrato o in alto centrato, mi finisce sempre in alto a sinistra della finestra?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "HBox"
            },
            {
              "keyword": "BorderPane"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4357,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Succede la stessa cosa se si prova con un VBox. Di default vengono posizionati a sinistra ma se provi a chiamare il metodo getAlignment() sull'oggetto posizionato al centro ti ritorna l'indirizzo giusto(e non null) anche se in realtà è posizionato in alto a sinistra.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4344,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 553,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In teoria dovresti scegliere la sua posizione tramite coordinate (x e y). Quindi ti viene dove vuoi, non dove vuole lui.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4330,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 557,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "In alto a sinistra è la posizione di default di un nodo posizionato nella regione \"top\" del BorderPane, la quale regione \"top\" è quella predefinita in cui vanno a collocarsi i noti la cui posizione non viene specificata.\r\nGli errori possono essere dunque due:\r\nIl primo errore può essere quello di non aver specificato in che posizione vada l'HBox all'interno del BorderPane. Questo se si vuole posizionare il nodo in posizione Center.\r\nL'altro errore, possibile se si vuole posizionare l'elemento nella regione Top (in quanto, se l'errore non è il primo, si ha specificato che il nodo dovrà essere inserito in posizione Center e quindi non finirà in alto a sinistra), è quello di non specificare che il posizionamento predefinito nella regione \"Top\" dovrà essere TOP_CENTER (ovvero \"in alto, al centro\"), in quanto se non si precisa diversamente, di base l'allineamento di \"Top\" è TOP_LEFT, ovvero \"in alto, a sinistra\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4312,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "perchè sbagli il comando....",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4360,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 478,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Quando inserisci l'hBox, che sia al centro (center) o in alto (top), l'hBox occupa tutto lo spazio disponibile (quello libero), di conseguenza a te sembra che vada a finire sempre in alto a sinistra non avendo niente nelle altre posizioni. \r\nSe provi ad inserire qualcosa nella posizione \"left\" e poi l'hBox in \"center\" non vedrai più l'hBox in alto a sinistra ma spostato più a destra (quanto dipende da cosa c'è a sinistra).\r\nTi ho messo su pastebin il main e il foglio stile con un test con background e rettangoli che ti dovrebbero essere d'aiuto per capire bene il concetto (qui non ci sta purtroppo :-]).\r\n\r\npastebin.com/NaXiiH1j     Main\r\npastebin.com/T0UNZunZ   Css\r\n\r\nSe osservi il codice noterai che lo sfondo blu del borderPane è completametne coperto dal nero dell'hBox, e che gli elementi in esso sono centrati grazie al setAlignment dell'hBox stesso.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4286,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze e caratteristiche dei vari tipi di listener? (esterno, interno, interno anonimo, self-listener). Con che logica si sceglie di utilizzare uno o l'altro?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " tipi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4273,
          "asker": {
            "courseId": 4,
            "askerId": 486,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi comporta la scelta di un Listener interno rispetto ad un Listener esterno?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener inteterno"
            },
            {
              "keyword": "Listener esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4250,
          "asker": {
            "courseId": 4,
            "askerId": 439,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Esponi un esempio di come un handler può gestire un evento.¿",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": " handler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4348,
          "asker": {
            "courseId": 4,
            "askerId": 585,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si definiscono gli eventi in javaFX? Come vengono gestiti al suo interno...?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 3,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": "javaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4303,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "che cos'è un event handling?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event hadling"
            },
            {
              "keyword": " java fx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4330,
          "asker": {
            "courseId": 4,
            "askerId": 456,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale ruolo giocano i concetti di \"Parent\" e \"Node\" nella gestione degli eventi in un'applicazione JavaFX?",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 3,
          "numEvaluators": 1,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " Parent"
            },
            {
              "keyword": " Node"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4309,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 467,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Node equivale a un semplice oggetti, tipo un cerchio, mentre Parent è un contenitore di oggetti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4367,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Dato un evento, un Node è un qualsiasi elemento della Scene, cioè è ognuno degli elementi che formano il contenuto dell'applicazione.\r\nOgni Node ha un solo Parent (ad eccezione del Root Node che banalmente non ne ha) e può avere Figli, definendo così una precisa struttura gerarchica dei Nodes; in particolare, Parent IS A Node. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4293,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Un parent è un node mentre node contiene dei parent.\r\nQuesti servono nella gestione degli eventi in quanto vanno a formare le foglie di un albero che organizza gli elementi che constituiranno la scena stessa nell'applicazione.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4342,
          "asker": {
            "courseId": 4,
            "askerId": 511,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "è consigliato fare la gestione degli eventi all'interno della classe stessa o creare una classe apposita? quali sono le differenze?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " fx"
            },
            {
              "keyword": " event"
            },
            {
              "keyword": " handling"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4328,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 490,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Qual'ora l'ascoltatore da descrivere fosse utilizzato solo in una determinata classe è consigliabile crearlo all'interno della stessa. Se invece fosse utilizzato anche da altre classi è consigliato creare una classe apposita. Per evitare così la rindondanza del codice",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4358,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "42",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4314,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "A livello teorico sarebbe meglio creare una classe apposita che gestisca tutti gli eventi quindi farle implementare l?interfaccia dell?opportuno Listener (è necessario scrivere una classe che implementi TUTTI i metodi dell?interfaccia), questo è fattibile finchè ai 2-3 eventi, se hai un 100 di eventi diversi da gestire, auguri.\r\nPer fortuna java ci viene in aiuto mettendo a disposizione delle classi astratte (adattatori) che implementano già tutti i metodi.\r\nE' comunque possibile gestire l'evento all'interno della classe stessa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4329,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 447,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "E' consigliato fare la gestione degli eventi all'interno della stessa classe in modo da creare un collegamento logico tra gli eventi all'interno di quella classe e gli oggetti di quella stessa classe!!!!",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4342,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Precisiamo innanzitutto che la gestione degli eventi si fa attraverso delle classi (gli ascoltatori) che vanno create implementando EventHandler, quindi in ogni caso bisogna implementare una classe. La scelta sta se farlo all'esterno o all'interno della nostra applicazione (che chiamerò classe App).\r\n\r\nLa differenza è che implementando un ascoltatore interno questo avrà a disposizione tutte le variabili e i metodi della nostra App, e potrà quindi usarli direttamente.\r\nDefinendo invece un ascoltatore esterno, se voglio fargli usare istanze di App devo passargliele. Per farlo creo un ascoltatore Listener che abbia una variabile di istanza appDaGestire di tipo App e un costruttore \r\n  Listener(App a){appDaGestire = a;}\r\nin questo modo chiamando dentro App \r\n  Listener ascolta = new Listener(this)\r\nquesto si salva l'indirizzo di App e può accedere a tutte le sue istanze\r\n\r\nSolitamente è consigliato l'ascoltatore interno perché rende il codice più compatto e, a mio gusto, meno macchinoso!",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4333,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 440,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "dipende dalla complessità dell'applicazione e dall'utilizzo che si vuole farne",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4272,
          "asker": {
            "courseId": 4,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "ah si?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ah"
            },
            {
              "keyword": " si"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4291,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un evento?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4281,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un \"Listener interno anonimo\"?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "evento"
            },
            {
              "keyword": "listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4322,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "è possibile associare un listener a più bottoni contemporaneamente?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " button"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4323,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Si, è possibile associare un listener a più bottoni contemporaneamente, ad esempio\r\n\r\nActionListener x = new ActionListener ({implementa i metodi astratti});\r\n\r\np1.setActionListener(x);\r\np2.setActionListener(x);\r\n\r\np1 e p2 avranno così lo stesso action listener.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4349,
              "task": {
                "taskId": 111,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Si, è possibile, ed è certamente consigliato farlo in modo da creare codice più leggibile, più documentabile e con una struttura logica più semplice. Creare più listener per pulsanti che svolgono (immagino dalla domanda) una funzione simile (es: somma, sottrazione..) oltre che essere superfluo è pure inutile in quanto si spreca tempo a scrivere codice che va a complicare il programma rendendo la futura manutenzione, correzione ed aggiornamento più difficile e dispendiosa in termini temporali e quindi monetari (non contando il tempo speso a scrivere lo stesso codice inutile).",
              "notes": "-",
              "rating": 6,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4294,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali diferenze tra un Listener esterno e un Listener interno?In particolare, specificare come bisogna cambiare il codice per passare da uno all'altro.  ",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener interno"
            },
            {
              "keyword": " Listener esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4248,
          "asker": {
            "courseId": 4,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un \"Listener\" e a cosa serve?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javaFX"
            },
            {
              "keyword": " Listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4252,
          "asker": {
            "courseId": 4,
            "askerId": 572,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 110,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'event handling?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Event"
            },
            {
              "keyword": " Handling"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 41,
      "lectureTitle": "Strutture dinamiche in C++",
      "questions": [
        {
          "questionId": 3616,
          "asker": {
            "courseId": 4,
            "askerId": 557,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il principale motivo per il quale, se si vuole copiare una pila, è opportuno andare a copiare ogni singola istanza della pila (marker, size, ecc) una alla volta invece di fare semplicemente \" pila2 = pila1 \"?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Copia"
            },
            {
              "keyword": " pila"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3638,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 479,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "per evitare di incorrere in problemi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3700,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 558,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il principale motivo per il quale se si vuole copiare una pila è opportuno copiare ogni singola istanza anzichè fare \"pila2=pila1\" sta nel fatto che in quest'ultimo caso non si crea una nuova pila uguale alla prima ma si fa puntare pila2 ai medesimi campi di pila1. Pila1 e pila2 sono quindi la stessa cosa, modificandone una cambia anche l'altra. Copiando ogni singola istanza invece si crea una nuova pila che contiene gli stessi valori della prima pila, modificandone una l'altra però resterà invariata. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3625,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 456,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "La scrittura Pila * pila2 = pila1 non è opportuna, dal momento che non crea fisicamente nella memoria una copia di pila 1. Infatti tale assegnazione non fa altro che indirizzare un puntatore pila2 allo stesso indirizzo di memoria del puntatore pila1, ed è pertanto un'operazione ben diversa dalla creazione di una copia di pila1, dal momento che una modifica dei dati in pila1 si ripercuoterebbe su pila2 (e viceversa).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3612,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 444,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il motivo principale per il quale si preferisce copiare ogni singola istanza della pila invece di fare \"pila2=pila1\" è che quest'ultima copia è troppo sbrigativa, si rischia inoltre di copiare in maniera sbagliata la pila e, senza i dovuti controlli, compromettere la funzionalità del programma",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3701,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 448,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perchè eseguendo pila2 = pila1 si copia solo il riferimento alla pila, ed entrambe le variabili punteranno alla stessa locazione di memoria. Modificando una pila quindi, le modifiche saranno effettuate anche sull'altra. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3615,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Se faccio Pila2 = Pila1 copio il riferimento e non i dati interi della pila. Quindi se voglio fare delle prove su pila2 in modo che pila1 resti invariata in caso di errori così da ripristinare lo stato originale così (pila2=pila1) non posso farlo perchè ogni volta che modifico un elemento di pila2 modifico lo stesso elemento della pila1.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3677,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Assunto che pila1 e pila2 siano due puntatori ad una pila (come nell'esempio visto in classe), dove pila1 punta alla pila che vogliamo copiare, mentre pila2 è il puntatore che dovrà puntare alla copia di essa, l'operazione pila2=pila1 non fa altro che copiare il puntatore pila1 in pila2; ciò significa che pila1 e pila2 puntano alla stessa struttura. Di conseguenza, le operazioni fatte su pila1 si ripercuotono inevitabilmente anche su pila2. Ciò che invece ci si aspetta da un'operazione di copia è di ottenere due strutture identiche, ma indipendenti tra di loro. Per questo motivo è necessario definire un'apposita funzione copia che, presa in input una pila, ne allochi una nuova, copi il contenuto e i valori di tutti gli attributi della prima in quella nuova, e restituisca l'indirizzo della pila così creata.  \r\n",
              "notes": "-",
              "rating": 6,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3658,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "discutere l'allocazione statica e dinamica di memoria",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " operatori new delete"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3666,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "A lezione abbiamo visto che in C++ è possibile effettuare l'operator overloading. Come funziona?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "operator"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3636,
          "asker": {
            "courseId": 4,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "qual è la differenza tra class e struct? quale dei due è più efficente?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": " struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3679,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché non è consigliato/permesso usare le strutture dinamiche in C++ come primitive?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Strutture Dinamiche "
            },
            {
              "keyword": " Primitive"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3690,
          "asker": {
            "courseId": 4,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In che cosa consiste il principio della località dell'informazione (information hiding) nominato nella slide \"variabili globali\"?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili globali"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3591,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che funzione svolge il distruttore? Come funziona?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "distruttore"
            },
            {
              "keyword": "struttura"
            },
            {
              "keyword": "classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3599,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Innanzitutto il distruttore è un metodo di una classe, ovvero una funzione portata all'interno della classe(o di una struttura) così da renderla propria della classe specifica. Il distruttore in particolare è un metodo che serve ad eliminare una classe o struttura. Il distruttore va esplicitamente dichiarato all'interno della classe per mezzo della dicitura ~<NomeClasse>(). Una volta implementato il metodo di distruzione, per essere chiamato all'interno del programma è necessaria solo la chiamata \"delete s\", dove 's' è una variabile di tipo <NomeClasse>. In questo modo viene automaticamente chiamato il distruttore che provvederà ad eliminare la classe. Il ragionamento è analogo per il creatore, ovvero il metodo che serve a creare la classe o struttura.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3644,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In C++ a differenza di java l'operatore è delegato alla allocazione-deallocazione delle cellette di memoria, funzione che viene espletata tramite gli operatori new e delete, nel caso dell'allocazione dinamica, e con gli scope delle variabili nel caso delle variabili \"classiche\". Dando all'operatore la possibilità di gestire a suo piacimento la memoria della macchina è suo dovere utilizzarla al meglio ricordando di deallocare la memoria inutilizzata correttamente. La funzione distruttore come si può vedere dal codice dealloca prima ciò che è contenuto nella struct ( delete [] s->contenuto) e poi la struct stessa ( delete s). Ovviamente non si potrebbe fare al contrario, in quanto deallocando la struct \"s\" andrebbe perduto l'unico collegamento che abbiamo con il contenuto della struct.\r\nAncora, dando solo il comando \"delete s;\" come potrebbe essere più intuitivo fare andrebbe nuovamente perso il collegamento con ciò che era contenuto in s.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3681,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il distruttore ha una funzione simile ma opposta al costruttore; anch'esso è una particolare funzione membro che però viene eseguita automaticamente quando stiamo per rilasciare un oggetto, tramite l'operatore delete ad un puntatore all'oggetto, il programma esce dal campo di visibilità di un oggetto della classe.\r\nAnche in questo caso ci permette di gestire comportamenti come il rilascio al sistema della memoria allocata internamente dall'oggetto.\r\n\r\nIl distruttore,  ha sempre lo stesso nome della classe nella quale è definito ma è preceduto dal carattere tilde (?);\r\nI distruttori non possono accettare argomenti e non possono essere modificati tramite overloading.\r\nI distruttori, quando non vengono definiti esplicitamente, vengono creati automaticamente dal compilatore (distruttore di default).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3684,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il distruttore è una funzione membro che, se non definita, viene creata automaticamente dal compilatore (in questo caso si parla di distruttore di default). Il distruttore viene eseguito automaticamente quando si è prossimi al rilascio di un oggetto tramite l'operatore \"delete\" e permette di gestire alcuni comportamenti dell'oggetto come la restituzione della memoria allocata all'interno dello stesso o la stampa a video di un messaggio. \r\n\r\nIl distruttore ha lo stesso nome della classe nella quale è definito ma è preceduto dal carattere \"?\". Non può essere modificato tramite overloading e non può accettare argomenti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3687,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 503,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il distruttore ha il compito di distruggere un oggetto ciò dealloca in modo corretto la memoria utilizzata dall'oggetto creato dal corrispondente costruttore (nel nostro caso parliamo del distruttore ~Pila() vedi slide 80) ed tutta la memoria allocata dinamicamente. Esso è un metodo che non ammette nessun parametro in input perchè se non chiamato esplicitamente sarà il compilatore ad inserire a fine programma la chiamata al distruttore, in modo tale da evitare consumo di memoria dovuto alla mancanza di deallocazione della memoria. In linguaggi di programmazione ad oggetti dotati di garbage collected(come ad esempio è Java) il distruttore è spesso inutile in quanto la memoria allocata da un oggetto viene automaticamente liberate nel momento in cui non c'e nessun riferimento all'oggetto stesso.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3645,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra metodo e funzione?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodo"
            },
            {
              "keyword": " funzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3659,
          "asker": {
            "courseId": 4,
            "askerId": 526,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa succede quando heap e stack si \"incontrano\" nello stesso \"livello\" di memoria occupando lo spazio disponibile?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": " stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3596,
          "asker": {
            "courseId": 4,
            "askerId": 521,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Per che cosa, e come, sono utilizzati gli operatori new e delate?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3653,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai quando re-implemento le funzioni all'interno della struttura \"Pila\" le \"s->\" diventano \"this->\"(come se si riferissero a una nuova struttura)?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " This"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3655,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Perchè si fa uso di una nuova struttura.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3711,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 526,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "A causa della visibilità delle funzioni all'interno della struttura Pila",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3652,
          "asker": {
            "courseId": 4,
            "askerId": 548,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in java non è necessario utilizzare i \"delete\" e perché non è stata utilizzata la stessa soluzione anche per c/c++?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "delete"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3608,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "quale differenza intercorre tra le struct e le classi e perche quest'ultime sono meglio delle prime?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct "
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3640,
          "asker": {
            "courseId": 4,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale \"problema\" è collegato alle variabili globali?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3606,
          "asker": {
            "courseId": 4,
            "askerId": 432,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Durante la lezione è stato spiegato come creare una struct Pila (in seguito diventata classe) che incapsula gli elementi in un array statico, che arrivato a capienza massima viene copiato e aumentato per contenere un numero indefinito di elementi. Non è forse meglio organizzarlo come un array di puntatori in modo da poter eliminare il passaggio copia-ingrandisci mostrato? O ancora è possibile organizzare l'array in modo che all'immissione dell'elemento che andrà ad occupare l'ultimo blocco al suo posto venga inserito un puntatore ad array che faccia continuare la pila anche se tecnicamente è separata da memoria occupata ad altri scopi? In questo modo si limiterebbe la frammentazione della memoria in quanto non di alloca-dealloca continuamente",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3681,
          "asker": {
            "courseId": 4,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponiamo di avere una pila salvata in memoria e di voler aggiungere altri elementi in essa, nonostante la pila sia piena. Supponiamo inoltre che lo spazio di memoria immediatamente successivo sia già occupato. Come si comporta il sistema per poter salvare la nuova pila in memoria? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3578,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è considerata una stringa in c++ e come vengono trattate?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stringhe"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3667,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In un sistema unix a un file sono associati permessi di scrittura, lettura e esecuzione.\r\nCome funziona la sicurezza per quanto riguarda la Ram ovvero: a quali indirizzi posso accedere (leggere e/o dereferenziare) con un puntatore?\r\n(Mi viene spontanea un'altra domanda facoltativa: esiste quindi una gerarchi fra i processi?)",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": "ram"
            },
            {
              "keyword": "sicurezza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3602,
          "asker": {
            "courseId": 4,
            "askerId": 592,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Il linguaggio C++ fornisce due operatori molto interessanti, che sono il comando \"new\" e \"delete\".\r\nQuali sono i vantaggi e, se esistono, gli svantaggi che forniscono ad un programmatore?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "operatori"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3661,
          "asker": {
            "courseId": 4,
            "askerId": 463,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Se mi costruisco un array v di interi lungo 10 (per esempio v:=(1;2;3;4;5;6;7;8;9;10)) e chiedo al programma di stampare v+5\r\n\r\ncout<<(v+5)<<endl;\r\n\r\ncosa leggerò sulla console?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3624,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 490,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "v è un puntatore che punta al primo elemento dell'array, quindi fare \"v+5\" equivale a sommare 5 volte la \"lunghezza di un intero\" all'indirizzo di memoria di v.\r\nL'output sulla console in questo caso corrisponderà all'indirizzo in memoria del sesto elemento dell'array.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3626,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 497,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Leggerò l'indirizzo della prima cella di memoria dell'array incrementato di 5 volte la dimensione del tipo specificato (in questo caso int = 4 byte).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3597,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 562,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "6",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3678,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 449,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'indirizzo di memoria della cella v+5",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3583,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa implica la definizione di una Class rispetto ad una Struct in c++?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "OOP "
            },
            {
              "keyword": " C++ "
            },
            {
              "keyword": " Struct "
            },
            {
              "keyword": " Class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3643,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè nella funzione distruggi (slide n^80) non eseguiamo la delete del puntatore \"this\"?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Deallocazione"
            },
            {
              "keyword": " puntatore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3662,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Quando de-allochiamo un oggetto in C++ dobbiamo compiere due passaggi: il primo è creare un metodo distruttore con firma \"~NomeClasse\" nel quale ci occupiamo di cancellare tutti gli attributi dell'oggetto allocati dinamicamente; il secondo passaggio è di invocare nel nostro programma il distruttore tramite \"delete variabileOggetto\". Quando compiamo questo passaggio viene eseguito il codice all'interno del distruttore e successivamente viene in modo automatico de-allocato l'oggetto, rendendo così superfluo il passaggio manuale di de-allocazione, ovvero \"delete this\".\r\nA livello puramente teorico delete this è corretto e funzionante, il solo problema è che oltre a rendere il codice poco leggibile non si può essere sicuri che l'oggetto sia stato allocato dinamicamente, e un delete su una variabile allocata staticamente provoca il crash immediato del programma.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3598,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Quando si utilizza \"delete this\" si sta assumendo che l'oggetto che ha chiamato il distruttore e' stato allocato con una new, quindi che si trova nello heap e non nello stack e che non e' stato allocato con new[] (cioe' che non e' parte di un vettore, con il pericolo di cercare di \"deallocare 2 volte il medesimo oggetto\"). In generale l'utilizzo di delete this rende molto meno riutilizzabile il codice (funziona solo con singole istanze allocate dinamicamente). Dopo la delete this bisogna inoltre fare molta attenzione a non cercare di riutilizzare l'oggetto (segmentation fault). Un po' come goto continue e break, delete this e' permesso in C++ ma fortemente sconsigliato perche' diventa facile perdere il controllo del programma.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3657,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 435,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "La funzione distruggi (che viene chiamata nel main con s->distruggi(); ) si occupa di deallocare l'area di memoria occupata nell'heap dalla Pila (che è una struct allocata dinamicamente) in questo modo: essendo distruggi() una funzione membro della struct Pila, la pila (in questo caso s) va dereferenziata chiamando la funzione distruggi che fa la delete del campo \"contenuto\" e della pila stessa a cui appartiene; la distruzione avviene quindi tramite una funzione. \r\nCon le classi invece non distruggiamo un oggetto tramite funzione, ma tramite il suo DISTRUTTORE, definito all'interno della classe. Quindi quando voglio eliminare un oggetto, basta fare nel main la delete dell'oggetto come nella slide 81: automaticamente verrà invocato il distruttore che provvederà ad \"eliminare\" l'oggetto (liberare la memoria), senza bisogno poi di fare la delete del puntatore in quanto punta ad un oggetto già eliminato dal distruttore.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3718,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 564,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": ".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3723,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Se si aggiungesse al codice scritto nella slide 80 il comando \"delete this;\", si otterrebbe un esempio di \"undefined behaviour\": con ciò si intende che il comportamento del codice in questione è arbitrario. L'esito più probabile sarebbe quello di invocare ricorsivamente il distruttore (fatto che porterebbe ad uno \"stack overflow\"), ma comunque l'esito non è a priori prevedibile.\r\nIl problema è il seguente: il comando \"delete this;\" è già incluso in \"~Pila()\". Aggiungerlo una seconda volta risulterebbe in una ripetizione, con le conseguenze appena descritte. Essenzialmente, nel momento in cui il distruttore viene invocato, l'oggetto è già stato distrutto, cosicché \"delete this;\" non è valido.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3660,
          "asker": {
            "courseId": 4,
            "askerId": 478,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché per copiare una pila scrivere \"Pila * w=s\" è sintatticamente corretto ma formalmente è un errore abbastanza grossolano?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " puntatori"
            },
            {
              "keyword": " common mistakes"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3639,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per classi e per strutture dinamiche in C++? Spiegarne struttura ed utilità",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": "Strutture dinamiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3674,
          "asker": {
            "courseId": 4,
            "askerId": 516,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "void distruggi(Pila * s) { \r\n delete [](s->contenuto); \r\n delete s; \r\n} \r\n\r\nPerchè è importante deallocare prima il contenuto e poi s?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "distruggi"
            },
            {
              "keyword": " delete"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3607,
          "asker": {
            "courseId": 4,
            "askerId": 483,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il pezzo di codice sottostante può avere delle conseguenze catastrofiche?\r\n\r\nchar parola[4];\r\ncin >> \"Frase molto lunga\";",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": "memoria"
            },
            {
              "keyword": "c++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3703,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il codice scritto non rispecchia un esempio di overflow di una variabile. Se il codice fosse stato corretto la risposta sarebbe stata: l'inizializzazione del vettore \"parola\" riserva spazio nello stack per soli 4 caratteri. Cercando di assegnare a tale vettore una sequenza di caratteri più lunga si invade spazio di memoria che potrebbe essere riservato a un' altra variabile, sovrascrivendola. Il codice presentato non compila perchè la \"cin\" non riesce ad assegnare l'input dato a una costante, generando un errore.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3596,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Non è che \"può avere\" conseguenze... HA delle conseguenze catastrofiche!  È stato dichiarato un array di char di dimensione 4 e stai cercando di metterci dentro 17 caratteri + 1 (il '\\0' - Terminatore). Logicamente si capisce che è impossibile fare una cosa del genere perché comunque il compilatore cerca di mettere \"frase molto lunga\" nel posto di un char. Se provi, gli errori arriveranno inesorabilmente. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3611,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Guarda ti correggo:\r\nchar par[4];\r\ncin >> par;\r\n\r\ne da terminale inserisco:\r\n\"blablablaguarda_che_il_codice_non_compila_hahahahah\"\r\n\r\nQuesto codice puó avere conseguenze catastrofiche perché la frase molto lunga va fuori dal vettore allocato nello stack e va a sovrascrivere altra memoria.\r\nOra questa non é una conseguenza cosí catastrofica perché il sist.operativo o chi per lui assegna sempre dopo vettori una memoria di \"sicurezza\"per evitare di sovrascrivere altre\r\nvariabili.\r\n\r\nSe peró la stringa inserita é lunga abbastanza da sovrascrivere il codice sorgente del programma in ram l?utilizzatore del programma potrebbe far fare al vostro programma quello che vuole, finché questo é sul suo computer contento lui, ma se il programma fosse sul tuo server? cosa potrebbe fare un utente in canada che ha libero accesso al tuo server grazie ad una cosa del genere?\r\n\r\nNon sono del tutto sicuro che con cin questa cosa funzioni ma con altri metodi di input questo trucchetto funziona.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3590,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 468,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "poiché se dichiaro un array di 4 elementi di tipo char, il computer riserverà lo spazio sufficiente a contenere solo 4 char. Questo significa che: se come nell'esempio acquisiamo un imput con più di 4 elementi  andremo a salvare le altre variabili nello spazio sucessivo a parola[3] che potrebbe essere già occupato da altri dati. Il pericolo perciò è dato dalla possibilità di sovrascrivere dei dati che cosi andrebbero persi per sempre con delle conseguenze appunto catastrofiche. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3635,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Se la \"Frase molto lunga\" deve essere inserita nella stringa parola (e quindi cin >> parola;), il pezzo di codice può avere conseguenze catastrofiche perché, se si inserisce nello stream cin una frase o una parola formata da più di 3 caratteri, l'operatore \">>\" colloca tutti i caratteri della frase in memoria sovrascrivendo aree di memoria libere o, peggio, già occupate da altre variabili e quindi non riservate alla variabile \"parola\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3654,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Le conseguenze possono essere catastrofiche poiché l'array di caratteri è stato allocato staticamente per avere una dimensione massima di 4, andando a scrivere una frase lunga più di 4 caratteri si esce dal range dell'array e si rischia di andare a scrivere sopra una celletta in cui magari era stata salvata una variabile o chissà cosa, avendo potenzialità catastrofiche per l'esecuzione del programma.. Il rischio sta proprio nel non poter essere certi di cosa si va a sovrascrivere, quindi ad una esecuzione su un certo computer potrebbe funzionare ma su un altro no, dunque bisogna stare attenti a rientrare nel range degli array allocati!",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3618,
          "asker": {
            "courseId": 4,
            "askerId": 457,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra classe e struttura e perchè è meglio rendere \"private\" una parte di codice? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Struct"
            },
            {
              "keyword": " class"
            },
            {
              "keyword": " private"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3620,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè l'indice in un array di lunghezza N scorre tra 0 e N-1 anziché tra 1 e N?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " indice"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3647,
          "asker": {
            "courseId": 4,
            "askerId": 437,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i benefici derivanti dall'utilizzo dell'operatore \"this\"?\r\nEsso è utilizzabile sia in c che in c++?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Operatori "
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3696,
          "asker": {
            "courseId": 4,
            "askerId": 425,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono il costruttore ed il distruttore nelle classi in c++?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": "distruttore"
            },
            {
              "keyword": "classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3674,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 478,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Innanzitutto costruttore e distruttore sono due METODI: delle \"funzioni speciali\" definite all'interno delle classi quando si programma ad oggetti.\r\nCOSTRUTTORE: è il metodo che si occupa di riservare lo spazio necessario all'oggetto per risiedere in memoria. Esso è invocato quando di crea un oggetto tramite l'operatore \"new\", ovvero si crea un'istanza di una classe. Al suo interno, questo metodo si comporta come una funzione: si possono assegnare dei valori passati come parametro a delle variabili e/o eseguire delle operazioni. La \"figata\" è che si possono scrivere più costruttori con firme diverse, e questo torna molto utile. \r\nDISTRUTTORE: si occupa di deallocare lo spazio che era riservato all'oggetto precedentemente istanziato. Tutto quello che si è allocato dinamicamente all'interno della classe deve essere esplicitamente deallocato dal programmatore, mentre l'eliminazione del rifermento all'oggetto stesso è implicito: non serve fare \"delete this\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3591,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 469,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il costruttore di una classe in c++ serve per inizializzare o allocare spazio di memoria per ogni nuovo oggetto che viene creato. Invece il distruttore serve per liberare spazio di memoria una volta che l'oggetto viene rimosso.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3593,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il costruttore è un metodo di una classe che viene chiamato ogni volta che ne viene istanziato un oggetto. Esso assegna valori di default a variabili, chiama metodi, alloca zone di memoria o svolge altre attività utili all'oggetto (es: dichiarazione di eventi). Si possono creare overloading di esso con differenti parametri, in modo da poter decidere il valore delle variabili interne all'oggetto. Il costruttore si chiama come nomeclasse(). Se non viene definito nel codice, il compilatore genera automaticamente un costruttore di default vuoto.\r\nIl distruttore è un metodo di una classe che ha funzione inversa al costruttore. Esso infatti ha il compito di deallocare la memoria dell'oggetto (delete), liberando lo spazio da esso occupato. Il distruttore, a differenza del costruttore, non permette overloading. Il distruttore si chiama ~nomeclasse().  Nel caso non si fosse definito nel codice, come per il costruttore, il compilatore provvede a creare un distruttore di default vuoto.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3683,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Il costruttore determina il comportamento che l'oggetto avrà alla sua creazione, quindi noi possiamo  usarlo per l'inizializzazione delle variabili e per l'allocazione dinamica della memoria.\r\nIl distruttore ,come si può intuire dalla parola stessa , distrugge ciò che il costruttore ha creato, liberando la memoria occupata precedentemente e riportando alle condizioni preesistenti alla creazione dell'oggetto.\r\nDa notare che questi non sono obbligatori , nel caso in cui nella classe non fosse presente un costruttore  c++ mette a disposizione un costruttore di default con corpo nullo, se invece  non fosse presente il distruttore semplicemente non verrebbe liberata l'area di memoria occupata dall'oggetto. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3597,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in C++ bisogna stare attenti quando si alloca della memoria? fare riferimento allo stack e alla heap..",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione dinamica"
            },
            {
              "keyword": " heap"
            },
            {
              "keyword": " stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3672,
          "asker": {
            "courseId": 4,
            "askerId": 530,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra una funzione ed un metodo?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3651,
          "asker": {
            "courseId": 4,
            "askerId": 480,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Struct e Class sono strutture essenzialmente intercambiabili, cosa porta a preferire la seconda opzione rispetto alla prima in un contesto di programmazione orientata agli oggetti?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3677,
          "asker": {
            "courseId": 4,
            "askerId": 511,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è utile implementare un metodo \"cresci\", quando costruiamo uno stack?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " cresci"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3571,
          "asker": {
            "courseId": 4,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze fra una pila ed una coda?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "coda"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3614,
          "asker": {
            "courseId": 4,
            "askerId": 519,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Se un programma, durante l'esecuzione, chiede all'OS di allocare un'area di memoria tramite l'operatore new, ma si incorre in un errore (ad esempio la memoria è già interamente occupata) e l'operazione fallisce, che cosa può accadere?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione dinamica"
            },
            {
              "keyword": " new"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3692,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra 'struct' e 'class'?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3642,
          "asker": {
            "courseId": 4,
            "askerId": 567,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In che senso richiamare un array all'interno di un codice equivale essenzialmente ad utilizzare un puntatore?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 3,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Puntatore"
            },
            {
              "keyword": " Array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3592,
          "asker": {
            "courseId": 4,
            "askerId": 570,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando conviene utilizzare delle strutture dinamiche in C++?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stutture"
            },
            {
              "keyword": " convenienza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3617,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi di una coda implementata mediante un array dinamico (come quella vista a lezione) rispetto ad una coda ad array statico e ad una coda dinamica a lista concatenata?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "coda"
            },
            {
              "keyword": " confronto"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3646,
          "asker": {
            "courseId": 4,
            "askerId": 434,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Il fatto di raggruppare tutte le funzioni all'interno di una sola classe rende il codice più facile da leggere e da mantenere?",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pattern"
            },
            {
              "keyword": "funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3648,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Dove sta la principale differenza della gestione dinamica di memoria tra un linguaggio Java ed un linguaggio C?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collector"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3584,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra questi due cicli for in java?\r\n\r\nfor (int i=0; i<20; i++) {\r\n      if (i==0 || i==7 && i<20){\r\n          cout << i;\r\n      }\r\n}\r\n\r\nfor (int i=0; i<20; i++) {\r\n      if (i==0 | i==7 & i<20){\r\n          cout << i;\r\n      }\r\n}\r\n\r\n\r\n",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "for"
            },
            {
              "keyword": "if"
            },
            {
              "keyword": "&"
            },
            {
              "keyword": "|"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3689,
          "asker": {
            "courseId": 4,
            "askerId": 500,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella costruzione di una Pila o di una Coda attraverso le Struct con le funzioni che devono essere pubbliche all'interno della Struttura dati stessa, per quale motivo bisogna evitare di scrivere il codice delle suddette funzioni all'interno della dichiarazione della Struct?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Struct"
            },
            {
              "keyword": " Funzioni pubbliche e private"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3632,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella costruzione di una Pila, c'è la funzione \"int estrai\" dove, c'è scritto il codice \"assert(s->marker->0)\", cosa svolge la funzione in questo preciso codice??",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "estrai"
            },
            {
              "keyword": "funzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3572,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che significato ha il simbolo -> in C++?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "operatori"
            },
            {
              "keyword": " dereferenziazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3682,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "L'operatore -> permette di accedere ad un campo di una struct (o di una classe, in C++) tramite un puntatore alla stessa.\r\n\r\nSupponiamo di avere un puntatore \"p\" ad una variabile (o meglio, istanza) di una certa struct, la quale contiene un generico campo \"field\".\r\nPer accedere a field (per qualsiasi operazione), scrivere:\r\np.field\r\nnon è corretto, e non si riesce a compilare il codice.\r\nLa giusta sintassi è la seguente:\r\n(*p).field\r\n\r\nDa notare che le parentesi sono obbligatorie:\r\n*p.field\r\nè errata, poiché equivarrebbe a:\r\n*(p.field)\r\nche è il medesimo errore di prima.\r\n\r\nUna sintassi come questa risulta spesso scomoda; si utilizza quindi l'operatore -> che \"provvede autonomamente\" a deferenziare il puntatore:\r\np->field\r\n\r\nSebbene possa sembrare che l'operatore -> sia ridondante e inutile, porta invece ad una miglior leggibilità del codice, che in applicazioni più complesse (array di struct e/o classi annidate) diventa fondamentale: non utilizzare l'operatore -> sarebbe pura follia.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3658,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 447,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Domanda stupida. In sè questo operatore in c++ non significa nulla, sarebbe corretto contestualizzarlo all'interno di un esempio.\r\nTuttavia per esempio, nel caso di un puntatore ad una struct:\r\nstruct lista{\r\nint val;\r\n}\r\nlista* p = new lista;\r\n\r\nUtilizzando operazioni primitive-tradizionali per accedere al campo \"val\" dovremmo usare la sintassi:\r\n(*p).val = 10; \r\nPer nostra fortuna però è stato introdotto l'operatore \"->\" che come semplice zucchero sintattico addolcisce appunto la sintassi:\r\np->val = 10;\r\n\r\nSemplicemente anche l'occhio vuole la sua parte.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3604,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il simbolo -> serve ad accedere ai membri di un oggetto tramite il suo puntatore; è uguale a scrivere (*p).membro.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3636,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Il simbolo ?->? si utilizza sui puntatori a strutture e serve per accedere al contenuto di un determinato campo di una struttura. Ad esempio se ?p? è un puntatore ad una struttura e ?a? è il nome di uno dei suoi campi, per accedere al valore contenuto in ?a?, scriverò ?p->a? . Questo operatore è semplicemente uno zucchero sintattico perché, rifacendoci all?esempio precedente, potevo scrivere ?*p.a? ed ottenere lo stesso risultato.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3649,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il simbolo \"->\" in C++ permette di accedere ai campi di una struttura. Si può usare al posto di \".\" se a sinistra del simbolo c'è un puntatore. Il simbolo \"->\" è molto utilizzato perché è più facile e suggerisce la cosa a cui il puntatore punta.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3671,
          "asker": {
            "courseId": 4,
            "askerId": 585,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra il definire variabili, costanti, funzioni, ecc. attraverso l'utilizzo del preprocessore oppure normalmente nel corso del codice?Quali sono i vantaggi e gli svantaggi nell'utilizzare il preprocessore all'interno di un programma?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "preprocessore"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3598,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Riguardo le re-implementazioni delle funzioni all'interno della struct stessa della Pila, come vanno distribuite le singole funzioni(dichiarazioni e definizioni) tra i vari \r\nfiles .h e .cc ? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Metodi"
            },
            {
              "keyword": "Funzioni Membro"
            },
            {
              "keyword": "Pila"
            },
            {
              "keyword": "Struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3635,
          "asker": {
            "courseId": 4,
            "askerId": 523,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile creare un vettore tri o più dimensionale in C++?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " dimensione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3650,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene interpretato dal compilatore in C/C++ l'arrey?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Arrey"
            },
            {
              "keyword": " C/C++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3664,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Avendo fatto C e non C++, qualcuno può spiegarmi, se ci sono, quali sono le differenze sostanziali tra malloc e free in C e new dolete in C++?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " C++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3670,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos è un puntatore? Come si dichiara una variabile puntatore e come si può fare riferimento al valore di una variabile tramite puntatore?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatore"
            },
            {
              "keyword": "c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3613,
          "asker": {
            "courseId": 4,
            "askerId": 486,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponendo che la memoria sia piena, cosa accadrebbe se si cercasse comunque di effettuare l'allocazione dinamica? Eventuali errori segnalati dal sistema come potrebbero essere gestiti?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Memoria"
            },
            {
              "keyword": "Dinamica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3654,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi derivanti dal fatto di poter dichiarare le funzioni all'interno di una struttura rispetto a doverle dichiararle separatamente?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Strutture"
            },
            {
              "keyword": " Funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3688,
          "asker": {
            "courseId": 4,
            "askerId": 449,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché un array ha indice di di partenza 0 e non 1?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Indice"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3627,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 523,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Siccome il linguaggio non è stato specificato, possiamo dire che non è vero che un array ha indice di partenza 0. Dipende dal linguaggio, maggior parte dei linguaggi utilizzano gli array con l'indice di partenza 0 ma ci sono anche quelli che utilizzano l'indice 1.\r\nQuindi non è vero che l'indice di partenza di un array è 0.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3672,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 521,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il primo elemento dell'array ha indice di partenza 0 perché abbiamo visto che v[i]=*(v+i) ovvero l'array in realtà è  un puntatore. Se volessi inizializzare l' indice di partenza a 1 allora dovrei automaticamente traslare tutto di 1 e quindi l'uguaglianza diventerebbe:\r\n v[i]=*(v+i-1). Dunque partiamo da 0 per  risparmiare un'operazione in modo che il costo computazionale risulti minore.",
              "notes": "-",
              "rating": 6,
              "coins": []
            },
            {
              "answerId": 3691,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 501,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Perché avere un indice di partenza 1 avrebbe significato sprecare un byte di memoria (quello di indice 0), inoltre in ambito di aritmetica dei puntatori le dimensioni dei vari tipi di dati (4,8,16, ecc) avrebbero dovuto essere gestite tenendo conto che l' indice di partenza è 1 e non 0.Dato che questo è scomodo per il calcolatore si è deciso di tenere l' indice iniziale uguale a 0.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3630,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 481,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Per ottimizzare al meglio la gestione della memoria e per il fatto che in C++ si parte sempre a contare da 0",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3705,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 591,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "perchè essendo l'array un puntatore al primo indirizzo del numero di celle di memoria pari alla lunghezza dell'array, se partisse da 1 e non da 0 allora per richiamare la cella i-esima dell'array avrei che v[i] = *(v+i-1) il che costa una sottrazione. Essendo uno degli obbiettivi del C la velocità si è deciso di cominciare da 0. ",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3713,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 511,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In c++ se io ho un array generico 'v', esso punta il primo elemento dell'array. *v equivale quindi a v[0] perchè la scrittura v[i] è vista dal compilatore come *(v+i). Per prendere il primo elemento i deve essere per forza 0.\r\n*(v+0)\r\nv[0]",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3719,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un array è essenzialmente un puntatore, un riferimento ad una locazione di memoria, e quindi per l'array l'espressione array[n] si riferisce ad una posizione di memoria n-elementi distanti l'elemento di partenza. Ciò significa che l'indice viene utilizzato come un offset. Il primo elemento nella posizione di memoria che fa riferimento  (0 elementi di distanza), quindi dovrebbe essere indicato come array [0].",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3694,
          "asker": {
            "courseId": 4,
            "askerId": 555,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In C++ vi sono (almeno) tre modi per passare parametri ad una funzione: il passaggio per valore, quello per indirizzo e quello per riferimento. Quali sono le differenze tra questi tre approcci?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "passaggio di parametri"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3633,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "dato il seguente codice:\r\n\r\nPila::~Pila() {\r\ncout<<\"entro nel distruttore\"<<endl; \r\ndelete []contenuto; \r\n} \r\nperche non faccio delete this?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "distruttore"
            },
            {
              "keyword": "delete"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3603,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Non si utilizza delete this perché mediante il delete []contenuto già si elimina l'oggetto nella struttura dati e non è necessario specificare l'appartenenza dell'oggetto alla struct, dato che la funzione è compresa in essa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3715,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "il this è inutile. quando passo le funzioni all'interno della struttura come funzioni membro questo viene usato come una sorta di parametro implicito ma non mettendolo il primo \"contenuto\" che andrà a trovare sarà proprio quello a cui non intendevamo riferirci con il this.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3710,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 489,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Perché non serve, in quanto l'istruzione delete this compariva nell'implementazione precedente del distruttore. La differenza fra le due implementazioni è che le funzioni sono già dichiarate direttamente nella struttura nella nuova versione, diversamente dalla prima. Perciò ora è chiaro cosa sto distruggendo, non occorre  aggiungere il comando delete this.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3595,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 467,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Perché è implicito, il compilatore cerca la variabile contenuto nello scope in cui ti trovi, e se non c'è continua ad allargare lo scope finché non la trova. Puoi anche mettere this, ma è inutile.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3665,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Facendo delete this si fanno assunzioni sull'utilizzo che si fa dell'oggetto (non e' detto che l'oggetto sia allocato dinamicamente, provoca errori a run time). Inoltre l'utilizzo di delete this riduce la possibilita' di riutilizzo del codice (l'oggetto con il delete this deve sempre esser allocato dinamicamente), inoltre se dopo l'utilizzo di \"delete this\" si cerca di accedere all'oggetto si incorre in altri errori (segmentation fault).",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3625,
          "asker": {
            "courseId": 4,
            "askerId": 524,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Posso definire una funzione all' interno di una sezione \"private\" di una \"class\"? Perchè?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Class"
            },
            {
              "keyword": " Funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3624,
          "asker": {
            "courseId": 4,
            "askerId": 505,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e svantaggi di una struttura dinamica piuttosto che una struttura statica in c++?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "dinamico"
            },
            {
              "keyword": " statico"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3579,
          "asker": {
            "courseId": 4,
            "askerId": 575,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra gestione manuale della memoria (memoria dinamica) e gestione automatica della memoria (memoria statica)?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria statica"
            },
            {
              "keyword": " memoria dinamica"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3680,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Forse intendevi allocazione dinamica e statica, comunque rispondo sulla memoria. La memoria statica sono i dati che vengono salvati nell'hard-disk del computer e che non vengono cancellati non appena viene spento il computer, mentre la memoria dinamica è in poche parole la ram, è quindi quella memoria dove vengono salvati temporaneamente i dati del sistema operativo, dei giochi o di programmi che una volta spento il pc vengono cancellati automaticamente. \r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3692,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 513,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "La memoria statica è una zona dello Stack dove vengono allocate costanti e variabili le cui dimensioni sono già predeterminate dal programmatore mentre la memoria dinamica è una zona della Heap dove vengono allocate variabili di cui non si conosce dimensione in fase di compilazione come ad esempio una stringa ricevuta in imput dall'utente ignorandone a priori la lunghezza.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3637,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 520,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "L'utilizzo di memoria dinamica permette al programmatore di lavorare con oggetti di cui si saprà la dimensione solo al momento dell'effettivo utilizzo del programma da parte dell'utente, ad esempio l'inserimento di una stringa di cui non si può sapere la lunghezza a priori. La gestione si dice manuale, infatti il programmatore dovrà preoccuparsi manualmente di allocare e deallocare lo spazio di memoria e, nel caso di array, di gestire la contiguità delle celle al variare della dimensione predefinita dell'array. L'area di memoria dinamica è detta heap. Nel caso di memoria statica si definisce a priori la dimensione dell'oggetto, ad esempio nel caso di inserimento di una stringa di cui si vuole limitare la dimensione, come il codice fiscale. Si parla di gestione automatica della memoria perché gestire l'allocazione, la deallocazione dello spazio e la contiguità delle celle degli array è gestito in automatico dalla macchina. L'area di memoria dedicata è detta stack.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3699,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 548,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "La differenza principale è che per la memoria statica il momento in cui viene allocata e de-allocata viene deciso dal compilatore mentre nella memoria dinamica il programmatore ha il controllo, la memoria allocata rimane tale fino al momento in cui chi ha progettato il software non decide di  de-allocarla oppure nel caso in cui ci sia un garbage collector basta che al programma non sia più necessaria un' area di memoria e la elimina automaticamente.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3717,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 502,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Con l'allocazione statica la memoria necessaria viene allocata prima dell'esecuzione del programma a tempo di compilazione (compile-time).\r\nL'occupazione della memoria è costante per tutta l'esecuzione del programma, l'allocazione viene fatta una volta sola prima dell'esecuzione del programma, non appesantendo il suo tempo di esecuzione e a tutte le variabili viene associata una zona di memoria permanente che verrà rilasciata solo quando il programma terminerà.\r\nL'allocazione dinamica della memoria consente, durante l'esecuzione di un programma \r\n(run-time), di eseguire le istruzioni per allocare lo spazio in memoria necessario e di \r\ndeallocarlo al termine della sua esecuzione, in modo da renderlo disponibile ad altri usi.\r\nL'occupazione della memoria è variabile nel corso dell'esecuzione in quanto le variabili sono allocate solo quando servono, appesantendo il tempo di esecuzione.\r\nUna variabile allocata dinamicamente utilizza l'area \"heap\", invece staticamente utilizza lo \"stack\".\r\n",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3589,
          "asker": {
            "courseId": 4,
            "askerId": 422,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Abbiamo visto che in C++ possiamo scrivere due definizioni equivalenti di Pila, sia come struct sia come class. A cosa è dovuta questa ambiguità? Questo problema è presente anche in Java?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": "struct"
            },
            {
              "keyword": "implementazione"
            },
            {
              "keyword": "ambiguità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3669,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "L'ambiguità è dovuta al fatto che in C++ esistono due ?strutture dati? molto simili tra loro: le struct e le class.\r\nUna struct fa tutto (o quasi) ciò che fa una class, solo che quest'ultima è utilizzata per la programmazione ad oggetti, perché nell'implementazione di una class non vengono dichiarati soltanto i dati al suo interno (come per la struct), ma anche le funzioni che operano sui dati stessi.\r\nUn'altra differenza è che di default i campi della struct sono pubblici, mentre quelli della class sono privati.\r\nPrima di ogni dichiarazione di dati o funzioni, infatti, sono presenti le parole public o private, che consentono rispettivamente di stabilire se dati e/o funzioni sono visibili anche all'esterno della classe (public) oppure se sono visibili solo al suo interno (private). \r\nNonostante sia un linguaggio che riprende per molti aspetti il C++, in Java questo problema non esiste, poiché, essendo un linguaggio object oriented, mantiene soltanto le class, eliminando le struct.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3639,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 433,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Le struct erano già implementate nel linguaggio C per poter creare delle strutture dati, perchè non esistevano le classi C non è un linguaggio di programmazione orientato agli oggetti come lo sono C++, Java e altri linguaggi), e C++ riprende C, e aggiunge la programmazione ad oggetti, quindi le classi. In Java non esistono le strutture dati (struct) come esistono in C, C++, C# e altri linguaggi di programmazione.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3621,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "È dovuta all utilizzo dei puntatori, il problema nn persiste anche in java perché i puntatori nn vengono utilizzati. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3661,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 524,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'ambiguità nel linguaggio C/C++ deriva dal fatto che entrambi i costrutti sono dei contenitori di elementi, cioè entrambi raggruppano elementi di diverso tipo sotto un' unica definizione e entrambi passano i propri campi per valore (a meno di \"dereference\"). Ma l'unica grande differenza tra i due è che nel costrutto \"struct\" i campi sono visibili all'utente (e per nasconderli bisogna inserirli in una  \"sottostruct\" \"private\"), mentre in una \"class\" i dati sono privati di default (e per renderli pubblici bisogna inserirli nella sottoclasse \"public\").\r\n\r\nIn Java questo problema non si riscontra in quanto \"class\" e \"struct\" sono due costrutti usati in ambiti completamente differenti. Il \"class\" si usa all'inizio del programma in Java per definire il programma che si sta implementando (es: public class <nome_programma>...), invece \"struct\" mantiene le stesse caratteristiche del linguaggio C/C++.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3708,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La Pila implementata con class differisce da quella implementata con struct poiché essa viene usata per la programmazione ad oggetti. Questo problema non è invece rilevante in java pochè utilizziamo solamente la Pila con class, essendo java una programmazione orientata agli oggetti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3595,
          "asker": {
            "courseId": 4,
            "askerId": 566,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene inserita una pila in memoria quando viene allungata di n elementi?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " cresci"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3619,
          "asker": {
            "courseId": 4,
            "askerId": 576,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Consideriamo una funzione che ha come unico parametro un vettore. Quando la funzione viene eseguita, in memoria, viene creata una nuova copia del vettore oppure no? Perché?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "arrays"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3582,
          "asker": {
            "courseId": 4,
            "askerId": 527,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza principale tra una struct e una class?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3586,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "I cicli che si utilizzano nel linguaggio di programmazione C++ come ad esempio for while do si possono utilizzare anche in Java?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "cicli"
            },
            {
              "keyword": " c++"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3588,
          "asker": {
            "courseId": 4,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per \"Overloading\" in C++? E in Java?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3593,
          "asker": {
            "courseId": 4,
            "askerId": 456,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è superfluo specificare l'operatore \"this\" nell'implementazione di un metodo interno a una struct che agisce sulle variabili della struct stessa?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3619,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 553,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"this\" è un tipo di riferimento che punta all'oggetto a cui appartiene. Può essere utile in certi casi per risolvere problemi di ambiguità (ad esempio oggetti di scope locale con lo stesso nome o con nome simile). Ma in una struct questo riferimento è già implicito: quando si tratta un campo, è già specificata la struct a cui appartiene.",
              "notes": "-",
              "rating": 6,
              "coins": []
            },
            {
              "answerId": 3679,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 458,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Posso rendere implicito il \"this\" poichè fa riferimento a variabili presenti già nella struct stessa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3594,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 440,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "a parola chiave this identifica un puntatore che fa riferimento alla struct. Non occorre che venga dichiarato poichè la sua dichiarazione è implicita nella classe.\r\nIl puntatore this punta all?oggetto per il quale è stata richiamata la funzione membro.\r\nData una definizione di struct con all'interno una funzione, il puntatore this consente l'accesso alla funzione precedentemente definita.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3664,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 429,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "È superfluo perché la variabile ha comunque validità solamente all'interno del metodo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3634,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perché implementando il metodo all'interno della struct, vengono lette di default le variabili definite nei campi della struct stessa, quindi \"this\", che è un puntatore alla struct, non è necessario.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3644,
          "asker": {
            "courseId": 4,
            "askerId": 577,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra lo stack e la queue?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " queue"
            },
            {
              "keyword": " differenza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3576,
          "asker": {
            "courseId": 4,
            "askerId": 565,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella funzione \"void distruggi\" (pagina 61 delle slides) qual'è la priorità della DELETE?\r\nMotiva la tua risposta.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "delete"
            },
            {
              "keyword": " distruggi"
            },
            {
              "keyword": " pagina61"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3621,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è preferibile dichiarare la grandezza di un array esternamente al codice, mediante l'utilizzo di una costante e non di una variabile globale?  ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Array"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3668,
          "asker": {
            "courseId": 4,
            "askerId": 559,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può dire che le 2 seguenti dichiarazioni siano equivalenti?\r\nCi sono differenze tra le due dichiarazioni?\r\n\r\n(1) int vector[100];\r\n(2) int *vector; vector = new int[100];",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "vettore"
            },
            {
              "keyword": "puntatore"
            },
            {
              "keyword": "stack"
            },
            {
              "keyword": "heap"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3605,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 551,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Le due dichiarazioni non sono equivalenti poiché attraverso la prima viene dichiarato un array di interi sullo stack, mentre tramite il codice del punto 2 viene prima dichiarato un generico puntatore ad intero a cui viene poi assegnato il valore di ritorno dell'operatore new a cui vengono passati come argomenti il tipo di dato e la quantità di dati da allocare (in questo caso vengono allocate un numero di unità di memoria sufficienti a contenere 100 interi). E' importante notare che, essendo il secondo vettore allocato dinamicamente, esso deve essere esplicitamente deallocato dal programmatore con l'uso di delete.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3696,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Gli array sono dei puntatori.\r\nQuando si dichiara un array in realtà si dichiara un puntatore con alcune caratteristiche in più: la dichiarazione di un puntatore comporta allocazione di memoria per una variabile puntatore ma non per la variabile puntata (int *vector alloca memoria per la variabile puntatore vector ma non per la variabile puntata vector).\r\nLa dichiarazione di un array comporta allocazione di memoria non solo per una variabile puntatore ma anche per l'area puntata, di cui viene definita la lunghezza, inoltre il puntatore viene inizializzato con l'indirizzo dell'area puntata, ovvero il primo elemento dell'array. \r\nEs: int vector[100]\r\n1) alloca memoria per il puntatore vector;\r\n2) alloca memoria per 100 valori di tipo int;\r\n3) inizializza vector con vett[0];\r\nIl comando new svolge esattamente le condizioni 2) e 3) dell'esempio sopra e da ciò si deduce che le due dichiarazioni sono equivalenti.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3659,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Entrambe le dichiarazioni avanzano la richiesta di allocare un array di 100 interi, la cui dimensione sarà data dal prodotto tra il numero di elementi contenuti nell'array e la dimensione del tipo a cui gli elementi appartengono (in questo caso intero). Ciò che le differenzia è l'area di memoria in cui l'array dichiarato sarà memorizzato. Difatti, mentre la prima dichiarazione richiede l'allocazione statica dell'array nello stack (porzione di memoria contente main, funzioni,variabili locali ecc..), la seconda richiede (tramite new) l'allocazione dinamica dell'array nello heap (area di memoria contenente tutto ciò che viene dichiarato con new), che si concluderà restituendo al puntatore, l'indirizzo in cui la \"struttura\" dell'array ha inizio. Da aggiungere che ciò dichiarato nello heap, dura fino a quando il programma non termina, a meno che non venga utilizzato l'operatore delete che dealloca l'array, rendendo nuovamente disponibile la porzione di memoria da esso occupata.",
              "notes": "-",
              "rating": 7,
              "coins": []
            },
            {
              "answerId": 3631,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 426,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Non si può affermare che le due dichiarazioni sono equivalenti.\r\nNel primo caso la memoria è statica, quindi è stata allocata nella memoria Stack.\r\nNel secondo caso è stato dichiarato un puntatore e successivamente dichiarata dinamicamente una porzione di memoria nell' Heap.\r\n\r\nTecnicamente sono tutti e due vettori che contengono 100 interi, ma vanno ad occupare parti di memoria differenti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3663,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 585,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "A livello sintattico le due scritture non presentano sostanziali differenze; la diversità sta nel fatto che mentre la prima è allocata staticamente, e quindi è meno pratica da utilizzare(in quanto può essere fatta in casi \"statici\", ossia dove sono note tutte le informazioni riguardo il contenuto dell'array), la seconda è allocata dinamicamente e quindi anche più utile perchè si adatta meglio alle esigenze dei diversi utenti che la utilizzano. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3697,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Entrambe le dichiarazioni creano un array, però vi è una sostanziale differenza: la prima espressione dichiara un array statico di 100 elementi utilizzando la sintassi intuitiva con le parentesi []; la seconda invece prima dichiara un puntatore al primo elemento dell'array e poi alloca dinamicamente la memoria per creare un array dinamico di 100 elementi, quindi non si può dire che siano equivalenti da un punto di vista tecnico, tuttavia potrebbero essere utilizzate allo stesso modo in un programma in base alle necessità del programmatore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3683,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai negli array la prima locazione corrisponde all'indice 0?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3638,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il modello di memoria? ",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3649,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "nel copiare una pila, che differenza c'è tra usare la funzione copia (creata in classe sulle slide) e il comando Pila *w=s? (con s la nostra pila in input e con w la variabile con cui vogliamo chiamare la nuova pila copiata dalla precedente)",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3628,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 443,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "La domanda contiene un errore perchè `Pila *w=s` non copia affatto la pila ma crea solo un puntatore che punta ad essa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3667,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Con la funzione copia creo nello heap un'altra pila esattamente identica alla prima, mentre con il comando Pila *w=s faccio solo una copia del puntatore (non una copia della pila) nello stack. In quest'ultimo caso mi trovo quindi ad avere due elementi che puntano alla stessa pila.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3722,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 549,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La funzione copia risulta molto più efficiente e adatta allo scopo mentre il secondo metodo è molto più sbrigativo, nonché fonte di possibili errori. Infatti la funzione 'copia' duplica l'intera struttura e se ne distanzia, copiandone dimensioni e variabili in modo da averne una copia esatta ma indipendente dalla prima. Mentre nel secondo caso si verifica una situazione per cui sia w che s puntano allo stesso spazio di memoria. Perciò i valori di s vengono copiati dentro a w, ma ogni cambiamento che verrà fatto in s cambierà automaticamente anche dentro a w (e viceversa). Questo entrerebbe in conflitto con lo scopo iniziale che era quello di avere una copia della pila con i suoi valori di partenza. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3675,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 516,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "La differenza tra i due tipi di copia è che la prima è una copia per valore (profonda), mentre la seconda per riferimento (superficiale).\r\nLa copia per valore è effettivamente una duplicazione completa della pila fatta componente per componente e produce due pile distinte. Questo implica (nel caso di pile molto grandi) un uso importante di memoria.\r\nLa copia per riferimento invece è semplicemente la copia del puntatore alla pila, risultando cioè in due puntatori alla stessa pila. Questo implica che le operazioni effettuate tramite i due puntatori abbiano effetto sempre sullo stesso target, elemento che può essere causa di errore e/o confusione.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3706,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La funziona copia alloca un nuova pila in memoria, identica alla prima. Con il comando Pila *w=s, invece, si crea un alias di s chiamato w: entrambi puntano alla stessa zona di memoria. Da ciò ne consegue che eventuali modifiche apportate alla prima pila, nel caso della funzione copia, non vengono applicate alla pila copiata; il contrario accade quando si utilizza Pila *w=s, in quanto l'oggetto sui cui si lavora è lo stesso.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3657,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Secondo i Principi di Parna, l'implementatore deve dare all'utente tutte le informazioni necessarie all'utilizzo della funzione e nulla di più. Inoltre il committente deve dare all'implementatore tutte le informazioni necessarie alla realizzazione della funzione e nient'altro.\r\nCosa intendono questi principi, perchè è importante seguirli e in che modo le variabili globali tendono a violarli?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Parna"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " principi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3634,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Se nella programmazione in generale è scoraggiato l'uso di variabili, supponiamo di avere due classi differenti classeA e classeB, scritte rispettivamente in due fogli java distinti: classA.java e classB.java.\r\nCome posso dalla classeA visualizzare/operare sulle variabili contenute nella classeB ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "variabili_globali"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3671,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 422,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Intanto vorrei precisare che l'uso di variabili più che essere sconsigliato è necessario per poter salvare un qualsiasi tipo di dato. Se la domanda intende che è sconsigliato l'uso di variabili GLOBALI allora tutto prende senso. Inoltre, è giusto precisare che non posso accedere alle variabili di classeA o classeB direttamente (a meno che non siano dichiarate come static) ma a due loro istanze.\r\nPer accedere alle variabili della classeB dalla classeA, posso in generale creare dei metodi, detti \"getter\" e \"setter\" che regolamentano l'accesso alle variabili dall'esterno della classe. Posso infatti avere un getter pubblico e un setter privato, così da limitare l'accesso in sola lettura della variabile (dall'esterno).\r\nEsempio:\r\n\r\nclass classeA {\r\n  classeB b;\r\n  classeA() {\r\n    b = new classeB();\r\n  }\r\n  void accessoRemoto() {\r\n    b.setName('Paolo');\r\n    System.out.println(b.getAge());\r\n  }\r\n}",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3646,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 566,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Lo posso fare importando la classeB nella classeA. Questo si fa inserendo la parola chiave ?import? seguita dal nome della classe, quindi, nel caso classeA e classeB, scrivo ?import classeB;? nel file della classeA.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3610,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Innanzitutto, non è vero che nella programmazione è scoraggiato l'uso di variabili, semmai è l'uso di variabili globali o pubbliche all'interno delle classi che è deprecato. Proseguendo, non è vero che la classeA può operare sulle variabili della classeB; è un'istanza, un oggetto, della classeA che può tentare di operare sulle variabili contenute in un'istanza della classeB. Le variabili contenute nella classe infatti non hanno una locazione di memoria precisa, vengono allocate quando una nuova istanza della classe viene creata. Comunque, per andare a modificare le variabili di un oggettoB, istanza della classeB, da un oggettoA, istanza della classeA, senza utilizzare variabili globali, bisogna far utilizzare all'oggettoB uno dei metodi pubblici dell'oggettoA che permette di modificare le variabili private desiderate.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3622,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Se le variabili della classe B ,sono state dichiarate come public, si può tranquillamente interagire con esse dalla classe A. Questo non era possibile con c e c++  che richiedono l'utilizzo di un puntatore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3714,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Dunque, se per variabili intendi quelle globali é vero, ne é sconsigliato l'uso, in questo caso Per visualizzare/operare su variabili di una classe in un B.java partendo da una linea di codice in un A.java ci sono due possibilità: se la variabile in questione é pubblica (dichiarata come \"public\") ci si può accedere direttamente chiamandola dall'A.java; se invece non é pubblica, si può lavorare con variabili interne a una classe del B.java solamente attraverso i metodi della classe B sempre che questi siano definiti e che siano pubblici in modo da poterli chiamare dalla'A.java.\r\nSe invece volevi affermare che é scoraggiato l'uso di variabili in generale... Beh parliamone xD :P",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3704,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Ma la domanda non doveva essere su C++ ?  In ogni caso il meccanismo di fondo è lo stesso.\r\nSe i due file stanno nella stessa directory si può utilizzare direttamente la classe B stando nella A per creare oggetti di tipo B usando il suo costruttore, ad esempio\r\nClassB b = new ClassB(arg);\r\n(Se non stanno nella stessa directory basterà includerle specificando il percorso)\r\nÈ inoltre possibile chiamare le funzioni della classe B e/o usare le sue variabili specificando a chi appartengono (in questo modo variabili con lo stesso nome ma dentro classi diverse non entrano in conflitto), ad esempio\r\nb.variabileB1 = 3;\r\nb.funB3 ();\r\nRicordiamo però che per utilizzare metodi e variabili di una classe occorre che queste siano pubbliche. In C++ una classe considera privato tutto ciò che viene definito senza specifiche quindi se voglio una funzione pubblica occorre definirla come\r\npublic void funB3 () ...",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3641,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè la funzione:      Pila * crea(int initialsize); \r\ne la corrispondente: distruggi(); \r\nvengono rinominate (slide 79-80) rispettivamente come Pila(int initialSize); e ~Pila() ?\r\ncosa comporta ciò?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " crea"
            },
            {
              "keyword": " distruggi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3689,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 570,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per ottimizzare il programma",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3656,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Questi passaggi portano ad avere la struct Pila trasformata in un oggetto: infatti, partendo da funzioni esterne che vanno solamente ad usufruire della struct, si arriva a definire i cosiddetti metodi. Si arriva così ad avere la classe Pila, vista come un nuovo elemento (ad esempio stringa o int) con specifiche operazioni che posso eseguire su di essa, in questo caso crea e distruggi.\r\nPer fare ciò le funzioni vanno dichiarate all'interno dell'oggetto di appartenenza e all'utilizzatore vengono dati come unici punti di accesso all'oggetto queste ultime.\r\nAlla fine non è cambiato nulla rispetto all'esempio iniziale, essendo di piccola importanza, ma quando i programmi aumentano di complessità l'uso di metodi e oggetti semplifica molto il compito del programmatore ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3607,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 430,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Vengono rinominate a tali perché diventano metodi d'istanza, rispettivamente un costruttore e un distruttore. L'utilizzo di metodi d'istanza aumenta la chiarezza e la leggibilità del codice prevenendo effetti indesiderati quali ad esempio i conflitti tra nomi (ad es. \"crea\" per uno struct Pila ma anche Coda o Albero).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3642,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "La funzione \"Pila * crea(int initialsize)\" ha la funzione di creare una nuova pila, cioè di allocare la memoria necessaria e inizializzare le variabili di stato ai valori corretti; la funzione \"void distruggi(Pila pila)\" ha invece la funzione di liberare la memoria occupata quando la pila non è più necessaria.\r\n\r\nNella programmazione orientata a oggetti queste 2 funzionalità sono fornite rispettivamente da costruttore e distruttore dell'oggetto a cui si riferiscono.\r\nIl costruttore è una particolare funzione che viene chiamata dal sistema a ogni \"new\"; ha lo stesso nome dell'oggetto da creare e non ha un tipo e può avere o meno parametri; in questo caso abbiamo la nuova firma \"Pila::Pila(int initialsize)\".\r\nIl distruttore è una particolare funzione che viene chiamata dal sistema a ogni \"delete\"; ha firma ~<nome_oggetto>(), in questo caso \"Pila::~Pila()\".\r\n\r\nCiò implica di non dover passare ogni volta l'oggetto alle 2 funzioni, con migliore leggibilità del codice e altri vantaggi.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3721,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 545,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "non lo so :)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3666,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 439,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Talvolta può risultare comodo rinominare le funzioni costruttore e distruttore in Pila() e ~Pila affinché utilizzando \"delete\" venga richiamata automaticamente la funzione distruttore ~Pila().",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3665,
          "asker": {
            "courseId": 4,
            "askerId": 517,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze (se esistono) tra il modello di memoria usato in Java e quello usato in C++?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "modello"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " C++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3626,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è raccomandabile e perché non è indispensabile l'utilizzo dell'identificatore \"this\" ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "this"
            },
            {
              "keyword": " identificatore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3631,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi/svantaggi ci sono a portare all'interno della struct le funzioni che la gestiscono ? ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Struct"
            },
            {
              "keyword": " Pila"
            },
            {
              "keyword": " Funzioni"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3623,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Portare all'interno le funzioni che gestiscono la nostra struct ci consente di evitare il problema dei puntatori poiché possiamo fare riferimento alla struct stessa grazie alla keyword 'this', la quale può essere omessa grazie allo scope.\r\nUn ulteriore vantaggio è la possibilità di rendere private o pubbliche le variabili di istanza e le funzioni membro.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3690,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In virtù del teorema di Böhm-Jacopini, ogni algoritmo può essere espresso in un linguaggio di programmazione che disponga di almeno tre strutture di controllo:\r\nalmeno una struttura di sequenza;\r\nalmeno una struttura selettiva;\r\nalmeno una struttura iterativa.\r\nIl Java dispone di queste strutture e anche di una struttura aggiuntiva per la gestione delle eccezioni.\r\nLa successione delle istruzioni è determinata dall'ordine in cui sono scritte nel codice sorgente del programma.\r\nSotto certe condizioni, il compilatore può cambiare l'ordine delle istruzioni localmente ad un metodo, e ciò ha conseguenze nei programmi multithreaded in cui i thread non sincronizzano correttamente gli accessi alle risorse condivise.\r\nInvece, il programmatore non può sovvertire l'ordine in cui le istruzioni sono eseguite: l'istruzione goto, presente in altri linguaggi, è stata deliberatamente lasciata fuori dal Java.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3629,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 459,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Potrebbero crearsi problemi sia nella scrittura delle funzioni membro sia nella possibilità che i metodi, essendo definiti pubblici di default dal costrutto struct , vengano utilizzanti impropriamente creando problemi per esempio usando un metodo che è solo a supporto di altri metodi a disposizione degli utenti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3614,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Il vantaggio principale è che ottieni un oggetto che contiene tutte i metodi relativi all'oggetto stesso.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3663,
          "asker": {
            "courseId": 4,
            "askerId": 533,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "per quale motivo bisogna creare una funzione \"copia pila\" se si può semplicemente eseguire una copia con \"Pila * w=s;\"?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "copia pila"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3680,
          "asker": {
            "courseId": 4,
            "askerId": 470,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la principale differenza tra allocare staticamente e dinamicamente?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "statico"
            },
            {
              "keyword": "dinamico"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3687,
          "asker": {
            "courseId": 4,
            "askerId": 461,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il procedimento corretto per evitare il fenomeno di memory leak?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memory"
            },
            {
              "keyword": "leak "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3698,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 575,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "C++ non si occupa di deallocare la memoria quando essa non viene più utilizzata quindi il programmatore deve procedere alla gestione manuale di questo aspetto. Quindi lavorando con la memoria dinamica, dopo aver allocato la memoria che serve (con la NEW) si deve sempre deallocarla (con la DELETE) con grande attenzione a non perdere l?informazione relativa al puntatore altrimenti non sarà più possibile procedere all?operazione di delete. Supponiamo di avere int *v; v = new int[13] . Le due strategie possibili per evitare di perdere l?indirizzo di base sono: scrivere subito delete(v); alla fine della function oppure creare la funzione di tipo int *f( ) in modo che restituisca il puntatore.\r\nPer Java non abbiamo questo problema infatti tale linguaggio fornisce il garbage collector che è un meccanismo automatico per ripulire la memoria che lavora durante l?esecuzione del programma.\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3616,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 518,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "In linea generale, un buon programma privo di memory leak, dealloca sempre le parti di memoria che sono state allocate dinamicamente durante l'esecuzione dello stesso utilizzando la sintassi apposita in base al linguaggio utilizzato. \r\nIn c++ tale comando è delete indirizzo;",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3633,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 504,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il migliore metodo è ricordarsi di deallocare quello che è stato precedentemente allocato dinamicamente nella heap e che non serve più al programma, usando il comando \r\n\"delete (puntatore all'area allocata dinamicamente)\" .",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3685,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 495,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Il fenomeno del \"memory leak\" è causato da un uso scorretto della heap da parte del programmatore. In particolare capita quando si alloca dinamicamente della memoria tramite l'operatore \"new\" senza poi rilasciarla con l'operatore \"delete\". La causa principale del \"memory leak\" è la perdita dell'indirizzo a cui fa riferimento il blocco di memoria allocato e, quindi, la materiale impossibilità di rilasciarlo. Per ovviare a questa situazione si può agire essenzialmente in due modi: usare direttamente l'operatore \"delete\" all'interno della funzione stessa o, nel caso in cui sia necessario conservare i dati più a lungo, fare in modo che la funzione restituisca l'indirizzo con un semplice \"return\" cosicché la memoria potrà essere rilasciata da un'altra funzione quando i dati in essa contenuti non saranno più d'interesse per il programmatore.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3670,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il fenomeno del \"memory leak\" avviene quando non si deallocata la memoria allocata dinamicamente, ovvero il mancato uso del \"delete\", che in C++ è compito del programmatore  utilizzarlo per deallocare la memoria, mentre in Java se ne occupa il Garbage collector, il quale individua un'area di memoria che non è più puntata da nessuno e la recupera tramite opportuna deallocazione.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3587,
          "asker": {
            "courseId": 4,
            "askerId": 573,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra la scrittura \"int v[]\" e \"(int*)v\"?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " indirizzi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3594,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che problema potrei incontrare copiando una pila in questo modo: \r\n\r\n     Pila *w = s; ??",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Copia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3610,
          "asker": {
            "courseId": 4,
            "askerId": 430,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando il vettore sottostante una struttura dati di tipo pila si riempie cos'è consigliabile fare?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " riempie"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3603,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è lo scopo di dichiarare variabili o metodi, all'interno di una struct o di una class, come pubbliche (public) o private (private) ?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "public"
            },
            {
              "keyword": " private"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3606,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Poichè usualmente si trattano programmi che verranno venduti o usati da utenti esterni, si cerca di rifarsi al principio di Parna, ovvero: si deve fornire all'utente solo lo stretto necessario perchè egli sia in grado di usare il programma. In questo caso, ponendo come private funzioni o variabili, le si rende inaccessibili all'utente e dunque non modificabili. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3618,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 557,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Per i principi di Parna, lo sviluppatore deve fornire al fruitore tutte e sole le informazioni di cui ha bisogno per utilizzare il suo progetto, e allo stesso tempo il committente deve fornire allo sviluppatore tutte e sole le informazioni necessarie allo sviluppo del progetto.\r\nPer questo, nelle class e struct è opportuno privatizzare tutti i metodi e le variabili che non servono all'utente per il corretto utilizzo del software. Ad esempio, nelle pile è bene privatizzare le variabili come la grandezza o le funzioni di crescita automatica in modo che chi utilizza la pila non possa interferire con il suo funzionamento.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3601,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Un metodo \"public\" sarà visualizzato anche al di fuori della classe in cui è stato dichiarato.\r\nUn metodo \"private\" sarà visualizzato solo all'interno della classe in cui è stato dichiarato.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3617,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Lo scopo di dichiarare variabili o metodi in classi e strutture come pubblici o privati è quello di proibire al programmatore di modificare un certo dato (se privato) in modo tale da non manomettere dei dati che in precedenza si voleva tenere nascosti. Quindi per accedere ad una variabile privata c'è bisogno di un metodo pubblico nella stessa classe che lo modifichi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3720,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 460,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Fra i motivi per i quali un programmatore potrebbe voler rendere nota o nascondere una parte del suo programma (in inglese data hiding) vi sono sia quelli economici (volere o meno rendere pubblica la struttura e il funzionamento di un software a pagamento), che quelli tecnici. In particolare, se più programmatori lavorano alla creazione di uno stesso programma, e a ognuno è stata assegnata una parte di codice, è bene che ognuno sappia tutto e solo ciò di cui ha bisogno per svolgere il proprio compito (principio di Parnas): di conseguenza potrà risultare necessario rendere private variabili, metodi e altre parti di codice altrimenti pubblici (per es. il marker di una struct Pila) per evitare che i colleghi le fraintendano o ne influenzino per errore il funzionamento. D'altro canto può anche essere necessario rendere note alcune variabili o parti di codice altrimenti nascoste \"di default\" (come nel caso visto a lezione del marker di una class Pila) perché utili o necessarie ai colleghi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3632,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 505,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Si usano a scopo di nascondere o rendere visibili le variabili ,o metodi, al di fuori della struct o della classe in oggetto, in sostanza public e private regolano la visibilità dei miei metodi o variabili all'interno del mio programma.\r\nEs. se in una mia libreria ho un metodo private il programma che utilizzerà quella libreria non potrà accedervi, ma è utilizzabile dai miei metodi della libreria stessa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3716,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 480,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Una classe o struct è concepita come una struttura \"a scatola chiusa\", per questo motivo vengono definiti metodi e variabili public se essi costituiscono l'interfaccia con cui l'utilizzatore della classe deve poter interagire, mentre gli elementi specificati come private generalmente sono necessari per operazioni interne alla classe stessa ma non sono accessibili direttamente.\r\nQuindi, se non strettamente necessario, è buona norma impostare metodi e variabili interne a una determinata classe come private al fine di ridurre al minimo il numero di errori causati da modifiche non direttamente gestite dalla classe stessa.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3693,
          "asker": {
            "courseId": 4,
            "askerId": 581,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è consigliabile, in determinati casi, dichiarare come privati dei metodi di classe?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodi"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3630,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa differiscono le struct dalle classi?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3673,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per \"operator overloading\" e quali sono le sue funzionalità?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " operatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3600,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In che senso si può dire che in c++ gli array e i puntatori sono la stessa cosa?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "arrays"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3601,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di includere una o più funzioni all'interno di una struttura dati?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3608,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "i vantaggi sono diversi, prima di tutto è possibile definire le funzioni in maniera più semplice, infatti non è necessario ridefinire le variabili, in quanto già definite all'interno dello scope. Un altro vantaggio è quello di definire quali funzioni devono essere accessibili dal codice che non fa parte della classe (pubbliche) e quali invece devono essere con accesso privato, alle quali si può accedere solo tramite classe;",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3688,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "spero che intendi le dichiarazioni delle funzioni))\r\nprima di tutto, in questo modo il codice sembra ben organizzato perche tutti le funzioni che riguardano una certa struttura dati sono descritti all'interno di quella struttura, poi ,cosi è piu faccile di implementare,monipolare,gestire le funzioni,per d piu vengono introdotti il costruttore e il destruttore( che riguardano allocazione dinamica dei dati)... :)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3660,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "I vantaggi di includere funzioni in una struttura dati stanno nella compattezza e nella mantenibilità del codice poiché struttura dati e funzioni che operano su di esso sono nello stesso \"pacchetto\" che ci consente di non implementare le stesse funzioni ogni volta.\r\nInoltre includendo una o più funzioni all'interno di una struttura dati non c'\u0012e bisogno di un oggetto di invocazione. Se vogliamo creare una vettore per esempio, non abbiamo bisogno di passarne alcun parametro alla funzione che lo crea.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3650,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 461,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "I vantaggi di includere uno o più funzioni in una struct sono quelli di poter definire le parti che sono private ovvero visibili solamente dal programmatore della struct, da quelle visibili a tutti ovvero pubbliche, e in questo modo riuscire a \"rispettare\" il principio di Parna.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3686,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 428,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il vantaggio principale è dato dal fatto che, includendo più funzioni all'interno di una struttura dati, abbiamo un programma con poche ripetizioni di dati (informazioni) ed evitiamo scomode ridondanze. Questo anche se dovessimo mettere mano al programma in un secondo momento, più essenziale ed in ordine è l'elaborato, più facile sarà il nostro lavoro! ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3600,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "i vantaggi sono molteplici:\r\nil codice  diventa più leggibile, perche sono richiesti meno parametri formali al momento della dichiarazione e chiamata. Diventa più leggibile anche perche tutta la struttura e le funzioni vengono raggruppate, in modo che si sappia fin da principio cosa si può fare con quell'oggetto o meno. Inoltre è possibile evitare di utilizzare la parola chiave this. un altro vantaggio è che è possibile dividere funzioni e o variabili/altri dati in pubblici e privati. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3693,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 500,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Essenzialmente per il compilatore non cambia niente, i vantaggi sono principalmente per il programmatore poiché eliminando l'operatore \"->\" il codice risulta visibilmente più chiaro e leggibile. Non si deve inoltre trascurare la maggiore mantenibilità del programma.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3686,
          "asker": {
            "courseId": 4,
            "askerId": 440,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra i comandi di output di java e c++?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "streaming"
            },
            {
              "keyword": "output"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3697,
          "asker": {
            "courseId": 4,
            "askerId": 448,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "C'è differenza nel modo di memorizzazione delle class e degli struct?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " class"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3599,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale può essere un'alternativa valida al passaggio per puntatore non più disponibile in Java?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "passaggio"
            },
            {
              "keyword": " parametri"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3570,
          "asker": {
            "courseId": 4,
            "askerId": 443,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In che area di memoria sono allocate le strutture dinamiche",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " allocazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3623,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale, tra i tre costrutti della slide 37, risulta il codice migliore a livello di computabilità e leggibilità? Quale, invece, a livello di memoria?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Vettore"
            },
            {
              "keyword": " inizializzazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3611,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Pro e contro riguardo l'uso delle variabili globali nel linguaggio C/C++. In un progetto è consigliabile farne uso oppure no??",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pro"
            },
            {
              "keyword": " Contro"
            },
            {
              "keyword": " Variabili"
            },
            {
              "keyword": " Globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3676,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Si descriva il funzionamento del binomio \"new-delete\" e i rischi che comporta il suo non utilizzo.",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "New"
            },
            {
              "keyword": "delete"
            },
            {
              "keyword": "heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3682,
          "asker": {
            "courseId": 4,
            "askerId": 442,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè nella costruzione di uno stack è necessario allocare la memoria dinamicamente e perchè al termine dell'esecuzione questa stessa memoria va deallocata?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": "allocazione"
            },
            {
              "keyword": "dinamica"
            },
            {
              "keyword": "deallocazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3685,
          "asker": {
            "courseId": 4,
            "askerId": 545,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si intende con \"metodi\" e quali differenze fondamentali ci sono tra \"struct\" e \"class\"?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " metodi"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3678,
          "asker": {
            "courseId": 4,
            "askerId": 525,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il metodo di una classe?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 24,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3662,
          "asker": {
            "courseId": 4,
            "askerId": 473,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la variabile defaultGrouthSize presente nell'implementazione in C++ della pila?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " c++"
            },
            {
              "keyword": " defaultgrouthsize"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3656,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Slide pag.80: Vorrei un chiarimento sull'utilizzo di \"Pila::~Pila()\" anziché \"void Pila:: distruggi ()\": è semplicemente una forma che il c++ conosce di default per non dover specificare \"delete this\"?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": "delete"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3585,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza nell'utilizzo tra una struttura ed una classe? (struct e class)",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3612,
          "asker": {
            "courseId": 4,
            "askerId": 572,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Come scelgo se usare gli struct e quando uno le classi?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3609,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Ciao! lo so che é una rottura.. quindi ti faccio una domanda semplice semplice:\r\n\r\nMario da una mela a Francesco, con questi dati calcola la distanza dalla Terra al Sole.\r\n\r\n:D La vera domanda é:\r\nIn C++ come si rappresentano le strighe? esiste un tipo nativo Stringa oppure si usano strane cose con strane convenzioni? (ovviamente la seconda)",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "string"
            },
            {
              "keyword": "C++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3628,
          "asker": {
            "courseId": 4,
            "askerId": 551,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'implementazione di una funzione membro di una struttura dinamica è possibile fare riferimento alle variabili di istanza anche omettendo la parola chiave `this`. Quale assunzione del linguaggio ci permette di fare ciò?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Strutture"
            },
            {
              "keyword": " Funzioni Membro"
            },
            {
              "keyword": " C++"
            },
            {
              "keyword": " Variabili d'istanza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3580,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che dati vengono immagazzinati nell'area di memoria denominata \"text\" da un dato programma? Come può il suddetto programma influenzare i dati presenti in quest'area? Per quale motivo?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Memoria"
            },
            {
              "keyword": " Text"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3573,
          "asker": {
            "courseId": 4,
            "askerId": 479,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In una pila, perché dovrei definire alcuni parametri come private (se pila è definita come struct) o public (se pila è definita come class)?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Struct/private"
            },
            {
              "keyword": " class/public"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3707,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Nella programmazione ad oggetti, \"public\" e \"private\" sono dei modificatori, ossia delle parole riservate che permettono di impostare il livello di visibilità delle classi, attributi o metodi. Con \"public\" l'accesso è libero, quindi l'elemento è visibile ovunque. Assegnando \"private\" ad un elemento lo si rende accessibile solo all'interno della classe (Information Hiding). Quando è stato introdotto il concetto di classe in C++, i suoi membri sono stati imposti come \"private\" di default, in accordo con la filosofia della programmazione ad oggetti. Per rendere accessibili i suoi elementi all'esterno della classe bisogna assegnargli il modificatore \"public\". Le struct al contrario in accordo con il C, sono di default public.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3602,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "I campi di una struct vengono impostati 'public' di default, ciò significa che sono accessibili in modo incondizionato, quindi (per il principio di PARNAS secondo il quale l'utilizzatore del mio codice deve avere l'accesso SOLO allo stretto indispensabile per utilizzare le funzionalità del mio codice) se voglio 'nascondere' alcune variabili o funzioni implementate all'interno della struct devo dichiararle private. \r\nIn una classe, invece, variabili e metodi sono definiti privati di default, quindi se voglio rendere il mio codice utilizzabile (visibile) da qualcun altro devo dichiarare alcuni campi come pubblici.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3609,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Perché in una classe se non viene definita la visibilità, il parametro prenderà \"private\" di default mentre in una struct,la visibilità deve essere definita.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3613,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 590,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Alcuni parametri vanno definiti  in una struct come \"private\" se non si vuole che venga visto dall'esterno.\r\nNelle pile definite come class si definisce \"public\" se si vuole che venga visto all'esterno.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3592,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "La differenza sta tutta nella visibilità di default applicata a struct e class. Nelle struct (slide 83), quando non si specifica nè private nè public, i membri sono automaticamente impostati come public; per avere membri privati, quindi, è necessario specificare esplicitamente l'accessibilità private. Nelle class (slide 84), invece, l'accessibilità di default è private; è quindi necessario specificare quando si vogliono membri public.\r\n\r\nCome si può vedere nella slide 85 le due dichiarazioni sono in realtà equivalenti ed hanno lo scopo di nascondere al mondo esterno i componenti vitali per il corretto funzionamento della pila ed, al tempo stesso, esporre i metodi necessari all'utilizzo della pila stessa.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3676,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 454,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Bisogna farlo perchè per default in una pila definita come struct ciò che non viene definito con il parametro private è visibile a tutti gli utenti, mentre in una pila definita come class tutto è privato e se voglio far vedere qualcosa all'utente devo renderlo pubblico con il parametro public.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3655,
          "asker": {
            "courseId": 4,
            "askerId": 549,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i side-effects delle variabili globali?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " globali"
            },
            {
              "keyword": " side"
            },
            {
              "keyword": " effects"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3629,
          "asker": {
            "courseId": 4,
            "askerId": 537,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Supposto di aver dichiarato un puntatore mediante il comando p=new type, quali problemi potrebbe causare il mancato uso dell'operatore delete(*p)? ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3637,
          "asker": {
            "courseId": 4,
            "askerId": 558,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra una class e una struct? ",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": " struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3615,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenze ci sono tra le zone di memoria Stack e Heap?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3695,
          "asker": {
            "courseId": 4,
            "askerId": 439,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale modo è possibile costruire una struttura dati dinamica in C++?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struttura"
            },
            {
              "keyword": " dinamica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3605,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Che rapporto esiste tra array e puntatori in C++? Se 'a' è un array di dimensione 10, qual è la differenza tra scrivere \"a[0], *a, *(a+0), 0[a]\"?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3675,
          "asker": {
            "courseId": 4,
            "askerId": 541,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra un'allocazione \"at compile time\" e un'allocazione \"at run time\"?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione"
            },
            {
              "keyword": " compile time"
            },
            {
              "keyword": " run time"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3669,
          "asker": {
            "courseId": 4,
            "askerId": 540,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra il passaggio di parametri a una funzione per riferimento e il passaggio di parametri per puntatore?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " riferimenti"
            },
            {
              "keyword": " parametri"
            },
            {
              "keyword": " funzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3581,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra una struct ed una classe?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Struct"
            },
            {
              "keyword": "Class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3577,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel momento in cui un assert fa abortire il programma, cosa succede nell'heap? ",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "assert"
            },
            {
              "keyword": " heap"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3673,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "L'assert è un sistema di controllo delle funzioni, che può essere utilizzato per verificare e controllare l'eventuale verificarsi di casi \"impossibili\" del programma che ne potrebbero compromettere l'esecuzione. Alcune implementazioni di compilatori più moderni del C/C++ prevedono uno svuotamento della memoria heap, ma in alcuni casi è possibile che si riscontri un errore che porta a dover rimuovere manualmente ogni allocazione di memoria dinamica.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3652,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "assert() è una macro (non mi risulta che l'abbiamo affrontata: è una sorta di funzione in cui quando il preprocessore, analizzando il codice, trova una chiamata a tale macro, la sostituisce con la sua definizione) che valuta una asserzione, ovvero che valuta la veridicità (!0) o meno (0) dell'espressione che gli viene passata.\r\nNel caso di asserzione falsa (quando qualcosa non va come desideravamo), assert() stampa in STDERR un messaggio che indica dove si è verificato il problema, e quindi chiama abort() per abortire l'esecuzione del programma.\r\nQuando si verifica tale situazione, l'unica richiesta di abort(), secondo le specifiche POSIX.1-2001 e C89 (e successive), è la chiusura forzata di tutti gli stream, e quindi non gli viene demandato nulla che abbia a che fare con la memoria heap.\r\nQuindi la risposta è: niente.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3643,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Dal momento in cui il programma termina (anche se è stato abortito da assert), i dati che tale programma aveva allocato nella heap vengono deallocati, e le celle prima occupate adesso diventano disponibili per altri programmi.In poche parole tutte le celle di memoria occupate dal programma vengono \"liberate\" e rese disponibili per altre applicazioni.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3575,
          "asker": {
            "courseId": 4,
            "askerId": 426,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Come alloco correttamente in C una matrice dimamica con dimensioni x e y passati dall'utente?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "C"
            },
            {
              "keyword": "arrays"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3691,
          "asker": {
            "courseId": 4,
            "askerId": 475,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella slider 61(void distruggi) perchè si dealloca 2 volte?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "deallocazione"
            },
            {
              "keyword": " struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3574,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'operator overloading in C++?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "operator"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3641,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 466,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "È semplicemente definire due funzioni con lo stesso nome che prendono tipi di argomenti diversi. Infatti in C++ la \"firma\" (cioè la stringa che usiamo per dichiarare una funzione) comprende non solo il nome ma a che il tipo e gli argomenti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3589,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Il C++ ha il meccanismo di overload (sovraccaricamento) per le funzioni ovvero gli operatori non sono altro che un modo conciso per scrivere delle funzioni.\r\nEs. a+b è in realtà funzione_somma(a,b)\r\nIn C++ gli operatori si possono indicare esplicitamente e sovraccaricarli, rendendoli così specifici per i tipi utente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3620,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 592,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'operator overloading in C++ è la possibilità di redefinire gli operatori  messi a disposizione dal linguaggio  (+, / , += , -- ,new, >=, !=,...) per i tipi di dati predefiniti (int,float,char,...) su i tipi di dato creati dall'utente (il programmatore), attraverso il comando \"operatorOp\" dove Op è l'operatore che si vuole redefinire.\r\nIn altre parole se creo uno tipo di dato, ho la possibilità di definire il funzionamento dei vari operatori. Ciò ci permette di utilizzare gli operatori senza incorrere nell'errore di un malfunzionamento del programma per dell'adizione non è svolta correttamente tra due operandi di un tipo di dato non predefinito.\r\nEs.\r\nstruct Complex {\r\nint parteRe;\r\nint parteIm;\r\n}\r\nLa somma tra due numeri di questo nuovo tipo di dato, non dara il risultato desiderato. Questo perchè non è stato stabilito come si fa l'addizione. \r\nOvvero bisognerebbe redifinire l'operatore di addizione nel seguente modo: \r\nComplex operator+(const Complex& a ,const Complex& b) { ... }\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3647,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 496,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "In C++ l'operator overloading è una tecnica che permette di dotare gli operatori di più funzionalità differenti.Per effettuare l'operator overload in C++ si usa la parola chiave \"operator\" seguita da: il simbolo dell'operatore su cui vogliamo effettuare l'overload,la lista dei parametri di ingresso,la definizione dell'operatore.\r\nES:int operator/ (float a,float b) {\r\nint i=0;\r\nfloat tot=0;\r\nwhile (tot+b<=a){\r\ntot+=b;\r\ni++;\r\n}\r\nreturn i;\r\n}\r\nL'operator overloading dell'esempio permette di utilizzare l'operatore / sui float,non più solo sugli int. Quando verrà valutata ad esempio l'espressione a/b, se a e b sono due interi verrà effettuata la divisione tra interi, se sono float verrà effettuata la divisione così com è definita sopra.\r\nGrazie all'operator overload è perciò possibile aumentare le funzionalità di un operatore, ma non è possibile modificarne il numero di parametri ('+' può accettare solo 2 parametri) ne la priorità sugli altri operatori(* ha prior.magg di +)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3712,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 547,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "L'operator overloading (cioè il sovraccarico di un operatore) in c++ non è altro che la ridefinizione di un operatore da parte del programmatore.\r\nCiò serve a 'estendere' l'uso degli operatori a tipi non primitivi (come matrici, numeri complessi o stringhe di caratteri); ad esempio bisogna per forza effettuare l'overload di un operatore (ad eccezzione di '&' e '=') per poterlo utilizzare sugli oggetti di una classe.\r\nPossono solo essere definiti operatori esistenti (+,*..) ed è buona norma che il senso a loro riassegnato rimanga più vicino possibile a quello originario, per quanto di fatto esso possa essere arbitrario.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3645,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 517,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Il meccanismo di overloading degli operatori consente di attribuire ulteriori significati /usi agli operatori del linguaggio. In C++ è possibile eseguire l'overloading della maggior parte degli operatori, per consentire loro di svolgere operazioni specifiche rispetto a determinate classi. Cioè fa si che gli operatori diventino utilizzabili oltre che ai tipi nativi anche ai tipi di dati astratti. \r\nL'overloading di un operatore:\r\n-  estende l'insieme dei tipi ai quali esso può essere applicato, lasciando invariato il suo uso originale; \r\n- consente di integrare meglio le nuove classi create dall'utente nell'ambiente di programmazione; \r\n- è alla base delle operazioni di I/O del C++;\r\n- viene realizzato tramite le funzioni \"operator\". Una funzione \"operator\" definisce le specifiche operazioni che dovranno essere svolte dall'operatore sovraccaricato (overloaded) rispetto alla classe specificata.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3709,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 445,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'overloading in C++ Consente al programmatore di richiamare all'interno del main una stessa funzione purchè con argomenti diversi.\r\nAd esempio posso richiamare una funzione \"moltiplica\", che moltiplica due numeri, all'interno del main quante volte voglio.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3653,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Gli operatori in C++ sono considerati come funzioni e definiti per tipi di parametri standard. Fare l'operator overloading (sovraccarico dell'operatore) consiste nel ridefinirli per poter operare sui tipi di dato creati dall'utente così come si opera sui tipi primitivi(int,char,..). Questo permette una manipolazione più intuitiva e concisa degli oggetti creati.\r\nSupponiamo di aver definito una classe per i numeri complessi. Affinché un operatore (ad esempio +) possa operare sugli oggetti della nostra classe, deve essere esplicitamente ridefinito  (operator+). Il senso di una ridefinizione di un operatore dovrebbe essere quanto più vicino al senso che l?operatore ha per i tipi predefiniti per evitare un codice di difficile interpretazione (ma nulla vieta di chiamare ? l'operatore che somma due complessi!)",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3702,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In C++ l'overload di operatore consiste nel definire il comportamento di un operatore. Si procede come nelle funzioni: il nome della funzione che si va a creare è formato dalla parola chiave operator seguita del simbolo dell'operatore che si vuole sovraccaricare, ad esempio se voglio sovraccaricare l' operatore meno avrò operator-.\r\nLa sintassi è:\r\nmy_class my_class :: operator-(argomento) {\r\n //definizione operazione\r\n}\r\nSe si ridefinisce un operatore il suo senso deve avvicinarsi il più possibile al senso che aveva per i tipi predefiniti(se faccio l'overload dell'operatore + per eseguire una sottrazione, creo confusione e la leggibilità del codice diventa critica).\r\nNon si possono inventare nuovi operatori facendone l'overload (come $,£) e non si possono ridefinire gli operatori se operano sui tipi predefiniti(come int,char,float ecc.).\r\nNon si può inoltre cambiare il numero di parametri (detto \"arità\") che prende l'operatore: in a+b l'overloading è operator+(tipo a, tipo b).",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3604,
          "asker": {
            "courseId": 4,
            "askerId": 591,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la variabile 'defaultGrowthSize' nella struttura della Pila?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " defaultGrowthSize"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3590,
          "asker": {
            "courseId": 4,
            "askerId": 487,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consistono i principi di Parna e come ci permettono di omettere il puntatore \"this\" e la sintassi (this ->) quando una funzione è definita all'interno della struct su cui va ad operare?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 4,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Parna"
            },
            {
              "keyword": " struct"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3684,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Si spieghino il funzionamento dello stack e dello heap e le differenze tra di loro.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": " heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3627,
          "asker": {
            "courseId": 4,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 85,
            "taskName": "Ask A Question"
          },
          "questionText": "Negli esempi visti a lezione si dice che si possono dichiarare vettori che allocano spazio in modo statico(stack) e in modo dinamico(heap), quale versione conviene usare e perchè?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "c++"
            },
            {
              "keyword": " vettori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3651,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Dipende dal programma che si vuole creare. L'allocazione dinamica è conveniente in programmi più complessi, per evitare lo spreco di memoria.\r\nMentre i vettori statici devono comprendere un numero fisso di elementi, che deve essere conosciuto al momento della compilazione, i vettori dinamici possono essere creati ogni qualvolta si desidera e ogni volta con un numero diverso di elementi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3648,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Parto da un esempio: devo scrivere un programma che fa delle operazioni con una matrice che ricevo in input. \r\nA priori non sono note le dimensioni della matrice. In questo caso conviene dichiarare un vettore (bidimensionale) che alloca spazio in Heap,cosi' facendo la memoria e' allocata a run-time e non a compile-time.\r\nSe invece sono già note le dimensioni del vettore da utilizzare ha senso che questo allochi memoria nello Stack.\r\nSe il programma deve utilizzare il vettore solo per operazioni temporanee puo' essere comunque utile lavorare in Heap in modo da liberare memoria inutilizzata una volta che non serve piu' il vettore (considerando la memoria di un pc attuale penso ad esempio a matrici 1000x1000).\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3668,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Per la dichiarazione di un vettore (array) conviene usare l'allocazione dinamica (heap) e non quella statica (stack). Il problema principale della dichiarazione in stack è che il numero degli elementi dell'array deve essere deciso prima dell'esecuzione del programma (ovvero in fase di compilazione). Usando invece un allocazione di tipo dinamico (usando il comando new()) questo problema non sussiste (ovviamente in tal caso è fondamentale l'uso dell'operatore delete(),per evitare problemi di memory leak).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3694,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 578,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "L'allocazione dinamica è più vantaggiosa per il fatto di poter gestire al meglio la memoria. Con IP fatto di poter deallocare alla fine del programma ti permette di ottimizzare le prestazioni della memoria. Attenzione: è compito del programmatore deallocare ciò che è stato allocato in precedenza per evitare rallentamenti e memory leak.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3640,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Non c'è un \"modo migliore\" per allocare la memoria, dipende dall'uso che se ne deve fare. L'allocazione statica è da preferire nel caso in cui non si abbia la necessità di far esistere la variabile anche al di fuori del blocco in cui è dichiarata e si sappia a priori (prima del runtime) la grandezza del vettore da allocare; infatti in generale l'allocazione statica permette di non avere i \"memory leak\" dovuti alle dimenticanze del programmatore (è la macchina a deallocare automaticamente la memoria alla fine del blocco); nello stack non si avrà inoltre il rischio di \"frammentazione\" della memoria tipica dello heap.\r\nL'allocazione dinamica si rende invece necessaria quando non si conosce nel momento della compilazione lo spazio di memoria necessario per le variabili, e quando si ha la necessità di far esistere le variabili anche al di fuori del proprio blocco; infatti qui la memoria viene allocata al \"runtime\" e gli operatori new-delete permettono al programmatore di gestire la memoria.\r\n",
              "notes": "-",
              "rating": 6,
              "coins": []
            },
            {
              "answerId": 3695,
              "task": {
                "taskId": 87,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 567,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Lo stack è una parte di memoria in cui viene allocato lo spazio per le variabili dichiarate nelle funzioni. Queste variabili restano visibili solo all'interno della funzione, e lo spazio che esse occupano in memoria viene automaticamente deallocato alla fine della funzione. Le variabili che sono allocate nello stack hanno inoltre dimensione fissata per ogni tipo, a seconda del sistema operativo. \r\nL'heap invece è la parte di memoria in cui lo spazio viene allocato manualmente e quindi deve essere anche deallocato manualmente. Questo passaggio è fondamentale e non va scordato in quanto diversamente la memoria che è stata allocata e non viene rilasciata, rimane occupata e si rischia di incorrere nel memory leak. \r\nÈ difficile definire quale versione conviene usare. Lo stack garantisce il rilascio automatico della memoria. D'altro canto il vantaggio dell'heap è di non fornire una dimensione definita per le variabili, ma ampliabile.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        }
      ]
    },
    {
      "lectureId": 42,
      "lectureTitle": "Classi ed EreditarietÃ ",
      "questions": [
        {
          "questionId": 3819,
          "asker": {
            "courseId": 4,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'ereditarietà cosa si intende per estensioni? Qual'è la differenza fra estensioni strutturali e comportamentali?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " estensioni"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3837,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Parlando di ereditarietà, nel linguaggio Java l' estensione di classi è il meccanismo\r\nche permette di definire una classe partendo da un' altra classe tramite l' aggiunta\r\ne/o la ridefinizione di funzionalità.\r\nLa classe che viene definita è denominata SOTTOCLASSE mentre la classe di partenza prende il nome di SUPERCLASSE e tutte le proprietà e le operazioni da lei definite sono implicitamente definite anche nella sottoclasse che le eredita.\r\nLa superclasse può introdurre nuove proprietà e funzionalità per i propri oggetti, ri-definire funzionalità già definite nella classe base e ogni istanza della classe estesa può essere considerata anche un' istanza della classe base.\r\nLe estensioni possono essere di due tipi:\r\n-STRUTTURALI: la sottoclasse è caratterizzata dall' aggiunta e/o modifica di variabili di istanza.\r\n-COMPORTAMENTALI: la sottoclasse è caratterizzata dall' aggiunta e/o dalla modifica di metodi.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3799,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Estendere una classe significa semplicemente aggiungere dei membri alla stessa per creare una nuova classe, più \"ricca\", oppure ridefinirne alcuni metodi.\r\nUn'estensione è strutturale se vengono aggiunte delle nuove variabili d'istanza alla nuova classe creata, mentre sono da considerarsi comportamentali se nella nuova classe estesa vengono aggiunti dei nuovi metodi(o sovrascritti)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3868,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 477,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Con \"estensione\" si intende l'arricchimento di una classe esistente con nuove funzionalità, per poter estenderne l'utilità o aggiungere informazioni, creando così una sottoclasse.\r\n\r\nLa sottoclasse \"eredita\" le variabili di istanza ed i metodi della classe padre, cioè ha a sua disposizione i metodi e le variabili di istanza definiti in questa (salvo eventuali restrizioni sulla visibilità di variabili e metodi della classe padre).\r\n\r\nOltre a questo la sottoclasse può utilizzare variabili di istanza aggiuntive rispetto a quelle già acquisite, creando così una estensione strutturale.\r\nSe invece la sottoclasse modifica i metodi ereditati (tramite overloading e/o overriding) oppure aggiunge a sua volta nuovi metodi, l'estensione è considerata comportamentale. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3763,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 495,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Le estensioni di una classe altro non sono che le sue sottoclassi, le quali \"estendono\" la classe base nel senso che vi aggiungo informazioni (campi e/o metodi) \"ereditando\" (da cui il termine \"ereditarietà\") campi e/o metodi da essa. L'uso della parola \"estensione\" deriva dal verbo inglese \"extends\" che è la formale parola sintattica che si usa nel codice per dire a Java che ciò che stiamo creando è una sottoclasse di una classe precedente come nel seguente esempio: class Uccelli {...}, class Pinguini extends Uccelli {...}. La differenza tra estensione strutturale e comportamentale è, invece, teorica e non ha a che vedere con il codice: per estensione strutturale s'intende l'aggiunta di campi (che sono la struttura di una classe), mentre per estensione comportamentale s'intende l'aggiunta e/o la modifica di metodi (che ne definiscono il comportamento).",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3849,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 489,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Per estensione di intende una classe che eredita dati e funzionalità da un'altra classe. In altre parole, creo una classe, detta classe padre, in cui definisco dei dati e delle funzionalità. Ora posso creare un'altra classe estendendo quella appena creata, ereditando i dati e le funzionalità della classe padre. Quindi nella seconda classe posso utilizzare tutte le funzioni e i dati definiti nella prima e implementarne di nuovi/e. La seconda classe si dirà un'estensione della prima. Le estensioni possono essere strutturali, quando creo nuove variabili di istanza, o comportamentali, quando creo nuovi metodi o modifico quelli esistenti nella classe padre.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3869,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'ereditarietà rappresenta un meccanismo che consente di creare nuovi oggetti basandosi su altri già preesistenti. Si tratta di una relazione di generalizzazione/specificazione imposta dal programmatore: da una certa classe \"madre\" se ne ottiene un'altra, detta \"figlia\", specializzando quella iniziale.\r\nUna sfaccettatura di questo paradigma è il concetto di estensione: si dice che una classe B estende una classe A se B è figlia di A ed è (possibilmente) dotata di ulteriori variabili di istanza o di metodi aggiuntivi (rispetto ad A), accessibili ed utilizzabili da ogni istanza di B.\r\nVi sono due principali tipi di estensione (e le loro combinazioni): le estensioni strutturali (rispetto ad A, B possiede ulteriori variabili di istanza) e quelle comportamentali (a B sono stati aggiunti nuovi metodi o sono stati modificati metodi ereditati da A - nel secondo caso, detto overriding, se deve valere il principio di sostituzione di Liskov, la differenza non può essere osservabile dall'esterno).",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3767,
          "asker": {
            "courseId": 4,
            "askerId": 531,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze e le somiglianze di una struttura dati in c++ e una classe in java?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": " struttura"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3779,
          "asker": {
            "courseId": 4,
            "askerId": 513,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la funzione toString e perchè è possibile usarla senza definirla nelle varie classi?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "toString"
            },
            {
              "keyword": " gerarchia"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3729,
          "asker": {
            "courseId": 4,
            "askerId": 511,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa significa la parola chiave \"super\" in una sottoclasse?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " sottoclasse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3699,
          "asker": {
            "courseId": 4,
            "askerId": 445,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "a cosa serve il comando \"super\" nelle sottoclassi e come si usa?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "subclass"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3738,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Ciao, rottura o meno ti tocca rispondere quindi vediamo di divertirci ;)\r\n\r\nti chiedo:\r\nmotivami secondo te perché é migliore una descrizione del mondo\r\ntramite oggetti ed ereditarietá piuttosto che alla cavolo con variabili schifo in giro per il mondo :)\r\n\r\ndai é facile,\r\nciao ciao buona risposta :P",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietá"
            },
            {
              "keyword": "classi"
            },
            {
              "keyword": "opinione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3816,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "In che senso si può affermare che la gerarchia delle classi in Java è \"ad albero\"?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "gerarchia"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " albero"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3800,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 503,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "La gerarchia delle clasi in java si dice ad albero perchè ogni classe può essere vista come classe figli, ovvero ha sempre una superclasse di cui è estensione. Infatti anche le classi non definite come estensioni hanno una comune superclasse (un unica radice) che è la classe Object (la quale contiene alcuni metodi comuni a tutte le classi come il metodo toString). Tale proprietà di java è una novità dato che in C++ la classe Object non esiste, dunque non abbiamo un'unica radice (gerarchia a foresta).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3834,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "In Java, qunado si definisce una classe, se non viene definita come estensione di un'altra classe, pur apparendo una classe a se stante, in realtà estende la classe predefinita Object. La classe Object, che implementa alcuni metodi di base (ad esempio il toString), rappresenta la radice dell'albero della gerarchia delle classi: infatti, ogni classe, che sia definita dall'utente o predefinita dal linguaggio, o estende direttamente la classe Object, oppure estende una classe che a sua volta può estendere Object o una terza classe... e così via, fino a trovare che ogni classe estende, direttamente o indirettamente, la classe Object. Non è così in tutti i linguaggi, ad esempio nel C++, dove infatti non si parla di gerarchia ad albero, ma piuttosto di gerarchia a \"foresta\".",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3865,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 422,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "La gerarchia ad albero che si ottiene in Java è semplicemente data dal fatto che una classe non può estendere più di una ed una sola classe. Ciò si traduce, in un albero (inteso come grafico), che ogni nodo avrà come parent uno ed un solo altro nodo, mentre può avere come discendenti altre classi, da questo la tipica forma \"ad albero\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3787,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 443,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perchè ogni classe può ereditare da una sola classe ma più classi possono ereditare da essa.\r\nQuesto è molto simile alla struttura dati dell'albero, in cui ogni nodo (classe) ha un nodo padre (classe base) ma può avere più figli (classi che ereditano da essa).",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3829,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Overloading e Overriding?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3806,
          "asker": {
            "courseId": 4,
            "askerId": 439,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa viene utilizzata l'istruzione \"super\" e quale problema risolve¿",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "package"
            },
            {
              "keyword": " super"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3756,
          "asker": {
            "courseId": 4,
            "askerId": 437,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Ipotizziamo di avere una classe chiamata A e un sottoclasse chiamate B che definiscono entrambe una variabile intera chiamata x, se NON usiamo l'operatore \"this.\" visto a lezione quale variabile x prevale nel caso io ad esempio richieda una stampa della stessa dall'interno della sottoclasse B? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Scope"
            },
            {
              "keyword": "Sottoclasse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3752,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa rappresenta la parola \"extends\" nella dichiarazione di un metodo ?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "extends"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3780,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra coda e pila?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "coda"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3800,
          "asker": {
            "courseId": 4,
            "askerId": 519,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi nell'utilizzare i modificatori \"private\" o \"protected\" rispetto a \"public\", il quale è molto più semplice da implementare?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": " Visibilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3802,
          "asker": {
            "courseId": 4,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra un costruttore protected e un costruttore private? perché si usano?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttori"
            },
            {
              "keyword": " scope"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3821,
          "asker": {
            "courseId": 4,
            "askerId": 500,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la superclass \"object\" e perché è importante? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Superclass"
            },
            {
              "keyword": " object "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3754,
          "asker": {
            "courseId": 4,
            "askerId": 523,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in una classe si usa la parola chiave \"this\"?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": " this"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3708,
          "asker": {
            "courseId": 4,
            "askerId": 575,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene risolto il problema della mantenibilità in Java?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Mantenibilità"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3718,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare da cosa deriva la classe String e cosa posso far derivare da essa.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "String"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3701,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando di toString() e metodi vari, all'interno di essi compariva il carattere \"+\", ad esempio : return name+\" (\"+x+\",\"+y+\")\"; Che funzione ha ?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Metodi"
            },
            {
              "keyword": "Overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3845,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 460,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "In questo caso il carattere '+' è l'operatore di concatenazione (e se necessario conversione) di stringhe, che unisce i caratteri di 2 stringhe mettendoli in successione in una nuova stringa. Per esempio il codice:\r\nString a = \"hello\";\r\nString b = \"world\";\r\nString c = a+b;\r\nSystem.out.println(c);\r\nstamperà: \"helloworld\".\r\nInoltre, qualora uno dei 2 operandi non dovesse essere una stringa il compilatore cercherebbe automaticamente di convertirlo in una stringa: per esempio è possibile utilizzare una variabile di tipo riferimento al posto di una stringa, e il compiler proverà automaticamente a convertirlo in String invocando su di esso il metodo toString.\r\nSi noti infine che il simbolo '+' è utilizzato anche per sommare 2 numeri (int, float ecc.): tale sovrapposizione di significati costituisce un esempio di overloading di operatori, e di conseguenza un eccezione alla norma, poichè in Java (contrariamente a quanto avviene in C++) non è ammessa la pratica dell'overloading sugli operatori.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3749,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 433,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "L'operatore + sulle stringhe ha il significato di concatenamento, cioè di \"attaccare\" una stringa ad un'altra, per esempio:\r\n \"ciao \"+\"come va?\" = \"ciao come va?\"\r\nNel caso della domanda, se avessi:\r\nname=\"Origine\"\r\nX=0\r\nY=0\r\nIl valore di ritorno del metodo toString() sarebbe: \"Origine (0,0)\"",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3788,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "L'operatore '+' è un operatore che concatena tipi di eterogenei di dati quali string, char, integer, double o float  (convertendoli preliminarmente in dati di tipo string e successivamente concatenandoli).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3776,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Concatenazione di stringhe.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3755,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 467,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "il + tra le stringhe ha la funzione di concatenazione:\r\nreturn \"hello\" + \"world\" -> \"helloworld\"",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3825,
          "asker": {
            "courseId": 4,
            "askerId": 559,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'ereditarietà? Come si implementano e a cosa servono gli override? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "override"
            },
            {
              "keyword": "implementazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3737,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che scopo ha l'istruzione ''super'' in Java? E l'istruzione ''this''? Qual è dunque la differenza fra le due?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": " this"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3762,
          "asker": {
            "courseId": 4,
            "askerId": 552,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa é una classe?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3808,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare qual è la logica del funzionamento dell' \"overriding\".",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3791,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 567,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "L'overriding è un concetto riguardante la ridefinizione nella classe figlio di metodi ereditati dalla classe padre. Esso stabilisce che in una sottoclasse è possibile scrivere  un metodo con la stessa firma di un metodo presente nella superclasse, che lo sostituisce solo all'interno della sottoclasse. \r\n\r\nVediamo con un esempio l'effetto dell'overriding su classe e sottoclasse.\r\nPoniamo di avere una classe Stanza che possiede tra i vari metodi il metodo porta\r\n\r\npublic void porta(){System.out.println('sono di legno');}. \r\n\r\nPoniamo ora di generare una sua sottoclasse Cucina. In questa classe Cucina facciamo un overriding del metodo porta:\r\n\r\npublic void porta(){System.out.println('sono di vetro');}.\r\n\r\nNel caso specifico di Cucina l'output fornito dal metodo è: sono di vetro. Infatti si adotta il metodo della sottoclasse.  \r\nAl di fuori della sottoclasse Cucina però viene adottato il metodo della superclasse Stanza, ovvero l'output è: sono di legno.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3770,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "l'overriding è la ridefinizione di un metodo di una superclasse in una sua sottoclasse.\r\nin java è necessario che questi due metodi abbiano la stessa firma, cioè che le funzioni abbiano lo stesso nome, lo stesso tipo e numero di parametri, e il tipo del suo valore di ritorno.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3774,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 457,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Con l'ovverriding ridefinisci una funzione in una sottoclasse, cioè riutilizzi una funzione in un'altra classe, in un altro ambito. Per esempio, la funzione \"estrai\" è la medesima sia per quanto riguarda la Pila che la Coda, quindi può essere implementata una volta sola e riutilizzata nell'altra classe. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3743,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "L'overriding è la ridefinizione di una funzione già definita nella superasse in una sottoclasse. \r\nAd esempio la funzione \"estrai()\" nella pila viene ridefinita diversamente nella coda.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3798,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 504,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Quando noi creiamo una nuova sottoclasse, ovvero un'estensione di una superclasse (attraverso il metodo \"extends\"), le stesse funzioni e variabili che noi troviamo nella superclasse vengono attribuite anche alla nuova classe creata. Cosi' all'interno della sottoclasse basta scrivere soltanto quello che cambia o che la classe ha in più rispetto alla superclasse di appartenenza. Se noi ridefiniamo una variabile o funzione in questo punto, il compilatore (grazie all'extends della classe) \"capisce\" che se noi usiamo una funzione\\variabile della superclasse, ma che è anche ridefinita all'interno della sottoclasse(estesa), userà quella della sottoclasse(come se avessimo fatto una sovrascrittura). ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3848,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 558,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "¿L'overriding è la ridefinizione, in una sottoclasse, di un metodo ereditato da una superclasse. Ci sono quindi 2 metodi con la stessa firma. Durante l'esecuzione ha priorità il metodo che si trova nella classe di cui l'oggetto è istanza.\r\nIpotizziamo di avere due classi, Alfa e Beta, con Beta che estende Alfa e ridefinisce un metodo, ad esempio cerca(). Dichiariamo un oggetto:\r\nAlfa dato = new Alfa();\r\ndato.cerca();\r\n\r\neseguirà il metodo di Alfa.\r\n\r\nDichiariamo un altro oggetto:\r\n\r\nAlfa dato = new Beta();\r\ndato.cerca();\r\n\r\neseguirà il metodo di Beta.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3817,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa bisogna modificare del costruttore nel definire Coda a partire da Pila in Java?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": "ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3750,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le parole chiave public, protected e private in Java? Perchè sono utili?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " visibilità"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3703,
          "asker": {
            "courseId": 4,
            "askerId": 557,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono il significato ed il funzionamento dello specificatore \"final\" se associato a variabili, metodi e/o classi?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "final"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " metodi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3824,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Indicare i vantaggi (ed eventuali svantaggi) legati all'utilizzo delle superclassi",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": "Superclassi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3761,
          "asker": {
            "courseId": 4,
            "askerId": 525,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa in java ad allocare un array nella memoria stack?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3795,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 540,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "In Java solamente i \"dati elementari\" (dati dei tipi base: int, char, float, ecc.) vengono memorizzati nello stack.\r\nArray ed oggetti vengono invece sempre memorizzati nello heap. Essi sono però sempre accessibili mediante puntatori (impliciti) memorizzati nello stack.\r\nIn Java, infatti, l'espressione\r\nint[] a = new int[100];\r\nnon equivale all'espressione in c++\r\nint a[100];\r\nbensì all'espressione\r\nint* a = new int a[100]; ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3797,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 454,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "tipo <nomearray>[]= new tipo[dimensione]: in questo modo creo e alloco in heap la memoria necessaria a contenere un array della dimensione desiderata. Nello stack non posso allocare mai un array proprio perchè lo creo con l'operatore new; nello stack trovo soltanto il riferimento dell'array. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3809,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "As said earlier in Java objects are created in the heap. The programming language does not offer the possibility to let the programmer decide if an objects should be generated in the stack. But in certain cases it would be desirable to allocate an object on the stack, as the memory allocation on the stack is cheaper then the memory allocation in the heap, deallocation on the stack is free and the stack is efficiently managed by the runtime.\r\nThe JVM uses therefore internally escape analysis to check if an object is used only with a thread or method. If the JVM identify this it may decide to create the object on the stack, increasing performance of the Java program. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3838,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 425,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In java, a differenza del c++, tutto viene allocato dinamicamente. Quindi per allocare un array in java non dovremmo più preoccuparci dei puntatori.\r\nAd esempio, se dovessimo allocare un array di 5 interi avremmo:\r\nint[] myIntArray = new int[5];\r\n\r\nVolendo possiamo già inizializzare i vari elementi quando dichiariamo il vettore;\r\nAd esempio, se volessi creare un vettore di 3 interi con valore 1,2,3 dovrei scrivere:\r\nint[] myIntArray = {1,2,3};\r\n\r\nQueste istruzioni si possono estendere anche agli altri tipi di variabili, quindi se dovessimo creare un array di tipo \"Tipo\" di 10 elementi dovrei scrivere:\r\nTipo[] myTipoArray = newTipo[10];",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3755,
          "asker": {
            "courseId": 4,
            "askerId": 443,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si estende una classe bisogna ridefinire tutte i metodi della classe base?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3854,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 476,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "No. Il concetto di ereditarietà in Java permette proprio di ovviare a questo problema, risparmiando inutili e ridondanti righe di codice ed evitando al programmatore di perdere parecchio tempo. Sia data una classe A con le relative variabili di istanza e relativi metodi formali. Volendo estenderla mediante una sottoclasse B con la sintassi \"public class B extends A\" non è poi necessario ridefinire all'interno della sottoclasse B i metodi della classe base A, dal momento che sono stati tutti ereditati. Qualora, invece, si ridefinisca un metodo all'interno della sottoclasse ereditato da A, allora si intende modificarne il comportamento in modo tale che che operi diversamente dalla superclasse, mantenendo però inalterati tutti gli altri metodi, come è stato mostrato a lezione con le classi Pila e Coda. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3855,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 439,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Non è necessario ridefinire tutti i metodi della classe base, ma può risultare utile reintegrarli con le nuove modifiche implementate alla classe figlia.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3812,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 517,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "No, quando si estende una classe (sottoclasse) non c'e' bisogno di ridefinire i metodi esistenti della superclasse. Infatti, questo e' uno dei compiti della superclasse padre verso le classi figli: mettere a disposizione i metodi (e non solo).",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3775,
          "asker": {
            "courseId": 4,
            "askerId": 430,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile in Java fare in modo che una classe erediti le caratteristiche di due classi diverse?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " multipla"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3730,
          "asker": {
            "courseId": 4,
            "askerId": 497,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi che derivano dalla possibilità di avere classi praticamente uguali a meno di alcune specifiche differenze scelte appositamente dal programmatore?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classi e superclassi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3826,
          "asker": {
            "courseId": 4,
            "askerId": 593,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "che cos'è l'ereditarietà?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà "
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3771,
          "asker": {
            "courseId": 4,
            "askerId": 518,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale ragione si è scelto di non allocare nello stak le stringhe ?!",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": "stak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3705,
          "asker": {
            "courseId": 4,
            "askerId": 486,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi può essere utile invocare espressamente il garbage collector (tramite il metodo System.gc())?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage collector"
            },
            {
              "keyword": "System.gc()"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3793,
          "asker": {
            "courseId": 4,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra un metodo dichiarato private e uno dichiarato final, dal punto di vista di una classe che eredita e vuole fare override di tale metodo?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": " override"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3753,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 456,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Non c'è nessuna differenza a livello pratico. Entrambi i metodi non possono essere sovrascritti in una sottoclasse. Da un punto di vista teorico, le motivazioni sono sottilmente differenti: un metodo \"final\" non può essere sovrascritto per definizione del modificatore \"final\" stesso, mentre un metodo \"private\" non può essere sovrascritto perchè nessuna classe ad esclusione di quella in cui è definito può accedervi, e dunque è di fatto \"final\" al di fuori della sua classe di definizione.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3846,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 502,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Un metodo dichiarato private può essere richiamato solo da altri metodi definiti internamente alla classe di appartenenza, quindi  private modifica la sua visibilità, invece, un metodo dichiarato final indica che le sottoclassi non possono ridefinire(sovrascrivere) quel metodo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3739,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Su entrambi non può essere fatto override da una classe figlia, quindi in entrambi i casi ci sarà un errore da parte del compilatore. Usare final al posto di private fa capire al compilatore che l'override è impossibile qualsiasi sia il livello di accesso della subclasse. Il compilatore comunque li tratta entrambi allo stesso modo quando si compila il programma",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3747,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La differenza è che private può essere \"AGGIRATO\" final no.\r\nUn metodo dichiarato PRIVATE risulta essere nascosto a tutto ciò che sta fuori da dove è stato dichiarato (per intenderci dalle graffe).Un metodo dichiarato FINAL invece corrisponde alle variabili \"const\" in C++; ossia esso una volta definito non può essere sovrascritto ne tantomeno subclassato. Ipotizzando di voler creare una classe che eredita  dai metodi sopra indicati mantenendo la firma immutata(overriding). Nel caso del metodo FINAL esso per definizione non permette la redefinizione : ora questo implica che se eredito la classe che contiene il metodo, su questo non potrà essere eseguito l'override. Con la dichiarazione PRIVATE del METODO non lo si può ereditare poichè viene nascosta la sua struttura. Se però all'interno delle stesse graffe è definito un metodo PUBLIC, che si \"aggancia\" a quello PRIVATE, richiamando il metodo PUBLIC lo si può implementare.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3717,
          "asker": {
            "courseId": 4,
            "askerId": 595,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "super(x,y), va chiamato tutte le volte che in una classe ho un extends?\r\n\r\npotrebbe rispiegare il concetto di passaggio di parametri per riferimento e per copia?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " subclassing"
            },
            {
              "keyword": " passaggio parametri"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3720,
          "asker": {
            "courseId": 4,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si indica col termine classi???",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3778,
          "asker": {
            "courseId": 4,
            "askerId": 585,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si estendono delle cmetodo in modo annidato a partire da un'unica superclasse nel seguente modo: SUPERCLASSE A \r\nClasse B-> extends A e\r\nClasse C-> extends B\r\n... se io non Esplicito il metodo che rimanda al costruttore della superclasse, qual è il metodo di default?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "superclasse"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3723,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la parola \"extends\" nella definizione di una classe ? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarieta"
            },
            {
              "keyword": " Superclasse"
            },
            {
              "keyword": " Sottoclasse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3782,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una superclasse?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "superclasse"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3791,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Dato il seguente codice:\r\npublic class Punto {\r\n    int x=0;\r\nint y=0;\r\npublic Punto(int x, int y){\r\nif (x==0 && y==0){ x=1; y=1;}\r\nelse x=x+y;\r\n}\r\npublic static void main(String a[]){\r\nPunto p = new Punto(0,0);\r\nSystem.out.println(p.x+ \" \" + p.y);\r\n}\r\ncosa stampa a video e perché?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3731,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo finalize() e quali differenze ci sono con il distruttore vero e proprio?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodo"
            },
            {
              "keyword": " finalize"
            },
            {
              "keyword": " distruttore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3707,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa è la UML?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": "Language"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3807,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Unified Modeling Language, esso consiste in un linguaggio che consente di costruire modelli object-oriented. Questo linguaggio fornisce concetti e strumenti applicabili in tutti i contesti, quindi è un linguaggio base che viene poi ampliato se necessario.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3758,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "UML (linguaggio di modellazione unificato) è un linguaggio, utilizzato nella programmazione object-oriented, che si presuppone di essere unificato e standard nella rappresentazione della soluzione analitica di un problema. E' utile proprio per la sua sinteticità e semplicità di comprensione ed è organizzato in modo schematico ed essenziale. Un modello UML è infatti formato da uno o più diagrammi che in modo semplice ma preciso, attraverso elementi grafici e testuali, forniscono una soluzione che poi, nel nostro caso, andrà ''tradotta'' in codice. E' bene costruire questi diagrammi prima di iniziare la stesura del codice, così da organizzare le idee semplificando molto la successiva fase di programmazione.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3736,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 575,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "La UML è un linguaggio formale che si usa nella fase di design del modello di ciò che si vuole rappresentare ovvero nella primissima fase che deve precedere la scrittura di un programma. Nella pratica si costruisce un diagramma a blocchi le cui frecce vanno lette come 'IS-A'. Dunque questo linguaggio ci permette di rappresentare per via grafica l'ereditarietà ovvero i rapporti tra le classi che costituiranno il nostro programma.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3818,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "UML, acronimo di linguaggio di modellazione unificato, è un linguaggio visuale utilizzato per descrivere programmi che implementano il paradigma object-orientied. Esso è costituito principalmente da diagrammi che riassumono le classi ed i tipi di relazioni e associazioni tra esse in modo da poter descrivere in maniera più intuitiva la struttura logica di un programma. Il diagramma può essere definito in varie fasi (analisi, Disegno di dettaglio, ecc). ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3777,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 595,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Schematizzazione di linguaggi di programmazione che permette di analizzare e progettare in dettaglio un progetto(codice) prima di iniziare a scriverlo.\r\nRappresenta in modo schematico classi, oggetti, attributi e relative operazioni. \r\nMolto utile per evidenziare i vincoli(es: ereditarietà) che legano fra loro le classi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3775,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "la UML è un tipo di scrittura universale realizzata da alcuni informatici. con essa è possibile realizzare \"grafici\" facilmente capibili riguardanti ,ad esempio, le varie classi e superclassi. è composta da quadrati,contenenti i vari oggetti, divisi in parti, una per ogni metodo o variabile, collegate tra loro da frecce, che consentono di visualizzare il rapporto tra le varie superclassi e classi figlie. è un linguaggio utilizzato anche nella scrittura dei database, perche consente al programmatore di visualizzare i rapporti tra le varie tabelle e query",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3734,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "UML è l'acronimo di \"Unified Modeling Language\". È un linguaggio di modellazione che, attraverso una rappresentazione grafica, permette di descrivere l'intera struttura di un applicazione.\r\nIn particolare è possibile rappresentare oggetti, specificando o meno i loro relativi attributi, e classi con i loro legami di ereditarietà e la loro gerarchia che compongono l'intero programma.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3740,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "qual'è la differenza tra \"private\" e \"protected\"? :)",
          "totalDifficultyLevel": 1,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": "visibiltà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3779,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 481,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Una funzione o una variabile dichiarata con private è nascosta a tutti mentre una variabile o una funzione dichiarata con protected è visibile solo alle sottoclassi",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3810,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Con l'operatore \"protected\" le proprietà e i metodi non sono accessibili e modificabili dall'esterno della classe ma lo sono dalle classi che ereditano.\r\nL?indicatore \"private\" è il più restrittivo. Infatti le proprietà dichiarate come \"private\" sono accessibili o modificabili solo dall?interno della classe che le dichiara, cosi come i metodi privati sono richiamabili solo al suo interno.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3730,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Gli indicatori di visibilità private e protected sono più restrittivi rispetto all'indicatore public;  nel primo caso le proprietà dichiarate nella classe sono accessibili e modificabili solo dall'interno della classe stessa. Le proprietà dichiarate come protected sono invece accessibili anche dalle classi derivate da quella in cui è presente la proprietà stessa.\r\nLa medesima differenza si replica parlando dei metodi.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3781,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 445,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "il \"private\" è visibile solamente all'interno della classe mentre il \"protected\" è visibile anche nelle estensioni della classe.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3731,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3767,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "metodi o variabili difiniti come private sono visibili solo all`interno della stessa classe invece se sono definiti come proteted allora sono visibili ache nelle sottoclassi.)",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3843,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 487,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "La differenza sta nel fatto che le variabili, i metodi o le classi marchiate come \"private\" possono sono accessibili soltanto ai membri appartenenti alla stessa classe, mentre quello che è marchiato come \"protected\" è accessibile anche alle sottoclassi e alle classi appartenenti allo stesso package e ai membri appartenenti alla stessa classe. \"protected\" non è altro che un modo per estendere leggermente la visibilità rispetto a \"private\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3778,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 469,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Private e protected sono sostanzialmente la stessa cosa con l'unica differenza che con private la funzione è visibile solo all'interno della classe in cui è dichiarata e con protected la funzione può essere modificato solo nelle classi che estendono la classe in cui è stata dichiarata la funzione con protected.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3820,
          "asker": {
            "courseId": 4,
            "askerId": 480,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale contesto sarebbe opportuno dichiarare una variabile di stato interna ad una classe tramite i modificatori final e private? indicare un esempio.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "final"
            },
            {
              "keyword": "private"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3724,
          "asker": {
            "courseId": 4,
            "askerId": 573,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in c++ si parla di \"foresta\" e in Java di \"albero\", in campo di ereditarietà?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " foresta"
            },
            {
              "keyword": " albero"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3704,
          "asker": {
            "courseId": 4,
            "askerId": 461,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa succede se una classe non ha un costruttore?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSE"
            },
            {
              "keyword": "COSTRUTTORE"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3803,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Una classe ha sempre almeno un costruttore. Semplicemente, se non lo definisci, ne esiste uno detto \"di default\" senza alcun parametro e che non fa nulla di pratico.\r\nSe invece ne definisci uno, il costruttore di default viene meno.\r\nÈ comunque sempre possibile fornire una classe di più costruttori, facendo l'overloading di tali metodi: ciò significa creare metodi con lo stesso nome ma con numero e/o tipo di parametri diversi, in modo da avere diversi modi di creare uno stesso oggetto a seconda del numero e/o del tipo di parametri che appaiono nella chiamata.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3819,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 516,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Al momento della compilazione, se non è presente un costruttore \"esplicito\", ne viene generato automaticamente uno di default che consiste in NomeClasse() {}.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3835,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Se in una classe non viene definito un costruttore Java ne crea uno predefinito. Questo costruttore però è privo di argomenti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3728,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 430,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Se in una classe non viene dichiarato un costruttore automaticamente ed implicitamente ne viene creato uno di default, cioè senza parametri che inizializza ogni campo classe al suo valore di default.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3752,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Semplicemente il compilatore genererà un costruttore di default per\r\nquella classe, ovvero un costruttore senza parametri che non fa\r\nniente:\r\n\r\nMyClasse() {}\r\n\r\nciao ciao ;D",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3871,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 581,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Al momento della compilazione, il compilatore non permette di proseguire, segnalando un errore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3792,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Quando si crea un oggetto di una classe di cui non si è dichiarato il costruttore viene automaticamente chiamato il costruttore di default (quello senza parametri, per esempio per la classe Point sarà Point() ). Se si tratta di una sottoclasse, nel costruttore di default viene automaticamente inserita la chiamata a super(). \r\nDevi fare attenzione perché se nella classe Point non c'è il costruttore vuoto ma solo costruttori del tipo Point(argomenti) nei costruttori delle sottoclassi dovrai chiamare esplicitamente super(argomenti) come prima istruzione.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3802,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 496,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Questo dipende dal linguaggio di programmazione. In Java sarà presente un costruttore di default, che viene ereditato dalla classe object (la classe radice, da cui ereditano tutte le altre classi). PS: Il costruttore di default è vuoto, non effettua alcuna operazione)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3725,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Se una classe non ha costruttori, allora per essa viene automaticamente definito il costruttore vuoto.\r\n\r\nSe in una classe ci metto un costruttore, allora quello vuoto non viene aggiunto automaticamente.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3727,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è un costruttore ? Quali sono le sue principali funzioni ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": " visibilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3790,
          "asker": {
            "courseId": 4,
            "askerId": 516,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "In questo pezzo di codice:\r\n\r\npublic class NamedPoint extends Point { \r\n String name; \r\n public NamedPoint(int x,int y,String name) { \r\n super(x,y); //prima istruzione! \r\n this.name=name; \r\n }\r\n}\r\n\r\nViene comunque chiamato il costruttore di default della classe padre come prima istruzione nonostante ne venga chiamato uno più \"specifico\" successivamente?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": " costruttore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3809,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Si spieghi il funzionamento della subclassing e dell'overriding.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": "overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3810,
          "asker": {
            "courseId": 4,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Si spieghi brevemente in cosa consiste la differenza tra una struttura gerarchica delle classi \"ad albero\" e una \"a foresta\", specificando quale delle due riguarda Java e citando eventualmente la superclasse (o le superclassi) di maggior interesse",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Object"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3772,
          "asker": {
            "courseId": 4,
            "askerId": 473,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè quando si estende una classe la prima cosa da fare è una chiamata a super ()?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "erediarieta"
            },
            {
              "keyword": " super"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3713,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la funzione super e quando viene chiamata automaticamente?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " super"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3818,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "public class A {\r\nA(){\r\nSystem.out.println(\"23\");}\r\n}\r\npublic class B extends A{\r\nB(int x){\r\nSystem.out.println(x);}\r\n}\r\npublic static void main (int k[]){\r\nnew B(7);\r\n}\r\n\r\nQual'è l'output di questo codice?Si dia una spiegazione.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " modificatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3712,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "come puo'essere descritta la struttura tra le varie classi di java? e in cosa differisce da c++?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "superclasse"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3714,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per ereditarietà, e quali vantaggi comporta?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3833,
          "asker": {
            "courseId": 4,
            "askerId": 549,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa a scrivere un oggetto ereditandolo da un'altra classe ma volendo modificare una delle funzioni \"ereditate\" al suo interno?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eredità"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3828,
          "asker": {
            "courseId": 4,
            "askerId": 567,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando serve ed a cosa serve il prefisso \"super\" nel richiamare un metodo all'interno di una classe?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classe"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3774,
          "asker": {
            "courseId": 4,
            "askerId": 572,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando viene instanziata una  classe e quest'ultima eredita da un'altra, qual è l'ordine in cui vengono richiamati i costruttori? Se il costruttore di default non è presente cosa succede?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Costruttori"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3827,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Viene chiamato prima il costruttore della classe chiamata, poi quello della sovraclasse. Se non è presente un costruttore vengono inizializzati i valori degli attributi a null e 0.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3790,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 461,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Quando una classe viene istanziata il compilatore crea automaticamente un costruttore e lì dentro chiama il costruttore della superclasse. Il costruttore di default è proprio quello che viene automaticamente creato dal compilatore ma,nel caso in cui all'interno della classe, venga fornito del codice per qualche altro costruttore, sarà utilizzato proprio il costruttore dichiarato.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3815,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 499,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Prima di tutto va ricordato che se in una classe non è presente alcun costruttore, viene automaticamente creato il costruttore di default (senza parametri) ed in questo caso posso istanziare un oggetto con tale costruttore.\r\nNel costruttore di una classe che eredita, come primo bisogna richiamare un costruttore della superclasse, ed è possibile farlo con il comando super a cui in input vanno inseriti gli opportuni parametri del costruttore a cui si vuol far riferimento. Se tale comando non è presente, di default il compilatore invoca il codice super(), se un costruttore senza parametri non è stato istanziato nella superclasse questo genera un errore di compilazione. In seguito vengono eseguiti eventuali inizializzatori di nuovi parametri introdotti nella classe figlio e comandi propri del costruttore.\r\n",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3860,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "mi piacerebbe saper rispondere..ma non lo so",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3772,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 468,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "L'ordine in cui vengono chiamati i costruttori va dal più interno al più esterno, quindi se istanzio una classe che eredita da un altra prima verra chiamato il metodo costruttore della sottoclasse (se presente), se invece manca viene chiamato il metodo della classe sovrastante, ovvero quella da qui eredita.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3833,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 428,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Quando si instanzia una o più classi si crea un rapporto di subordinazione a \"piramide\", che vede a capo il costruttore di default e sotto tutti gli altri. Nel caso in cui non ci fosse il costruttore di default si segue l'ordine dell'instanza delle classi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3706,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponendo che sia stata scritta una ClasseA che eredita da una ClasseB che a sua volta eredita da una ClasseC e che in nessuna di queste classi sia stato specificato dal programmatore un costruttore di qualsiasi genere, creando un'istanza di un oggetto di tipo ClasseA vengono chiamati dei costruttori? Se sì, in quale sequenza?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Costruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3858,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In java al momento della compilazione, se non è presente alcun costruttore all'interno della classe, viene creato un costruttore di default che permette di istanziare l'oggetto.\r\nQuest'ultimo non accetta parametri ma viene richiamato ogni volta che viene creata un'istanza di un oggetto tramite l'operatore \"new\".\r\nNel caso descritto vengono quindi richiamati i costruttori, nell'ordine di ereditarietà da te dato: \r\n1. costruttore ClasseC;\r\n2. costruttore ClasseB (eredità da ClasseC);\r\n3. costruttore ClasseA (eredità da ClasseB);\r\nDato che abbiamo creato un'istanza ma non dei costruttori che accettano parametri (visto che ne abbiamo solo di predefiniti di java) non vegono forniti argomenti a \"new\".",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3816,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Non essendoci dei costruttori specificati dal programmatore, creando un'istanza di un oggetto di tipo classeA chiamerà un costruttore di defaulf che assegnerà dei valori di default alle variabili del nuovo oggetto:\r\n-il valore zero per gli scalari\r\n-valore null per gli oggetti",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3764,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Guarda, detto tra noi.. Non lo so.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3821,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Ogni classe eredita un costruttore di base dalla classe object, ma è buona prassi dichiarare manualmente il costruttore di ogni classe che si scrive.\r\nLa sequenza dei costruttori con l'instanziamento della classe A sarebbe (se ognuno avesse il proprio costruttore): \r\n- costruttore_classe_objcet\r\n- costruttore_classe_C\r\n- costruttore_classe_B\r\n- costruttore_classe_A\r\nMa, considerando che ogni classe senza costruttore viene istanziata con un costruttore standard vuoto, l'unico costruttore presente nella sequenza sarebbe quello della classe object",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3823,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 459,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "i costruttori vengono chiamati nel' ordine con cui il programmatore ha descritto l'ereditarietà nella riga di codice che crea la CLASS A per esempio:\r\n\r\nCLASS A extends CLASS C extends CLASS B in questo caso il primo costruttore chiamato sarà il costruttore della CLASS C e il secondo quello della CLASSE B.\r\n\r\nDa notare che java non implementa questa tipologia di multi estensione delle classi, dato che comporta una complessità non indifferente. Basta pensare al caso in cui le classi C e B a loro volta ereditano da altre classi e così via; per risolvere la \"matassa\" di quale costruttore chiamare entrano in campo grafi e i vari algoritmi per risolverli.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3759,
          "asker": {
            "courseId": 4,
            "askerId": 524,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come agisce il metodo \"extends\" in Java? Esiste qualcosa di analogo in C?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3788,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra \"Overloading\" e \"Overriding\"?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3815,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Negli esempi di classe Point e Named Point ci sono dei main alla fine, mi chiedevo se andassero sempre messi quando definisci un oggetto di questo tipo (anche solo vuoti), o se si potessero omettere.",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3754,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "No, servono solo per far vedere la chiamata a un costruttore e la creazione di un oggetto a scopo didattico in quel caso. Il metodo main è l'entry point del programma e va usato obbligatoriamente una e una sola volta nell'applicazione, in particolare nella classe  che si occupa di gestire il programma e istanziare oggetti di altre classi. Tutte le altre classi sono strumenti per costruire e gestire oggetti e non possono avere un proprio metodo main in quanto creerebbe ambiguità",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3782,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 448,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il main è il punto di ingresso di esecuzione del programma, e dato che Java è un linguaggio di programmazione orientato agli oggetti, necessita che tutte le funzioni siano implementate all'interno di una classe. In questi esempi il main è posto all'interno delle classi Point e NamedPoint non perchè sia necessario, ma al solo fine di non dover scrivere un'altra classe che contenga il main e che poi utilizzi le classi relative al punto. In generale non è una buona idea (e infatti non si usa) scrivere il main all'interno di una classe, dato che questa serve per rappresentare formalmente un'entità presente nella realtà. E visto anche che una stessa classe può essere utilizzata in più programmi, il fatto che implementi un metodo main al suo interno non permette al programmatore che la utilizza di definire un diverso punto di ingresso all'esecuzione del programma.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3751,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 426,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Questo è un discorso particolare. Se dovessi risponderti velocemente alla domanda ti direi di si, il main è obbligatorio, perchè la java virtual machine inizia a caricare una classe specifica e successivamente invoca il metodo main in essa, come punto d'accesso.\r\nTuttavia non è corretto dire che è obbligatorio perchè effettivamente non lo è, nelle java webapp non c'è proprio.\r\nInoltre puoi benissimo avere un programma normale senza main, ad esempio:\r\nclass ProgrammaJavaSenzaMain{\r\n static\r\n {\r\nSystem.out.println ( \"Sono Partito!\" ) ;\r\n }\r\n}\r\nCompilando ed eseguendolo da questo output:\r\nSono Partito!\r\nException in thread \"main\" java.lang.NoSuchMethodError: main\r\n\r\nCome puoi vedere il programma funziona, anche se da quell'eccezione: non ha trovato il metodo main.\r\nQuindi queste sono le conclusioni:\r\n-Ti serve o il metodo main che deve essere public, static, void e con esattamente un argomento: String[]\r\n-Oppure un inizializzatore statico, come visto prima.\r\n\r\nIl main è preferito.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3724,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Non è una domanda da fare a uno studente e non credo sia una tipologia di domanda da fare su questo sito comunque la main va in ogni caso!",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3811,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 447,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Non riesco a trovare gli esempi in questione ma in generale quando si definisce una classe non c'è nessun bisogno di mettere dei main poichè non coesisterebbero con la definizione stessa di classe e oggetto.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3817,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "I main sono metodi facoltativi che vengono chiamati soltanto nel caso in cui la classe venga invocata dal sistema operativo. Perciò, nel caso una classe crei un'istanza di un'altra classe il metodo main non viene considerato.\r\nSpecificare il metodo main per ogni classe è utile quando si vogliono mostrare le funzionalità di essa classe, come una specie di demo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3853,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Il metodo main è il punto in cui, per convenzione , inizia l'esecuzione del programma. Tale metodo si può omettere quando la classe che si sta scrivendo , non verrà mai eseguita direttamente ma verrà soltanto usata da altre classi. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3760,
          "asker": {
            "courseId": 4,
            "askerId": 488,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il garbage collector in Java?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage"
            },
            {
              "keyword": " collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3768,
          "asker": {
            "courseId": 4,
            "askerId": 568,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una classe?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3770,
          "asker": {
            "courseId": 4,
            "askerId": 483,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché con Java nessun array verrà allocato nello stack?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": "stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3803,
          "asker": {
            "courseId": 4,
            "askerId": 442,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il vantaggio dell'ereditarietà? è possibile definire più metodi con lo stesso nome ed eventualmente seguendo quali regole?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " metodi"
            },
            {
              "keyword": "regole"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3797,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che vantaggi porta l'uso della parola \"extends\" e dove va usata?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Class"
            },
            {
              "keyword": "  ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3728,
          "asker": {
            "courseId": 4,
            "askerId": 591,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "come possono essere le estensioni? quali sono le differenze?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3781,
          "asker": {
            "courseId": 4,
            "askerId": 477,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Date le seguenti classi A e B:\r\n\r\npublic class A {\r\nint x;\r\npublic A (int x) { this.x = x; }\r\n}\r\n\r\npublic class B extends A {\r\nint y;\r\npublic B (int x, int y) { this.y = y;}\r\n}\r\n\r\n\r\nCostruisco un oggetto di tipo B, chiamando il seguente costruttore:\r\n\r\nB b = new B(1, 2);\r\n\r\nQuale sarà il valore della variabile di istanza \"x\"?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " costruttore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3872,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 435,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Non compila perché creando l'oggetto b viene chiamato il costruttore della sottoclasse B che a sua volta chiama il costruttore della superclasse A, ma siccome non viene passato il parametro richiesto, il compilatore genera errore. Per passare il parametro al costruttore della superclasse bisogna utilizzare il comando super.A(x).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3814,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 520,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il valore sarà 1 perché B eredita le caratteristiche di A tra cui la x.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3863,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 542,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "1",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3771,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 553,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La variabile di istanza x, così come b.x sarà vuota. L'oggetto b avrà un valore b.y=2, ma NON avrà il valore b.x=1. Questo perché essendo la classe B un'estensione di A, in B serve l'istruzione- super(x); -se si vuole ereditare da A in B il valore di x, essendo in A specificato- this.x=x -.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3746,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Da un errore di compilazione in quanto bisognava passare il valore ad x mediante super(x) nel seguente modo:\r\n\r\npublic class B extends A {\r\n    int y;\r\n    public B (int x, int y) { \r\n        super(x); // Bisogna inserire questa riga altrimenti il compilatore la inserisce come: super();\r\n        this.y = y;\r\n    }\r\n}\r\n\r\nNon facendolo il compilatore non può passare x perchè, non scrivendo il super, sarebbe come fare \"super();\" ma quest'ultimo ha bisogno di un parametro in ingresso dato che il costruttore di A ne richiede uno.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3789,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 566,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il valore della variabile x sarà 1, valore passatogli tramite B b = new B(1,2);",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3746,
          "asker": {
            "courseId": 4,
            "askerId": 469,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Per cosa è utile l'ereditarietà nel linguaggio a oggetti ?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "oggetti"
            },
            {
              "keyword": "ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3722,
          "asker": {
            "courseId": 4,
            "askerId": 548,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l' istruzione super in Java?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3813,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 466,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "L'istruzione super serve per richiamare metodi e variabili d'istanza in una sottoclasse già dichiarati nella sua classe madre. In particolare nel costruttore di una sottoclasse l'istruzione super è eseguita automaticamente prima di tutte le altre istruzioni.\r\nPer richiamare metodi di una classe superiore l'istruzione è super.(nome_del_metodo)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3759,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "L'istruzione supern java è un puntatore implicito alla classe madre, cioè un puntatore che rimanda sempre alla classe estesa da quella in cui è presente. Va utilizzato ad esempio nel caso ci si voglia riferire ad un membro della classe madre che nella classe figlia è sottoposto ad override",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3769,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 557,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "In java, l'istruzione super si usa in ambito di sottoclassi per richiamare metodi presenti nella superclasse relativa.\r\nAd esempio, se la classe SOTTO ha come superclasse SOPRA, con l'istruzione super.met1(args) posso richiamare il metodo met1 proprio di SOPRA nonostante io stia lavorando nella sottoclasse SOTTO.\r\nSe l'istruzione viene chiamata senza estensioni, ovvero super(args), viene invece invocato il costruttore della superclasse.\r\nL'istruzione super può infine essere concatenata, ad esempio se ho le classi CLASS1, CLASS2 sottoclasse di CLASS1 e CLASS3 sottoclasse di CLASS2, se chiamo super.super(args) in CLASS3 verrà invocato il costruttore di CLASS1.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3794,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 524,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'istruzione \"super\" in Java viene utilizzata nelle sottoclassi per fare riferimento ad un oggetto della rispettiva e più immediata superclasse. Tale istruzione dev'essere istanziata come primo elemento della sottoclasse. Per esempio: \r\n\r\n(esempio fatto in aula)\r\n\r\npublic class Point{\r\n[...]\r\n   Point (int x, int y){\r\n     this.x=x;        { variabili originarie di Point\r\n     this.y=y;}      {\r\n}\r\n\r\n[...]\r\n\r\npublic static NamedPoint extends Point {\r\n    String name;\r\n    public NamedPoint (int x, int y, String name){\r\n        super(x,y); &#8592; prima istruzione della sottoclasse e riferimento alle variabili definite   '                              in \"Point\" nella superclasse omonima\r\n\r\n        this.name=name;\r\n}\r\n[...]\r\n}\r\n\r\nIn questo breve esempio si vede come \"super\" vada a riprendere le variabili definite nella superclasse \"Point\" per usarle in \"NamedPoint\".",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3745,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 478,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "La parola chiave super (simile al this), permette di riferirsi alla super-classe: ovvero la classe che la nostra classe estende, cioè quella \"padre\".\r\nLa parola chiave super ha due utilizzi:\r\n1) chiamare un costruttore della super-classe:\r\n\tsuper(elenco parametri);\r\nLa chiamata può essere:\r\n *Implicita: se il costruttore è a zero argomenti\r\n *Esplicita: se il costruttore prevede almeno un argomento\r\nsuper() deve essere la prima istruzione all'interno del costruttore di una sottoclasse. \r\n2) permettere di accedere a membri della super-classe \"nascosti\" da membri della sottoclasse.\r\nSe una classe contiene una variabile di istanza con lo stesso nome di una variabile di istanza della sua super-classe, la variabile della sottoclasse \"nasconde\" quella della super-classe. In questi casi, per accedere alla variabile della super-classe bisogna usare super; stesso discorso per i metodi. In caso contrario, la chiamata di super per accedere ad una variabile/funzione della classe padre è implicita.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3794,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'ereditarietà di due classi e in che modo si crea una sottoclasse B che erediti da una superclasse A ?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " sottoclassi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3796,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega il ruolo delle parole chiave \"public\", \"protected\" e \"private\" nella visibilità di variabili e metodi.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Visibilità"
            },
            {
              "keyword": " Modificatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3742,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa definiscono i termini subclassing, overriding e overloading?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " sottoclasse"
            },
            {
              "keyword": " superclasse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3823,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come avviene la gestione della memoria? A cosa servono i distruttori e i costruttori?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gestione"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " costruttori"
            },
            {
              "keyword": " distruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3700,
          "asker": {
            "courseId": 4,
            "askerId": 576,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa significa UML e per cosa viene utilizzato?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3744,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra public, protected e private?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "private"
            },
            {
              "keyword": " protected"
            },
            {
              "keyword": " public"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3711,
          "asker": {
            "courseId": 4,
            "askerId": 428,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare quando si può parlare di 'aggregation' e quando di 'composition'.",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Aggregation"
            },
            {
              "keyword": " Composition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3743,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è una super classe? Queli sono le sue proprietà?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3702,
          "asker": {
            "courseId": 4,
            "askerId": 456,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "In una sottoclasse, nell'implementazione del metodo costruttore, può sorgere un problema di ambiguità, relativo alla chiamata di un metodo costruttore di una superclasse con lo stesso nome del metodo costruttore della sottoclasse. Quale espediente risolve questa situazione e qual è l'accortezza principale a cui stare attenti nel suo utilizzo?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " ereditarietà"
            },
            {
              "keyword": " costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3813,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cosa significa una relazione IS-A e HAS-A",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "composizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3830,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si ha l'Overloading? E in che cosa consiste?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3831,
          "asker": {
            "courseId": 4,
            "askerId": 555,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos?è la classe \"Object\"? A cosa serve?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3733,
          "asker": {
            "courseId": 4,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'operatore extends?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Operatore"
            },
            {
              "keyword": " extends"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3811,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "spiega il concetto di scope nel contesto delle sottoclassi e dell'ereditarietà.",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3783,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Lo scope consente di definire l'accessibilità e la visibilità di campi e classi nei confronti di altre classi. In Java esistono 3 modificatori di visibilità: \r\n-private, che rende visibile quel campo solo alla classe a cui appartiene;\r\n-protected, che lo rende visibile anche alla sottoclasse e al package;\r\n-public, che rende visibile il campo in tutti i casi;\r\n\r\nDi default (senza specificare nessun modificatore) un campo o una classe di Java è visibile solo all'interno della classe in cui è dichiarato e nel suo package. \r\n\r\nQuesto meccanismo consente di controllare quali campi possono essere modificati e usati da altre classi, rendendo più facile scrivere codice facile da mantenere e aggiornare.\r\n\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3842,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Lo scope, ossia la visibilità di una variabile all'interno del codice, è normalmente limitato al blocco che contiene la dichiarazione della variabile considerata. In situazioni legate all'ereditarietà invece il meccanismo cambia; è possibile infatti modificare la visibilità di un membro, un metodo o una classe attraverso l'utilizzo delle parole chiave \"public\", \"protected\" e \"private\". Utilizzando la prima si rende visibile un oggetto sia ai metodi della classe che lo contiene, sia ai metodi che non fanno parte della stessa. La seconda invece serve a limitare la visibilità ai metodi della classe che contiene l'oggetto e a quelli delle sottoclassi che ereditano la classe di partenza. L'ultima parola chiave ha lo scopo di rendere visibile l'oggetto solamente ai metodi della classe esaminata. Nel caso in cui nessuna di queste parole chiave venga specificata l'oggetto è visibile di default da tutti i metodi delle classi contenute nello stesso package della classe presa in esame.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3773,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Le regole dello scope sono le stesse anche nel contesto delle sottoclassi. Come un blocco interno a un altro, una sottoclasse può utilizzare variabili e metodi delle classi più esterne. In caso di overriding (cioè di ridefinizione nella sottoclasse di una funzione già presente in una classe più esterna) viene letta la funzione definita nella classe più interna. Non è però possibile che una classe acceda a variabili e funzioni definite in una sua sottoclasse.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3750,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 590,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Con scope si indica la visibilità di una variabile all'interno di una applicazione.\r\nIn particolare si parla di variabili globali o locali, visibili rispettivamente in tutto il programma o in un solo blocco.\r\nIn una sottoclasse vengono riprese le variabili della classe padre.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3734,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa permette di fare la parola chiave 'extends' ? spiegane i vantaggi.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "extends"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3807,
          "asker": {
            "courseId": 4,
            "askerId": 554,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e come funziona una supercalsse?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi "
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3709,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è lo scopo della \"public class NamedPoint extends Point\" vista in classe??",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "NamedPoint"
            },
            {
              "keyword": " extends"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3735,
          "asker": {
            "courseId": 4,
            "askerId": 570,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa differenzia una classe base da una classe derivata?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Base"
            },
            {
              "keyword": " derivata"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3763,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'ereditarietà? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3827,
          "asker": {
            "courseId": 4,
            "askerId": 545,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Ma quando utilizzo l'operatore \"new\" in java, è necessario che io elimini l'oggetto con il delete oppure interviene automaticamente il garbage collector?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "new"
            },
            {
              "keyword": " garbage_collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3805,
          "asker": {
            "courseId": 4,
            "askerId": 487,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché toString è uno dei 27 metodi definiti all'interno della classe System?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Class"
            },
            {
              "keyword": " System"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3785,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi nella creazione di una sottoclasse e in quali problemi ci si può imbattere?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "sottoclasse"
            },
            {
              "keyword": " vantaggi"
            },
            {
              "keyword": " svantaggi"
            },
            {
              "keyword": " problemi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3741,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si comporta la funzione costruttore di Object?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Object"
            },
            {
              "keyword": " costruttore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3765,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "qual'è il principale motivo per cui una classe non può ereditarne 2 allo stesso tempo in java?\r\n\r\n(ovvero perche in java non si può fare \"class ciao extends ciao2 extends ciao3{...}\")",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3747,
          "asker": {
            "courseId": 4,
            "askerId": 565,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Esistono delle classi che non ereditano da nessuno? Motiva la tua risposta.",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3844,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 429,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "No, esiste una classe principale da dove ereditano tutte le classi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3757,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 505,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Si, l'ereditarietà è strutturata in modo tale che esiste una (vedi java) o più (vedi c++) classe padre che sta all'inizio della catena, in java per esempio troviamo la classe Object che non eredita da nessuna classe.",
              "notes": "-",
              "rating": 6,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3766,
          "asker": {
            "courseId": 4,
            "askerId": 501,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può creare delle variabili read-only e write-only usando i modificatori di visibilità public, private e protected? ",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Variabili"
            },
            {
              "keyword": "Visibilità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3836,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Per creare una variabile read-only definiamo, all'interno di una classe pubblica, una variabile privata, che quindi non sarà visibile, e definiamo un metodo pubblico che restituisce il valore della variabile. In questo modo nessuno può modificare la nostra variabile ma tutti possono chiamare il metodo per leggerla.\r\nSe allo stesso modo definiamo un metodo pubblico che invece di restituire la variabile le assegna il valore desiderato otteniamo che chiunque può scrivere la variabile ma nessuno può leggerla. \r\nAd esempio, per la read-only:\r\npublic class Classe {\r\n  private int var;\r\n  public int leggiVar() {\r\n  return var;}\r\n}\r\nper la write-only sostituiamo leggiVar con\r\n  public void assegnaVar(int n){\r\n  var = n; }\r\nSi può anche utilizzare protected al posto di public per permettere l'accesso al metodo di lettura o scrittura solo all'interno delle sottoclassi.",
              "notes": "-",
              "rating": 7,
              "coins": []
            },
            {
              "answerId": 3867,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Innanzitutto definiamo una variabile come private.\r\n1) Se definiamo una funzione (detta \"getter\") che restituisce il valore di tale variabile come public, creiamo una variabile read-only.\r\n2) Se definiamo una funzione (detta \"setter\") che ci permette di assegnare alla variabile un valore che imponiamo essere private (cioè, una volta assegnato, non possiamo averne più accesso), creiamo una variabile write-only.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3765,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "I modificatori public, private e protected servono a modificare la visibilità di variabili e metodi all'esterno della classe in cui sono stati definiti. Per creare una variabile Read-Only si usa il modificatore final nella definizione della variabile. Le variabili Write-Only non vengono implementate perché sarebbero inutili, in quanto non potrebbero essere lette.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3825,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 518,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Non avendo capito a fondo la domanda cerco di rispondere come ho inteso la suddetta, si possono creare sia varaibili che classi con visibilità diverse usando gli aggettivi sora elencati, public è un livello di \"protezione\" per i membri della classe  e gli rende accessibili tramite il nome della classe o un oggetto di essa al \"codice consumer\", private: rende i membri accessibili solo all'interno della classe stessa. Protected: rende i membri accessibili e visibili solo all'interno della classe stessa e della classe derivata. Detto questo per creare una variabile read-only si necessita di una variabile di tipo protected e di un metodo che abbia come return il tipo della variabile, chi vorrà scrivere in essa non potrà farlo direttamente ma dovrà passare dal metodo che permette soltanto la scrittura. Il contrario se si vuole una variabile read-only.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3783,
          "asker": {
            "courseId": 4,
            "askerId": 579,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "java supporta l'ereditarietà multipla? Quali sono i vantaggi e gli svantaggi?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarieta"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3732,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Data una classe specifica, cosa vuol dire che una nuova classe è una subclasse di quella precedente? Cosa comporta questo?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "subclasse"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3792,
          "asker": {
            "courseId": 4,
            "askerId": 537,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il principale vantaggio nell'uso di un modificatore di visibilità (public,private o protected) durante la dichiarazione di un metodo o di una classe?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "bug"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3812,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "che cosa fa il metodo super all'interno di una sottoclasse?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3758,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con ereditarietà? Come funziona l'ereditarietà?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3736,
          "asker": {
            "courseId": 4,
            "askerId": 533,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "come faccio a far convivere due funzioni con lo stesso nome ma con firma diversa?\r\n\r\nfunzione( A x, B y) \r\nfunzione(A x, By, C z) \r\n",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "nome funzioni"
            },
            {
              "keyword": " firma"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3798,
          "asker": {
            "courseId": 4,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste l'overriding??",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "sottoclasse"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3719,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "gli array si possono indicare solo con string[]?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "string"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3777,
          "asker": {
            "courseId": 4,
            "askerId": 558,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale principio sta alla base dell'overloading e dell'overridding¿",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 3,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overridding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3716,
          "asker": {
            "courseId": 4,
            "askerId": 527,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e a cosa serve un metodo \"costruttore\"?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Costruttore "
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3748,
          "asker": {
            "courseId": 4,
            "askerId": 551,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è possibile limitare la visibilità di metodi e/o variabili d'istanza?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Subclassing"
            },
            {
              "keyword": " Overriding"
            },
            {
              "keyword": " Visibilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3749,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché la chiamata del costruttore della superclasse dev'essere sempre la prima istruzione del costruttore?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": " super"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3839,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Il costruttore è un metodo che non viene ereditato ma, utilizzando il costrutto super, si può far riferimento a quello della superclasse all'interno di quello della sottoclasse. Che tale chiamata sia la prima istruzione dipende dal modo di operare di Java: quando viene istanziato un oggetto della sottoclasse per prima cosa il costruttore della sottoclasse chiama quello della superclasse ( risalendo lungo tutta la gerarchia fino alla classe Object ) e quando questo non avviene in modo esplicito ( come ad esempio tramite il super) avviene comunque in modo implicito attraverso il costruttore di default. In altre parole per inizializzare le variabili della sottoclasse devono già essere state inizializzate quelle della superclasse.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3741,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 570,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perchè, essendo la classe principale, le altre classi hanno bisogno di ereditare delle funzioni da essa, perciò va chiamata per prima",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3824,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "La chiamata al costruttore della superclasse deve essere la prima istruzione del costruttore della sottoclasse.\r\n\r\nSe il costruttore della sottoclasse non chiama esplicitamente un costruttore della superclase,viene chiamato il costruttore predefinito (senza parametri) della superclasse. Il compilatore Java riporta un errore se la superclasse non ha il costruttore predefinito e il costruttore della sottoclasse non chiama esplicitamente un altro costruttore della superclasse.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3808,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Se la prima istruzione del costruttore non è un comando super(...), allora, prima di eseguire il corpo dello stesso, verrà invocato il costruttore di default della superclasse.\r\nSe, invece, la prima istruzione sarà effettivamente una chiamata al costruttore della superclasse, allora prima di eseguire il corpo del costruttore, verrà invocato quello della superclasse, determinato dai parametri attuali di super(...), ma solo in questo caso. Ciò non avverrà (o lo farà in modo scomposto o ripetitivo) se tale chiamata verrà posta in seguito alla prima istruzione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3756,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Questo comportamento può essere anche spiegato attraverso i modificatori di accesso:\r\nse stiamo inizializzando una classe derivata attraverso il suo costruttore, questo non\r\npuò inizializzare le variabili istanza private della superclasse. Il compilatore forza\r\nquindi la chiamata al costruttore della superclasse che è l?unico con tutti i diritti per\r\naccedere ai campi privati della superclasse.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3832,
          "asker": {
            "courseId": 4,
            "askerId": 581,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene abbreviata la chiamata al costruttore della superclasse in Java?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarieta"
            },
            {
              "keyword": " costruttore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3814,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il motivo fondamentale per cui nel definire una sottoclasse è obbligatorio scrivere come prima istruzione super()?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3822,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché Java è dotato della superclasse Object?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3698,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la parola chiave \"extends\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " extends"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3769,
          "asker": {
            "courseId": 4,
            "askerId": 470,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'ereditarietà?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3801,
          "asker": {
            "courseId": 4,
            "askerId": 475,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa è l'Overriding?\r\n",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding "
            },
            {
              "keyword": " funzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3757,
          "asker": {
            "courseId": 4,
            "askerId": 444,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Si definisca il concetto di ereditarietà, si spieghi inoltre l'overloading e l'overriding in una sottoclasse",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3715,
          "asker": {
            "courseId": 4,
            "askerId": 592,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando una classe (figlio) viene definita sulla base di un'altra classe (padre) attraverso il meccanismo dell'ereditarietà, esso eredità i membri e le funzionalità del classe-padre.\r\nQual è il vantaggio che ci offre questo meccanismo del programmazione OOP?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3732,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il vantaggio è quello di poter creare alberi di dati che abbiano al loro interno variabili con lo stesso nome ma con valori differenti in ogni classe.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3870,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 449,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Scusate l'ignoranza ma non lo so mi dispiace",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3735,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Uno dei vantaggi consiste nel fatto che con classi e sottoclassi si riesce a rappresentare al meglio il mondo reale (vedi cavallo-zebra). Inoltre dal punto di vista del programmatore, si ha il vantaggio che, avendo la possibilità di definire una sottoclasse sulla base della sua superclasse, quando ci si accorge di un errore, o si vuole fare una miglioria ad un metodo, lo si può cambiare una sola volta per tutte le sottoclassi a cui esso è collegato. Questo non potrebbe accadere se si utilizzasse un banale copia-incolla del codice per definire i metodi di una classe che concettualmente potrebbe essere una sottoclasse di quella di partenza.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3768,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Questo meccanismo di programmazione OOP porta con se innumerevoli vantaggi. Uno dei più importanti è sicuramente la possibilità di creare classi specializzate partendo da una più generale, ovvero creare dei sottotipi di classi già esistenti; ciò permette di estendere e accorpare caratteristiche aggiuntive. Inoltre tutti i membri e i metodi della classe padre vengono ereditate da quella figlia e ciò comporta un notevole risparmio di tempo in fase di sviluppo, in quanto gran parte del codice precedentemente scritto potrà essere riutilizzato anche dalle subclassi. Un'altra importante caratteristica è la relazione is-a, ovvero la relazione tra la subclasse e la superclasse, in quanto la subclasse è un caso particolare della superclasse, quindi è a tutti gli effetti in grado di esibire tutti i comportamenti della classe padre, in modo tale che possano sostituirle, senza alterare l'informazione. Questo comportamento è detto polimorfismo e permette di avere programmi estremamente flessibili.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3859,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 480,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il principale vantaggio del meccanismo dell'ereditarietà descritto è quello di poter riutilizzare metodi precedentemente definiti in classi più generiche.\r\nInfatti il meccanismo di ereditarietà permette di creare una vasta gamma di classi derivate sempre più articolate, partendo da caratteristiche generali fino ad arrivare a descrizioni dettagliate che, però, mantengono le proprie radici attraverso metodi e variabili di stato dichiarate gerarchicamente nelle classi da cui esse vengono derivate. I vantaggi possono essere, quindi, riassunti in una migliore leggibilità del codice ed una maggior mantenibilità dovuta alla modularità che permette di riflettere singole modifiche su più porzioni del programma.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3832,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il vantaggio più lampante è la possibilità di riutilizzare il codice già scritto: ereditando da una classe, si acquisiranno tutte le sue caratteristiche, pure se sconosciute al programmatore; la classe figlia può ampliare le sue funzionalità e divenire, com'è facilmente intuibile, una \"versione migliore\" del padre, anche solo ridefinendone alcuni membri o metodi (con overloading e overriding).\r\nDa notare che la classe padre rimane esclusa dalle modifiche: è completamente indipendente dai figli ma fondamentale per essi, poiché ne costituisce la base.\r\nNon a caso esiste il modificatore \"protected\", che amplia la visibilità dei campi del padre ai figli, consentendo loro più libertà d'azione, ma garantendo comunque che certi attributi non siano utilizzabili dalle semplici istanze. È il concetto di incapsulamento e, più in generale, come si è visto, l'ereditarietà permette di mantenere una buona modularità del codice.\r\nDall'ereditarietà, inoltre, derivano le meccaniche del polimorfismo.\r\n",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3796,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il meccanismo dell'ereditarietà offre la possibilità di creare versioni specializzate di classi già esistenti, fornendo dati o funzionalità aggiuntive.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3804,
          "asker": {
            "courseId": 4,
            "askerId": 530,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Ciao,\r\nCosa occorre fare se dato un tipo di oggetti (Chiamiamolo tipo \"A\") con un determinato comportamento, si vuole crearne un nuovo tipo (chiamiamolo tipo \"B\") molto simile al precedente ma con alcune caratteristiche e comportamenti aggiuntivi?\r\nBye!\r\n ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " metodi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3764,
          "asker": {
            "courseId": 4,
            "askerId": 521,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Se dopo aver dichiarato una superclasse costruisco una sottoclasse senza dichiarare esplicitamente il costruttore cosa fa il programma? o meglio quale costruttore usa?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": "classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3737,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Se il programmatore non definisce un costruttore esplicito per una certa classe, il compilatore cerca di aggiungerne uno in modo automatico.\r\n\r\nNel caso in cui la superclasse definisca un costruttore senza parametri in ingresso, il compilatore aggiunge alla sottoclasse un costruttore senza parametri; questo costruttore non fa altro che chiamare quello senza parametri della superclasse.\r\n\r\nNel caso contrario, cioè quando la superclasse non ha un costruttore senza parametri, il compilatore non è in grado di trovare un costruttore adatto e quindi da un errore di compilazione.\r\n\r\nNB: Se una classe non eredita in modo esplicito da nessuna, essa eredita in modo implicito dalla superclasse Object. In questo caso il compilatore aggiunge alla sottoclasse un costruttore senza parametri che chiama quello di Object senza parametri (in modo analogo al primo caso).\r\n",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3847,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 551,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Anche se non viene effettuata una chiamata specifica al costruttore della superclasse, il compilatore inserirà automaticamente, come prima istruzione del costruttore della sottoclasse, una chiamata al costruttore della superclasse.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3789,
          "asker": {
            "courseId": 4,
            "askerId": 540,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità dell' \"UML\" ?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3830,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 500,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "L' UML (Unified Modeling Language) è un linguaggio di modellazione che risulta utile in programmazione poiché è possibile descrivere i domini di diverso genere in modo sintetico e comprensibile.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3829,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 548,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "L' UML viene utilizzato sopratutto quando ci si accinge a sviluppare un software abbastanza complesso, tramite questo linguaggio è possibile definire la struttura, i metodi e le caratteristiche tecniche del programma che verrà scritto, facilitandone la stesura e la comprensione e facendo in modo che vengano individuati eventuali errori concettuali prima che il programma vena tradotto in codice.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3840,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 547,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "L'UML funge da linguaggio internazionale standardizzato per la rappresentazione della programmazione ad oggetti tramite diagrammi e frecce. \r\nE' inoltre quasi indispensabile in fase di progettazione di un programma; per farsene un'idea chiara e mantenerne la struttura durante l'implementazione, quindi per evitare errori. E' anche utile a rendere comprensibile un programma a qualcuno che lo abbia commissionato senza conoscere linguaggi di programmazione.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3786,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 440,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'utilizzo dell' \"UML\" ricade tipicamente in una delle seguenti tipologie:\r\n· Utilizzo come strumento di documentazione a posteriori.\r\n· Utilizzo come strumento attivo di analisi e design.\r\n· Utilizzo come strumento di sviluppo, attraverso il cosiddetto round-trip.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3740,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 501,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "La grande importanza dell' UML (Unified Modeling Language) consiste nella definizione di standard, che descrivono come si devono affrontare varie problematiche relative al mondo della programmazione object-oriented, in modo sintetico e comprensibile.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3780,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Permette di avere una maggiore chiarezza del codice, una più semplice e intuitiva rappresentazione grafica! Dunque semplifica la vita del programmatore implementando questa funzionalità anche all'interno di ambienti di sviluppo dediti a tale operazione. L'unified modelling language permette di visualizzare il codice come un grafico in cui le varie classi sono collegate tra loro e tramite la disposizione di esse all'interno del grafo si possono intuire immediatamente le classi principali e quelle che ne ereditano le proprietà.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3795,
          "asker": {
            "courseId": 4,
            "askerId": 489,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Dopo aver ridefinito una funzione in una sottoclasse con il processo di overriding, è comunque possibile riutilizzare la funzione che era stata implementata precedentemente nella classe padre?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overriding"
            },
            {
              "keyword": " sottoclasse"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3761,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 591,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Si, se ad esempio ho un metodo, nella classe padre, con un parametro come argomento e nella classe figlio viene ridefinito con due parametri allora in base al numero di parametri in entrata il compilatore deciderà se utilizzare il metodo della classe padre o della classe figlio.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3762,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Si', supponiamo di avere una classe A e una classe B che estende la classe A (B is a A, B è figlia di A, B eredita i parametri di istanza e metodi di A), in B ritroviamo tutti i parametri di istanza e i metodi di A ma reimplementando un metodo in B con la stessa firma di A (facendo un overriding) nella classe figlia viene mascherato il metodo della classe padre (per esempio l'estrai della Coda visto a lezione). In Java e' possibile accedere ai metodi della classe padre utilizzando super.<nome metodo>(<eventuali parametri>); con il caso particolare del costruttore per il quale basta scrivere super(<eventuali parametri>);\r\n\r\nIn generale super permette di risalire di un livello nella gerarchia della classi, esso può essere concatenato piu' volte per salire di piu' livelli.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3793,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 470,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Basta usare \"super.nomefunzione\" ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3820,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "No non è possibile perché questa è stata sovrascrivere. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3799,
          "asker": {
            "courseId": 4,
            "askerId": 425,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando chiamiamo il costruttore di una sotto-classe, cosa viene eseguito automaticamente se non specificato?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": "superclasse"
            },
            {
              "keyword": "sottoclasse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3726,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra una classe in java e una struct in c++?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3751,
          "asker": {
            "courseId": 4,
            "askerId": 432,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel caso in cui si crei una classe che è derivata da due superclassi (es. classe PuntoStringa{...} derivata da Punto{...} e Stringa{...}, al comando super quale classe si andrà a puntare? È necessario specficare la classe di appartenenza tramite comandi aggiuntivi?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3831,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 549,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In Java, una classe può ereditare le interfacce da più di una classe base -cioè esporre all'esterno gli stessi metodi delle interfacce delle classi base - ma può ereditare i dati ed i metodi effettivi da una sola classe. Perciò col comando super si andrà a puntare all'oggetto della classe da cui eredita i dati. E' quindi, si, necessario specificare da quale delle due classi si vuole farlo. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3727,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In Java una classe può ereditare al massimo da una classe. Questo significa che ogni classe può avere al massimo una superclasse diretta. Invece, una classe può essere estesa da molte classi. Possono quindi esserci molte classi che hanno in comune la stessa superclasse diretta, ma non l'opposto.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3760,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 592,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Premettendo che certi linguaggi di programmazione, come ad esempio C++, ammettono l'ereditarietà multipla, il problema nel decidere a quale classe padre deve puntare il comando \"super\", si risolve in due modi.\r\nIl primo consiste nel considerare nel cercare la funzionalità desiderata nella prima classe padre dalla quale si eredità.\r\nOvviamente se non si trova l'operazione desiderata, si controlla la successiva classe nell'elenco, finche non finiscono le classi padre.\r\nInoltre se le classi padre, ereditano da altre classi, vi si applica lo stesso processo finche non trovo la funzione, o variabile desiderata.\r\nAd esempio:\r\n\r\nclass PuntoStringa extends Punto , Stringa {...}\r\n\r\nPrima controlo in \"Punto\", nel caso \"super\" non abbai successo,  passo ad \"Stringa\" e così via.\r\nTuttavia se si desidera esiste un secondo modo ed è quello di utilizzare dei comandi aggiuntivi per decidere a quale classe si deve riferire (puntare) il comando \"super\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3851,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 511,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "nessuna in quanto in Java non si può derivare una classe da più sottoclassi contemporaneamente. o derivi da PuntoStringa o derivi da Stringa. in quel caso super andrà a puntare la classe da cui derivi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3753,
          "asker": {
            "courseId": 4,
            "askerId": 590,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze fra ereditare una classe in c++ e java?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " ereditarieta"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3773,
          "asker": {
            "courseId": 4,
            "askerId": 448,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Se istanzio un oggetto della classe figlio (che estende la classe padre) chiamando un costruttore non di default, qual è l'ordine in cui vengono chiamati i costruttori (anche di default)?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3787,
          "asker": {
            "courseId": 4,
            "askerId": 463,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra Overloading e Overriding?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3776,
          "asker": {
            "courseId": 4,
            "askerId": 440,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un Overriding?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3725,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra l'ereditarietà in Java e in C++?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 4,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " differenze"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3739,
          "asker": {
            "courseId": 4,
            "askerId": 566,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè uso \"this.x=x;\" nella slide numero 11?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " class Point"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3748,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "è buona prassi utilizzare come parametri del costruttore, lo stesso nome delle variabili della classe che si vogliono inizializzare, questo per semplificare la leggibilità del codice.\r\nPerciò devo specificare con la parola chiave 'this' che mi riferisco alla variabile definita all'interno della classe, e non al parametro del costruttore.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3826,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 593,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per richiamare il costruttore",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3828,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Nella slide n. 11 viene mostrato un nuovo aspetto dell'etica del programmatore. A volte infatti quando si scrive la funzione costruttore sono necessari dei parametri di ingresso, naturalmente si possono dare dei nomi qualsiasi ai parametri, ma si cerca di dare a ogni parametro lo stesso nome del dato che andrà a inizializzare. Prendiamo per esempio l'oggetto:\r\n\r\nMacchiaColore {int larghezza; color colore;}\r\n\r\nSi tende a scrivere una funzione costruttore di questo tipo, per rendere più CHIARO l'intero codice:\r\n\r\nMacchiaColore(int larghezza, color colore) { ... }\r\n\r\nA questo punto però se nella funzione Costruttore si cerca di inizializzare la variabile di istanza dell'oggetto con \"larghezza = larghezza;\" non si eseguirà alcunchè, in quando la \"larghezza\" dell'oggetto è OSCURATA dal parametro della funzione, viene quindi usato il \"this.\" per aggirare questo problema! ;)",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3726,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "\"this.x\" è una reference facoltativa ad un oggetto. In questo caso è utilizzata per rendere più chiaro il codice e non confondere quindi un membro della \"class\" Point (il primo \"x\"), con un argomento di una funzione (il secondo \"x\").",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3744,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "l'istruzione \"this.x = x\" viene usata in un costruttore; e significa, che la variabile \"x\" preceduta dal \"this\", appartiene alla firma (lista dei parametri) del costruttore stesso e assume il valore della variabile \"x\" che sarà stata dichiarata precedentemente e ovviamente al di fuori del costruttore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3804,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 564,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": ".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3766,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 497,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Nella funzione \"costruttore\" Point che prende due parametri, this.x=x e this.y=y devono essere le inizializzazioni delle variabili di istanza (quindi diamo gli stessi nomi delle variabili di istanza). Si usa il costrutto \"this\" poiché altrimenti le variabili x e y presenti nel costruttore schermerebbero le x e y delle variabili di istanza.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3822,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perché sennò Java crede ci si stia riferendo alla variabile locale e non si accederebbe dunque alla classe.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3857,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "\"this.x\" si utilizza per specificare che ci si sta riferendo alla variabile \"x\" con scope più \"interno\" a quella porzione di codice, infatti possiamo vedere poco sopra nella slide che abbiamo una variabile \"x\" passata alla funzione e una variabile \"x\" dichiarata all'interno della funzione stessa.\r\nIn generale \"this\" si può spesso omettere ma torna utile in questi corner case in cui è necessario essere più specifici nello definire a quale variabile si fa riferimento in quanto potenzialmente \"oscurata\" da un altra con lo stesso nome.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3784,
          "asker": {
            "courseId": 4,
            "askerId": 457,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos' è l'ereditarietà e in cosa consiste precisamente la differenza tra estensioni strutturali e comportamentali? ",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " estensioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3786,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le restrizioni quando si esegue l'override di un metodo?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "nome"
            },
            {
              "keyword": "tipo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3710,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il metodo super e perchè deve essere chiamato come prima istuzione?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3721,
          "asker": {
            "courseId": 4,
            "askerId": 434,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Se una classe A eredita da un'altra classe B, la quale contiene molti metodi, lo spazio che A occupa nella memoria aumenta? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": "ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3864,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 531,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "No perché i metodi vengono chiamati dalla classe B",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3785,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 585,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Lo spazio occupato dalla superclasse A in questo caso non aumenta perchè è la cottoclasse B che, essendo una sua estensione, andrà ad occupare più spazio in memoria... la classe A rimane uguale a come era definita precedentemente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3806,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "No, lo spazio che A occupa nella memoria non aumenta",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3852,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 444,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "No lo spazio occupato da A non varia in base allo spazio che occupa B, altrimenti il programma sarebbe inefficiente e la OOP sarebbe caduta in disuso molti anni addietro",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3862,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 458,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "No. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3801,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "La classe A (sottoclasse) eredita (tramite l'operatore extends) dalla classe B (superclasse), tutto ciò che contraddistingue quest'ultima (variabili di istanza, metodi ecc..). Ne segue che la classe A avrebbe un'occupazione di memoria non superiore ma bensì pari alla classe B, a meno che al suo interno non vengano definite ulteriori variabili di istanza o metodi.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3805,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Se una classe B, sottoclasse di A, viene istanziata, allora in memoria verranno allocate tutte le variabili di A e di B; i metodi (di A e di B) invece vengono inseriti solo una volta (se istanzi due oggetti B i metodi saranno caricati solo una volta) in un'area apposita della memoria, quindi la risposta è si.\r\nIn caso di esecuzione di un metodo verrà allocata nello stack una quantità di memoria necessaria alle variabili del metodo stesso.\r\nPer riassumere, tutti i metodi sono caricati una volta mentre le variabili tutte le volte che l'oggetto viene istanziato.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3850,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 525,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Ovviamente no, infatti grazie all'ereditarietà, la classe A acquisisce tutto il contenuto, quindi anche i metodi, della superclasse senza doverne fare una copia nella propria struttura. Tutto questo è possibile grazie alla keyword \"super\", seguita dal metodo della classe superiore, per eseguire quest'ultimo. Bisogna però definire la subclasse con un'altra keyword, quella di \"extends\" più il nome della classe da cui erediterà il contenuto, per far si che le due classi siano rispettivamente delle classi \"figlio\" e \"padre\". In questa maniera le due sono \"collegate\" e quindi la subclasse potrà accedere a quella a lei superiore. In definitiva la risposta è no, in quanto una copia sarebbe un gran spreco di memoria.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3866,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 545,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "No perchè interviene l'overriding, quindi i metodi di A si sostituiscono ai metodi ereditati da B.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3745,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 89,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e svantaggi di un sistema di classi come quello di Java (unica classe radice, struttura ad albero) rispetto al sistema del C++ (molte classi radici, struttura a foresta)? Quali sono le principali conseguenze?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "confronto C++ Java"
            },
            {
              "keyword": " classe radice"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3856,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 490,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "E quando l'avrebbe spiegata questa cosa?",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3784,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Boicottiamo il sistema, V.O.T.A.T.E. la mia risposta! Ricambierò il voto a tutte le prossime risposte con la sigla V.O.T.A.T.E!\r\nPer un sistema più giusto ( e per un punto in più all'esame).\r\n\"Some animals are more equal than others\"- G.Orwell",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3861,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 521,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "I vantaggi di una struttura ad albero come quella di java dove abbiamo un unica radice padre e più classi figli consistono in :\r\n-polimorfismo\r\n-ordine: il programmatore è in grado di capire quali metodi eredita dalla superclasse padre \r\ne quali cambiano\r\n- la presenza di una classe padre da cui derivano tutti\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3841,
              "task": {
                "taskId": 95,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 541,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "L'ereditarietà multipla che viene consentita dal linguaggio di programmazione C++ consentendo di far ereditare processi da più classi padre presenta alcune criticità. Il programmatore deve porre particolare attenzione all'eventualità che vi siano più metodi con uno stesso nome ereditati dalle classi padre e vi siano quindi delle ambiguità da risolvere.\r\nCionostante la possibilità di eredità multiple è una grande potenzialità di questo linguaggio di programmazione.\r\nIl linguaggio Java (essendo però orientato più verso la semplicità della programmazione piuttosto che alla libertà del programmatore) impedisce l'ereditarietà multipla (con l'eccezione delle \"interfacce\").",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        }
      ]
    },
    {
      "lectureId": 40,
      "lectureTitle": "Introduzione a Java",
      "questions": [
        {
          "questionId": 3510,
          "asker": {
            "courseId": 4,
            "askerId": 439,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi di eseguire un programma attraverso una macchina virtuale (in questo caso JVM)?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3524,
          "asker": {
            "courseId": 4,
            "askerId": 526,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale ruolo assume la JVM (Java Virtual Machine) all'interno del processo di compilazione di un progetto .java?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3460,
          "asker": {
            "courseId": 4,
            "askerId": 456,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo Java risolve il problema della portabilità dei programmi?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3457,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale soluzione ha adottato Java per evitare gli errori causati dall'uso dei puntatori?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3569,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Parla del garbage collection e dei benefici che comporta in Java rispetto alla programmazione in C.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3501,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si traducono le funzioni libreria che si possono trovare in C++, nel linguaggio di programmazione JAVA?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3516,
          "asker": {
            "courseId": 4,
            "askerId": 533,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "come si potrebbe risolvere il problema di una scheda ROM,con l'eventuale possibilità di commettere errori nella sua programmazione, all' interno di un di un qualsiasi apparecchio elettronico, ignorando l'ipotesi di installare una RAM che renderebbe col passare del tempo l'apparecchio troppo \"antico\" per sostenere i continui miglioramenti e aggiornamenti? ",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3523,
          "asker": {
            "courseId": 4,
            "askerId": 437,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Le classi possono essere assimilate alle struct di c++?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3526,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste il miglioramento apportato da Java rispetto al linguaggio C?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3511,
          "asker": {
            "courseId": 4,
            "askerId": 440,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando con laureandi in informatica del terzo anno di c++ e java associano il primo principalmente al Mac OS e java ai software Microsoft, perché questa distinzione?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3534,
          "asker": {
            "courseId": 4,
            "askerId": 435,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa toglie Java rispetto a C e C++?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3492,
          "asker": {
            "courseId": 4,
            "askerId": 551,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale fondamentale differenza del processo di compilazione di codice Java (rispetto a quella di C o C++) rende possibile l'esecuzione dei programmi su macchine dotate di hardware e sistemi operativi diversi tra loro?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3473,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi è preferibile l'utilizzo di C++ al posto di Java? E perché?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3478,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il modo più semplice per definire una classe e le sue componenti?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3539,
          "asker": {
            "courseId": 4,
            "askerId": 477,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo la programmazione ad oggetti risulta efficiente in progetti di grandi dimensioni, rispetto alla programmazione imperativa?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3562,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende esattamente per JVM (Java Virtual Machine) e qual è il suo compito?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3459,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che vantaggio ha lo schema di applicazione consigliato nelle slides rispetto a quello minimale?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3553,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 501,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il principale vantaggio consiste nella rapidità di aggiornamento del codice nel caso in cui occorra cambiare una parte che viene usata ripetutamente.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3582,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 525,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Grazie allo schema consigliato si ha un codice molto più facile, con una struttura che rende la lettura ed anche la rielaborazione molto più efficaci rispetto ad uno schema minimale.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3490,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 480,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Mentre a livello di esecuzione non vi sono differenze sostanziali tra i due modelli proposti, l'applicazione minimale risulta molto meno leggibile, non tanto per applicazioni il cui codice è composto da poche semplici righe di codice, ma soprattutto in progetti ben più complessi dove requisiti come la chiarezza e mantenibilità del codice diventano fondamentali. Ed è proprio in questo che lo schema consigliato si distingue da quello standard, risultando molto più chiaro e ben definito rispetto ad un modello minimo (schema minimo slide 24 lezione 1, schema consigliato slide 25 lezione 1).",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3580,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 578,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Ha il vantaggio di essere più modulare; così facendo tieni un main molto snello, quindi più leggibile, e rende il codice più facile da riutilizzare.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3565,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 444,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Lo schema consigliato porta vantaggi nel multithreading, inoltre é possibile cambiare in toto la logica del programma cambiando solamente la classe senza sconvolgere il main. La seconda é più \"comoda\"",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3575,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 562,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Rispetta il paradigma della programmazione ha oggetti, non ha nessun vantaggio",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3507,
          "asker": {
            "courseId": 4,
            "askerId": 540,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono le \"API\"?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3470,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 542,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Le API, application programming interfaces, sono solitamente delle librerie che contengono informazioni su come varie parti del software debbano interagire, sia tra di loro, sia con altri software, sia con l'hardware. Ad esempio possono descrivere determinate classi o oggetti.9",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3534,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Le API (Application Programming Interface) sono librerie, cioè collezioni di componenti software (come funzioni e procedure) disponibili per la programmazione di nuove applicazioni.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3445,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Le API sono le librerie software di un linguaggio di programmazione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3452,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 443,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Application Programming Interface, sono la parte \"pubblica\" di un software ai quali gli sviluppatori possono accedere per ottenere dei servizi",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3533,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Le API (application programming interface) sono dei componenti software gia' scritti che permettono lo svolgimento di diversi compiti (si potrebbe fare un'analogia con le librerie del C o C++).\r\nLe API permettono al programmatore di lavorare ad un piu' alto livello di astrazione facilitandone, di conseguenza, il compito.\r\nUtilizzando le API un programmatore non deve scrivere un programma da zero, ma sfrutta dei comandi che qualcun'altro ha scritto per lui risparmiando una grande quantita' di tempo. Alcune API per esempio gestiscono l'IO (input output), altre le stringhe ecc...",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3478,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 577,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Le \"API\" (Application Programming Interface) sono un insieme di specifiche che i programmi software posso utilizzare per comunicare tra di essi. In questo modo la loro interazione è più facile poiché fungono proprio da interfaccia tra i programmi stessi. Per \"API\" si intende anche un insieme di librerie software scritte in un certo linguaggio di programmazione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3568,
          "asker": {
            "courseId": 4,
            "askerId": 422,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali caratteristiche di Oak (in seguito Java) lo hanno reso un linguaggio particolarmente adatto alla programmazione web (applet), pur avendo, inizialmente, come target gli \"intelligent consumer electronics\"?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3560,
          "asker": {
            "courseId": 4,
            "askerId": 517,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono gli Software Layers?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3497,
          "asker": {
            "courseId": 4,
            "askerId": 480,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa sono dovuti principalmente i cali di prestazioni riscontrati nell'utilizzo di una macchina virtuale come JVM ?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3519,
          "asker": {
            "courseId": 4,
            "askerId": 541,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per portabilità di un programma?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3468,
          "asker": {
            "courseId": 4,
            "askerId": 527,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Ma quindi è corretto dire che la JVM è un'applicazione installata sulla frame del sistema operativo? O è meglio dire che si installa sull'hardware?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3460,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "JVM (Java Virtual Machine) è il nome che viene dato alle implementazioni delle specifiche dettate da chi mantiene la tecnologia Java.\r\nNe esistono diverse implementazioni e, in quanto tali, permettono l'esecuzione del bytecode, il prodotto della compilazione delle sorgenti.\r\nPossiamo pensare al bytecode ad \"il linguaggio macchina per le JVM\", e, di conseguenza, che le JVM sono \"un'architettura hardware implementa via software\", che quindi servono ad astrarre l'ambiente d'esecuzione.\r\nLe implementazioni possono avere diversi target, come PC e sistemi embedded. Nel primo caso, trovi quasi sempre un sistema operativo, e quindi la JVM astrarrà il livello dell'OS, che quest'ultimo astrae a sua volta l'architettura hardware (anche). Nel caso embedded, spesso non trovi un sistema operativo, quindi la JVM si appoggia direttamente sul livello hardware.\r\nQuindi la risposta è: entrambe, a seconda della JVM che installi, che è in funzione dall'ambiente su cui il software dovrà lavorare.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3476,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 448,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "La JVM è un'applicazione, e in quanto tale fisicamente è installata sull'HD, ma logicamente è installata nel sistema operativo. Si occupa di di interpretare il ByteCode (linguaggio dei programmi Java compilati) e di tradurlo in modo che il il sistema operativo possa eseguire le istruzioni contenute in esso interfacciandosi con l'hardware.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3505,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 479,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "in linea di principio la JVM può essere incorporata direttamente nell'hardware. Tuttavia può essere comodamente installata come un programma all'interno del sistema operativo, ovviamente utilizzando programmi diversi su macchinde diverse",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3483,
          "asker": {
            "courseId": 4,
            "askerId": 483,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è la JVM (Java Virtual Machine)?",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 4,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3506,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "La parola chiave \"static\" davanti al main ha lo stesso effetto di quelle che si trovano nel c++ davanti alle variabili? Cosa vuol dire questa parola chiave?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3465,
          "asker": {
            "courseId": 4,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "L'\"import\" di ogni programma e' definito come un include \"intelligente\", cosa significa esattamente?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3464,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "significa che non hai bisogno delle operazioni #ifdef , #ifndef. cioè se fai import due volte, il compilatore si arrabia dicendo che non e' possbile questa operazione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3510,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "non c'è bisogno di includere librerie...\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3585,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "In pratica non c'è un precompilatore. E non serve un #ifdef.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3493,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "L?istruzione #include del C viene utilizzata per inserire all?interno del file sorgente un file contenente prototipi delle funzioni di libreria, costanti e prototipi di funzioni.\r\nL?istruzione import di java invece e' una semplificazione per specificare il nome di una classe, non include niente nel file sorgente, dice solo dove si trova la classe.\r\nUtilizzare #include può diventare complicato quando il programma inizia a diventare più complesso. La direttiva import sostituisce comodamente la #include evitando di incorporare due volte lo stesso file.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3469,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "L'\"import\", utilizzato in Java, viene definito \"intelligente\" perchè, a differenza di \"#include\" di C/C++, prima di copiare la parte di codice necessaria, esegue un controllo e verifica se esso sia già stato importato altrove. Questo controllo viene fatto in automatico da parte del compilatore, a differenza di C/C++ dove il controllo veniva fatto dal precompilatore solo se il programmatore utilizzava la dicitura \"#ifndef\". Quest'ultima diviene perciò inutile all'interno dell'ambiente Java.",
              "notes": "-",
              "rating": 6,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3530,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale problema risolse l'introduzione del linguaggio Java ? E come ?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3474,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è stato il principale motivo del successo di Java nel 1994?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3495,
          "asker": {
            "courseId": 4,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "è indifferente il sistema operativo sul quale utilizzo netbeans? O ce n'è uno sul quale è meglio?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3461,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'operatore ~ ?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3467,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci sono differenze nella portabilità del codice tra un programma scritto in C++ e uno scritto in Java?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3515,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "che cos'è HW-OS neutral SOFTWARE LAYER?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3470,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo Java risolve i problemi di partabilita' presenti in altri linguaggi di programmazione come C e C++?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3521,
          "asker": {
            "courseId": 4,
            "askerId": 426,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali innovazioni che Java ha introdotto?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3533,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano gli operatori del gruppo \"Bit\"?(pag. 50)",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3584,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 529,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Gli operatori del gruppo bit permettono la modifica diretta del valore. Tra questi troviamo quelli di scorrimento: >> (scorrimento a destra), << (scorrimento a sinistra), >>>> (scorrimento a destra con riempimento con zero); e quelli di confronto: & (AND binario), | (OR binario), ^ (XOR binario), ~(NOT binario unario).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3567,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 558,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Gli operatori del gruppo \"Bit\" agiscono sui singoli bit che compongono gli operandi. Eseguono l'operazione su ogni coppia di bit (i primi, i secondi...) separatamente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3574,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 547,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Gli operatori del gruppo bit servono a manipolare e valutare bit.\r\nL'operatore shift (<<, >>)sposta tutti i bit di n posizioni (verso dx o sx), ossia, dato x=0010011, 'x<<3' diventa 0011001 (analogamente 'x>>3' risulta 0110010)\r\nGli operatori AND NOT OR e XOR sono bit a bit.\r\nNOT (~) è la negazione logica di ogni bit, equivalente quindi al complemento. ( ~0100=1011)\r\nL'operatore (&) AND confronta due variabili di ugual lunghezza, a e b, e ne produce un'altra che ha '1' nelle pozizioni in cui entrambi a e b hanno 1 e '0' in tutte le altre.(a=001, b=101, a&b=001)\r\nL'Operatore OR (|, inclusive or) confronta due variabili di ugual lunghezza, a e b, e ne produce un'altra che ha '1' nelle pozizioni in cui almeno o a e b hanno 1 e '0' in tutte le altre.(a=001, b=101, a|b=101)\r\nL'operatore XOR (^, exclusive or) confronta due variabili di ugual lunghezza, a e b, e ne produce un'altra che ha '1' nelle pozizioni in cui a e b hanno stesso valore e '0' in tutte le altre.(a=001, b=101, a^b=011)\r\n",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3507,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 517,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Gli operatori bit a bit o bitwise consentono di manipolare singoli bit nei tipi interi primitivi, ed eseguono operazioni booleane sui bit corrispondenti nei due argomenti per produrre il risultato. L?operatore bitwise AND (&) restituisce 1 nel bit di output se entrambi i bit di input valgono uno; altrimenti, produce 0. L?operatore OR(|) restituisce 1 nel bit di output se entrambi i bit di input valgono uno e produce 0 solo se entrambi i bit valgono 0. L?operatore bitwise XOR od OR ESCLUSIVO (^) restituisce 1 se uno qualsiasi dei bit di input vale uno, ma non entrambi. L?operatore bitwise NOT (~, detto anche operatore di complemento a uno) è di tipo unario in quanto accetta un solo argomento, a differenza di tutti gli altri operatori bit a bit che sono, invece, binari. L?operatore bit a bit NOT restituisce l?opposto del bit di input: 1 se il bit vale zero e 0 se il bit inserito vale uno.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3538,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "La prossima volta fai una domanda su cose affrontate a lezione, grazie.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3446,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Gli operatori di bitwise (che operano sui singoli bit) sono i seguenti:\r\n   \"&\" AND\r\n   \"|\" OR\r\n   \"^\" XOR\r\n   \"~\" Complemento a 1 (0=>1, 1=>0)\r\n   \"<<\" shift a sinistra\r\n   \">>\" shift a destra  \r\n\r\nIn Java  tutti i tipi di interi  sono 'signed' e gli operatori \"<<\" e \">>\" fanno degli shift aritmetici. In Java e' presente anche l'operatore \">>>\" per fare uno shift logico a destra, dal momento che gli operatori logico  e aritmetico di shift a sinistra sono identici non esiste un operatore \"<<<\" in Java.\r\n\r\nGli operatori di shift eseguono uno shift dall'operatore indicato \r\na destra a quello indicato a sinistra. L'operatore destro deve essere \r\npositivo. I bits liberati vengono riempiti con zero (cioe' non si tratta di\r\nuna rotazione, con recupero sul lato opposto dei bit shiftati).\r\n\r\nEsempio:\r\n\r\nz<<2 shifta i bit in z di due posti verso sinistra\r\n\r\nz=00000010 (binario)\r\nz>>=2 => z=00000000\r\nz<<=2 => z=00001000 ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3545,
          "asker": {
            "courseId": 4,
            "askerId": 500,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quali motivi si è sentita la necessità di un linguaggio di programmazione come Java?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3548,
          "asker": {
            "courseId": 4,
            "askerId": 429,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa contiene la documentazione generata automaticamente da JAVADOC?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3480,
          "asker": {
            "courseId": 4,
            "askerId": 444,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di java rispetto a c/c++?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3546,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Solo una curiosità: le applet Java non le usa più nessuno per una effettiva mancanza di mercato, nel senso che non avevano una grande utenza, o semplicemente perché sono state rimpiazzate da altri prodotti? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3567,
          "asker": {
            "courseId": 4,
            "askerId": 545,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste e come funziona il sistema \"Garbage Collection\" introdotto da Java? ",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3468,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Java per ovviare al problema della memoria allocata e non più rilasciata (memory leaks), dovuto nel C e nel C++ in gran parte all'uso di puntatori, abolisce l'utilizzo di questi ultimi ed introduce un meccanismo automatico di gestione della memoria chiamato \"Garbage Collection\".\r\nIl \"Garbage Collection\" essenzialmente scova l'area di memoria che non viene più utilizzata dal programma e la dealloca, rendendola nuovamente utilizzabile dal programma in uso.\r\nLa caratteristica di questo modello è che nella memoria che il compilatore rende disponibile per un determinato programma, da un lato dello heap (memoria allocata dinamicamente dal programmatore) sposta tutti i file necessari alla compilazione del programma (codice eseguibile, variabili globali e statiche...), mentre rende disponibile l'altra parte per le varie funzioni interne al programma (stack), così da evitare una frammentazione dello heap stesso.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3539,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 524,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il sistema di \"Garbage Collection\" di Java quando entra in funzione ricerca all'interno di un programma eventuale memoria (variabili, ecc.) - allocata all'inizio dello stesso e non deallocata alla fine - usata solo una volta e considerata inutile cancellandola. Così facendo libera memoria altrimenti occupata inutilmente e mantenendo la macchina efficiente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3554,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 504,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il Garbage Collector è un meccanismo di Java che permette di liberare spazi in memoria solo quando non sono piu' effettivamente usati.Questo è possibile perchè ad ogni oggetto si assegna la proprietà di raggiungibilità dalla root (oggetti sempre presenti durante l'esecuzione del programma); un oggetto è raggiungibile se esiste un percorso di riferimenti dalla root, che permette di indirizzare l'oggetto stesso.Quindi gli oggetti raggiungibili sono quelli referenziabili e quindi \"vivi\", mentre gli altri sono quelli da eliminare, per fare ciò Java usa una serie di algoritmi.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3462,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il sistema di \"garbage collection\" di Java è una particolare modalità di gestione della memoria. Essa prevede che un processo, eseguito separatamente dal programma principale, esamini periodicamente la RAM utilizzata da esso e deallochi la memoria non più referenziata, quindi non più necessaria all'esecuzione. Questo sistema permette di sollevare il programmatore dall'onere di deallocare esplicitamente la memoria evitando la maggior parte degli errori legati ai puntatori, come i \"memory leaks\", che si possono verificare a causa di una scrittura errata del codice. Lo svantaggio dell'utilizzo di questo sistema è che il processo che si occupa di esaminare la memoria consuma risorse di calcolo penalizzando parzialmente le prestazioni del programma principale. Inoltre non è prevedibile quando il meccanismo di garbage collection viene attivato e quindi non si può sapere in che punto dell'esecuzione si verifica il calo di performance.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3549,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il \"Garbage Collection\"",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3511,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 495,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Un'introduzione è necessaria. In Java esistono due categorie di tipi di dato: i type primitivi (int, ...) che vengono allocati direttamente nello stack, e le possibili sottoclassi di java.lang.Object. Quest'ultima categoria viene allocata dinamicamente dall'operatore \"new\" in una specifica porzione di memoria chiamata \"Java Heap\".\r\nDunque, il sistema Garbage Collection è una speciale routine di sistema che scandisce il Java Heap liberando la memoria occupata dagli oggetti non più referenziati. Funziona principalmente in tre fasi:\r\n-Trova l'oggetto da eliminare (garbage detection);\r\n-Libera la corrispondente zona di memoria per renderla disponibile al programma;\r\n-Applica tecniche di deframmentazione dello heap.\r\nIl lato positivo è, evidentemente, che il programmatore non deve più preoccuparsi di deallocare memoria quando non la utilizza più. Di contro, però, il Garbage Collection è un costo in termini di CPU visto che è un sistema sempre parallelamente attivo",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3535,
          "asker": {
            "courseId": 4,
            "askerId": 516,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Se:\r\n\r\nint a = 1;\r\nboolean b = true;\r\n\r\ncosa ritorna l'espressione: \r\n\r\n(a == b)\r\n\r\n?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3458,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 497,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "L'espressione non ritorna nessun valore. Non è possibile confrontare un tipo booleano con un intero.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3453,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Dipende qual'è in main del programma!",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3479,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "In Java l'espressione (a==b) non è permessa in quanto in questo linguaggio non è possibile la comparazione tra il tipo \"boolean\" e un altro tipo qualsiasi (come ad esempio un int). Inoltre, in Java, nessun tipo può essere convertito (tramite casting) nel tipo \"boolean\".\r\n\r\nIn C++ invece, se si utilizza il tipo \"bool\" come tipo equivalente al tipo \"boolean\", l'espressione (a==b) restituisce \"true\".",
              "notes": "-",
              "rating": 6,
              "coins": []
            },
            {
              "answerId": 3522,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Poiché in Java il confronto tra due valori deve essere dello stesso tipo, tale espressione viene considerata un errore in fase di compilazione, quindi non ritorna nulla.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3542,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 469,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Allora l'espressione a==b non può essere eseguita perchè non e' possibile confrontare un tipo int con un tipo boolean.Quindi da errore in fase di compilazione.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3544,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "a e b non sono dello stesso tipo quindi una comparazione tra tipi diversi di variabili è impossibile.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3517,
          "asker": {
            "courseId": 4,
            "askerId": 488,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze sostanziali tra il linguaggio Java e il linguaggio C++?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3505,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'applicazione che sta alla base della filosofia Java \"Write once, run everywhere\" ?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3493,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Avendo fatto C e non C++ non so quali siano le parole dell' int main () di C++ dette a lezione.\r\nQuali sono le componenti delle parentesi e quale significato hanno?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3537,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "In C++ è possibile passare ai programmi argomenti (es. valori numerici, nomi di file,..) direttamente da linea di comando: ./a.out 10 20 myinput\r\nQuesto è possibile tramite due parametri formali predefiniti all'interno della funzione main: int main (int argc, char * argv[])\r\nargc: a questo intero viene assegnato il numero delle parole nella linea di comando\r\nargv:è un array di stringhe in cui vengono copiate le parole della linea di comando\r\n\r\nQuesto è molto usato quando si usano file di testo in input e in output perché vengono fatte digitare in stringa di comando il nome dei file.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3532,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "I parametri passati ad int main(...) di C/C++ e Java hanno lo stesso significato, ossia quello di rappresentare una collezione di parametri passati alla chiamata del programma.\r\nPer spiegare al meglio il significato di essi mi serivrò di un esempio: sia \"/a.out param1 param2\" chiamata al programma.\r\nIn C/C++ il main si articola nella seguente maniera: \"int main(int argc, char *argv[])\". argc è un intero che rappresenta il numero di paramentri passato (>= 1, poiché è contato anche il nome del programma, nell'esempio a.out), *argv[] è un vettore contente i parametri passati (nell'esempio \"param1\",\"param2\").\r\nIn Java (come in C#, per chi ha familiarità con il linguaggio proposto da Microsoft), il main si articola nella seguente maniera: \"void main (String args[])\". args è un vettore contenente i parametri passati (nell'esempio sempre \"param1\",\"param2\"), il parametro argc non esiste poiché essendo String un array, in java, è possibile risalire alla sua dimensione tramite \"args.length\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3454,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 566,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "In c++, si può trovare la seguente sintassi \"main(int argc, *argv[])\", dove argc indica il numero di parametri in ingresso che si inserisce dal terminale al momento della compilazione mentre argv è il vettore di puntatori a caratteri contenenti i parametri passati in ingresso.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3535,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Ciao, innanzitutto mi preme correggerti sul fatto che non si trattano di \"parole\" bensì argomenti.\r\nI prototipi della funzione main (), ovvero in soldoni i vari tipi di main (), che puoi avere nel tuo codice C/C++ (dunque non solo legati solo al C++!) sono:\r\nint main ()\r\nint main (int argc, char **argv)\r\nint main (int argc, char **argv, char **envp)\r\nLa prima è la main () più semplice, in quanto non prevede che gli venga passato alcun tipo di parametro.\r\nLa seconda, invece, prende in input gli argomenti che vengono passati al lancio del programma. argc contiene il numero di questi parametri, argv è un array di char * (quindi stringhe) contenente i parametri.\r\nLa terza è uguale alla seconda, solo che aggiunge il parametro envp, anch'esso un array di char * di lunghezza, a differenza di argv, non specificata, con ultimo elemento NULL. Quindi, se vuoi iterare questo array, dovrai farlo finchè envp[i] non punta a NULL.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3475,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 556,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "int main(int argc, char *argv[])\r\n\r\nin cui argc rappresenta il numero di elementi in ingresso e argv il vettore di elementi dati in ingresso.\r\nin argv[0] è contenuto il nome dell'eseguibile, nelle successive eventuali posizioni i parametri dati in ingresso.\r\nesempio: ./a.out parametro1 parametro2",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3482,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 468,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "sono: int main(int argc, char* argv [])\r\nargc non è altro che un contatore che contiene il numero degli elementi presenti in argv, che invece è un array di stringhe. In c++ le stringhe vengono rappresentate come array di caratteri, perciò char* argv [] non è altro che un array di array di caratteri.\r\n(è possibile scriverlo anche come char** argv)\r\n\r\nad esempio: se scrivo ./a.out input output\r\n\r\nargc vale 2 (si parte a contare da 0) ed argv conterrà : \r\nargv[0]=./a.out \r\nargv[1]=input\r\nargv[2]=output ",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3488,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi della programmazione in Java rispetto alla programmazione in C++?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3502,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Si spieghi perché i codici scritti in java danno lo stesso risultato anche su macchine che adoperano sistmi operativi diversi.",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3563,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa AGGIUNGE e INTRODUCE java rispetto al c++?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3484,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una classe in Java?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3557,
          "asker": {
            "courseId": 4,
            "askerId": 449,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra Java e c++?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3541,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i programmi stand-alone scritti in linguaggio java?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3525,
          "asker": {
            "courseId": 4,
            "askerId": 530,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Dal punto di vista della scrittura del software, quale compromesso viene raggiunto con la creazione di Java?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3537,
          "asker": {
            "courseId": 4,
            "askerId": 428,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale esigenza troviamo alla base dello sviluppo del linguaggio di programmazione Java, o meglio, cosa ha spinto a sviluppare questo nuovo linguaggio?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3522,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali motivazioni per cui Java ha riscosso un così ampio successo?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3451,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 523,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un unico codice può essere eseguito su \"qualsiasi\" piattaforma utilizzando lo stesso eseguibile.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3525,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 457,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Java ha riscosso un grande successo soprattutto per la sua maggior robustezza e qualità grafica. Successivamente è diventato sempre più utilizzato nella sicurezza informatica, nella gestione finanziaria e nella creazione di pagine web. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3545,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 475,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "-\"Write once, run everywhere\"\r\n-Toglie i puntatori conferendo così più robustezza\r\n-Introduce classi predefinite\r\n-Utilizza un linguaggio object-oriented\r\n-Tramite javadoc genera automaticamente la documentazione\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3498,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 548,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "La portabilità del codice java da un sistema all' altro è sicuramente il suo punto di forza; contribuiscono anche la semplicità generale e la possibilità di programmare ad oggetti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3524,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 466,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "L'utilizzo della memoria stack in C++ e Java è lo stesso?",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3513,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il principale motivo per cui il linguaggio Java ha avuto un enorme successo, è stato creare un linguaggio che sia indipendente dalla piattaforma, cioè risolvere il problema di portabilità del codice, infatti un codice java scritto in una delle tante piattaforme, crea un eseguibile in grado di essere leggibile per qualsiasi sistema, cosa che non risulta possibile con altri linguaggi di programmazione. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3581,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Uno dei motivi di successo di Java è la sua portabilità su ogni piattaforma. Il motto all'inizio era \"Write once, run everywhere\" nel senso che, una volta compilato il codice sorgente, il file eseguibile era indipendente dalla piattaforma sulla quale era stato compilato il codice sorgente, e poteva essere eseguito su qualunque piattaforma che supportasse Java.\r\nAltro vantaggio di Java è rappresentato dal linguaggio di programmazione: viene ripreso il linguaggio C, effettuando qualche miglioria (per esempio l'eliminazione dei puntatori).",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3466,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Da cosa deriva il nome \"JAVA\"?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 5,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3475,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di Java rispetto a C e C++?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3543,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Vorrei chiedere cosa si intende per garbage collection e come questa soluzione aumenti la robustezza di Java.",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3542,
          "asker": {
            "courseId": 4,
            "askerId": 472,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Non ho capito cosa s'intende per \"documentazione\" quando si utilizza questo tipo di commento.\r\n\r\n\"/**documentation */!\r\n/**Stile di commento usato da JAVADOC!\r\nper la generazione automatica di \r\ndocumentazione */!\"\r\n",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3482,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché un programma in java risulta meno performante di un analogo c++?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3465,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Un programma in java risulta meno performante rispetto ad un programma analogo in C++ in quanto tra software e hardware viene aggiunto un layout intermedio chiamato JVM (Java Virtual Machine) che permette l'esecuzione di codice JAVA su qualsiasi macchina/O.S. ; è ovvio che uno strato intermedio presenta un leggero peggioramento delle prestazioni. In secondo luogo C++ è un linguaggio pensato per sfruttare al massimo la macchina, a discapito della robustezza del codice (alcune istruzioni di controllo come ad esempio l'out of range negli array sono omesse), cosa che invece Java esegue garantendo una stesura del codice più veloce.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3583,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 511,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Per un programma in java solitamente ci vuole meno tempo per la progettazione ma esso risulterà meno performante di un programma analogo in c++ in quanto esso è compilato attraverso un \"layer\" aggiuntivo, la java virtual machine, essa serve a garantire la compatibilità e la portabilità su diversi dispositivi e sistemi operativi, castrando quindi le prestazioni rispetto ad un compilatore \"nativo\" per una determinata macchina/sistema operativo",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3495,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 433,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Un programma scritto in Java risulta meno perfomante rispetto a C++ perchè Java necessità di una macchina virtuale per interpretare il bytecode, ossia il codice ottenuto dalla compilazione di un programma Java. In questo modo si può realizzare l'idea di portabilità, cioè di eseguire lo stesso programma su tutti i sistemi operativi, basta che essi abbiano la JVM (Java Virtual Machine), ma purtroppo l'utilizzo di questo interprete richiede più tempo per compiere le operazioni, e quindi Java risulta meno perfomante rispetto a C++",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3497,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il Java è un linguaggio progettato per essere multi-piattaforma, al contrario del C++. Per questo motivo ha bisogno di una macchina virtuale, la Java Virtual Machine (JVM) che è implementata per le varie piattaforme. Il programma Java non viene eseguito direttamente dal sistema operativo come farebbe un programma scritto in C++, ma viene virtualizzato dalla JVM che occupa delle risorse di sistema e ne rallenta le prestazioni. Nei calcolatori odierni in realtà le prestazioni di un'applicazione Java sono paragonabili a una scritta in C++ grazie ad ottimizzazioni sempre migliori.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3443,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Il fatto di poter essere eseguito in tutti i sistemi operativi senza cambiare il codice di una virgola (o un punto e virgola hahaha) produce degli svantaggi notevoli in quanto, aggiungendo un ulteriore livello di astrazione) la velocità cala dato che le istruzioni con cui viene tradotto un file sorgente non sono in codice macchina(direttamente eseguibile) ma sono per la nostra java virtual machine, che a sua volta convertirà in runtime(nel corso dell'esecuzione) il javassemby in assembly relativo a quel sistema operativo. Questo é il motivo principale, se poi si vuole dare un altro motivo é perché volendo fare un linguaggio molto più robusto di quello che puó essere il c++ hanno introdotto dei controlli che aiutano il programmatore a trovare gli errori subito, senza spendere tempo e di conseguenza denaro (il tempo é denaro) per trovare errori stupidi di distrazione, questi controlli aumentano leggermente il costo computazionale di questo linguaggio. Grazie mille per l'attenzione ;D lol",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3506,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perché un programma Java compila ed esegue all' interno di una virtual machines che è quindi un emulatore. Di conseguenza un programma Java risulta leggermente più lento di uno c++ in fase di compilazione ed esecuzione....",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3536,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il nuovo tipo di commento presente in Java e non i C/C++?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3571,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 425,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il nuovo stile di commento usato da JAVADOC serve per la generazione automatica di  documentazione in formato HTML.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3455,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 470,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "la tipologia di commento  /**.....*/ serve per creare automaticamente la documentazione del programma",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3499,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "E' un commento che permettere di utilizzare la funzione Java della documentazione, in modo da poter aggiungere ai propri programmi le informazioni necessari a rendere comprensibile il codice in tutte le sue parti",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3530,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Java possiede una forma di commento ulteriore, identificata dal possedere un asterisco in più all'apertura del commento:\r\n/** comment-documentation */\r\nQuesto particolare commento viene utilizzato per generare automaticamente, attraverso un tool, la documentazione del codice, partendo dal codice stesso. Il programmatore evita così l'ulteriore \"fatica\" di documentare a parte il proprio codice, ma gli basta commentarlo semplicemente come ha sempre fatto.\r\nQuesto tipo di commento si affianca comunque a quelli classici del C/C++, che possono continuare ad essere usati e che semplicemente non verranno inclusi nella documentazione.\r\nIl tool utilizzato per generare la documentazione in modo automatico è chiamato Javadoc",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3562,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Serve alla manteneabilità del codice, infatti permette di spiegare per ogni classe che cosa fa, che parametri prende in ingresso e che valori restituisce nel return.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3442,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il nuovo tipo di commento (/** ......... */ ) presente in Java e non in C/C++ serve per la generazione automatica di documentazione relativa al codice. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3494,
          "asker": {
            "courseId": 4,
            "askerId": 525,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è lo scopo della Java Virtual Machine?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3519,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Lo scopo della JVM è quello di poter far girare un programma su qualsiasi macchina indipendentemente dal sistema operativo o architettura  usata.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3518,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Lo scopo della JVM è quello di eseguire i programmi compilati (bytecode), senza dover far conto con il sistema operativo in uso.\r\nCon questo software Java è riuscito a soddisfare il motto \"Write once, run everywhere\".",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3463,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 426,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Gli sviluppatori di Java volevano creare una piattaforma che fosse il più portabile possibile.\r\nCosì crearono la Java Virtual Machine, il cui scopo è quello di fare da intermediario tra il programma Java e la macchina su cui gira. Inoltre gestisce la memoria e le interazioni con l'hardware.\r\nIn questo modo un programma in java può essere scritto una volta sola ed essere eseguito su una qualsiasi macchina (che abbia la JVM) indipendentemente dall'hardware.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3561,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 561,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Standardizzare un ambiente al fine di avere unacompatibilità universale su ogni O.S.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3448,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Lo scopo della JVM è quello di astrarre l'hardware ed il software della macchina in modo tale da permettere ai programmi scritti in java di funzionare indipendentemente dalla macchina stessa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3579,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 476,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "La Java Virtual Machine ha come scopo quello di eseguire il bytecode (una specie di assembly language ottenuto dalla compilazione del codice Java su una qualsiasi piattaforma) in modo coerente ed inalterato su una macchina dotata di un qualsiasi sistema operativo.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3547,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Java nasce negli anni '90 per rispondere ad alcune esigenze e risolvere alcuni problemi della programmazione. Quali sono? partendo da questi confronta i due linguaggi Java e C.",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3463,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi dell'uso del linguaggio Java rispetto al C++?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3554,
          "asker": {
            "courseId": 4,
            "askerId": 523,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè la funzione \"main\" in C++--++ è \"void\" e non \"int\" come quella in C++ ?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3552,
          "asker": {
            "courseId": 4,
            "askerId": 505,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Una fondamentale differenza che esiste tra il linguaggio c++ e java è che il primo è un linguaggio compilato mentre il secondo è interpretato, qual'è la differenza?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3552,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La differenza sostanziale tra un linguaggio compilato ed uno interpretato è la seguente: nel primo linguaggio avviene una traduzione del codice sorgente in linguaggio macchina ad opera di un compilatore, al momento dell'avvio di un eseguibile il codice viene quindi caricato in memoria e può iniziare immediatamente l'esecuzione ad opera del processore; nel linguaggio interpretato vi è invece un interprete (es. Java Virtual Machine) incaricato di tradurre il codice sorgente in linguaggio macchina al momento dell'esecuzione.\r\nI linguaggi compilati sono quindi più efficienti in termini di velocità e richiedono meno memoria al momento dell'esecuzione, in compenso i linguaggi compilati sono indipendenti dal sistema operativo e ne consegue una miglior portabilità (es. se compilo un programma scritto in C++ su linux ottengo un eseguibile che funziona solo su macchina linux).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3514,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 460,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "La differenza sta nella traduzione del linguaggio ad alto livello del codice sorgente in ling. macchina: un linguaggio è interpretato se tale traduzione viene effettuata da un interprete (programma che traduce in ling. macchina e fa eseguire al processore istruzione per istruzione); è compilato se viene effettuata da un compiler (che traduce tutto il codice sorgente in linguaggio macchina creando un programma eseguibile dal processore e non più modificabile a meno di cambiare il codice sorgente e ricompilare, risultando quindi più veloce nell?esecuzione ma più difficile da correggere).\r\nSi noti per altro che sarebbe più preciso parlare di ?linguaggi ideati per essere interpretati/compilati? poiché nulla ci impedisce (in linea del tutto teorica) di compilare un linguaggio ideato per essere interpretato e viceversa. Inoltre Java è un tipo particolare di ling. interpretato: l?interprete (JVM) interpreta il bytecode, struttura intermedia ottenuta tramite un compiler dal codice sorgente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3558,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "La compilazione prevede prima la traduzione da linguaggio di alto livello a linguaggio macchina e successivamente l'esecuzione del  programma. \r\nIl linguaggio interpretato invece esegue il programma man mano che lo traduce. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3516,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 549,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "I linguaggi compilati si servono di un compilatore, mentre i linguaggi interpretati di un interprete. \r\nQuando un programma viene compilato ogni istruzione del codice sorgente viene convertita nel corrispondente codice in linguaggio macchina, in modo che possa essere eseguita dal processore. In particolare i compilatori traducono per intero il programma prima di eseguirlo. \r\nGli interpreti invece operano traducendo un'istruzione per volta del codice ed eseguendola direttamente. Quindi non appena un'istruzione è interpretata può essere eseguita. \r\nEssi perciò offrono il vantaggio di potersi accorgere immediatamente di eventuali errori commessi e di apportare modifiche al codice in modo più semplice e immediato.\r\nMentre i linguaggi compilati permettono di scrivere dei programmi che risultano molto più veloci e che quindi hanno migliori prestazioni nelle esecuzioni. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3517,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "La compilazione valuta direttamente il codice sorgente alla ricerca di errori, in seguito lo traduce in un eseguibile (linguaggio macchina) che potrà essere per l'appunto eseguito, ogni qualvolta venga richiesto. La compilazione presenta elevate prestazioni. Mentre l'interpretazione consiste nell'eseguire le istruzioni \"al momento\", come sono scritte nel codice sorgente mentre con la compilazione, una volta avvenuta, il programma è pronto a essere eseguito. Nell'interpretazione questo viene valutato ed eseguito ogni volta, ed è ciò che rende questo processo più lento (di poco, oggigiorno). Per essere precisi, Java è \"a metà strada\" tra i due processi, di fatti il codice sorgente nome.java viene compilato in un formato intermedio chiamato bytecode e a sua volta interpretato dalla JMV (Java Virtual Machine).",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3504,
          "asker": {
            "courseId": 4,
            "askerId": 430,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale comando si usa per compilare un file *.java e quali sono i suoi output?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3577,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 477,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Il comando \"javac nomefile.java\" compila il file sorgente \"nomefile.java\", producendo come output il file \"nomefile.class\", che contiene i file bytecode della classe.\r\nSe vi sono più classi nel file sorgente, saranno prodotti diversi file \".class\", il cui nome corrisponderà al nome della rispettiva classe.\r\nIl file \".class\" compilato sarà inserito nella stessa directory dove si trova il suo file sorgente.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3461,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 531,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Si usa il comando $javac nomefile.java. Il suo output produce un file class (in realtà un file class per ogni classe contenuta nel sorgente).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3502,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 513,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Per compilare un file *.java si usa il comando \"javac\" seguito dal nome del file. questo deve necessariamente contenere alla fine l'estensione \".java\" . L'output sono dei file *.class e sono tanti quanti le classi contenute nel file d'origine.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3471,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 563,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per compilare un file .java usiamo il comando \"javac\" seguito dal nome del file e la sua estensione. (Es. javac Hello.java) Dalla compilazione si ottiene un file .class.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3472,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Per compilare un file *.java (di alto livello) bisogna usare il comando   javac *.java   (javac è un comando contenuto nel JDK). Se il programma è sintatticamente corretto il compilatore crea un nuovo file   *.class   che è  la traduzione in bytecode (basso livello) di    *.java   e che potrà essere eseguito col comando    java *   , altrimenti segnalerà la presenza di errori di sintassi (con riferimento alla posizione dell'errore nel codice) e per poterlo compilare sarà necessario correggerlo.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3564,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 440,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per compilare un file da terminale utilizzo il comando \"javac nomefile.java\" (è obbligatorio specificare l'estensione).\r\nViene creato un file \"nomefile.class\" e poi per eseguirlo utilizzo il comando \"java.nomefile\" (in questo caso l'estensione del file deve essere omessa).\r\nIl comando per l'output  nell' editor è \"System.out.println(\"Testo\");\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3487,
          "asker": {
            "courseId": 4,
            "askerId": 552,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Java:In fase di definizione di un array, che cosa non bisogna specificare?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3529,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "What are class libraries?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3462,
          "asker": {
            "courseId": 4,
            "askerId": 427,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Java è un linguaggio rivoluzionario rispetto a c++ per quali motivi ?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3518,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel mondo reale a cosa mi può servire saper utilizzare Java? Cosa posso fare?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3499,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché si sconsiglia di utilizzare Java per programmi di grosse dimensioni in quanto potrebbero rallentare moltissimo la macchina su cui sono eseguite?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3452,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'ambito in cui Java è maggiormente utilizzato?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3477,
          "asker": {
            "courseId": 4,
            "askerId": 497,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra java e C++?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3527,
          "asker": {
            "courseId": 4,
            "askerId": 518,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "In java la classe è l'ossatura del linguaggio, come si può definire confrontandola con un concetto equivalente del c++ ?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3528,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè Java garantisce una portabilità maggiore rispetto ad altri linguaggi di programmazione?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3553,
          "asker": {
            "courseId": 4,
            "askerId": 457,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quanto riguarda la grafica è più congeniale usare java o c++? ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3476,
          "asker": {
            "courseId": 4,
            "askerId": 448,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella slide n. 36 che parla dei tipi di dato primitivi è indicato che il tipo booleano viene memorizzato in 1 bit. E' effettivamente così o è solamente una convenzione e viene memorizzato in 1 byte come in C#?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3586,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Chiaramente, il contenuto informativo di una variabile booleana è pari ad un bit. Tuttavia, lo spazio in memoria concretamente occupato da una variabile booleana non è definito esplicitamente dalle specifiche di Java. Esso dipende dalla Virtual Machine utilizzata, ma è in generale pari ad almeno un byte (anche se può essere molto maggiore se si includono i byte di header e si tengono in conto le regole interne di allineamento).\r\nÈ tuttavia anche possibile salvare una variabile booleana in modo tale che essa occupi un solo bit: se è necessario salvare grandi quantità di variabili booleane, lo si può fare in maniera più efficiente usando un BitSet (questa strategia, a differenza di un semplice array di variabili booleane, permette di salvare le variabili in modo tale che occupino solo un bit ciascuna).",
              "notes": "-",
              "rating": 6,
              "coins": []
            },
            {
              "answerId": 3491,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 449,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "è una convenzione perchè un booleano può contenere fino a 8 bit (quindi 1 byte)\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3546,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 520,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Anche in java, nonostante il tipo booleano occupi in se' un bit, esso viene memorizzato in un byte per facilitare le operazioni di lettura e scrittura. E' infatti più complesso e dispendioso un sistema che legga/scriva singoli bit a una determinata posizione piuttosto che un sistema che lavori su tutto il byte.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3484,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Java non definisce \"precisamente\" la quantità di memoria \"dedicata\" a memorizzare un booleano. Più precisamente quest'ultima dipende dalla VM (Virtual Machine) su cui viene fatto  girare il programma. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3521,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 456,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il tipo booleano è un nuovo tipo di dato primitivo introdotto dal linguaggio Java. Dal momento che esso può assumere solo due valori, corrispondenti al vero/falso logico, un solo bit è sufficiente per immagazzinare l'informazione ed è questo lo spazio di memoria che Java gli corrisponde.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3551,
          "asker": {
            "courseId": 4,
            "askerId": 478,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi e quali svantaggi ha l'utilizzo di meccanismi di garbage collection?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3444,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 516,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Vantaggi:\r\nLa GC esonera il programmatore dall'eseguire manualmente l'allocazione e la deallocazione di aree di memoria, riducendo o eliminando alcuni bug come per esempio:\r\n- Persistenza nel programma di puntatori che si riferiscono ad aree di memoria che contenevano oggetti, ma che sono state deallocate.\r\n- Doppia deallocazione (tentativo di rilascio di zone di memoria già rilasciate).\r\n- Impossibilità di deallocare una zona di memoria allocata in seguito alla cancellazione del suo puntatore.\r\n\r\nSvantaggi:\r\nLa garbage collection presenta tuttavia anche alcuni svantaggi:\r\n- Il processo consuma risorse per tenere traccia dell'utilizzo delle varie aree di memoria e per decidere quando e cosa liberare.\r\n- Il momento in cui viene effettuata la GC non è prevedibile, ciò può determinare improvvisi freeze o rallentamenti dell'esecuzione.\r\n- L'ordine e il momento di rilascio dipendono dal particolare algoritmo implementato per il collector, quindi secondo uno schema non deterministico.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3578,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 564,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Come vantaggio l'operatore non deve eseguire manualmente allocazione e deallocaziione che sono spesso causa di errore. Come svantaggi questo porta un uso maggiore di risorse di calcolo per decidere quale area di memoria liberare ed è impossibile prevedere quando accadrà questo processo che puo causare quindi blocchi momentanei dell'applicazione imprevedibili.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3527,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 541,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Il \"garbage collection\" (letteralmente raccolta di rifiuti) è un meccanismo automatico che si occupa di ripulire la memoria quando non viene usata. In altre parole il garbage collector individua le aree di memoria allocate per processi non più attivi e le libera in modo da recuperare spazio in memoria.\r\nIl vantaggio maggiore è che il compito di deallocare le aree di memoria non più utilizzate dai processi non è più a carico dello sviluppatore ma svolto da un processo automatico.\r\nLo svantaggio è che il processo di garbage collection occupa risorse di calcolo nella propria esecuzione, inoltre, lavorando in parallelo con altri processi ha diffcoltà ad individuare le aree di memoria da deallocare (in quanto parte della memoria è in uso dai processi in corso).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3466,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 447,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Vantaggi: esonero del programmatore dai compiti della gestione della memoria riducendo errori o bug comuni come: -Darling-Pointers (puntatori ad aree ormai deallocate: essendo non più riservate il loro utilizzo è pericolo); -doppia deallocazione; -ALCUNI tipi di memory leaks(esaurimento della memoria a causa di mancata deallocazione).\r\n\r\nSVANTAGGI: -Consumo di risorse di calcolo da parte del processore nei controlli; -Azione di collection del tutto imprevedibile per cui si può assistere ad improvvisi picchi di carico di lavoro che possono rallentare la macchine (inaccettabile in ambienti in real-time); -Memory leaks comunque presentabili: sta al programmatore ottimizzare l'algoritmo in modo da non mantenere riferimenti attivi a oggetti \"morti\" (riferimenti attivi non permettono di identificare quella areea al GC come \"sacrificabile\").",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3477,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 553,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il garbage collection, o GC, è un gestore automatico della memoria riservata agli oggetti di un programma durante l?esecuzione dello stesso.\r\nIl maggior vantaggio che si incontra ad utilizzarlo è l?esonero del programmatore dalla responsabilità di allocare e de-allocare singole celle di memoria, evitando ricorrenti errori dovuti all?utilizzo dei puntatori e possibili memory leaks. Il GC rende quindi la programmazione più semplice e sicura.\r\nLo svantaggio iniziale era l?imprevedibilità del processo di garbage collection che, quando automaticamente attuato, per tenere traccia dell?utilizzo delle varie aree di memoria e poter decidere il momento e la quantità di memoria da liberare, consumava cotante risorse, che l?esecuzione del programma doveva interrompersi. Questo problema si è risolto con l?introduzione del multitreading, grazie al quale il GC può avvenire parallelamente all?esecuzione del programma. L?unico svantaggio persistito è quindi lo strenuo utilizzo delle risorse di calcolo",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3520,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Con che target nasce il linguaggio java?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 5,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3559,
          "asker": {
            "courseId": 4,
            "askerId": 519,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi e svantaggi della \"garbage collection\"?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 22,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3504,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 570,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La garbage collection è una modalità automatica di gestione della memoria che semplifica l'allocazioe e la deallocazione delle aree di memoria effettuando queste operazioni in maniera automatica. L'affidamento di queste mansioni al compilatore semplifica il lavoro del programmatore ed evita eventuali errori di programmazione, ma al tempo stesso il processo consuma delle risorse e rende la compilazione più lenta.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3492,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "L'introduzione della Garbage Collection libera il programmatore dal dovere di gestire la memoria variabile per variabile. Si eliminano quindi i bug causati da Puntatori a celle di memoria deallocate e si evitano molti tipi di memory leaks. Il codice diventa quindi molto più gestibile nella sua interezza. \r\nTuttavia a seconda della versione del GCollector esso può funzionare in \"parallelo\" rispetto al programma controllandolo mano a mano che procede nella sua esecuzione, può invece essere integrato a \"Compiling time\" dal compilatore oppure può funzionare \"immobilizzando\" completamente il programma, dopo un certo intervallo di tempo o di istruzioni, eseguendo un controllo della memoria utilizzata. Ognuno di questi approcci ha i suoi pro e i suoi contro, a seconda delle esigente un programma potrebbe essere impossibile da interrompere per fare un controllo, oppure un sistema embedded potrebbe non avere abbastanza risorse per far funzionare un processo in parallelo.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3467,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 467,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Il Garbage Collection attuale porta il vantaggio di ripulire la memoria da blocchi non più utilizzati dal programma, il tutto mentre il programma è in esecuzione. Nelle versioni precedenti l'esecuzione doveva essere bloccata per consentire al Garbage Collection di scannerizzare la memoria. Un possibile svantaggio è la diminuzione delle prestazioni.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3509,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 461,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Per \"garbage collection\" si intende una modalità automatica della gestione della memoria da parte di un compilatore. I vantaggi di questa modalità sono dati dal fatto che il programmatore è esonerato dalla gestione della memoria e dunque sono ridotti i rischi di bug come ad esempio deallocare una parte di memoria che era già stata deallocata in precedenza, oppure dalla persistenza di puntatori che rimandano a celle di memoria che erano state liberate. Gli svantaggi sono dati dall'uso di risorse di calcolo che vengono consumate dal processo per capire il momento e la quantità giusta di memoria da liberare, inoltre questo non è prevedibile e puo' inoltre causare rallentamenti e ritardi nell'esecuzione.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3474,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "http://it.wikipedia.org/wiki/Garbage_collection#Benefici",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3486,
          "asker": {
            "courseId": 4,
            "askerId": 469,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Per compilare e scrivere codice in Java di che ho bisogno oltre alla Java virtual machine ??",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3450,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Serve un SDK (Software Development Kit), come Java Platform o NetBeans. Questi programmi contengono sia un editor di testo per scrivere il codice, e il compilatore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3536,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Posso utilizzare il Java Development Kit.\r\nE' un Kit che contiene:\r\n-un compilatore che produce un file che contiene un bytecode\r\n-la Java Virtual Machine (JVM)\r\n\r\nIl compilatore produce un file '.class', e per eseguirlo ometto l'estensione '.class' nella JVM.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3551,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 500,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Per poter scrivere e compilare un codice in Java c'è bisogno di un JDK (Java Development kit) e per poterlo eseguire bisogna in più avere la JVM(Java Virtual Machine).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3563,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per scrivere il codice in Java si ha bisogno di un editor di testo e è obbligatorio specificare l estensone del file \".java\" per compilarlo. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3515,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 557,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Per poter scrivere ed in seguito compilare in linguaggio Java è necessario il JDK (Java Development Kit)\r\nIl primo è un insieme di tool necessari al corretto sviluppo di un sorgente (ed in seguito di un'applicazione) in Java, quali debugger, il javac (ovvero il compiler), il java (inteso come lo strumento per eseguire i file in ByteCode generati dal javac), il jar (per poter utilizzare i file in estensione .jar) ed altri.\r\nLa JVM (Java Virtual Machine) serve in realtà solo ad eseguire il file in ByteCode ritornato dal javac. Essa è contenuta nel JRE (Java Runtime Enviroment), il quale è l'ambiente in cui eseguire le applicazioni scritte in linguaggio Java, completo di librerie (API java), JVM per l'appunto, e un launcher per eseguire le applicazioni in ByteCode.",
              "notes": "-",
              "rating": 6,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3532,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è preferibile usare il linguaggio Java al posto del C++?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3479,
          "asker": {
            "courseId": 4,
            "askerId": 432,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci è stato spiegato durante le ore di programmazione 1 che nella scrittura di un codice l'uso del comando goto è da evitare a tutti i costi a meno che non sia di rilevante importanza per il corretto funzionamento del programma. Durante programmazione 2, invece, questo comando è stato inserito nella lista delle keywords riservate per usi futuri (pagina 55 delle slides): opera quindi diversamente dal C++, permettendo magari di semplificare alcuni comandi/funzioni oppure anche qui l'unica sua utilità è ristretta a specifiche eventualità? Si può togliere dal \"tabù\" dei comandi da non usare?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3455,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che tipo di file produce la Java Virtual Machine alla fine della compilazione?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3503,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il main di un programma scritto in Java deve essere contenuto in una classe?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3566,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra Java e C++ ??",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3481,
          "asker": {
            "courseId": 4,
            "askerId": 470,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per portabilità di un linguaggio di programmazione?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3564,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa è un IDE ?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3565,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la Java Virtual Machine? ",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3498,
          "asker": {
            "courseId": 4,
            "askerId": 549,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si supplisce all'eliminazione dei puntatori nel linguaggio Java? Esistono meccanismi per ottenere risultati simili a quelli prodotti dai puntatori?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3540,
          "asker": {
            "courseId": 4,
            "askerId": 511,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega in quali livelli del calcolatore o della macchina si può inserire la JVM. Inoltre, a cosa serve?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3453,
          "asker": {
            "courseId": 4,
            "askerId": 461,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè Java non supporta gli operatori di deferenziazione?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3550,
          "asker": {
            "courseId": 4,
            "askerId": 529,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la caratteristica principale della portabilità di Java rispetto al linguaggio C++?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3490,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "A lezione è stato detto che l'uso del commento \"   /**documentation */    \" genera automaticamente la documentazione del programma, ma che tipo di file viene creato (se questo accade) e cosa esattamente contiene?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3512,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Il file generato da questo meccanismo di documentazione è di tipo HTML. Il documento creato contiene i commenti scritti dal programmatore con questo particolare formato (/** ? *) Per una corretta esecuzione di questo sistema è necessario seguire alcune regole di sintassi nello scrivere i commenti e il codice. Questo tipo di commento può essere utilizzato, ad esempio, prima di una classe, metodo o attributo per documentare il loro funzionamento. Possono anche essere inseriti dei tag HTML per facilitare la formattazione del documento.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3568,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "La documentazione viene salvata in un file .html contenente appunto tutti i commenti inseriti nel programma (abbinati alla riga in cui sono stati inseriti durante la scrittura del codice).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3456,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Con questo tipo di commento il sistema di documentazione di Java permette di generare automaticamente un documento in formato HTML, al cui interno viene descritto come si usa un programma o una classe indipendentemente dalla sua implementazione",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3483,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Javadoc estrae la documentazione dal codice java e dai commenti /** ...... */  \r\nscritti nel programma, e genera una serie di file .html (+ un .css e un file package-list). I file così generati possono essere aperti da un normale browser.\r\nContengono:\r\nLe classi o le interfacce pubbliche o protette;\r\nIn una classe, costruttori, metodi, attributi definiti come pubblici o protetti;\r\nClassi interne che hanno un nome;",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3557,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Contiene il commento, e il file non cambia",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3489,
          "asker": {
            "courseId": 4,
            "askerId": 487,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche che permettono di lanciare un eseguibile JAVA su un qualsiasi tipo di hardware o sistema operativo?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3531,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché quando si compila un programma in java, se poi il file bytecode che si ottiene è indipendente dalla piattaforma e viene eseguito nella JVM, bisogna comunque usare un compilatore diverso per ogni sistema operativo? (mi riferisco allo schema \"portability of java programs\")",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3500,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè utilizzare JAVA piuttosto che C\\C++?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3472,
          "asker": {
            "courseId": 4,
            "askerId": 445,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Trovo interessante l'introduzione di esempi in video online per facilitare lo studio e renderlo più leggero.\r\nE' stato detto a lezione che in java sono stati eliminati i puntatori con l'aggiunta di altri metodi per bypassarli, la mia domanda è: \"nel bypassare i puntatori non si ottengono dei metodi altrettanto complessi e facili da sbagliare?\"",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3469,
          "asker": {
            "courseId": 4,
            "askerId": 544,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il linguaggio Java permette di creare programmi portabili?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3458,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Una delle differenze tra \"Java\" e \"C/C++\" è l'inesistenza dell'operatore \"SIZEOF\". Per quale motivo il linguaggio \"Java\" non necessita di questo operatore?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3491,
          "asker": {
            "courseId": 4,
            "askerId": 443,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Come fa lo stesso programma Java a funzionare su più computer senza essere compilato per ogni piattaforma/sistema operativo?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3576,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 489,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Dopo che compilo un programma in Java, javac mi restituisce un file di \"bytecode\" che viene eseguito dalla jvm. Questo file viene eseguito correttamente da ogni sistema operativo fornito di jvm che fa da strato di adattamento fra la macchina e l'eseguibile. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3543,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 458,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un qualsiasi programma Java può funzionare su diverse piattaforme grazie all'utilizzo della JVM (Java Virtual Machine) che esegue i programmi tradotti nel linguaggio ByteCode dopo averli compilati una singola volta.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3457,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Java è un linguaggio detto multipiattaforma perché compila in linguaggio bytecode, un linguaggio simile all?assembly. Tale linguaggio ha la particolarità di essere eseguito mediante una macchina virtuale (JVM, Java Virtual Machine) immediatamente prima dell?esecuzione del programma. Questa dinamica di compilazione (al momento dell?esecuzione) permette di velocizzare i tempi di esecuzione e di rendere portabile il programma, che può essere quindi eseguito indifferentemente su qualunque piattaforma (da qui lo slogan ?Write once, run everywhere?).\r\nIn materia di portabilità però sono presenti alcune controversie. Infatti sebbene sia possibile scrivere programmi Java che si comportano molto bene su tutte le piattaforme, essi si appoggiano su macchine virtuali, che sono a loro volta programmi che contengono inevitabilmente bug. Da questo nasce la parodia dello slogan ?Write once, debug everywhere?.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3459,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Nel momento in cui un programma Java viene compilato non si ottiene un codice eseguibile (causa della non portabilità di altri linguaggi come C++), ma un bytecode ovvero una codifica intermedia indipendente dalla piattaforma su cui è stata creata ma non eseguibile di per se come i programmi compilati con altri linguaggi. Il bytecode deve essere eseguito da un ambiente di runtime chiamato Java Virtual Machine (o JVM) che deve essere presente nel sistema operativo, permette la complilazione e offre altri servizi necessari al programma. In questo modo, installando la JVM su differenti sistemi operativi si ottiene la possibilità di \"portare\" il bytecode senza bisogno di compilazioni differenti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3547,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 503,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In realtà il programma Java viene compilato dal compilatore javac contenuto nel JDK (Java Development Kit) diverso per ogni piattaforma (slide 11), il quale genera un bytecode eseguibile da qualsiasi piattaforma/sistema operativo grazie alla JVM (Java Virtual Machine).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3573,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 502,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Un programma java può funzionare su più computer in quanto viene utilizzato un linguaggio appositamente progettato per essere il più possibile 'neutro' e, quindi, indipendente dal sistema su cui verrà effettivamente eseguita l'applicazione. Ciò permette l'indipendenza dalla piattaforma hardware, in quanto il codice sorgente prodotto è lo stesso per ogni macchina, differendo soltanto per l'interprete.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3549,
          "asker": {
            "courseId": 4,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Indicare il significato degli acronimi \"JDK\" e \"JRE\" comprendendo differenze e funzionalità.",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3570,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 499,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "JDK= Java Development Kit.\r\nJRE= Java Runtime Environment.\r\nIl JDK è un ambiente di sviluppo, permette quindi sia di compilare che di eseguire un codice Java. Al suo interno contiene diversi strumenti tra cui java, javac e  javadoc.  Il JRE è invece un ambiente di esecuzione contenuto all'interno del JDK; serve solo per eseguire un codice java già scritto e non è possibile sviluppare con esso.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3494,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il JDK (Java Development Kit) è un ambiente di sviluppo che include tutti gli strumenti necessari alla scrittura, compilazione ed al debugging di applicazioni in Java. Il JDK contiene il JRE, insieme con il compilatore Java e librerie di programmazione occorrenti per lo sviluppo di programmi Java. Esso contiene tutti gli strumenti per la gestione di input/output utente, creazione e gestione di connessioni web, o per istanziare e gestire strutture dati complesse. Il JRE (Java Runtime Environment) è un ambiente di esecuzione per applicazioni scritte in linguaggio Java. Esso contiene la Java Virtual Machine, le librerie standard (API Java) e un launcher per le applicazioni Java, necessario per avviare i programmi scritti in linguaggio Java e già compilati in bytecode. Il JRE non costituisce un ambiente di sviluppo software e non contiene tool di sviluppo (compilatori e/o debugger). Per poter sviluppare in Java, a partire dal codice sorgente, è necessario il JDK.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3503,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "JRE sta per \"Java Runtime Environment\"; esso contiene la JVM e le librerie standard, che consentono l'esecuzione di programmi in java, ma non gli strumenti di sviluppo (ad esempio il compilatore); per questo motivo, possono essere eseguiti solo programmi già copilati, ovvero forniti in forma di file bytecode.\r\nJDK sta invece per \"Java Development Kit\"; esso contiene sia gli strumenti neccessari ad eseguire programmi precompilati (in questo senso il JDK contiene il JRE stesso), che gli strumenti atti allo sviluppo di programmi in java (compilatore, debugger, etc), consentendo la creazione e l'esecuzione di programmi a partire dal codice sorgente.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3485,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "JDK o Java Development Kit, è il principale ambiente di sviluppo per Java e consente al programmatore di creare un'applicazione fornendogli degli strumenti adatti alla sua realizzazione tra cui java(interprete del codice scritto), JavaDoc(documentazione), jar (gestore di applicazioni eseguibili direttamente), jdb(Debugger Java) e javac (crea il bytecode dal codice sorgente).\r\nJRE o Java Runtime Environment invece, è l'ambiente di esecuzione dei programmi scritti in Java e sfrutta la Java Virtual Machine per far girare i programmi già compilati in bytecode, inoltre contiene le API Java e il Launcher per le applicazioni.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3556,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 445,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "JDK è un acronimo che sta per Java Development Kit, JRE sta invece per Java Runtime Environment.\r\nLa JDK è una estensione della JRE e contiene al suo interno quest'ultima.\r\nLa JRE contiene al proprio interno, oltre al JVM, delle librerie di base e altre estensioni necessarie per poter eseguire applicazioni Java.\r\nLa JDK ha come aggiunta la possibilità di poter sviluppare delle nuove applicazioni Java.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3544,
          "asker": {
            "courseId": 4,
            "askerId": 501,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Garbage Collection?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3561,
          "asker": {
            "courseId": 4,
            "askerId": 524,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè un programma scritto in linguaggio java è eseguibile su più sistemi operativi (pur mantenendo la stessa sintassi all'interno del programma stesso)?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3481,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "La possibilità di garantire un esecuzione di un programma scritto in linguaggio java su più sistemi operativi è resa possibile grazie all'impiego del jvm (java virtual machine), componente facente parte della stessa piattaforma java, la cui funzione è quella di provvedere all'esecuzione di programmi tradotti in bytecode (linguaggio intermedio tra linguaggio macchina e linguaggio di programmazione) dopo una prima compilazione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3496,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 551,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Un programma scritto in Java può essere eseguito su sistemi operativi diversi tra loro senza essere modificato dato che, a differenza di linguaggi come C e C++, il codice non viene compilato direttamente in linguaggio macchina ma in uno pseudo assembly denominato \"bytecode\", che verrà poi interpretato da una macchina virtuale detta JVM (Java Virtual Machine). Questa macchina virtuale fa da intermediaria tra il sistema operativo ed il programma, astraendo quindi quest'ultimo dal contesto del primo.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3489,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perchè il programma viene compilato su una java virtual machine che utilizza gli stessi standard su qualsiasi sistema operativo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3526,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 567,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Un software di java è eseguibile su più sistemi operativi, in quanto esso viene eseguito da un software intermedio e non dal sistema operativo stesso.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3488,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 435,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Perché, a differenza del C e del C++, viene compilato in un file eseguibile in linguaggio ByteCode (indipendentemente dalla piattaforma sul quale viene compilato) che può essere poi eseguito grazie alla Java Virtual Machine (JVM) su qualsiasi sistema operativo. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3587,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 545,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il successo di Java risiede soprattutto nella propria portabilità su differenti sistemi operativi. Ciò è possibile grazie alla Macchina virutale Java, detta anche Java Virtual Machine o JVM, la quale è il componente della piattaforma Java che esegue i programmi tradotti in bytecode dopo una prima compilazione. Il bytecode è generalmente prodotto dalla compilazione di codici sorgenti (o file sorgenti) scritti in linguaggio Java e la JVM agisce da interprete del bytecode nei diversi sitemi operativi; non a caso lo \"slogan\" di Java è \"Write once, run everywhere!\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3485,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Durante la lezione si e' parlato di una Java Virtual Machine fisica, un processore il cui assembler e' il bytecode: in che occasioni si preferisce eseguire Java su queste macchine fisiche anziché su una macchina virtuale?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3509,
          "asker": {
            "courseId": 4,
            "askerId": 531,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Come possono programmi scritti in Java posso essere eseguiti su qualsiasi O.S.?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3447,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 454,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un programma scritto in Java  può essere eseguito in qualsiasi sistema operativo grazie alla JVM, \r\nJava Virtual Machine, una macchina virtuale (software) che interpreta il bytecode, prodotto dalla compilazione del codice sorgente scritto in linguaggio Java. \r\nPer questa proprietà, si parla di portabilità del linguaggio Java.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3508,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 430,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "L'esecuzione dei programmi java in bytecode non viene effettuata dal S.O. ma da un programma di tipo macchina virtuale (JVM) scritto ad hoc per ogni sistema. Jav infatti fornisce un'interfaccia di API platform-independent.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3560,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 429,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Un classico compilatore (ad esempio per un codice in C++) genera un file eseguibile in base al Sistema Operarativo in cui ci si trova e tale file può essere eseguito solo su Sistemi Operativi analoghi. Ad esempio un eseguibile per Windows non girerà su Mac. In Java, all'atto della compilazione invece viene generato il cosiddetto BYTECODE che è identico per tutti i sistemi operativi. Questo file eseguibile non viene però eseguito direttamente dal sistema operativo ma da un \"sistema virtuale\" chiamato Java virtual machine che deve essere precedentemente installato sul pc. È proprio grazie a questa macchina virtuale che si comporta allo stesso modo su tutti i Sistemi Operarivi che gli eseguibili di un codice in Java possono funzionare su tutte le macchine.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3572,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 521,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "La portabilità dei programmi dipende essenzialmente dal linguaggio di programmazione usato. Alcuni linguaggi non si possono considerare portabili (ovvero non consentono la scrittura di programmi portabili) per il semplice motivo che per alcuni ambienti non esiste un interprete o compilatore del linguaggio; oppure perché i compilatori o interpreti disponibili in diversi ambienti presentano alcune differenze più o meno sottili relativamente alla sintassi che accettano o alla semantica che attribuiscono ad alcuni costrutti;\r\nLa piattaforma java ha come caratteristica il fatto di rendere possibile la scrittura e l'esecuzione di applicazioni che siano indipendenti dall'hardware sul quale poi sono eseguite che risulta così virtualizzato dalla piattaforma stessa. In altri termini la piattaforma Java, grazie alla presenza della 'macchina virtuale' è quella che rende il linguaggio java e i relativi programmi portabili su piattaforme hardware diverse.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3548,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "java si basa su un altro software chiamato java virtual machine che emula i programmi java. in questo modo, purche la jvm sia installata sul pc ogni programma java può funzionare. l'unica differenza è che la jvm cambia in base a OS e a componenti hardware. ovviamente un programma java è più lento di altri linguaggi(di circa 1,5 %) perche la jvm deve consumare cpu e ram per emulare ogni programma java",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3523,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 575,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Attraverso la JVM, una macchina simulata che può essere installata su qualsiasi OS e interpreta il bytecode prodotto dal compilatore legato al particolare OS",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3520,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 540,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "I programmi scritti in Java godono di portabilità, ovvero possono essere eseguiti su qualsiasi sistema operativo su cui sia stata installata la Java Virtual Machine (JVM).\r\nLa JVM infatti interpreta il bytecode, ovvero il codice oggetto prodotto dal compilatore, e permette di eseguire tali programmi su qualsiasi macchina garantendo inoltre la portabilità dei tipi di dati (machine independent).\r\nInoltre Java rende possibile l'inserimento di piccoli programmi Java (applet) all'interno di pagine Web destinate a essere visualizzate da diversi browser (Java enabled) in esecuzione su macchine completamente diverse.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3558,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Che vantaggi ha Java rispetto a Python partendo dal presupposto che:\r\n- sono entrambi linguaggi multipiattaforma\r\n- entrambi supportano la programmazione ad oggetti\r\n- Python ha una sintassi estremamente semplice",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 4,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3456,
          "asker": {
            "courseId": 4,
            "askerId": 442,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Ho qualche piccola difficoltà con eclipse, se si chiude una delle finestre come ad esempio il debugger poi per riaprirla devo ogni volta riavviare il programma o  (come immagino) c'è qualche comando comodo?Grazie",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3538,
          "asker": {
            "courseId": 4,
            "askerId": 521,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare java rispetto a C++ e quali gli svantaggi?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3471,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega il significato della frase 'write one, run everywhere'.",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3555,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una Java Virtual Machine ?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3556,
          "asker": {
            "courseId": 4,
            "askerId": 489,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché l'operatore sizeof è pleonastico ed è quindi soppresso?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3480,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "La risposta a questa domanda va ricercata nel metodo di compilazione dei sorgenti Java.\r\nUn normale linguaggio di programmazione (come C/C++) viene compilato in modo differente in base al tipo di macchina su cui si sta lavorando, per questo motivo l'implementazione dei vari tipi di dato può non essere sempre la stessa (per esempio un intero potrebbe occupare 4 byte se compilato per una macchina a 32 bit, mentre occuperebbe 8 bit se compilato per una macchina a 64 bit). Java invece viene compilato in un bytecode che è comune a qualsiasi architettura hardware e piattaforma software e così le caratteristiche dei vari tipi di dato rimangono sempre le stesse. Nel nostro caso l'operatore sizeof diventa inutile in quanto la dimensione occupata in memoria dai vari tipi di dati sono standardizzati e si posso trovare nelle guide di riferimento di Java.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3473,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "L'operatore sizeof() del c/c++ è detto pleonastico, e quindi superfluo, in quanto in Java l'operatore non è abilitato alla gestione della memoria per questioni pratiche come l'esemplificazione della sintassi, della mantenibilità e della comprensibilità del codice.\r\nQuesto è possibile grazie a una routine di sistema chiamata garbage collector (raccoglitore della spazzatura) che l'interprete usa per evitare di avere ingenti memory leak all'interno dei nostri programmi, essa infatti tiene traccia delle allocazioni di memoria e le dealloca solo quando sono effettivamente inutilizzate, questo porta java ad essere un attimo meno efficente rispetto al c/c++ ma molto più semplice da utilizzare. :)",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3449,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Si dice che l'operatore sizeof è pleonastico, ovvero superfluo, perchè in Java le dimensioni dei tipi fondamentali (dunque integer, char, ecc...) sono fissate, dunque non è necessario usare un operatore per conoscerne le dimensioni.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3555,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 459,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "perchè in java non serviva e dunque sarebbe stato come \"ridondante\" ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3540,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore sizeof non viene utilizzato perché tutte le dimensioni dei tipi in Java sono prefissate, mentre in C e C++ alcuni tipi non avevano una dimensione fissa (per esempio il tipo unsigned). In C e C++ serviva inoltre per sapere la dimensione di dati allocati sulla memoria, mentre in Java è superfluo in quanto di ciò si occupa la garbage collection.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3496,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Da cosa è dovuta l'esplosione di Java tra i linguaggi di programmazione pochi anni dopo la sua nascita?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3454,
          "asker": {
            "courseId": 4,
            "askerId": 425,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le maggiori differenze tra il linguaggio di programmazione Java ed il linguaggio di programmazione C?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3464,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "che differenza c'è tra gli API e le librerie di java?Inoltre dove è possibile trovare le guide (come mostrato a pagina 40/44) del contenuto delle varie librerie?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3566,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 439,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "API e librerie sono fondamentalmente la stessa cosa. Il resto della domanda non è del tutto chiaro e contiene rifermenti non precisati!",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3487,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 518,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "In linea generale le API e sono delle interfacce che ti permettono un livello di astrazione più alto, in soldoni puoi preoccuperti meno di cambiare quel bit rispetto all'altro per raggiungere un determinato risultato. Sono degli utili strumenti se si vuole lavorare per creare applicativi che usano un perticolare srevizio(google maps, facebook ecc...)e anche,come nel nostro caso, per dialogare con il sistema operativo in questione. Le librerie di java sono le API del linguaggio di programmazione (contengono per esempio le classi stringa,ecc...) quindi in sostanza sono la stessa cosa.\r\n(la seconda domanda non sarebbe lecita, ma rispondo ugualmente)cerca in internet, ci sono tonnellate di esempi e spiegazioni a patto che tu riesca a masticare un pò di inglese.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3528,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 428,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Le librerie sono generici insiemi di funzioni, mentre le API sono delle interfacce di programmazione che facilitano il ruolo del programmatore.\r\nSe si usa la libreria, ci si può interfacciare con la stessa attraverso le chiamate ai metodi. L'API invece, contiene tutto quello che serve per potersi interfacciare con la libreria, per poterla usare, senza che sia necessario sapere come, chi l?ha pensata, l'ha scritta. \r\n\r\nJava possiede un?enorme libreria di classi standard organizzata in vari package che raccolgono le classi secondo un?organizzazione basata sul campo di utilizzo.\r\nI numerosi package del linguaggio sono descritti nelle guide in linea del JDK.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3541,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Una API è un'interfaccia di programmazione delle applicazioni che definisce le modalità con cui un programma richiede i servizi dalle librerie, mentre quest'ultime sono un'insieme di funzioni o strutture dati fatte apposta per essere implementate in un programma. In sostanza sono delle righe di codice già pronte che possono essere usate dal programmatore al posto di riscrivere il codice che permette di eseguire una tale funzione.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3588,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 496,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Un API permette di interfacciare piu parti software, mentre una libreria è un insieme di funzioni",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3508,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "C'è una persona in particolare che è considerata l'inventore di Java?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 4,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3514,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 80,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i punti di forza di Java rispetto ai linguaggi precedenti?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3486,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Sin dal principio Java nacque con l'intento di semplificare e togliere i principali problemi che affliggevano gli altri linguaggi di programmazione, per primo il più diffuso C++. Alcuni miglioramenti furono la velocità nello scrivere codice (usando costrutti e metodi più elaborati, a discapito della velocità di esecuzione), l' eliminazione della possibilità di far comunicare direttamente memoria e programmatore (puntatori), e l' invenzione del Garbage Collector che deallocava automaticamente la memoria inutile senza causare memory leaks.\r\nTuttavia il vero punto di forza di Java fu la portabilità delle sue applicazioni, soprattutto sul Web. Con l'esplosione di Internet i vecchi linguaggi dovevano compilare il proprio sorgente in modi specifici (Linux, Mac OS, Windows) per rendere l'applicazione utilizzabile. Java introdusse il proprio interprete, detto Java Virtual Machine, in ogni software che interpretava lo stesso eseguibile chiamato ByteCode, divenendo Platform Independent.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3500,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Uno fra i principali punti di forza di Java è il seguente: una volta compilato il file sorgente, utilizzando la Java Virtual Machine, l'applicativo può essere eseguito su macchine aventi sistema Windows, Machintosh o Linux, cosa che non si poteva effettuare con i linguaggi C e C++. La Java Virtual Machine è un software che compie principalmente un ruolo di interprete del codice compilato. \r\nAltro pregio del linguaggio Java è quello di essere più semplice rispetto ad altri lignaggi (es. C++) per quanto riguarda la programmazione ad oggetti: non è presente l'aritmetica dei puntatori come in C o C++. Questo conferisce al linguaggio Java una facilità di apprendimento.\r\nPer quanto riguarda la sicurezza Java riscontra un altro punto di forza in quanto in esso la memoria non viene gestita dall'utente, quindi non ci sarà più il pericolo di andare a scrivere in celle di memoria sbagliate sovrascrivendo magari dati importanti.\r\n ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3529,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 580,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Java grazie alla sua Java virtual machine integrata era in grado di riuscire a scrivere un programma e compilarlo su tutti i sistemi operativi in modo uguale. Quando si compila un programma in Java viene creato un file eseguibile uguale sia in windows che in MacOs che in linux. Con i linguaggi precedenti per ogni sistema operativo veniva creato un file eseguibile diverso e quindi incompatibile tra computer con sistemi operativi diversi",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3550,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 481,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "I punti di forza di Java nei confronti dei linguaggi precedenti sono :\r\n-L'eliminazione dei puntatori e la conseguente riduzione degli errori possibili, resa possibile dal Garbage Collector;\r\n-La trasportabilità, infatti java è stato inteso come linguaggio di programmazione che si potesse utilizzare in qualsiasi sistema operativo senza variazioni grazie alla Java Virtual Machine\r\n-E' simile come sintassi al C e al C++;\r\n-Esiste il tipo stringa;\r\n-E' un linguaggio ad oggetti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3569,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 526,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "I punti di forza di Java sono molteplici: maggiore portabilità a livello di sistemi operativi differenti, abolizione del formalismo dei puntatori,introduzione del concetto di programmazione ad oggetti orientata, maggiore robustezza rispetto al linguaggio C e sintassi molto simile a quella del linguaggio C.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3559,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "I principali punti di forza di Java derivano dalle necessità a cui è chiamato a rispondere:\r\n1)\tProgrammazione ad oggetti\r\nLe classi sono modelli astratti caratterizzati da specifiche definite a priori. Questo comporta un maggior livello di ASTRAZIONE  che facilita la MODULARITA' e il RIUSO DEL CODICE;\r\n2)\tPORTABILITA'\r\nJava è in grado di operare in diversi ambienti grazie all?introduzione della Java Virtual Machine ( JVM ). Una prima compilazione non genera l?eseguibile bensì il byte code di cui la JVM è destinataria.L'aumento dei tempi di esecuzione è trascurabile nella maggior parte dei casi.\r\nConfrontando Java con i linguaggi di programmazione ad esso più vicini C e C++ si nota inoltre una maggiore ROBUSTEZZA dovuta soprattutto ad una nuova gestione della memoria (garbage collection) e alla conseguente ELIMINAZIONE DEI PUNTATORI, l?INTRODUZIONE DI UN LINGUAGGIO OBJECT-ORIENTED e di una GERARCHIA TRA CLASSI. Java risulta, quindi, un linguaggio più FACILE  e USER-FRIENDLY.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3501,
              "task": {
                "taskId": 83,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il principale punto di forza di Java è la potabilità, cioè la possibilità di ottenere, indipendentemente dalla macchina sul quale viene compilato il file sorgente, lo stesso eseguibile e di poterlo usare su qualunque computer con installato una Java Virtual Machine. Inoltre, Java toglie una caratteristica del C fonte di innumerevoli errori, i puntatori, e introduce il garbage collector, un meccanismo che tiene traccia delle locazioni di memoria utilizzate e libera quelle non più necessarie. Infine, grazie alla semplificazione del linguaggio, i tempi di sviluppo di un software sono relativamente ridotti.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        }
      ]
    },
    {
      "lectureId": 47,
      "lectureTitle": "Generics, Anonymous inner classes, static",
      "questions": [
        {
          "questionId": 4355,
          "asker": {
            "courseId": 4,
            "askerId": 568,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il vantaggio di usare generics?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4458,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Si illustri il funzionamento del metodo CLONE.",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": "cloneable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4466,
          "asker": {
            "courseId": 4,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi di un codice che usa i generics rispetto ad uno che non li usa?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4404,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa a creare un array di tipo generico?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4400,
          "asker": {
            "courseId": 4,
            "askerId": 590,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire il significato di: final, static, private, public e sottolineare le differenze dove possibile",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Final"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4413,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Ag",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4468,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 425,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Final:rendere impossibile la reinizializzazione dopo che la variabile è stata inizializzata con un valore esplicito.\r\nStatic: Rende la variabile/il metodo di classe e non più d'istanza.\r\nPrivate: Rende la variabile/il metodo visibile solo all'interno della classe stessa.\r\nPublic: Rende la variabile/il metodo visibile a tutte le altre classi.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4445,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "final: definisce un oggetto/metodo come costante, o sia che non può essere modificato all'interno del programma, ma può solo essere letto./eseguito\r\nstatic: definisce un oggetto/metodo comune a tutte le istanze di una classe.\r\nprivate: definisce un oggetto/metodo privato ossia che non può essere utilizzato/modificato da altre classi tranne quella in cui è stato creato.\r\npublic: definisce un oggetto/metodo pubblico ossia che può essere utilizzato/modificato da altre classi.\r\nN.B. esiste anche il tipo \"protected\" che definisce un oggetto/metodo che può essere utilizzato/modificato solo dalla classe e dalle sottoclassi in cui è definito.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4449,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Con l'utilizzo di \"final\" si definiscono le costanti in java; il modificatore \"static\" si utilizza invece per \"specializzare\" metodi e proprietà di una classe, facendo ciò essi si legano alla classe stessa e non alle sue istanze e per esempio nel caso modificassimo una proprietà di classe anche le sue istanze vedranno tale proprietà modificata; \"private\" e \"public\" servono invece per definire lo \"scope\" di un determinato attributo (variabile, metodo o classe) rendendolo visibile o meno in differenti parti del programma.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4384,
          "asker": {
            "courseId": 4,
            "askerId": 426,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per anonymous inner classes?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "anonymous"
            },
            {
              "keyword": "class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4369,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi comporta usare i generics?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vantaggi"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4385,
          "asker": {
            "courseId": 4,
            "askerId": 552,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra una Collection istanziata normalmente e una Collection<String> e a quale altro oggetto verrà applicato lo \"<String>\" per poter utilizzare la Collection. Un bacione alla mamma, California.\r\nPraise The Sun.\r\n\\ &#928; /\r\n |* | \r\n  ||",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 2,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": "Generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4428,
          "asker": {
            "courseId": 4,
            "askerId": 592,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è stato introdotto il concetto dei generics nella programmazione ad oggetti, in altre parole a cosa serve ed quali sono i suoi svantaggi, sempre che ce ne siano?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tipi"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4459,
          "asker": {
            "courseId": 4,
            "askerId": 521,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa servi finalize quando dichiariamo un metodo o una variabile tale??",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "finalize"
            },
            {
              "keyword": "variabile"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4448,
          "asker": {
            "courseId": 4,
            "askerId": 517,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perche i metodi possono essere richiamati senza creare una istanza nel caso di static?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "metodi"
            },
            {
              "keyword": " richiamati"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4415,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 590,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "I metodi static sono richiamabili anche se non è stato istanziato l'oggetto, il perchè è dato dalla strutturazione del compilatore",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4440,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Perchè se dichiaro una classe static i suoi metodi sono richiamabili solamente usando Classe.metodo senzal'istanziazione: sono metodi che non sono associati ad un oggetto ma voglio che siano disponibili a tutti i programmi che usano la classe",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4421,
          "asker": {
            "courseId": 4,
            "askerId": 497,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste (brevemente) la \"clonazione\"?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clonazione"
            },
            {
              "keyword": " cloni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4414,
          "asker": {
            "courseId": 4,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è java",
          "totalDifficultyLevel": 1,
          "totalInterestingnessLevel": 1,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " linguaggio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4456,
          "asker": {
            "courseId": 4,
            "askerId": 463,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Posso definire una classe con due(o più) generics? ",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4393,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 551,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "E' possibile definire una classe con generics multipli separando con una virgola i diversi generics all'interno dei brackets.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4450,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione delle Anonymous Classes?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Anonymous"
            },
            {
              "keyword": " Classes"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4393,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché i metodi statici possono agire solo su variabili statiche e non d'istanza?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " metodi"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " istanza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4401,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale occasione può risultare più conveniente utilizzare un Listener esterno anziché un Listener interno anonimo? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " ascoltatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4407,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali utilizzi ha la keyword static ?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": "anonymus"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4440,
          "asker": {
            "courseId": 4,
            "askerId": 440,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché viene utilizzato l'operatore static con la funzione main?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "main"
            },
            {
              "keyword": "static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4463,
          "asker": {
            "courseId": 4,
            "askerId": 477,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra una classe interna statica ed una non statica?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "statica"
            },
            {
              "keyword": " anonima"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4427,
          "asker": {
            "courseId": 4,
            "askerId": 554,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi di usare un metodo static?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodo"
            },
            {
              "keyword": "static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4422,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Illustrare i due metodi per colorare uno sfondo interno e esterno in una classe.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Metodi"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " interno"
            },
            {
              "keyword": " esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4435,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "perchè il main è static?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4425,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il vantaggio dei Generics?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4464,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nella slide 11 non posso scrive P p2=p1.clone() ?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4432,
          "asker": {
            "courseId": 4,
            "askerId": 567,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il metodo main deve essere definito static?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4382,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo non è possibile allocare un array di tipo generico?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4457,
          "asker": {
            "courseId": 4,
            "askerId": 593,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual é lo scopo dell autoboxing?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4461,
          "asker": {
            "courseId": 4,
            "askerId": 555,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale effetto ha la dichiarazione static di una variabile? E la dichiarazione static di un metodo?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " variabile"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4379,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "che cos'e il \"bootstrap\"?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4403,
          "asker": {
            "courseId": 4,
            "askerId": 448,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché se un metodo di istanza modifica una variabile statica il compilatore genera un warning?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " compiler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4409,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Perché una variabile statica è condivisa da tutte le istanze della classe. Se viene modificata in un'istanza sarà automaticamente modificata per tutte le istanze di quella classe. Quindi, in tutta la classe, perdi il ''valore statico'' perché lo rimpiazzi con quello modificato. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4427,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Una variabile viene definita statica per dire che quella variabile è associata alla classe e non ad un oggetto che viene creato. Quindi dichiarando una variabile o un metodo static, questi vengono definiti come comuni a tutte le istanze di quella classe. Inoltre si possono richiamare senza istanziare le classe.\r\n\r\nEs:\r\n\r\npublic class ciao{ public static int n = 10; }\r\n\r\nnel main:\r\n\r\nciao ciao1 = new ciao();\r\nciao ciao2 = new ciao();\r\nciao1.n = 20;\r\n\r\nprintln.out(ciao1.n + \" \" + ciao2.n);\r\n\r\nstamperà 20 20. Come già detto essendo comune a tutte le istanze della classe anche ciao2 verrà modificato. Come avrai capito il warning serve a comunicarti che non stai modificando solo una istanza ma tutte le istanze di quella determinata classe. Se ti da fastidio puoi usare @SupressWarning :D",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4431,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "perchè è un eccezione che il sistema gestisce di sua iniziativa essendo le variabili statiche parte dello stack e non modificabili dall'utente una volta che sono già state dichiarate e istanziate.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4485,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 521,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "I metodi d'istanza possono accedere alle variabili d'istanza direttamente, così come alle classi di variabili e i metodi di classe possono accedere direttamente alle variabili di classe. \r\nI metodi di classe possono accedere alle variabili d'istanza o ai metodi d'istanza solamente usando una referenza. Inoltre solamente i metodi static possono cambiare una variabile statica.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4387,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Perche i metodi d'istanza si applicano a oggetti singoli mentre static é pensato per condividere una variabile in tutta la classe. Se mi metti mi piace ti offro un coffea.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4368,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra listener interno, interno anonimo e self listener?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4424,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il listener interno, molto semplicemente, è una classe all'interno di una altra classe, ad esempio un Frame con dei bottoni, che implementa l'interfaccia che vorremo utilizzare in relazione al tipo di listener che ci occorre (nel esempio seguente un listener di bottoni e quindi Action Listener)\r\nesempio:\r\npublic class MyFrame {\r\n        private class MyButtonListener implements ActionListener {\r\n                public void actionPerformed(ActionEvent evt) {//codice da eseguire}\r\n        }\r\n}\r\nPer quel che riguarda il listener interno anonimo è un particolare tipo di listener che viene dichiarato e definito all'interno dell'argomento della chiamata a funzione addListener();\r\nesempio:\r\nb1.addActionListener(\r\n            new ActionListener() {\r\n                public void actionPerformed(ActionEvent e) {\r\n                    // codice da eseguire\r\n                }\r\n            }\r\n\r\n         ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4465,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 448,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il listener interno consiste in una classe che implementa l'interfaccia EventHandler all'interno della classe dell'applicazione, la quale sarà istanziata per esempio nel costruttore dell'applicazione.\r\nIl listener anonimo permette di istanziare una classe che implementa EventHandler defindola simultaneamente. Questo permette di non dover creare una classe separata nel codice ma di contro ha che non può essere istanziata più di una volta (a meno di ridefinizione).\r\nIl self listener consiste nel far implementare EventHandler alla classe dell'applicazione, molto dispendioso in generale.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4439,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Si parla di Listener interno quando viene definita una classe Listener, che implementa l'interfaccia EventHandler, all'interno dello scope della classe che ne farà uso. Se, invece di definire esplicitamente una classe Listener, si definisce, sempre all'interno della classe, una variabile di tipo EventHandler e, al momento dell'istanziazione, si specifica l'implementazione del metodo handle(Event e), si ottiene un listener interno anonimo; in alternativa, è possibile omettere la dichiarazione della variabile, e passare l'implementazione dell'EventHandler direttamente al metodo addEventHandler della componente a cui lo si vuole associare. Infine, si parla di self listener quando è la classe principale dell'applicazione ad implemetare l'interfaccia EventHanler e il metodo handle; in questo caso, al metodo addEventHandler si passa come ascoltatore la classe this. In tutti i tre casi, l'ascoltatore può accedere a variabili e metodi della classe Applicazione, secondo le regole dello scope.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4419,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Il listener interno definisce una classe all'interno del codice che usa il listener.\r\n\r\nIl listener anonimo non da un nome alla classe, è il più veloce da usare e dal punto di vista della leggibilità si capisce subito che operazioni sono associate all'evento.\r\n\r\nIl self listener consiste nell'estendere la classe con cui si lavora a Eventhandler",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4373,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi ci sono nell'uso dei tipi Generics?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4354,
          "asker": {
            "courseId": 4,
            "askerId": 575,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli svantaggi di usare un SelfListener?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "SelfListener"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4441,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Che problema si riscontra nel creare un generic array?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4446,
          "asker": {
            "courseId": 4,
            "askerId": 500,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli svantaggi nell'usare un listener interno anonimo?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " Listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4431,
          "asker": {
            "courseId": 4,
            "askerId": 559,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è utile usare i generici invece della classe object? Es: collezioni di oggetti generici (T) invece di oggetti object.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generici"
            },
            {
              "keyword": "object"
            },
            {
              "keyword": "T"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4392,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per una maggiore velocita di lettura del codice e per evitare di avere una collisione con degli oggetti ti tipo object",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4487,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Usare riferimenti ad object potrebbe sembrare un'ottima (e soprattutto più semplice) alternativa ai generics, tuttavia, sebbene superficialmente potrebbe funzionare, porta con se diversi svantaggi.\r\nIndicare un oggetto come object è come \"dire tutto e non dire niente\" allo stesso tempo. Con un riferimento di tipo object possiamo si indicare qualunque tipo di oggetto (poiché tutte le classi ereditano da Object), ma ne perdiamo pure il controllo, non avendo più un controllo sui tipi.\r\nAd esempio una collection di object potrebbe contenere qualsiasi cosa, int, string, oggetti, ecc e pure mischiati tra loro. Utilizzando i generics invece non si corre questo rischio.\r\nQuesto genere di errori (dovuti al particolare polimorfismo di object) vengono rilevati solo a runtime, poiché il compilatore non è in grado di fare controlli sugli oggetti realmente referenziati da riferimenti object.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4396,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "E' utile utilizzare i generici per creare dei vincoli sul tipo di oggetti che si stanno usando",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4461,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Perché questo meccanisco consente a compile time di controllare soltanto il tipo indicato tra <>. Per esempio nelle collezioni questa tecnica è molto utilizzata perché si specifica il tipo di dato che potrà contenere e dunque appena un oggetto inserito non è dello stesso tipo specificato verrà notificato un errore e consente un controllo più efficiente e quindi una correzione più rapida degli eventuali errori di scrittura del codice",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4433,
          "asker": {
            "courseId": 4,
            "askerId": 478,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi è meglio preferire un listener esterno anzichè quello interno o interno anonimo?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " anonymous inner class"
            },
            {
              "keyword": " inner class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4467,
          "asker": {
            "courseId": 4,
            "askerId": 581,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Che tipi di listener abbiamo visto a lezione?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4445,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "A quale scopo viene utilizzata una variabile (o metodo) statica?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "condivisa"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4378,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "perchè il metodo main deve essere dichiarato statico?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4429,
          "asker": {
            "courseId": 4,
            "askerId": 434,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Un listener anonimo, interno o esterno sono uguali dal punto di vista delle prestazioni?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 3,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " prestazioni"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4408,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Java è lento, usa c++  se vuoi le prestazioni",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4481,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "si, potrebbe variare la velocità di creazione del bytecode ma, una volta che quest'ultimo è stato creato, la velocità è uguale",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4399,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Allora, se li implementi con lo stesso \"codice\" allora non dovresti trovare differenze, il listener interno ed esterno sono però più comodi se devi maneggiare degli eventi che si ripetono nella tua applicazione (es. bottoni con funzioni simili o uguali) invece il listener anonimo è utile quando devi implementare un handle di un evento specifico che altrimenti sarebbe troppo lungo da trasformare in classe interna o esterna.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4460,
          "asker": {
            "courseId": 4,
            "askerId": 576,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è necessario utilizzate variabili di tipo static?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4438,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 495,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Quando, nella progettazione di una classe, si ritiene necessario inserire delle caratteristiche che non dipendano dalle singole istanze, ma che siano uniche per tutta la classe. Possono servire, ad esempio, per tenere conto delle istanze di una certa classe (con gli accorgimenti del caso: aumentare il contatore col costruttore o diminuirlo in certe situazioni). Possono inoltre servire come variabili/metodi di \"libreria\", richiamando NomeClasse.metodoStatic per usarle.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4483,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Le variabili o metodi di tipo static sono costrutti che riguardano la classe in cui risiedono e non l'oggetto. A differenza dei costrutti tradizionali che possono essere letti/modificati soltanto da istanze (ovvero oggetti) i costrutti statici possono essere referenziati in un contesto dove non sono presenti istanze, appunto detto statico (come ad esempio il main, metodo che viene eseguito anche quando la classe non viene istanziata)\r\nIn altre parole, se una classe A ha attibuti o metodi statici pubblici è possibile accedervi senza dichiarare un oggetto di tipo A ma accedendo direttamente tramite A.<variabile> o A.<metodo>. Caratteristica importante delle variabili static è che una volta modificate vengono ovviamente modificate per tutte le entità del programma, essendo condivise in maniera analoga alle variabii globali.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4407,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "...",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4417,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Dichiarare una variabile come \"statica\" corrisponde a rendere quella determinata variabile comune a tutte le istanze della classe.\r\nLe variabili static quindi si possono utilizzare ogniqualvolta è necessario o comunque si vuole che un'unica variabile globale sia visibile e modificabile da tutte le classi che sono state istanziate.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4411,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Se dichiariamo una variabile di tipo static avremo come risultato la definizione di una variabile globale accessibile a tutte le istanze di una classe. Quindi quando avrò bisogno di una variabile che sia accessibile in tutte le istanze di una classe la definirò di tipo static",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4418,
          "asker": {
            "courseId": 4,
            "askerId": 442,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "una variabile definita static è modificabile da una sottoclasse della classe main? e da una classe \"figlia\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4455,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Da dove nasce il fatto che il main viene definito come static?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4358,
          "asker": {
            "courseId": 4,
            "askerId": 430,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è possibile definire, in una classe generica con arg. di tipo T, un array di tipo T?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4377,
          "asker": {
            "courseId": 4,
            "askerId": 457,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos' è una clonazione e come si può implementarla? ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clonazione"
            },
            {
              "keyword": " implementare"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4388,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il main va dichiarato \"static\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4409,
          "asker": {
            "courseId": 4,
            "askerId": 456,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo il metodo main è dichiarato con il modificatore static?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4410,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa è una struct",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Anonymous"
            },
            {
              "keyword": " inner"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4416,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "perchè il metodo main va dichiarato static? essendo static non dovrebbe aver accesso alle variabili non static?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4383,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la ragione principale per cui in Java sono stati introdotti i Generics?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "cast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4452,
          "asker": {
            "courseId": 4,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché l'uso di Generics è utile e ti evita di fare errori?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4390,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile gestire delle forme o oggetti disegnati su un canvas in modo da poter permettere al calcolatore di riconoscerle in seguito(per esempio per cambiarne il colore,la grandezza ecc ecc)?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "canvas"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4394,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è conveniente usare un listener interno anonimo rispetto a uno interno ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": "yolo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4390,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "È conveniente usare un listener interno anonimo, piuttosto che uno interno, quando non si ha la necessità di dichiarare una variabile evento e quindi quando non si vuole sprecare memoria per utilizzare una volta sola un evento.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4404,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Un listener interno anonimo secondo me è molto piu comodo e sbrigativo in quanto puoi fare tutto in modo breve e veloce mentre è piu comodo farne uno interno se devo creare piu eventi e quindi li metto tutti in una classe ascoltatore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4470,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Poichè così non serve creare una classe listener e perchè conosce tutti gli oggetti dentro la funzione start.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4472,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 585,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Quando il codice è complicato e l'utilizzo di classi interne renderebbe meno scorrevole e flessibile la lettura del codice stesso... le classi interne anonime, invece, permettono di implementare un codice complesso e dettagliato senza troppi problemi!",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4477,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Ricorrere ai listener interni anonimi può risultare utile se, all'interno di un programma, si utilizzano diversi bottoni o controlli, a ciascuno dei quali si vuole associare un listener diverso. In tal caso, invece di definire per ciascuno di essi una classe (in una sede separata), da impiegare poi di fatto una volta sola, può essere conveniente definire il listener direttamente dove viene utilizzato (addirittura senza dargli un nome - da qui l'appellativo \"anonimo\"), dato che non vi è necessità di riutilizzare quella parte di codice. Questa pratica (se diligentemente usata) rende il codice più leggibile e aumenta la velocità di scrittura del codice stesso, ma non rispecchia appieno la filosofia della programmazione ad oggetti: ad esempio, nel caso in cui uno stesso listener venga usato più volte, è sconsigliato definirlo ogni volta come listener interno anonimo. È buona norma definire un listener (interno), da richiamare di volta in volta.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4406,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il problema dell'uso di generic <T> coi vettori ?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": "vettori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4469,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 558,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "¡Il problema dell'uso di generic <T> coi vettori è che può creare un errore di tipo \"type safe\"!",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4397,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Che non puoi avere vettori generici.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4456,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 581,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Perché gli elementi sono in realtà Object mascherati da T, ed è consigliato mantenere all'interno della classe questo stratagemma.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4443,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 480,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il principale problema che nasce dall'uso dei vettori associati a generics è dato dal fatto che non è possibile creare un vettore di tipo T (con T tipo associato alla classe generica). Questo è dovuto al fatto che il vettore è intrinsecamente legato al tipo di variabile di cui viene dichiarato, infatti, essendo allocato in stack, esso consiste in una serie di n celle di dimensione sizeof T (con n dimensione del vettore e tipo T).\r\nNon essendo noto a priori il tipo T, il compilatore non è in grado di allocare la memoria necessaria in quanto incognita in fase di compilazione, e, per questo, viene generato un errore.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4458,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 440,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un generics è uno strumento che permette la definizione di un tipo parametrizzato, che viene esplicitato successivamente in fase di compilazione secondo le necessità; i generics permettono di definire delle astrazioni sui tipi di dati definiti nel linguaggio.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4374,
          "asker": {
            "courseId": 4,
            "askerId": 523,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve una funzione statica e come la possiamo usare fuori dalla classe a cui appartiene?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4420,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 504,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Un metodo static è dichiarato tale per essere usato da tutti quelli a conoscenza della sua classe senza dover per forza istanziarla(come se fossero delle operazioni basi, vedi System e Math), di solito viene scritto quando è l'unica cosa che si vuol far conoscere della classe verso l'esterno. Per chiamare un metodo static basta semplicemente aggiungere al nome della funzione il nome della classe: NomeClasse.metodo(); ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4410,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "La funzione principale delle funzioni definite statiche è quella di andare a lavorare, senza il bisogno di creare un istanza della classe, sulle variabili di classe, ovvero quella variabili definite statiche che diventano condivise da tutte le istanze della classe. La chiamata della funzione infatti diviene \"NomeClasse.NomeMetodo\" così da essere legata esclusivamente alla classe. Questo escamotage è utilizzato ad esempio per il metodo main che non deve agire su un'istanza. Ciò è necessario perchè in java ogni funzione deve essere contenuta in una classe.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4444,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano e a cosa servono gli operatori \"<>\"?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "operatori"
            },
            {
              "keyword": " <"
            },
            {
              "keyword": " >"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4419,
          "asker": {
            "courseId": 4,
            "askerId": 519,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando di funzioni static, quali differenze troviamo tra Java e C++?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 1,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " funzioni"
            },
            {
              "keyword": " C++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4391,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il main è ?static??",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "main"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4372,
          "asker": {
            "courseId": 4,
            "askerId": 483,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo un metodo dichiarato static non può fare riferimento a variabili non statiche?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": "metodo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4436,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Le variabili non statiche \"appartengono\" a una determinata istanza della classe. I metodi statici sono invece della classe, cioè sono gli stessi per ogni instanza della classe stessa.\r\n\r\nUn metodo statico non può fare riferimento a variabili non statiche perchè non ha modo di sapere a quale instanza particolare si riferiscono. Per manipolare le variabili non statiche di una certa istanza di una classe da un metodo statico occorre passare al metodo come parametro l'istanza da manipolare (o comunque recuperarla in qualche modo all'interno del metodo stesso). Normalmente, in questi casi basta rimuovere il modificatore \"static\" dal metodo per avere il comportamento desiderato.\r\n\r\nUn metodo statico può invece fare rifermimento a variabili statiche in quanto queste appartengono alla classe, cioè sono condivise tra tutte le istanze della classe.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4421,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 575,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Un metodo statico è un metodo di classe. Tale metodo non può accedere a variabili di istanza (variabili non statiche) in quanto deve essere possibile chiamarlo senza creare un'istanza della classe e se non c'è istanza non ci possono essere variabili di istanza. Questo meccanismo è fondamentale infatti quello che permette il funzionamento del main (ovvero costituisce il bootsrap di Java).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4446,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 520,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Metodi dichiarati static sono associati ad una Classe anziche? ad un Oggetto. I metodi static non possono quindi accedere alle variabili di istanza perché l'istanza potrebbe non essere ancora stata creata.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4473,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 476,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Per il semplice motivo che l'accesso alle variabili non statiche di un oggetto è consentito se e solo se è presente almeno un'istanza dell'oggetto stesso. Un metodo static, che ha ragione di esistere anche senza che sia presente un'istanza della classe a cui appartiene, non può quindi fare riferimento ad una variabile non statica in quanto quest'ultima presupporrebbe l'istanziazione di una classe, mentre il primo no. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4434,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile creare delle classi \"libreria\" che contengono solo funzioni e non devono essere istanziate? (Integer, Math, ...)",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Libreria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4437,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche dei metodi static?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " - "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4402,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è System.out.println()?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "System"
            },
            {
              "keyword": " println()"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4376,
          "asker": {
            "courseId": 4,
            "askerId": 557,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è necessario che il Main sia Static?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Main"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4454,
          "asker": {
            "courseId": 4,
            "askerId": 540,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'autoboxing?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4395,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "L'Autoboxing è una funzione per effettuare il cast tra l'oggetto wrapper e il suo tipo primitivo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4425,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "L'autoboxing permette di convertire da tipo primitivo a corrispondente classe wrapper e viceversa. Ad esempio la conversione da Integer ( tipo primitivo ) a int (classe Wrapper ).\r\nIl processo contrario è definito unboxing.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4448,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "L'autoboxing è il processo di conversione da un tipo primitivo (int, short, double, char, ecc...) alla corrispondente wrapper class (Integer, Short, Double, Character, ecc...), contenuta all'interno del package java.lang, che fornisce i metodi Object per il tipo primitivo a cui fa riferimento. Il processo inverso viene definito unboxing. Entrambi (autoboxing e unboxing) possono essere impiegati insieme alle Generics.\r\n\r\nESEMPI:\r\n\r\n1) AUTOBOXING:\r\n    int numero= 5;\r\n    Integer numero_autoboxing= numero;\r\n\r\n2) UNBOXING:\r\n    Character carattere=new Character ('z');\r\n    char carattere_unboxing=carattere;\r\n\r\n3) AUTOBOXING con Generics\r\n    int i=1;\r\n    LinkedList<Integer> linkedlist=new LinkedList();\r\n    linkedlist.add(i);\r\n\r\n4) UNBOXING con Generics:\r\n    int sum=5+linkedlist.get(n);\r\n\r\nSPIEGAZIONE: somma 5 con l'elemento ottenuto alla posizione n-esima della linkedlist                        (dove linkedlist è definita come linkedlist<Integer>).\r\n\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4432,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "L'autoboxing è un casting AUTOMATICO con cui i tipi di dato primitivi vengono trasformati nei corrispettivi oggetti. é grazie ad esso che possiamo inserire i numeri in una Collections senza preoccuparci di nulla.Anche il processo inverso è possibile ed è chiamato unboxing.Per fare un esempio eseguiamo all'interno del main questo pezzo di codice:\r\n  Integer object= 22; // autoboxing\r\n  int primitivo=  new Integer(22); // unboxing\r\n  Integer somma = object + primitivo+ 10; // autoboxing e unboxing\r\n  System.out.println(\"La somma è: \" + somma);\r\n  if(object== primitivo)\r\n      System.out.println(\"VERO\"); \r\n  else\r\n      System.out.println(\"FALSO\"); l'output è: la somma è 54      VERO\r\nNota quindi che Java, sommandoli tra loro, tratta i due dati come dello stesso tipo.La corrispondenza dell'indirizzo controllata nell' if conferma come anche nella memorizzazione i due vengono trattati esattamente nello stesso modo.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4435,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 447,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "E' la conversione automatica che l'interpreta fa tra un tipo primitivo e la sua corrispondente classe contenitrice. Per esempio, converte un int in un Integer, un double in un Double. Se la conversione avviene nel senso opposto si chiama unboxing",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4442,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il tipo generico? ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generico"
            },
            {
              "keyword": "_"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4465,
          "asker": {
            "courseId": 4,
            "askerId": 422,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'uso delle \"anonymous inner classes\" in Java? Si può dire che l'uso di queste è uno dei vantaggi di questo linguaggio di programmazione?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "anonymous"
            },
            {
              "keyword": "inner"
            },
            {
              "keyword": "classes"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4363,
          "asker": {
            "courseId": 4,
            "askerId": 572,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè non posso istanziare un vettore come generic?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " Array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4396,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché e come si utilizzano le generics e cosa sono?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4418,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Le generics servono per imporre un determinato tipo ad esempio ad una determinata lista affinché l'inserimento di variabili di altro tipo non sia concessa.. Quindi possono aiutare per evitare che vengano erroneamente inseriti valori al posto sbagliato.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4414,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Le generics permettono di vincolare i tipi di dato su cui opera una classe:\r\ntipizzando una Collection il compilatore mostrera' un errore se si cerca di inserire, nella stessa, oggetti che non sono di quel tipo.\r\nEs\r\nCollection<String> s = new HashSet();\r\ns.add(\"c\"); //va bene\r\ns.add(1); //errore\r\n\r\nCosi' vedo a compiletime errori che altrimenti sorgerebbero a runtime (se nella collection inserisco un intero e poi, estraendolo cerco di castarlo a String sorge un errore)\r\nle generics permettono di definire un tipo generico\r\nEs\r\nclass Gen<T>{ T item; Test(T og){ item=og; } }\r\nclass A{... Gen n= new Gen(1); Gen c= new Gen('a'); ...}\r\nLa classe A incapsula ogg di qualsiasi tipo. n sarà di tipo Gen tipizzato sugli int, c sui char\r\nNon si puo' creare un array generico: T a = new T[3]; errore a compile time\r\nsi può però fare T a[]; a = (T[]) (new Object[3]); tale scrittura è sconsigliata -> fonte di errori si tratta di un array di Object castato a array di T puo' provocare ClassCastException",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4478,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 481,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Un generics è uno strumento che permette la definizione di un tipo parametrizzato, che viene esplicitato successivamente in fase di compilazione secondo le necessità. I Generics forniscono un meccanismo per comunicare al compilatore il tipo di dato che viene gestito in un contenitore, in modo che possa essere controllato in fase di compilazione. Una volta che il compilatore conosce il tipo dell'elemento del contenitore, esso può verificare se esso viene utilizzato in modo coerente. Tutto ciò comporta una drastica riduzione dell'uso dei casting espliciti ad opera dell'utente e garantiscono a tempo di compilazione una garanzia della verifica sui vincoli dei tipi. Per quanto riguarda la creazione di array di tipo generico, questa non è possibile in modo semplice e ritorna un errore di compilazione.\r\nUn esempio di Generics è il seguente:\r\nList<String> words=new ArrayList<String>();",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4386,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Servono a dare il tipo a delle funzioni, in modo da garantire l'assenza di errori",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4447,
          "asker": {
            "courseId": 4,
            "askerId": 489,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché quando tento di fare un' array di un generico tipo T compare un' errore nel momento della compilazione?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4430,
          "asker": {
            "courseId": 4,
            "askerId": 566,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra i vari tipi di Listener? (Esterno, interno, interno anonimo e self listener)",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4423,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le parole chiave della programmazione in java fx?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "fx"
            },
            {
              "keyword": " chiave"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4399,
          "asker": {
            "courseId": 4,
            "askerId": 439,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "¿Quando è opportuno utilizzare i generics?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4417,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il main è sempre dichiarato static?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4365,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la principale differenza tra un Listener Interno Anonimo e un Self Listener? Che vantaggi/svantaggi comporta?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Handle"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4388,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 459,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "con l'interno hai il codice più compatto, mentre con il listner esterno hai la possibilità di scrivere più codice n modo ordinato e che permette una eventuale modifica.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4389,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il self comporta che viene trasformata la classe stessa in eventhandler e può essere implementata una sola handle. Nel caso invece del listener interno anonimo possono essere implementate quante handle sono necessarie, ma va riscritto il codice ogni per ogni oggetto interessato.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4411,
          "asker": {
            "courseId": 4,
            "askerId": 488,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qualora avessi bisogno di avere un array di tipo generics nel mio programma a che problemi andrei incontro e come farei per risolverli?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4484,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 499,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Utilizzando un array di tipo generics (Collection<T> lista = new Arraylist();) è possibile definire il tipo di parametro (T) che si vuole utilizzare (elemento dell?array), così facendo si rende il codice più comprensibile e più ?usabile?.\r\nUn problema che si può riscontrare è l?utilizzo di metodi sul parametro T, in alcuni casi java potrebbe non permetterlo poiché non riconosce il tipo del parametro (errore a compile time, esempio: contenuto=new T[size]);). Si aggira il problema utilizzando la classe Object (e quindi i metodi da lei implementati) e poi castando il tutto come T (contenuto=(T[])(new Object[size]);).\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4474,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 487,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Gli array, nonostante siano in tutto e per tutto degli oggetti, non vanno molto d'accordo con i Java Generics perché i loro tipi vengono definiti in due momenti differenti. Gli array infatti definiscono il proprio tipo a Run Time, mentre un oggetto o una classe marchiata da un Generics non fa altro che mascherare il proprio tipo facendo un Casting implicito al tipo dell'oggetto specificato, quindi il suo tipo è già noto a Compile Time. C'è comunque un modo per rendere un array del tipo Generics, non molto elegante, che consiste nell'incapsularlo all'interno di una classe di tipo Generics e al momento della creazione del array nel costruttore della classe farne un Casting ricavando il tipo del Generics. Spero di aver risolto i tuoi dubbi.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4361,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "che cosa significa un ogetto è \"clonable\" ?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " significato"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4434,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 567,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "La domanda non è ben posta.\r\nAd ogni modo \"cloneable\" è un'interfaccia che va implementata quando si vuole effettuare una copia di un oggetto.\r\nBisogna comunque prestare attenzione a questo processo. Esso possiede il grande vantaggio di effettuare una copia dell'oggetto e non solo delle sue referenze. Questo significa che vengono copiati i suoi campi ed i valori che essi contengono, ed effettuando modifiche sui campi di copia, non vengono  modificati i campi dell'oggetto originale.\r\nIl punto cruciale nell'uso di quest'interfaccia è ricordarsi che essa non contiene il metodo \"clone\". Per questo se si vuole effettuare una copia di una classe, occorre che in quella classe sia sovrascritto il metodo \"clone\" di Object. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4447,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 505,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Che possibile richiamare il metodo clone sull'oggetto quindi fare una copia bit a bit dell'oggetto che risponderà false all'operatore == ma se usato sul metodo equals risponderà true",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4412,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Innanzitutto tengo a precisare che questa domanda è ambigua. Infatti leggendola mi viene semplicemente da rispondere un oggetto è \"clonable\" (copiabile) quando è una sottoclasse di Object; infatti essendo che clone è un metodo PROTECTED di Object l'unica cosa che rende un \"oggetto clonable\" è appartenere a una sottoclasse di Object. Poi però mi viene da pensare che forse con \"clonable\" si voleva intendere cloneable  ossia un interfaccia. Così però la domanda non regge quindi non so davvero che cosa dire comunque l?interfaccia Cloneable non contiene metodi in quanto è una interfaccia marker implementando la quale si esplicita il fatto che un oggetto può essere clonato. \r\n\r\n ",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4360,
          "asker": {
            "courseId": 4,
            "askerId": 432,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'utilizzo dei generics?\r\n ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " - "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4424,
          "asker": {
            "courseId": 4,
            "askerId": 505,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Una classe statica può essere creata con l'operatore \"new\"? In quale situazione può servire una classe statica?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4386,
          "asker": {
            "courseId": 4,
            "askerId": 425,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i pro e i contro nell'utilizzo di una classe interna anonima?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pro"
            },
            {
              "keyword": "contro"
            },
            {
              "keyword": "classe"
            },
            {
              "keyword": "anonima"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4449,
          "asker": {
            "courseId": 4,
            "askerId": 573,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi nell'uso dei generics?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vantaggi"
            },
            {
              "keyword": " svantaggi"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4397,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo il metodo main è definito come static ? ",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4415,
          "asker": {
            "courseId": 4,
            "askerId": 487,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra Listener Interno, Listener Interno Anonimo e Self Listener?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4389,
          "asker": {
            "courseId": 4,
            "askerId": 537,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra un listener interno e uno esterno ?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "dichiarazione"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4438,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve dichiarare un tipo generico?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4370,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Un listener esterno deve essere scritto in un progetto javaFX? e se si come si crea poi un collegamento nella classe main???",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 3,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4412,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è consigliabile dichiarare final le variabili d'istanza a cui si accede tramite un listener esterno?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " final"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4405,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 595,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Le variabili di istanza vengono dichiarate final in modo che non vengano modificate dai dati del listener esterno.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4479,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Non é che non sia consigliabile, é obbligatorio, altrimenti non compila il codice. Questo per la questione del multi-threading, ovvero quando un programma é stato scritto per essere eseguito da più processori o in azioni parallele (i caricamenti di un database che però mantengono attiva un'interfaccia utente per esempio). Ora, siccome un singolo elemento potrebbe essere utilizzato in due thread distinti potrebbe venire modificato da uno \"sotto i piedi dell'altro\" (provate a tirare via la tovaglia senza sparecchiare... A meno di prestigiatori avrete lo stesso effetto). Per evitare questo problema le variabili utilizzate dalle classi interne (che quindi potrebbero agire su thread diversi) devono essere final, e quindi non modificabili!",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4457,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Perché in tal caso non si causa un errore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4423,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Per evitare di ottenere più istanze della variabile che si intende modificare. Si rischierebbe di avere più valori contemporaneamente per una sola variabile.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4392,
          "asker": {
            "courseId": 4,
            "askerId": 518,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale ragione una classe dichiarata in modo static ha la peculiarità di poter permettere l'utilizzo dei suoi metodi senza dover prima dichiarare un istanza ?! ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": "Metodo"
            },
            {
              "keyword": "static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4426,
          "asker": {
            "courseId": 4,
            "askerId": 513,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Usando un Listener esterno, come si può accedere a una variabile di un oggetto esterno al Listener stesso?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4380,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il costruttore super di una classe interna?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interna"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " costruttore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4433,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 524,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Quello definito nella sua immediata superclasse.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4429,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Non so se ho ben capito la domanda, io la interpreto così:\"Qual'è il costruttore della superclasse che viene chiamato da una sottoclasse quando invochiamo il costruttore della stessa?\".\r\nIn questo caso, quando usiamo l'ereditarietà nei nostri programmi, il costruttore invocato dal metodo new della sotto classe è il costruttore \"canonico\" della superclasse cioè quello la cui firma non ha argomenti ( Es: <nomeClasse> () ) se noi vogliamo specificare un diverso costruttore dobbiamo scrivere nella prima riga del costruttore della sottoclasse \"super(\\*argomenti vari*\\)\". ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4451,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 458,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Non saprei.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4475,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 422,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Non ho ben capito la domanda. Ti posso però allegare un esempio che può chiarire le idee.\r\n\r\nclass Outer {\r\n    class Inner {\r\n        Inner() { System.out.println(\"Inner\"); }\r\n    }\r\n}\r\n\r\npublic class Child extends Outer.Inner {\r\n    Child(Outer o) {\r\n        o.super();\r\n        System.out.println(\"Child\");\r\n    }\r\n    public static void main(String args[]) {\r\n        new Child(new Outer());\r\n    }\r\n}",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4416,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Una classe interna di per sé non è sottoclasse della classe che la contiene. Infatti l'ereditarietà entra in gioco solo quando si usa esplicitamente la parola \"extends\" o \"implements\".\r\nQuindi il costruttore super() di una classe interna chiamerà semplicemente il costruttore di Object, o della classe di cui si è dichiarato fare l'extends.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4366,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchéla funzione \"void main(string a[])\" deve essere dichiarata static?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4356,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Se una variabile interna al codice viene utilizzata una sola volta ha senso usarla?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4381,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra static e final ?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": "variabili"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4403,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Static indica che un metodo/variabile è statico, cioè che può essere chiamato senza una istanza dell'oggetto che lo contiene.\r\nFinal, invece, indica che il metodo/variabile è una costante, ma assume diversi significati a seconda del contesto",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4394,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "possiamo applicare final solo a una variabile. una variabile final non può più cambiare il suo valore, anche se, se la variabile è un oggetto, possiamo cambiare il valore delle variabili interne all'oggetto grazie alle funzioni. fondamentalmente la parola final non permette di cambiare l'indirizzo a cui punta la nostra variabile.\r\npossiamo applicare static sia a variabili che metodi. metodi static possono esser utilizzati senza dover istanziare un oggetto della classe a cui appartengono il metodo (ad esempio tutte le funzioni di System sono static). variabili static invece sono variabili visibili globalmente",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4466,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Sono cose completamente differenti!\r\nUna variabile dichiarata final non può essere sovrascritta. Se è un tipo primitivo il risultato è che non si può modificarne il valore. es:\r\nfinal int x=3;\r\nx=3+1; <-- non si può fare!\r\nAttenzione invece che se ad essere final è un oggetto, il final ha effetto su quello che è il puntatore. Per esempio\r\nfinal Punto p = newPunto(1,1);\r\np.x=3; <-- lo posso fare perché non modifico p (che è il nome di un indirizzo) ma x\r\np=newPunto(3,1); <--non lo posso fare!!\r\nAllo stesso modo posso usare final su un metodo di una classe A per impedirne l'overwrite nell sottoclassi di A.\r\n\r\nUna variabile static è comune a tutte le istanze della classe a cui appartiene.\r\nclass A{\r\npublic static int n=1}\r\nse faccio..\r\nA a=new A();\r\na.n=3;\r\nB b=new B();\r\nora anche b.n avrà valore 3,perché n è lo stesso a tutte le istanze di A.\r\nUn metodo static può essere chiamato senza dover creare istanze, per esempio posso chiamare\r\nMath.random()\r\nsenza aver istanziato un oggetto Math.",
              "notes": "-",
              "rating": 5,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4443,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "In che casi sono utili le generics?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4387,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in Java il main è static?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4395,
          "asker": {
            "courseId": 4,
            "askerId": 486,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi comporta l'uso delle Generics?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4451,
          "asker": {
            "courseId": 4,
            "askerId": 444,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Per cosa vengono utilizzati i generics?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Listener"
            },
            {
              "keyword": " Classes"
            },
            {
              "keyword": " Java FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4453,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i generics?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "cosa"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4462,
          "asker": {
            "courseId": 4,
            "askerId": 585,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Essendo la classe anonima e una classe senza nome per definizione, come è possibile definire il corrispondente costruttore...? \r\nQual è l'utilità di tali classi? Perché prediligerle alle classi locali?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classe anonima"
            },
            {
              "keyword": "classe locale"
            },
            {
              "keyword": "costruttore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4453,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 478,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Sul filo di quanto detto in classe, basta omettere in nome del costruttore, il risultato è uno spezzone di codice racchiuso solamente dalle parentesi graffe_\r\n\r\nCostruttore () {\r\n....  } diventa\r\n{ ..... }\r\n\r\nLe classi anonime sono utili in svariati ambiti; noi ad esempio le abbiamo utilizzate nella definizione degli EventHandler e altre funzionalità correlate alla scrittura di interfacce JavaFX.\r\nEsse sono da preferire alle classi locali soprattutto per una questione di scope (in sostanza ti eviti una sacco di grane), inoltre io le preferisco anche per la pulizia del codice. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4398,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Una classe anonima può essere definita all'interno di un metodo, e ciò permette di poterla usare poi una volta sola. Questo è utile perchè, nel caso serva una classe una volta sola e in una particolare situazione, la si può definire localmente senza dover ricorrere ad una definizione esterna. \r\nDefinire il costruttore di una classe anonima è formalmente impossibile e, se ci si pensa, in parte anche inutile. Per la località di una classe anonima, richiamare un costruttore diventa dunque superficiale, poichè se una classe va chiamata solo in particolari frangenti, non sarà necessario crearne un costruttore al di fuori di essi. Nel caso sia invece necessario, bisognerà per forza creare una classe locale, che per questa caratteristica risulta più vantaggiosa, ma più dispersiva perchè non usabile solo localmente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4420,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "In che cosa consiste il metodo clone() di Object??",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "metodi"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4400,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Dato un oggetto x che chiama clone(), questo metodo crea e restituisce una copia di x tale che x.clone() != x e, generalmente, che le espressioni x.clone().getClass() == x.getClass() e x.clone().equals(x) restituiscano true.\r\nUna classe deve implementare un suo metodo clone() che per prima cosa chiami il metodo clone() della sua sovraclasse (non può chiamare direttamente il metodo clone() di Object). Per implementare il metodo clone() bisogna ricordare che la classe deve implementare l'interfaccia Cloneable e che nel corpo del metodo bisogna gestire l'eccezione CloneNotSupportedException.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 4402,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Il metodo clone() di Object esegue una shallow copy di un oggetto. Ciò significa che se all'interno  di tale oggetto sono instanziate delle strutture dinamiche verrà copiato solamente l'indirizzo di memoria di tali strutture. Inoltre non è possibile semplicemente 'chiamare' il metodo clone della superclasse Objcet, ma la classe dell'oggetto chiamante dele implementare l'interfaccia 'cloneable' e gestire l'eccezione 'CloneNotSupportedException', altrimenti la chiamata genererebbe un errore a compile time.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4405,
          "asker": {
            "courseId": 4,
            "askerId": 470,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè non bisogna dichiarare tutte variabili static?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "dichiarazione"
            },
            {
              "keyword": "static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4454,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Perché dichiarando tutto variabili static si perderebbe la possibilità di accedere a variabili proprie dell'oggetto e non della classe e di conseguenza il principale vantaggio della programmazione ad oggetti.\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4437,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Non sò rispondere alla domanda.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4391,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il modificatore static assegnato a una variabile serve a rendere quella variabile unica per tutta la classe in cui è contenuta. Inoltre ne modifica anche la visibilità, poiché le variabili static sono visibili anche non avendo istanziato quella classe. Se tutte le variabili all'interno di una classe fossero definite static, allora tutte le istanze della classe avrebbero le stesse proprietà e qualunque modifica effettuata a un oggetto di quel tipo si estenderebbe a tutte le istanze della classe.\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4441,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "......",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4371,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "perchè sono stati introdotti i generics?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "perchè"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4455,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 490,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "perché permettono di definire delle astrazioni sui tipi di dati definiti nel linguaggio.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4463,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 426,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il JDK 1.5 ha introdotto alcune estensioni al linguaggio Java. Una di questa è l'introduzione dei generics o tipi generici. Un generics è uno strumento che permette la definizione di un tipo parametrizzato, che viene esplicitato successivamente in fase di compilazione secondo le necessità; i generics permettono di definire delle astrazioni sui tipi di dati definiti nel linguaggio.\r\n\r\n\r\nVi sono svariati vantaggi nell'uso dei generics:\r\n\r\n-Fornisce una migliore gestione del type checking durante la compilazione;\r\n-Evita il casting da Object. I.e.;\r\n-Invece di utilizzare:\r\nString title=((String) words.get(i)).toUppercase();\r\nverrà utilizzato:\r\n\r\nString title=words.get(i).toUppercase();\r\n\r\nVi sono però anche degli svantaggi:\r\n\r\nSi definisce:\r\nList<String>words=new ArrayList<String>();\r\ninvece di:\r\n\r\nList words=new ArrayList<String>();",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4480,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 477,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "I Generics sono stati introdotti con Java 5.0, per permettere di usare metodi e classi che utilizzano tipi \"generici\" (ad esempio Object), mantendo un controllo a compile-time sui tipi utilizzati.\r\nSenza utilizzare i Generics infatti è possibile creare una Collection ed aggiungere a questa una stringa. Ciò è perfettamente lecito in queste condizioni, dato che una collezione così definita può contenere generici Object.\r\nNel momento in cui però estraiamo un elemento dalla Collection e cerchiamo di trattarlo come se fosse un numero intero con un cast otteniamo un errore a run-time, dato che una stringa non può essere trattata come un intero.\r\nSe invece la Collection viene tipizzata per contenere interi potremmo solo aggiungere o estrarre da questa numeri interi, pena un errore a compile-time.\r\nI Generics quindi permettono di avere un controllo a compile-time sull'uso inappropriato dei tipi, evitando errori più difficili da individuare a run-time.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4401,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "I generics hanno una funzione fondamentale nell'implementazione di strutture dati dinamiche. Essi sono un metodo per separare la definizione delle strutture dati dal loro utilizzo in algoritmi.\r\nSi comportano in modo molto simile ai template C++ ( i quali permettono di scrivere una classe lista generica rispetto al contenuto, per poi usarla per gestire liste sia con argomenti semplici che complessi), e risolvono molti dei problemi relativi all'upper casting dei \"vecchi\" contenitori.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4357,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è consigliabile l'utilizzo di variabili di tipo static all'interno di una classe?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Statico"
            },
            {
              "keyword": " variables"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4430,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Quando voglio che tutti gli oggetti istanziati in un determinato momento della stessa classe, abbiano un campo comune in lettura/scrittura chiamato Variabile Globale.\r\nUn esempio potrebbe essere tenere traccia d quanti oggetti sono stati creati inizializzando la variabile a 0 e incrementandola/decrementandola in base alla chiamata del Costruttore/Distruttore",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4462,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Le variabili di tipo static vengono inizializzate in un'area di memoria dedicata quando il programma viene avviato. Esse non dipendono quindi da una particolare istanza di una classe, bensì dalla classe stessa; è dunque consigliabile utilizzare il nome della classe, e non delle sue istanze, per accedervi. In generale le variabili statiche devono essere utilizzate se si rende necessario avere una variabile a cui tutte le istanze di una determinata classe possono accedere e che possono modificare. Un esempio sono i contatori di istanze di una classe.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4467,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Le variabili di tipo static sono delle variabili condivise tra più istanze , infatti sono allocate in un'area di memoria diversa dallo stack (Utilizzato per allocare le variabili automatiche) per questo motivo \"sopravvivono\" anche quando un istanza di una classe termina il suo lavoro. Detto ciò le variabili static sono molto utili quando si lavora con i  threads o in generale quando\r\nsi creano più istanze e si vuole traccia del loro operato. Un esempio pratico senza chiamare in causa i threds, può essere quello di creare una class tris , che \"gioca\" all'omonimo gioco , e creare due variabili static \"vinto\",\"perso\" , le quali verranno opportunamente incrementate. Dopo di che si crea un main in un'altra classe che servendosi di un dato ciclo che istanzia e faccia eseguire la classe tris. Alla fine fuori dal ciclo si stampa a terminale il contenuto delle due variabili :  System.out.println(identificatore.vinto/perso);",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4359,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa comporta l'uso della parola chiave static su una variabile di istanza?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " istanza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4364,
          "asker": {
            "courseId": 4,
            "askerId": 558,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il main è static?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "main"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4482,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il main è static cosicché la Java Virtual Machine non debba creare un'istanza per poterlo richiamare. Inoltre, dichiarando il main static, si evitano ambiguità nel chiamare i costruttori. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4426,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 466,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Il main è di tipo static perché non deve aver bisogno di variabili inizializzate per essere chiamato",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4428,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il main è \"static\" perchè è un metodo che è associato ad una classe, il quale posso utilizzarlo in tutti i programmi che usano la classe stessa, inoltre viene richiamato senza creare una istanza.Quindi non è una operazione che faccio su un oggetto ma bensì su una classe.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4452,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "\"static\" è una parola riservata del linguaggio che permette, nel contesto di una classe, di rendere disponibili funzioni e/o variabili interne (che verranno condivise tra le istanze) senza aver necessariamente creato un oggetto di tale classe, usando anche la sintassi MiaClasse.membroStatic oltre che a mioOggettoDiMiaClasse.membroStatic.\r\nIn Java, tutto deve essere definito dentro una classe, e ciò vale anche per il main. Essendo il main il punto di accesso del programma, per poterlo chiamare è necessario marcarlo come static, altrimenti non sarebbe invocabile in quanto non esiste alcuna istanza della classe che lo contiene.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4406,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perché così può essere invocato solamente utilizzando il nome della classe, senza che occorra avere alcuna istanza. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4471,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 489,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il main è dichiarato come static perché in questo modo accetta parametri e non variabili d'istanza, quindi non dipende dalle variabili della classe in cui è contenuto.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4375,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo \"clone\" nelle variabili statiche?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4408,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare gli effetti e l'utilità del modificatore \"static\" quando applicato a variabili e metodi. ",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": "static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4439,
          "asker": {
            "courseId": 4,
            "askerId": 548,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali modificatori di visibilità delle variabili?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4367,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando una variabile viene dichiarata static?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Variabile"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4362,
          "asker": {
            "courseId": 4,
            "askerId": 551,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra shallow e deep copy? Quale delle due viene effettuata \"di default\" dall'implementazione del metodo clone offerto da Object?  In quali casi è opportuno applicare l'una piuttosto che l'altra?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Cloning"
            },
            {
              "keyword": " deep copy"
            },
            {
              "keyword": " shallow copy"
            },
            {
              "keyword": " Object"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4422,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 454,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La shallow copy è la copia della referenza di un oggetto, mentre la deep copy(o copia in profondità) è la reale copia dell'oggetto. La prima ha il vantaggio di avere una rapida velocità di esecuzione e può essere eseguita su oggetti di qualsiasi grandezza; se A è la copia di B allora si trovano entrambi nello stesso blocco di memoria e se modifico uno anche l'altro subirà le stesse modifiche. Con la deep copy A e B sono indipendenti tra di loro e posso usarli autonomamente senza dover modificare l'altro; lo svantaggio della deep copy è l'alto costo in termini di velocità. \"Di default\" il metodo clone di Object effettua la Shallow copy. Per la scelta tra una o l'altra copia devo chiedermi se mi serve la copia della referenza o dell'oggetto.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4476,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 439,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "¿Richiamando il metodo clone() viene effettuata di default una shallow copy dell'oggetto. Per effettuare una deep copy è necessario che la classe dell'oggetto implementi l'interfaccia Cloneable. La deep copy è adatta a classi con membri non primitivi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4459,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In Java le variabili e i campi contengono referenze a oggetti; usando l?usuale assegnazione non si ha una copia dell?oggetto (deep copy) ma una copia delle referenza (shallow copy) che porta a una condivisione di memoria. Per evitare questo è possibile clonare un oggetto sfruttando il metodo clone di Object e l?interfaccia Cloneable.\r\nL?assegnamento può essere usato senza side effects in due casi:\r\ntipi primitivi: quando si usano tipi primitivi non viene valorizzata la referenza ma il valore. Eseguendo un assegnamento si copia quindi il valore;\r\noggetti immutabili: alcuni oggetti Java (per esempio String) sono immutabili: una volta costruiti non possono cambiare il proprio stato interno (il valore dei campi). \r\nOvviamente dipende dalla logica che vogliamo implementare, usando il metodo clone si ha il vantaggio di non dover clonare manualmente tutti i campi. Scrivendo un metodo custom c?è da scrivere più codice ma abbiamo anche una maggiore libertà nello scegliere cosa (e come) copiare.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4486,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 549,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Shallow copies duplicate as little as possible. A shallow copy of a collection is a copy of the collection structure, not the elements. With a shallow copy, two collections now share the individual elements.\r\n\r\nDeep copies duplicate everything. A deep copy of a collection is two collections with all of the elements in the original collection duplicated.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4413,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono vantaggi e svantaggi nell'utilizzo dei generics?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "casting"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4398,
          "asker": {
            "courseId": 4,
            "askerId": 473,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli svantaggi di un self-listener? (Slide 7)",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "svantaggi"
            },
            {
              "keyword": " self"
            },
            {
              "keyword": " istener"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4464,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Utilizzare un self-listener è sicuramente svantaggioso in quanto questo è strettamente legato alla classe in cui è definito, perciò non riutilizzabile. Inoltre poiché si può fare solo override del metodo handle, risulta dispendioso a livello di risorse.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4444,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 429,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "..",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4460,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 457,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "La funzione handle è esterna al Listener",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4450,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 593,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "non so rispondere a questa domanda",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4442,
              "task": {
                "taskId": 116,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il problema principale è distinguere il tipo di evento e l'elemento chiamante che lo genera.\r\nPoiché l'interfaccia EventHandler richiede l'implementazione del metodo handle, ci si ritroverebbe a dover gestire tutti gli eventi al suo interno, diventando sempre più difficile per applicazioni più complesse.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4436,
          "asker": {
            "courseId": 4,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 114,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra un listener interno e un listener interno anonimo?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " interno"
            },
            {
              "keyword": "anonimo"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 45,
      "lectureTitle": "equals e Comparator/Comparable",
      "questions": [
        {
          "questionId": 4216,
          "asker": {
            "courseId": 4,
            "askerId": 479,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando e come dovrei utilizzare equals, comparator/comparable?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " comparator"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4212,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "che cosa sono Comparator e Comparable e quali differenti funzionalità hanno?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparator"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4236,
          "asker": {
            "courseId": 4,
            "askerId": 475,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra comparator e comparable?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": "Comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4197,
          "asker": {
            "courseId": 4,
            "askerId": 578,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa vuol dire che due oggetti sono uguali?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Uguali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4213,
          "asker": {
            "courseId": 4,
            "askerId": 521,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa hanno in comune i tre tipi di struttura dati?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struttura"
            },
            {
              "keyword": "dati"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4171,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra scrivere un metodo \"equals classico\" tramite l'uso di un operatore == e uno invece che utilizza la \"proprietà\" di java, HASHCODE ?\r\nQuale dei due è preferibile utilizzare ?  ",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "hashcode"
            },
            {
              "keyword": "operatore_=="
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4144,
          "asker": {
            "courseId": 4,
            "askerId": 559,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si implementano comparable e comparator?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": "comparator"
            },
            {
              "keyword": "interface"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4219,
          "asker": {
            "courseId": 4,
            "askerId": 442,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai è importante definire il metodo equals in ogni programma che si scrive nonostante sia già compreso nella libreria?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " libreria"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4179,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 497,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Definire il metodo equals() in ogni programma è importante per dare un punto di partenza su cui basare i nostri criteri di uguaglianza. Se non lo facessimo, verrebbe preso il metodo equals() di Object, secondo il quale se due cose sono identiche sono anche uguali. Questo criterio standard presente in Object potrebbe dunque non andare bene per la nostra uguaglianza e ritornare un risultato indesiderato.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4232,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 575,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Supponiamo di creare la classe class MyObject{...} che non implementa il metodo equals e supponiamo che p,q siano due istanze di tale classe. Allora p.equals(q) chiama il metodo della super-classe ovvero di Object. Tale metodo restituisce true se e solo se due oggetti sono identici (sono lo stesso oggetto) ovvero se e solo se hanno lo stesso indirizzo in memoria. A meno che questo non sia il criterio che vogliamo adottare per definire che due MyObject sono uguali dobbiamo fare l?overloading del metodo equals di Object \r\npublic boolean equals(Object o) \r\ncambiandone la firma, dobbiamo cioè scrivere il metodo \r\npublic boolean equals(MyObject o) \r\nche implementa il criterio scelto.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4178,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 444,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Nella classe Object, poichè non si può fare alcuna assunzione sulla struttura interna degli oggetti su cui viene invocato, il metodo equals è realizzato nel modo più restrittivo possibile: due oggetti sono considerati equivalenti solo se sono lo stesso oggetto. Quindi il confronto è basato sull'operatore ==. Avrebbero potuto confrontare tutti i campi della classe usando la reflection ma l?implementazione sarebbe stata più complicata e molto meno performante (e comunque non sarebbe stata sempre corretta). Il metodo equals può essere invocato su una istanza di una qualunque classe. Se però nella classe in questione il metodo non è stato sovrascritto, verrà eseguito il metodo ereditato da Object, con risultati che potrebbero essere inattesi. Quindi il metodo equals deve essere ridefinito in tutte le classi in cui è necessario effettuare confronti, per ottenere risultati significativi.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4265,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo equals presente nelle API di java per la classe Object verifica l'identità di due oggetti utilizzando l'operatore \"==\", difatti nel caso in cui l'identità sia confermata posso con assoluta certezza dire che essi sono anche uguali. Ciò fa in modo che tale metodo possa essere utilizzato per ogni oggetto da me creato. Va definito in ogni programma perchè nella maggior parte dei casi abbiamo bisogno di maggior precisione, ad esempio nel caso in cui vi sono due punti con uguali coordinate, se utilizzassi il metodo equals già definito nelle API essi finirebbero per essere distinti a meno che non siano identici.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4237,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 448,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "In Java quando viene definita una classe, questa eredita implicitamente da object e quindi eredita anche il metodo equals, il quale per confrontare l'uguaglianza tra due oggetti, controlla se il riferimento ad essi, restituendo true se e solo se i due oggetti puntano alla stessa locazione di memoria. Il programmatore ridefinendo il metodo equals può cambiare questo criterio e sancire l'uguaglianza tra due oggetti utilizzando un altro metodo di confronto (per esempio l'uguaglianza di alcuni campi).",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4141,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Dove va implementato il metodo compareTo (Object o);? In quale classe o interfaccia deve invece essere dichiarato?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": " interface"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4160,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è di preciso una mappa e quali sono le differenze tra una mappa e un set/lista?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "mappa"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4161,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come faccio a modificare il metodo equals?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4145,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è preferibile eseguire l'override del metodo Object.equals pittosto che l'overload?\r\n\r\nOverride:\r\npublic boolean equals(Object var) { \r\n    if (!(var instanceof P)) return false; \r\n    if(var==null) return false; \r\n    return (x==((P)var).x && y=((P)var).y) \r\n} \r\n\r\nOverload:\r\npublic boolean equals(P var) { \r\n    if(var==null) return false; \r\n    return (x==var.x && y=var.y) \r\n} \r\n\r\nIn altre parole, che senso ha farne l'override e controllare manualmente se il parametro è del tipo corretto con instanceof quando, grazie al dynamic binding, questo controllo può essere lasciato al runtime?\r\n\r\nNota che le due implementazioni di equals mostrate sopra ritornano valori uguali per qualsiasi input. Nel caso dell'overload, se var non è di tipo P verrà chiamato Object.equals invece che P.equals, ma il risultato sarà uguale (spoiler: false); se invece var è di tipo P verrà eseguito lo stesso controllo in entrambi i casi, producendo quindi lo stesso esito.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "overload"
            },
            {
              "keyword": "override"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4174,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo equals e compareTo?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " compareTo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4121,
          "asker": {
            "courseId": 4,
            "askerId": 530,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Se ho bisogno di implementare due differenti metodi di ordinamento per una stessa collection di oggetti, devo usare l'interfaccia Comparator oppure la Comparable?\r\nPer esempio, se ho la collection di macchine e voglio prima ordinarla per numero di serie e poi per velocità massima di punta di quale ho bisogno?  ",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4182,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "l'interfaccia Comparator ha una caratteristica particolare, molto utile ai fini della realizzazione di un qualsiasi progetto rispetto al Comparable... di cosa si tratta?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparator"
            },
            {
              "keyword": " libertà"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4156,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando bisogna ricorrere all'uso di \"equals\" ? E perché bisogna farne utilizzo?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4122,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega la differenza tra equals() e ==",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " =="
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4187,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come fa java a vedere se degli oggetti da inserire in un Hashset sono già contenuti al suo interno?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashset"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4208,
          "asker": {
            "courseId": 4,
            "askerId": 483,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale vantaggio introduce la funzione hashCode rispetto ad utilizzare solamente la equals?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "hashCode"
            },
            {
              "keyword": "collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4157,
          "asker": {
            "courseId": 4,
            "askerId": 519,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si sceglie di ordinare una collection con un'implementazione di \"comparator\" o di \"comparable\", in entrambi i casi si deve comunque scrivere personalmente una funzione che confronta due oggetti e restituisce valori concordati, seguendo lo standard imposto dall'ereditarietà.\r\nQuindi come dovrei scegliere se implementare \"comparator\" oppure \"comparable\", se in entrambi i casi dovrei fare la stessa cosa?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": " Comparable"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4140,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando chiamo il metodo equals() per confrontare due oggetti viene eseguito anche il confronto tramite hashCode()?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4264,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 490,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "quando chiamiamo il metodo \"equals()\" non facciamo altro che controllare se la referenza ai due oggetti è uguale. Quindi NO quando chiamo equals non viene eseguito il confronto con hashCode().",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4252,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "No, non automaticamente. Il metodo hashCode è fortemente legato al metodo equals e viene utilizzato nel caso di collection basate su hash table (per esempio HashMap e HashSet).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4220,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "No, equals() e hashCode() sono due funzioni indipendenti, anche se sono correlate, nel senso che vengono usate entrambe per confrontare due oggetti.\r\nhashCode() deve confronta dei codici che contraddistinguono i due oggetti, mentre equals() generalmente confronta i campi degli oggetti. Se si implementa equals() che esegue l'override della equals() di Object bisogna anche implementare l'override di hashCode().\r\nInoltre le due funzioni devono essere implementate in modo tale che se equals() restituisce \"true\", anche hashCode() deve restituire \"true\"; non è vero invece che se hashCode restituisce \"true\" anche equals() debba restituire \"true\".",
              "notes": "-",
              "rating": 6,
              "coins": []
            },
            {
              "answerId": 4246,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 521,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Quando richiamo il metodo equals() per vedere se due oggetti sono uguali questo richiama il confronto tramite hashcode presente nella classe astratta di object e va a verificare se tramite il metodo hashcode i due oggetti sono uguali. Se tramite hashcode sono diversi allora sono sicura che siano realmente diversi se invece una volta applicato il metodo hashcode ritorna lo stesso numero allora non è detto che siano diversi ma richiamo equals e vado a vedere se sono lo stesso oggetto..\r\nPer esempio se considero due stringhe 'caio' e 'ciao' ed assegno ad ogni lettera un valore noto che con il metodo hashcode queste risultano uguali anche se non lo sono, a questo punto quindi vado a vedere se sono la stessa parola controllando lettera per lettera.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4143,
          "asker": {
            "courseId": 4,
            "askerId": 568,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si usa  Comparator?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparator"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4221,
          "asker": {
            "courseId": 4,
            "askerId": 577,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo \"equals\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4113,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Si possono creare collection che contengono altre collection?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4172,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Certamente, una volta istanziata una implementazione di Collection è possibile inserivi qualsiasi tipo di oggetto, anche altre istanze di altre implementazioni di Collection.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4270,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 476,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Credo si possa. In fondo non ci sarebbe nulla di concettualmente sbagliato nel creare ad esempio una ArrayList i cui elementi sono a loro volta degli HashSet. Il risultato sarebbe analogo alla struttura di un soprammobile come il comò: abbiamo una struttura principale, l'ArrayList nel nostro caso, che contiene un numero di cassetti, gli HashSet, nei quali a loro volta è possibile inserire degli elementi. Coerentemente con le proprietà delle Collection elencate, il comò possiede un certo numero di cassetti disposti secondo un certo ordine e con la possibilità di avere dei cassetti duplicati, mentre all'interno di questi contenitori si può inserire un insieme di elementi che non ne abbia duplicati, ma questo dipende ovviamente dal tipo di struttura dati che si sceglie. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4188,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 553,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Premetto che ci ho messo un po' per rispondere perchè la domanda mi ha un po' confuso all'inizio...Quindi sto punto datemelo per l'impegno, dai! Sono tutte ricerche che sto risparmiando a voi queste! Andando a fondo ho scoperto che si, si possono creare collection che contengono altre collection: infatti si possono creare liste che contengono altre liste e  vale anche per i set (ho scoperto che conta tutto come collection quindi...TOP!). E alla fine è un po' come con gli array di array in c++...solo un po' più elaborato e con metodi comodi senza che devi tirar porchi ovunque per fare le funzioni.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4162,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 500,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Si.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4211,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "si, non c'è nessuna restrizione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4138,
          "asker": {
            "courseId": 4,
            "askerId": 470,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "quando conviene fare un override del metodo coparable, e quando invece del metodo comparator?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": "comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4222,
          "asker": {
            "courseId": 4,
            "askerId": 422,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali difficoltà / insidie sono da tenere in considerazione quando si fa l'@Override di `equals(Object o)` e il fratello `hashCode()`? In altre parole, quali sono le proprietà che devono rispettare questi due metodi? Queste proprietà definiscono cosa accade se chiamo o.equals(null), dato o un oggetto generico?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "properties"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4128,
          "asker": {
            "courseId": 4,
            "askerId": 439,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "¿Qual'è la differenza tra Comparator e  Comparable, e in quali occasioni è opportuno usare il primo piuttosto che il secondo?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparator"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4201,
          "asker": {
            "courseId": 4,
            "askerId": 579,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le classi interface?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4124,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra comparable e comparator?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4231,
          "asker": {
            "courseId": 4,
            "askerId": 554,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra l'operatore == e l'operatore equals ?  ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals "
            },
            {
              "keyword": " comparazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4119,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze fra Comparable e Comparator? In che modo vengono utilizzati?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Comparable"
            },
            {
              "keyword": " Comparator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4208,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Le differenze sono:\r\n-Comparable permette di creare una classe che sia confrontabile(posso mettere in ordine) con altri oggetti. Contiene il metodo CompareTo(Object o) che confronta la classe corrente con un oggetto esterno.Devo creare la mia classe come implementazione di Comparable e implementarci dentro compareTo\r\n public class T implements Comparable{..public compareTo(Object o){..}}\r\n\r\n-Comparator<T> permette di creare una (o più di una!!) classe ausiliaria esterna tramite la quale si possono confrontare 2 oggetti di tipo T. Contiene il metodo compare(T o1,T o2) (questa volta ho 2 argomenti). Posso implementarla fuori dalla mia classe T (a patto di metterla pubblica!)\r\n public class Cmp1 implements Comparator<T>{...}\r\ne per poterla usare devo ricordarmi di istanziarla!\r\n Cmp1 c = new Cmp1();\r\n\r\nOra posso ordinare una lista l di oggetti T comparabili chiamando\r\nCollections.sort(l) // ordino secondo la compareTo di T\r\no\r\nCollections.sort(l,c) // ordino secondo la compare di Cmp 1",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4230,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 481,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Comparable è un interfaccia che provvede un ordinamento naturale automatico in una classe che lo implementa. Un esempio di classi che lo implementano sono le classi String e le classi Data come int, float ecc... In queste classi l'ordinamento in ordine alfabetico (String) o in ordine cronologico(Data). Negli oggetti che implementano l'interfaccia Comparable è presente un metodo compareTo che prende come input un oggetto da confrontare con l'oggetto stesso e restituisce un intero int negativo, pari a 0, o positivo se l'oggetto stesso è minore, uguale o positivo rispetto all'oggetto preso come input.\r\nComparator, invece, è un interfaccia che permette al programmatore di scegliere lui stesso in base a cosa ordinare gli oggetti e ritorna anche lui un intero minore, uguale o maggiore di 0. Per far ciò è necessario sovrascrivere il metodo compare il quale prende in input due oggetti e li confronta in base alla scelta del programmatore.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4171,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Comparable definisce quello che è il \"natural order\" (l'ordine naturale) tra gli elementi di una classe. Ciò significa che, se due o più elementi di una determinata classe devono essere comparati fra di loro per stabilire chi viene prima e chi dopo, è corretto far implementare Comparable a tale classe. In questo modo, la maggior parte delle funzioni di ordinamento \"naturale\" sapranno come ordinare gli elementi di quella classe.\r\n\r\nComparator, invece, definisce una funzione di ordinamento che potenzialmente nulla ha a che vedere con l'ordinamento normale (naturale) degli oggetti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4212,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Entrambe sono interfacce. \r\nComparable viene implementata direttamente nella classe per la quale si vuole stabilire il criterio di ordinamento, implementandone il metodo compareTo(Object o), che restituisce un intero minore di, uguale a o maggiore di zero, a seconda che l'oggetto this sia minore, uguale o maggiore dell'oggetto passato come parametro. Si usa per definire l'ordinamento naturale della classe implementante. \r\nComparator viene invece implementata da una classe a parte (Es: MyCmp), implementandone il metodo compare(Object o1, Object o2), che restituisce un intero minore di, uguale a o maggiore di zero, a seconda che l'oggetto o1 sia minore, uguale o maggiore dell'oggetto o2, secondo il criterio di ordinamento scelto per una classe C. La classe C deve avere una variabile d'istanza del tipo MyCmp, che viene passata ai metodi che devono confrontare (o ordinare) delle istanze di C; in una classe possono essere presenti più comparatori diversi, dando quindi maggiore flessibilità.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4132,
          "asker": {
            "courseId": 4,
            "askerId": 426,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano i Comparator/comparable?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4134,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra equal \"==\"?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equal"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4139,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando sovrascrivo il metodo equals di object (nel processo di creazione di una nuova classe) devo sovrascrivere anche il metodo hashCode di object?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " sovrascrivere"
            },
            {
              "keyword": " hashCode"
            },
            {
              "keyword": " object"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4150,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando due oggetti si possono considerare uguali e quando identici?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " =="
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4234,
          "asker": {
            "courseId": 4,
            "askerId": 456,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche del metodo hashCode? a cosa serve e perchè è fortemente consigliato di effettuarne un overraid quando si riscrive il metodo equals?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4162,
          "asker": {
            "courseId": 4,
            "askerId": 445,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "nel caso volessimo fare una lista ordinata di studenti sarebbe meglio usare una list o un set? perché?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4205,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": " Quando può succedere che c1.hashCode()==c2.hashCode() non implica che c1.equals(c2) ?\r\n",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4179,
          "asker": {
            "courseId": 4,
            "askerId": 533,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'improtanza di definire un metodo EQUALS nell'implementazione di una applicazione che utilizza un HashSet?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4210,
          "asker": {
            "courseId": 4,
            "askerId": 531,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "quando due oggetti sono uguali (equals) in java?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": "uguale"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4227,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali situazioni viene impiegata l'interfaccia \"Comparable\" e in quali altre invece si sceglie l'interfaccia \"Comparator\"?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaces"
            },
            {
              "keyword": " ordering"
            },
            {
              "keyword": " sorting"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4135,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché non è sufficiente reimplementare il metodo \"equals(Object obj)\" per far sì che un HashSet possa giudicare uguali due oggetti non identici?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4163,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Dalla documentazione del metodo hashCode() di Object, se due oggetti (o1 e o2) sono uguali (cioe o1.equals(o2) è true), allora devono produrre necessariamente lo stesso valore di hashCode. Tuttavia 2 oggetti che producono lo stesso valore di hashCode non sono necessariamente uguali.\r\n\r\nHashSet utilizza la prima proprietà \"al contrario\": se due oggetti hanno hashCode diversi, allora sono diversi. Se invece trova due hashCode uguali, allora chiama il metodo equals() per verificare se siano o meno uguali. Visto che hashCode() è (in teoria) computazionalmente meno dispendioso di equals(), questo meccanismo rende HashSet efficiente.\r\n\r\nSe non si riscrive il metodo hashCode per le nuove classi, esse lo ereditano da Object, che di default restituisce la locazione di memoria dove si trova l'oggetto. Quindi 2 oggetti che il programmatore considera uguali producono hashCode diverso e vengono considetari diversi da HashSet (anche se equals() \"dice\" che sono uguali).",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 4239,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 456,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perchè per confrontare due oggetti un HashSet, prima di chiamare il metodo \"equals\", esegue un controllo preliminare tramite il metodo \"hashCode\". \r\nTale metodo della classe Object (che può e deve naturalmente essere soggetto a un overraid) è in grado di stabilire meno dispendiosamente e più velocemente se due oggetti sono diversi. \r\nPertanto, dal momento che condizione necessaria affinchè due oggetti siano uguali secondo \"equals\" è che siano uguali secondo \"hashCode\", tale metodo deve essere riscritto in modo tale da permettere all'overraid di equals di funzionare come pianificato.\r\nEsiste anche la possibilità di riscrivere \"hashCode\" in modo tale che restituisca sempre un valore di verità al controllo, in modo da delegare al solo metodo \"equals\" il compito di confrontare gli oggetti desiderati. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4273,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 524,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In Java ogni classe che sovrascrive il metodo \"equals\" di \"Object\", deve anche sovrascrivere il metodo \"hashCode\" (sempre di \"Object\"). Nel caso non si fosse eseguito l'overriding di \"hashCode\" ma solo di \"equals\", si può incorrere nella violazione del contratto generale di \"Object.hashCode\", causando problemi inattesi quando la classe che reimplementa \"equals\" si trova a \"contatto\" con altre Collections basate su \"hash\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4126,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In base a quale criterio devo scegliere se implementare l'interfaccia Comparable o Comparator?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " compare"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4253,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 489,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Comparable e Comparator sono due interfacce che permettono di degli oggetti. La differenza sta nel fatto che mentre comparable confronta se stesso con un altro oggetto, comparator confronta due oggetti differenti. Infatti mentre si tratta di mettere a confronto due oggetti come due numeri interi si utilizzano gli operatori uguale, minore o maggiore, ma quando si devono confrontare due oggetti di una classe bisogna dire al calcolatore come fare a confrontarli.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4224,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 468,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Dipende da come intendi ordinare gli elementi, ad esempio l'interfaccia Comparable fornisce un ordine 'naturale' degli elementi. Se invece si preferisce gestire i criteri di ordinamento di è meglio implementare Comparator.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4164,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Visto che ogni insieme di oggetti può essere ordinato secondo criteri diversi, l'interfaccia Comparable si occupa di definire quale sia l'ordine naturale degli oggetti contenuti nella Collection, mentre l'interfaccia Comparator si occupa di definire arbitrari criteri differenti di ordinamento.\r\nA sottolineare questa differenza il metodo da implementare all'interno dell'interfaccia Comparable ha un nome fissato (nomeCollection.compareTo()) e si usa di default quando ordiniamo la collection (nomeCollection.sort()). Nell'interfaccia Comparator invece i nomi delle funzioni di ordinamento sono a discrezione del programmatore.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4209,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Non esiste un criterio univoco per decidere quale delle due interfaccie sia meglio usare, in quanto tale scelta è legata per lo più ad una preferenza di 'impostazione' del programma, piuttosto che ad una scelta qualitativa. Tuttavia bisogna tener conto che :\r\n\r\n-Implementando (in una classe) l'interfaccia Comparable e sovrascrivendo il metodo int compareTo(Object o) definisco una relazione d'ordine tra la classe e gli oggetti (Object).\r\n\r\n-Implementando (in una classe) l'interfaccia Comparator e sovrascrivendo il metodo int compare(T o1, T o2) definisco un \"comparatore\" tra due oggetti di tipo T. Anche in questo caso è compito del programmatore assicurarsi che la relazione così definita sia una relazione d'ordine(al fine di evitare output errati).  \r\n \r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4271,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 487,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "La decisione dipende soltanto dalle necessità del programmatore, se il confronto tra due classi é univoco allora si implementerà l'interfaccia Comparable che contiene soltanto il metodo compareTo, mentre se si vuole avere la possibilità di comparare due oggetti in più di un modo si deciderà di implementare l'interfaccia Comparator che ci permette di definire più volte il metodo compare, inoltre il metodo compareTo compara un classe con quella che chiama il metodo, mentre il metodo compare compara due oggetti che possono essere anche semplicemente legati con un legame di tipo ISA con la classe che chiama il metodo. ",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4203,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos`è il Hashcode?:)",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4165,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè si deve implementare il metodo hashCode in modo che restituisca sempre uno stesso valore per risolvere i problemi di una eventuale modifica del metodo equals()?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4241,
          "asker": {
            "courseId": 4,
            "askerId": 595,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzione il metodo equals() e quali sono le sue proprietà?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " identici-uguali"
            },
            {
              "keyword": " costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4159,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè non posso verificare l'uguaglianza tra due oggetti semplicemente con l'operatore == senza implementare il metodo Equals ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " operatore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4149,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perché il compilatore non sa come compararli mentre definendo il metodo equals spieghi come farlo.\r\nCome compareresti una carta? Punteggio o seme e numero?",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4206,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 503,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Per verificare l'uguaglianza tra 2 OGGETTI ho bisogno di un metodo, appunto il metodo Equals; l'operatore == invece serve per verificare l'uguaglianza di 2 tipi primitivi (booleani). ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4226,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Quando creo un nuovo oggetto con l'operatore new, devo ricordare che ciò che mi viene restituito è in realtà un puntatore all'oggetto creato. Per questo, se cerco di verificare l'uguaglianza tra due oggetti con l'operatore ==, sto in realtà verificando l'uguaglianza dei due puntatori (il che significa che, a meno che non puntino allo stesso oggetto, otterrò sempre \"false\"). Con il metodo equals della classe Object ottengo lo stesso risultato, quindi è necessario implementare un metodo Equals personale che verifichi, campo per campo, l'uguaglianza dei due oggetti.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4168,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Bisogna ricordare che il confronto con == è ottimamente valido solo per variabili di tipi primitivi (float, char, int, ...), per i quali si confronta il valore contenuto nelle variabili.\r\nAl contrario, nel caso degli oggetti, adoperando == viene confrontato l?indirizzo di memoria a cui i puntatori fanno riferimento: return(p2==p1) restituisce true solo se precedentemente è stata definita un'assegnazione p1=p2, che fa puntare entrambi allo stesso oggetto. == non vale infatti se, per esempio, definiamo due oggetti nello stesso modo per tutte le loro istanze (ad esempio, se creiamo due oggetti \"persona\" p1 e p2 con stesso nome e cognome). In questo caso infatti, return(p1==p2) darà false, perchè i due oggetti non si riferiscono alla stessa locazione di memoria. \r\nEquals, invece, permette di dire che due \"persone\" possono essere uguali anche se hanno lo stesso nome e/o cognome, a prescindere dalla locazione in memoria, poichè l'uguaglianza è definita dal programmatore. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4181,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "perchè l'operatore == verifica identità, invece il metodo equals quasi sempre verifica l'uguaglianza,però dipende da quello come lo implementiamo :)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4217,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Se non implementato diversamente attraverso un overriding, il metodo equals ha esattamente lo stesso comportamento dell'operatore ==; tutti e due infatti restituiscono true solo nel caso in cui i due identificatori su cui si effettua il confronto sono riferimenti allo stesso oggetto. Se si vuole utilizzare invece un criterio di confronto che identifichi due oggetti come uguali anche se non sono esattamente lo stesso è necessario fare un overriding nella propria classe del metodo equals di Object definendo qui il criterio da utilizzare per il confronto. E' importante implementare equals in modo che il criterio di confronto rispetti la proprietà riflessiva, la simmetrica e la transitiva, e che il risultato sia consistente (sempre uguale se applicato agli stessi oggetti). Perché il criterio abbia senso è inoltre necessario che equals restituisca false se si tenta di confrontare due istanze di classi diverse (o che appartengono a gerarchie di classi diverse, a seconda dell'occorrenza).",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4169,
          "asker": {
            "courseId": 4,
            "askerId": 440,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In che caso il metodo \"equals\" di object ritorna true?",
          "totalDifficultyLevel": 1,
          "totalInterestingnessLevel": 1,
          "totalRelevanceLevel": 3,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": "object"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4123,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra uguale e identico?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "uguale"
            },
            {
              "keyword": " identico"
            },
            {
              "keyword": " differenza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4177,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 511,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "uguale significa \"lo stesso valore\" o, in modo più astratto, equivalenti secondo una procedura definita nel metodo equals. identico significa avere lo stesso indirizzo di memoria e quindi puntare alla stessa cosa/oggetto.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4214,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Nella programmazione ad oggetti un oggetto si dice identico ad un altro se i due oggetti valutati sono il medesimo oggetto, ovvero a livello pratico se il loro indirizzo di memoria coincide. L'uguaglianza tra due oggetti invece è un concetto molto più flessibile, infatti due oggetti potrebbero essere uguali in un contesto e diversi in un altro, cosa impossibile per l'identicità. Si può quindi dire che l'uguaglianza dipende dal tipo di comparazione si effettua tra i due oggetti, cioè quale criterio di uguaglianza andiamo ad attuare tra gli oggetti. Ciò comporta quindi nella programmazione alla definizione di uno o più metodi di comparazione, al fine di poter così confrontare gli oggetti e sapere così se sono uguali per i nostri scopi o diversi, ed in caso anche poterli ordinare. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4158,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "come mai bisogna ridefinire il metodo equals all'interno della classe che definiamo ? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4241,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 595,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Perché potrebbe essere fonte di errore. Il metodo equals() può essere riferito a qualsiasi oggetto della classe, quindi è meglio definirlo prima di utilizzarlo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4263,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 458,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perchè se non ridefinito, si viene rimandati immediatamente all'equals della classe padre e in caso non sia ridefinito anche lì si arriva fino all'equals di Object che si basa sul principio di Identità.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4244,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perchè altrimenti viene utilizzato quello di Object che restituisce true solamente se due oggetti sono lo stesso oggetto, ovvero sono riferimenti alla stessa area di memoria. Questo criterio risulta solitamente troppo restrittivo, quindi solitamente viene ridefinito secondo le proprie esigenze.\r\n\r\nW la gnocca (rasata, cit marco)",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4267,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo equals definito nella classe Object verifica l'identità tra due oggetti. Si dice che due oggetti sono identici quando i rispettivi riferimenti sono uguali, ossia quando l'operatore == applicato a entrambi restituisce il valore true. Due oggetti possono però essere equivalenti e risultare comunque diversi all'operatore ==, per questo esiste il concetto di uguaglianza. In questo caso due oggetti equivalenti vengono considerati uguali, non limitandosi quindi a paragonare i riferimenti in memoria. Per verificare l'uguaglianza tra due oggetti è necessario ridefinire il metodo equals all'interno della classe che si vuole confrontare. Possono quindi esistere oggetti che non sono identici ma che sono equivalenti, questo solo dopo aver ridefinito il metodo equals in modo che restituisca true sulla base delle informazioni contenute negli oggetti piuttosto che sulla loro identità.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4180,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il metodo \"equals\" è definito nella classe object. Purtroppo dentro tale classe non è possibile sapere come confrontare due oggetti e dunque è necessario ridefinire il metodo all'interno della classe da noi definita. Questo può essere fatto confrontando un qualsiasi campo della classe (per esempio il nome o il cognome nel caso della classe Persona).",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4180,
          "asker": {
            "courseId": 4,
            "askerId": 552,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra Comparator e Comparator?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": "Comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4142,
          "asker": {
            "courseId": 4,
            "askerId": 432,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire il concetto di bashcode ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Hashcode"
            },
            {
              "keyword": " - "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4243,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 541,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Bash è una shell di unix, ma non vedo come questo possa ricollegarsi al nostro programma di Java. Per cui suppongo che tu volessi digitare hashcode e risponderò di conseguenza.\r\nIl metodo hashCode() restituisce un valore hash per un oggetto (è utilizzato ad esempio per creare le hashmap). Le sue caratteristiche sono:\r\n1) Una volta istanziato l?oggetto, il valore restituito da questo metodo deve essere consistente (non deve cambiare) se non cambiano i campi con cui viene calcolato. \r\n2) Istanze dello stesso oggetto su diverse esecuzioni dell?applicazioni devono invece restituire valori diversi. \r\n3) Se due oggetti sono dichiarati uguali dal metodo equals() allora la funzione hash deve restituire lo stesso valore (non è necessario il contrario, infatti questo metodo è preferito ad equals() quando si prevendono molti controlli, in caso di hash value differente so che gli oggetti sono diversi, se è uguale richiamo l'equals)",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4194,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 425,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Direi che il \"B\"ashcode in java non esiste.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4161,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 501,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "L' hascode è un metodo che viene usato come criterio di valutazione rapida da java quando deve decretare se due oggetti sono uguali.\r\nSostanzialmente manipola in qualche modo l' oggetto su cui è chiamato e restituisce un intero.\r\nSuccessivamente java guarda se i due interi ritornati dalle due chiamate di hascode sono uguali,se non lo sono gli oggetti sono senza dubbio diversi, altrimenti procede per accertarsi dell' uguaglianza nuovamente, questa volta usando il metodo equals.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4213,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 470,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "hashCode viene usato tipicamente nelle tabelle di hash come HashMap o Hashtable per confrontare le chiavi di ricerca. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4198,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Forse ti stai sbagliando, a lezione abbiamo affrontato il concetto di hashcode. (Il codice BASH è un interprete di comandi il quale ti permette di comunicare direttamente con il sistema operativo). Tornando all'hashcode, esso è un metodo presente in qualsiasi oggetto, in quanto ereditato da Java.lang.Object. L'implementazione nativa del metodo fornisce l'indirizzo di memoria dello stesso, o comunque una sua rappresentazione. In ogni caso si può fare l'override di hashCode() in modo tale da riportare dei valori conformi ad un certo tipo di oggetto. hashCode() viene utilizzato in concomitanza con equals(), in particolare la specifica dice che se due oggetti risultano 'equals' allora DEVONO avere anche lo stesso hashCode. La cosa comunque non è reciproca, semplicemente hasCode() può risultare essere uno strumento molto più veloce di equals per controllare che due oggetti siano uguali.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4149,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo agisce l'operatore equals per comparare due oggetti?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4184,
          "asker": {
            "courseId": 4,
            "askerId": 551,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene risolta la chiamata al metodo equals di un oggetto? Perchè è importante implementare una versione di equals in grado di prendere in considerazione la morfologia dell'oggetto stesso?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Uguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4196,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè per sovrascrivere il metodo equals della classe Object bisogna sovrascrivere anche il metodo hashCode?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Object"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4256,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 460,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Quando un programmatore scrive in Java (così come in qualsiasi altro linguaggio che rispetti le regole della progettazione a contratto del software) deve rispettare alcune regole ben precise: in particolare una di queste impone che, date 2 istanze qualunque a e b di una stessa classe, se a.equals(b) ritorna true allora deve valere a.hashCode() == b.hashCode(). Supponiamo che il metodo equals di tale classe sovrascriva quello di object ,e che ovviamente ne modifichi le relazioni fra input e output, altrimenti sarebbe inutile sovrascriverlo: allora diventa necessario sovrascrivere anche il metodo hashCode di Object, altrimenti non sarebbe più rispettata tale regola. Infatti qualsiasi modifica che conservi riflessività, simmetria ecc. del metodo equals di object determina condizioni più restringenti su hashCode, dato che di default equals di object restituisce true se e solo se la locazione di memoria dei 2 oggetti confrontati è la stessa e hashCode restituisce la locazione di memoria.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4210,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "perchè il metodo equals da solo non è in grado di stabilire a pieno se due oggetti sono identici",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4260,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo equals, contenente l'implementazione della definizione di uguaglianza tra due oggetti (variabile a seconda del contesto), risulta essere un metodo \"pesante\" dal punto di vista prestazionale. Per compensare tale \"aspetto negativo\" viene introdotto il metodo hashCode che, oltre a contenere un'ulteriore definizione di uguaglianza tra i due oggetti, ovvero un metodo diverso per stabilire l'uguaglianza tra essi (purché connesso al metodo equals (si ricordi l'esempio attinente alla verifica di uguaglianza di due stringhe)), risulta essere più efficiente dal punto di vista della perfomance.\r\nPertanto si deduce che, nel momento in cui si andrà a verificare l'uguaglianza tra due oggetti, verrà chiamato prima il metodo hashCode  e poi eventualmente il metodo equals. Infatti:\r\n- uguaglianza (dei due oggetti) nell' hashCode implica controllo dell'uguaglianza \r\nnell' equals.\r\n- disuguaglianza nell' hashCode (oggetti diversi) implica nessun controllo dell' uguaglianza nell' equals.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4147,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il metodo equals può essere potenzialmente molto lento; per questo motivo è stato aggiunto il metodo hashCode, la sua versione veloce ma imprecisa. Se due oggetti hanno hash diverso sono sicuramente diversi, altrimenti potrebbero essere uguali ed è quindi necessario ricorrere ad equals. Questo meccanismo è sfruttato da diverse librerie di java\r\n\r\nTL;DR per ragioni di efficienza ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4190,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Come descritto nella documentazione della classe Object: [locale, Medialab, Sun], il metodo equals deve implementare una relazione d'equivalenza sulle istanze di ogni classe, cioè una relazione riflessiva, simmetrica e transitiva (e deve soddisfare alcune altre proprietà).\r\nNella pratica, il metodo equals di una classe viene scritto in modo che l'invocazione <obj1>.equals(<obj2>) restituisce true quando gli oggetti <obj1> e <obj2> sono istanze della stessa classe e hanno uguale contenuto, cioè valori equivalenti per ogni variabile d'istanza.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4200,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 518,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Quando 2 oggetti risultano uguali in base a equals() allora anche i loro hash code devono essere uguali, quindi è buona norma, quando si sovrascrive equals(), sovrascrivere anche hashCode(), un metodo ereditato dalla superclasse Object.\r\nNella implementazione in Object, hashCode() restituisce un intero diverso per ogni oggetto ma in generale è possibile che oggetti diversi condividano lo stesso hash code anche se questo rende il codice meno efficiente.\r\nUn altro vantaggio nello sovrascrivere hashCode() è una più efficiente ricerca nelle Collections come HashMap o HashSet che usano l?hash code nella gestione degli oggetti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4175,
          "asker": {
            "courseId": 4,
            "askerId": 575,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa bisogna importare per usare le interfacce Comparator e Comparable? E qual è la sintassi per usarle?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": " Comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4211,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A differenza di un set una List permette di aggiungere due elementi identici ovvero con lo stesso identificatore. Qual è l'utilità di avere elementi identici in un lista?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "identico"
            },
            {
              "keyword": "uguale"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4239,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando due oggetti x e y si definiscono \"uguali\"?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "oggetto"
            },
            {
              "keyword": " uguale"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4153,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 445,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Si definiscono uguali quando entrambi hanno lo stesso valore ma non è necessario abbiano lo stesso indirizzo",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4231,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 517,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "In senso generale la definizione di uguaglianza tra due oggetti dipende dal contesto, i criteri e gli scopi. Quindi esiste un grado di arbitrarietà nel definirlo.\r\nIn particolare per il metodo equals() di object si dice che due oggetti sono uguali solo e soltanto se sono identici. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4266,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 516,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Vi sono due tipi di uguaglianze:\r\n\r\n- Uguaglianza superficiale: verifica se 2 riferimenti ad oggetto sono uguali (puntano allo stesso oggetto).\r\n- Uguaglianza profonda: verifica se gli oggetti, con le informazioni in essi contenute, sono uguali.\r\n  Se due oggetti sono uguali secondo equals() allora devono avere lo stesso codice di hash secondo hashCode(). Non necessariamente vale il contrario.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4223,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 480,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Due oggetti x e y possono essere definiti uguali secondo vari criteri.\r\nDi default gli oggetti sono confrontati tramite il metodo equals di Object che definisce due oggetti uguali solo se si i loro riferimenti sono uguali, ovvero se sono lo stesso oggetto. Questo criterio risulta solitamente troppo restrittivo, pertanto si usa ridefinire il metodo equals secondo criteri tipicamente situazionali (quando si ridefinisce il metodo equals è buona norma ridefinire anche il metodo hashcode).\r\nQuindi, riassumendo, non esiste una vera e propria risposta unica: dipende dall'utilizzo di x e y che il programmatore ha intenzione di implementare.",
              "notes": "-",
              "rating": 6,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4192,
          "asker": {
            "courseId": 4,
            "askerId": 501,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il java collection framework?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "framework"
            },
            {
              "keyword": "collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4137,
          "asker": {
            "courseId": 4,
            "askerId": 590,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Differenza fra uguaglianza e identicità spiegata in classe",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "uguaglianza "
            },
            {
              "keyword": " identicita"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4218,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo equals() ?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4229,
          "asker": {
            "courseId": 4,
            "askerId": 548,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché dovremmo utilizzare la classe comparator invece che estendere comparable che sarebbe un procedimento più immediato?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4209,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali modi si può ordinare una collection e quali sono le differenze tra loro?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " ordering"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4193,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo sono state introdotte le interfacce Comparator e Comparable in Java?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": " comparator"
            },
            {
              "keyword": " ordinamento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4153,
          "asker": {
            "courseId": 4,
            "askerId": 591,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando due elementi sono identici? e in base a che criterio si definiscono uguali? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4228,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "In java la comparazione tra due oggetti può definire due casi: quello in cui essi siano identici e quello in cui siano uguali. L'identicità è definita dalla proprietà di puntare alla stessa allocazione di memoria e si può verificare con l'operatore '=='. \r\nEs: oggetto1 == oggetto2\r\nL'uguaglianza si verifica invece implementando l'interfaccia comparable (o definendo un comparator) tramite il metodo equals: all'interno del suddetto metodo si devono infatti definire i criteri di congruenza degli oggetti (ad esempio si può scegliere di confrontare degli oggetti persona per proprietà nome e cognome, ignorando ad esempio l'indirizzo). Per la definizione dell'uguaglianza si può decidere anche di definire un metodo che ritorni un codice hash calcolato sull'oggetto: tramite questa tecnica infatti si possono confrontare gli oggetti semplicemente tramite il codice hash, senza dover confrontare ogni volta le singole proprietà.\r\nes: oggetto1.equals(oggetto2)",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4205,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 592,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Due elementi o istanze di una classe si definiscono uguali se è solo se i due oggetti possiedono gli stessi attributi che gli carraterizzano.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4225,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 499,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Nel linguaggio di programmazione due elementi si dicono identici quando sono lo stesso elemento, o meglio quando 'puntano' allo stesso oggetto (per verificare se gli elementi a1 e a2 sono identici si utilizza la scrittura 'a1==a2'). Invece con uguali si intende che i due elementi hanno delle medesime caratteristiche (scelte in modo appropriato e funzionale dal programmatore); quindi nella classe dell'elemento viene implementato il metodo boolean equals(elemento) che restituisce true se i due elementi (chiamante e chiamato) sono uguali e false altrimenti. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4272,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 477,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Due elementi sono identici se sono la stessa istanza dello stesso oggetto. Questo deriva dalla definizione di identità, ovvero la capacità di individuare univocamente una entità all'interno di un contesto.\r\nIn Java un'istanza di un oggetto è identica solo a sé stessa, dato che è sempre possibile distinguere se due oggetti sono la stessa istanza, confrontando i rispettivi identificatori. Se due identificatori fanno riferimento alla stessa istanza di un oggetto, questa sarà unica, e gli identificatori quindi saranno identici.\r\nPer stabilire se due entità sono uguali è possibile adottare vari criteri, in base alle circostanze in cui ci si trova. Di default Java considera uguali due oggetti identici, per garantire un criterio quanto più discriminante possibile.\r\nSarà compito del programmatore sovrascrivere il metodo \"equals\" di Object, implementando lui stesso i criteri di uguaglianza che vuole adottare, se questo comportamento non lo soddisfa.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4248,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 529,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "...",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4235,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 433,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Due elementi sono identici quando hanno la stessa identità, e l'identità identifica ogni elemento in modo univoco. Due elementi sono uguali, se hanno delle proprietà uguali tra di loro, in base a dei criteri che variano da situazione a situazione",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4223,
          "asker": {
            "courseId": 4,
            "askerId": 523,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Può la funzione equals(super) essere utilizzata per qualsiasi tipo di dati?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4243,
          "asker": {
            "courseId": 4,
            "askerId": 540,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi ad utilizzare l'interfaccia Comparator?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparator"
            },
            {
              "keyword": " interfaccia"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4120,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra il compare e il compareTo?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "compareto"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4225,
          "asker": {
            "courseId": 4,
            "askerId": 585,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in linguaggio java uguale è inteso come identico...? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "uguale"
            },
            {
              "keyword": " identico"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4204,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In Java un oggetto è definito uguale ad un altro quando entrambi, al loro interno, presentano le stesse informazioni. In un Hash-Set questo non è possibile.\r\nDue oggetti sono identici quando entrambi si riferiscono ad un unico oggetto, comune ad entrambi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4154,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Non sempre uguale è come identico! Dipende dal contesto in cui si analizza il codice in quanto l'operatore \"=\" può significare uguale in caso di variabili; per esempio (come nelle slide del profe):\r\np1.x = 1; p1.y = 2; //qui si intende la variabile x (o y) di p1 è uguale (=) a 1 (o 2)\r\n\r\nnel caso in cui si metta a confronto con = due oggetti, per esempio:\r\nP p1 = new P();\r\nP p2 = p1;\r\nin questo caso invece p1 e p2 sono IDENTICI in quanto si riferiscono allo stesso oggetto, come abbiamo visto in modo più che chiaro in classe con l'uso del grafico della memoria!\r\nDunque è importante fare attenzione a ciò che si considera per dire se un oggetto è uguale o identico.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4159,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 504,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Perchè in Java, due oggetti, per essere uguali, devono avere lo stesso indirizzo di memoria e quindi si parla di identicità(lo stesso oggetto), da cui il legame con identico.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4193,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 551,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "In realtà, in Java, i concetti di uguaglianza ed identità sono distinti: per verificare l'uguaglianza tra due oggetti ci si basa sulle implementazioni del metodo \"equals\", che, a discrezione del programmatore, possono prendere in considerazione proprietà specifiche dell'oggetto stesso. Tramite il concetto di \"identità\" invece, ci si chiede solamente se due oggetti siano in realtà lo stesso, unico oggetto all'interno della memoria.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4146,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per non creare confusione all interno di colections o tra le variabili per esempio.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4169,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 430,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In linguaggio Java parlando di operatori 'uguale' è inteso come 'identico' nel senso che l'operatore \"==\" che confronta i due membri come valori (valido nel caso si utilizzino tipi valore come int float etc.), non prende in considerazione l'uguaglianza semantica tra gli oggetti ma la loro identità come posizione in memoria. Per l'uguaglianza di tipo semantico (ad esempio due stringhe uguali ma in locazioni di memoria diverse) viene utilizzato il metodo d'istanza equals(object o) ereditato da Object e sovrascrivibile. :)",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4200,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo \"int compareTo(Object o)\" dell'interfaccia \"Comparable<T>\"",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "compareto"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4154,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il metodo equals(Object obj) della classe Object e compareTo(T o) dell'interfaccia Comparable prendono un solo input mentre il metodo compare(T o1, T o2) dell'interfaccia Comparator ne prende due?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " compareble"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4269,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 585,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perché mentre il metodo compare è una funzione che effettivamente mette a confronto due oggetti,le classi object e comparable non hanno tale incarico pratico e quindi gli si passa un solo oggetto.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4275,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "L'ordinamento imposto da un comparatore c su un insieme di elementi S si dice che sia coerente con uguali oggetti se e solo se c.compare (e1, e2) == 0 che ha lo stesso valore booleano di e1.equals (e2) per ogni e1 ed e2 in S. Nel primo caso restituisce un intero negativo, nullo o positivo se a1 è rispettivamente minore, uguale o maggiore; nel secondo caso restituisce true se è vera l'uguaglianza tra i due oggetti o false in caso contrario.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4240,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Sinceramente non so se c'è un motivo particolare se non per una differenza concettuale espressa già nel nome dell'interfaccia: un oggetto comparabile è in grado di confrontare se stesso con le altre istanze della classe, uno comparatore paragona due istanze differenti. In altre parole, contrariamente a compareTo, il metodo compare è creato per confrontare non istanze della sua classe ma istanze di altre classi.Ecco perché entrambi gli oggetti gli vengono passati come parametri espliciti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4235,
          "asker": {
            "courseId": 4,
            "askerId": 566,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra comparator e comparable?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": " Comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4230,
          "asker": {
            "courseId": 4,
            "askerId": 459,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve i metodo equals e perchè serve implementarlo nelle nostre calassi ?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "comparable"
            },
            {
              "keyword": "compare"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4183,
          "asker": {
            "courseId": 4,
            "askerId": 527,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'operatore \"==\"?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Comparator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4155,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 548,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il simbolo \"==\" viene utilizzato per confrontare 2 valori che possono essere numeri (es. int, float, etc..), caratteri o valori booleani (\"true\" o \"false\") e restituisce: \"true\" nel caso in cui i due operatori siano uguali e \"false\" in caso contrario, viene utilizzato soprattutto negli if es:\r\n\r\nif(var1 == var2){\r\n\t//codice che viene eseguito se var1 è uguale a var2\r\n}\r\n\r\nviene inoltre utilizzato anche nei cicli es:\r\n\r\nwhile(var1 == var2){\r\n\t//codice eseguito finchè var1 è ugule a var2\r\n}\r\n\r\npuò anche avere altre implementazioni ma sono poco utilizzate.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4199,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Invocando questo costrutto viene confrontato il valore contenuto nella variabile. Quindi, nel caso di tipi primitivi viene confrontato il valore vero, mentre nel caso di oggetti viene confrontato l?indirizzo di memoria a cui i puntatori fanno riferimento.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4247,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 447,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "L'operatore \"==\" serve per confrontare 2 elementi, tuttavia nella programmazione ad oggetti è importante precisare che l'uguaglianza con l'operatore \"==\" non è esattamente univoca poichè:\r\n \r\n-Se ad essere confrontati sono 2 oggetti l'operatore restituirà VERO ssse(se e soltanto se) i due oggetti sono IDENTICI cioè sono lo stesso oggetto!!!!!!!!!(in altre parole sono 2 riferimenti allo stesso oggetto) altrimenti restituiràm SEMPRE FALSO\r\n\r\n-Se ad essere onfrontati sono 2 oggetti di tipo primitivo l'operatore restituirà vero se hanno lo stesso valore (i numeri sono un  esempio di dato primitivo) \"2==2\" VERO\r\n ",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4236,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "L'operatore == serve per valutare se due riferimenti ad oggetti sono uguali o no ovvero se referenziano (puntano) allo stesso oggetto in memoria :)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4174,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 570,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "A verificare un'equivalenza",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4199,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché devo modificare anche la HashCode quando modifico la equals?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4189,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Possono due oggetti che non sono uguali avere lo stesso hashCode? Indicare anche il perchè.",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "->"
            },
            {
              "keyword": "no(<-)"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4237,
          "asker": {
            "courseId": 4,
            "askerId": 477,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile ordinare una Lista secondo più criteri, utilizzando vari Comparator e \"unendo\" appropriatamente i criteri di ordinamento di ciascuno?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4191,
          "asker": {
            "courseId": 4,
            "askerId": 517,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual sono i problemi di Comparable Interfaces e come possono essere risolti?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "problemi"
            },
            {
              "keyword": " Comparable Interfaces"
            },
            {
              "keyword": " risoluzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4155,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In una classe, perché potrebbe essere utile fare un overriding del metodo equals di Object?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4198,
          "asker": {
            "courseId": 4,
            "askerId": 518,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale comodità comporta di fatto l'uso delle collection ?!",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "comodità"
            },
            {
              "keyword": "uso"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4152,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega le differenze fra Comparable e Comparator.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparable"
            },
            {
              "keyword": " Comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4130,
          "asker": {
            "courseId": 4,
            "askerId": 444,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare le proprietà di equals e la sua relazione con hashCode",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4216,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "In breve l' equals() è un metodo definito nella classe Object che permette di stabilire se due oggetti sono uguali (non solo identici). Si avvale del metodo hashCode() che genera una firma caratteristica di ogni oggetto per ridurre il carico di lavoro di una comparazione totale. \r\n\r\nIl metodo equals() è di tipo booleano e ritorna true o false a seconda se due oggetti possono essere considerati uguali rispetto alle esigenze del programmatore che lo sovrascrive. Si lascia la completa libertà di definizione al programmatore ma per convenzione si richiede che questo metodo sia:\r\n-Riflessivo (a=a sempre)\r\n-Simmetrico( se a=b allora b=a)\r\n-Transitivo (se a=b e b=c allora a=c)\r\nL'hashCode è una variabile d'istanza INT contenuta in ogni oggetto (deriva da Object) e viene comparata dal compilatore prima di ogni equals. Si tratta infatti di una sorta di firma caratteristica di un oggetto (per esempio derivata dalle sue variabili) e la loro comparazione è molto più leggera per la cpu. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4176,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "le proprietà di equals sono:",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4250,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Le proprietà che devono necessariamente valere per equals sono:\r\n-riflessività, cioè x.equals(x) deve essere sempre vero;\r\n-simmetria, cioè x.equals(y) è vero se e soltanto se y.equals(x) è vero;\r\n-transitività, cioè se x.equals(y) e y.equals(z) sono entrambi veri, allora anche x.equals(z) è vero;\r\n-costanza, cioè x.equals(y) deve dare sempre lo stesso risultato, indipendetemente da quante volte lo chiamo;\r\n-x.equals(y), se y è uguale a \"null\", deve restituire falso.\r\n\r\nLa relazione con hashCode deve prevedere che se un equals è vero, allora anche il corrispondente hashcode deve esserlo; mentre se un hashCode è vero, non necessariamente lo è anche l'equals.\r\nInfatti l'hashCode è un primo controllo (di solito computazionalmente molto veloce) che viene effettuato quando è chiamato l'equals: se risulta \"true\", allora viene effettuato anche il controllo equals, altrimenti viene restituito direttamente \"false\".",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 4158,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Il metodo equals deve rispettare le seguenti proprietà:\r\n- riflessività: per qualsiasi oggetto x, x.equals(x) deve ritornare true.\r\n- simmetria: per qualsiasi oggetto x e y, se y.equals(x) ritorna true allora anche x.equals(y) deve ritornare true.\r\n- transitività: per qualsiasi oggetto x, y e z, se x.equals(y) e y.equals(z) ritornano true allora anche x.equals(z) devono ritornare true.\r\n- consistenza: per qualsiasi oggetto x e y, più chiamate di x.equals(y) devono ritornare tutte lo stesso risultato (true o false).\r\n\r\nIl metodo equals è legato ad hashCode in quanto entità come le Collection Set solitamente chiamano il metodo hashCode per verificare l'uguaglianza tra 2 oggetti. Il metodo hashCode a sua volta, se reputa i 2 oggetti uguali, per avere una conferma definitiva chiama il metodo equals che confermerà o negerà l'uguaglianza.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4203,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 557,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo equals controlla se l'oggetto passato come argomento \"equivale\" all'oggetto sul quale questo metodo viene invocato. L'implementazione predefinita di equals nella classe Object controlla semplicemente che i due identificatori (quello su cui viene chiamato e quello in argomento) si riferiscano allo stesso oggetto; in altre sottoclassi il metodo equals viene sovrascritto (override) in modo da essere via via più specifico in base alla classe su cui viene chiamato.\r\nEquals è legato all'hashCode di ogni oggetto (un int legato all'oggetto secondo un criterio dipendente dalla sua classe): infatti se il metodo equals dà risultato positivo ciò implica che gli hashCode dei due oggetti siano uguali, ma non è vero il viceversa.\r\nDa ciò ne deriva che, se in una nostra classe vogliamo fare un override del metodo equals, è necessario ridefinire anche l'hashCode degli oggetti di tale classe, in modo da preservare la relazione di cui sopra.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4217,
          "asker": {
            "courseId": 4,
            "askerId": 478,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa può serivire implementare il metodo compare dell'iterfaccia Compare anzichè il compareTo dell'interfaccia Comparator?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " sort"
            },
            {
              "keyword": " natural sort"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4228,
          "asker": {
            "courseId": 4,
            "askerId": 489,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come dev'essere implementato il metodo equal?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equal"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4202,
          "asker": {
            "courseId": 4,
            "askerId": 488,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come faccio a determinare il metodo di comparazione tra oggetti?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparazione"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4168,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi brevemente in cosa consiste un metodo \"comparatore\".",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "descrivi"
            },
            {
              "keyword": " comparatore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4176,
          "asker": {
            "courseId": 4,
            "askerId": 567,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale differenza vi è tra il metodo \"Equals\" e l'operatore \"==\"?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4125,
          "asker": {
            "courseId": 4,
            "askerId": 563,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Fare un breve confronto tra Comparator e Comparable.",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparator"
            },
            {
              "keyword": " Comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4246,
          "asker": {
            "courseId": 4,
            "askerId": 570,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In che occasioni conviene utilizzare set piuttosto che list?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": " List"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4188,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali problemi legati al metodo equals?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " problemi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4190,
          "asker": {
            "courseId": 4,
            "askerId": 461,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè l'implicazione a.hashcode()==b.hashCode()=>a.equals(b) (true) non è corretta?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "hashCode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4245,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Spero di aver \"interpretato\" correttamente la domanda...\r\nL'implicazione scritta non è corretta perchè il confronto di due oggetti in Java avviene tramite equals e un confronto tra gli hashcode non è la stessa cosa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4182,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "L'implicazione non è corretta perchè a e b sono due oggetti diversi, e quindi i loro hash code sono calcolati in modi diversi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4262,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 478,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "L'implicazione non è vera perchè due oggetti a e b diversi possono avere lo stesso hashCode (non è univoco). Per esempio se calcolo la hash di una stringa sommando il valore di ogni carattere ASCII che la compone, la stringa ciao avrà la stessa hash di un'altra parola composta da stesse lettere ma rimescolate: ad esempio \"oaic\". (esempio simile a quello visto in aula).\r\nL'unica implicazione vera è che se due oggetti hanno hashCode differenti, sicuramente saranno diversi.\r\nSe invece hanno stesso hashCode allora POTREBBE trattarsi di oggetti uguali ma siccome l'hascode non è univoco la cosa non è garantita. \r\nPer questo motivo il metodo hashcode è comodissimo per verificare se due oggetti sono diversi poichè è molto veloce, ma per verificare l'ugualglianza bisogna sempre ricorrere al metodo equals (o metodi equivalenti come ad esempio il compareTo)",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4156,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "L'implicazione non è corretta perché oggetti diversi, definiti tali da una reimplementazione del metodo equals(), possono condividere lo stesso hash code, che restituisce un intero per ogni oggetto diverso. E' vero invece il contrario, cioè, se due oggetti risultano uguali in base al metodo equals(), allora devono avere anche lo stesso hash code.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4201,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "...",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4229,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Non è detto che sia vera perché dipende da come definiamo i metodi. Quando facciamo l'overriding l'importante è rispettare le proprietà richieste nella documentazione ufficiale.\r\nSe per esempio per la classe P definiamo\r\nclass P {\r\nint x; int y;\r\n\r\npublic boolean equals(Object var){\r\nif (!(var instanceof P)) return false;\r\nif(var==null) return false;\r\nreturn (x==((P)var).x && y=((P)var).y)\r\n}\r\npublic int hashCode(){\r\nreturn x+y;\r\n}\r\n}\r\nQuesta definizione rispetta le proprietà richieste ad equals(vedi slide 23) e hashCode() (è consistente e per ogni a,b della classe P a.equals(b)==true  <=>  a.hashCode()==b.hashCode()).\r\nMa se prendiamo a=(2,3) b=(4,1) a.hashCode==b.hashCode ritorna true mentre a.equals(b) è falsa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4172,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "parla delle struct",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4204,
          "asker": {
            "courseId": 4,
            "askerId": 537,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè durante un override del metodo Object.equals bisogna preferibilmente effettuare anche l'override del metodo Object.hashCode ?? \r\n ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "implicazione"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4177,
          "asker": {
            "courseId": 4,
            "askerId": 572,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il metodo equals e perchè a volte va ridefinito?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4151,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando dichiarò la funzione equals posso omettere la haschCode e cosa comporta ciò nell'esecuzione del programma??",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "HaschCode "
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4226,
          "asker": {
            "courseId": 4,
            "askerId": 505,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile usare il comparatore == su oggetti?Se si, in quale condizioni potrebbe essere piu' comodo usarlo al posto del comparatore equals?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " =="
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4160,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "innanzitutto voglio dire subito che non sono sicuro di questa risposta. in ogni caso credo sia possibile utilizzare il comparatore ==,ma non credo che faccia quello che tu vuoi. infatti == dovrebbe comparare gli indirizzi contenuti all'interno dei puntatori che si sta eguagliando. finche si parla di c++ o comunque linguaggi che supportano l'operator overloading, allora == compara gli oggetti in se, ma dato che questa funzionalità non è implementata in java l'unico effetto che mi viene in mente è l'uguagliare gli indirizzi. questo può comunque esser utile, perche si riescono a riconoscere oggetti identici(cioè se sono lo stesso oggetto), ma non oggetti uguali",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4249,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "L'operatore == si può usare su gli oggetti ma serve solo a confrontare due indirizzi di memoria riferiti a essi, quindi  se  metto a confronto due oggetti che sono dello stesso tipo e  che hanno tutti gli attributi identici , l'operatore restituirà falso. \r\nL'operatore equals invece da la possibilità al programmatore di decidere il significato di uguale,(ad esempio due automobili sono uguali se hanno lo stesso colore) stabilendo gli opportuni criteri. \r\nQuindi a parer mio l'operatore == non potrà quasi mai sostituire l'operatore equals , in quanto svolgono due lavori totalmente differenti, infatti l'unico caso in cui l'operatore == può sostituire equals è quando quest'ultimo emula il primo e ciò è privo di senso.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4191,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Si' e' possibile usare l'operatore == fra oggetti, ma e' necessario prestare attenzione. Siano o1 e o2 2 istanze della classe A. Quando scrivo o1==o2 non sto richiamando la equals di A ma semplicemente confrontando i 2 identificatori, quindi tale operazione restituira' true se e solo se o1 e o2 si riferiscono allo stesso oggetto (stessa area di memoria), quindi la stessa cosa che fa il metodo equals di Object. Se desideriamo un metodo che confronti le variabili di istanza di due oggetti secondo determinati criteri e ci dica se (secondo questi criteri) i due oggetti sono uguali e' compito di colui che implementa la classe A dotarla di un metodo equals opportuno.\r\nRiassumendo l'operatore == come il metodo equals di Object restitusce true nel caso piu' restrittivo possibile: se e solo se i 2 identificatori si riferiscono allo stesso oggetto in memoria. La comodita' nell'usare un metodo piuttosto che l'altro dipende dai nostri fini: dipende da cio' che vogliamo considerare come \"uguale\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4218,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 495,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Da un punto di vista prettamente semantico è possibile usare l'operatore == sugli oggetti, il ché significa che il compilatore lo permette. Esso non assolve, però, all'operazione logica che uno si aspetta, in quanto controlla unicamente che due oggetti siano effettivamente lo stesso o, per meglio dire, controlla che due identificatori puntino allo stesso oggetto, vanificando il concetto di \"uguaglianza\" tra oggetti nella logica del programmatore. Nonostante ciò non è completamente inutile in quanto può essere utilizzato per controllare quanti identificatori puntano ad un oggetto in modo tale da rendersi conto di quante \"copie\" noi stiamo facendo di un certo oggetto (tra virgolette perchè in realtà non sono copie dell'oggetto ma del suo indirizzo). Ad esempio questo può essere utile nel tener conto di quanti riferimenti ci sono ad un oggetto per poter prevedere il comportamento del garbage collector: se lo butterà via durante la sua esecuzione oppure no.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4238,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 428,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "...",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4222,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Si, il comparatore '==' si puo' usare sugli oggetti e restituisce true se i due oggetti confrontati hanno lo stesso identificatore. Utilizzare '==' o equals e' del tutto equivalente. Cosa serve allora equals? Serve per implementare un proprio equals a seconda delle esigenze di programmazione. Vedi l'esempio a pag. 16 delle slide",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4166,
          "asker": {
            "courseId": 4,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo hashcode()? In che modo è correlato con il metodo equals()?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4116,
          "asker": {
            "courseId": 4,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Se ho un oggetto B che estende un oggetto A e l'oggetto A ha implementato il metodo equals, vale anche per l'oggetto B?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4151,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Se una classe B estende la classe A:\r\n\r\n- B eredita tutte le variabili ed i metodi d?istanza di A (a meno di overriding)\r\n- puo? accedere a tutte le variabili e ai metodi statici di A\r\n\r\nquindi in conclusione l'oggetto B eredita dall'oggetto A il metodo equals.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4186,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 469,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il compilatore andrà a controllare se il metodo è definito in B e se non lo trova andrà alla superclasse A siccome in A e' definito il compilatore utilizzerà il metodo equals di A il quale implementa il metodo di object.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4170,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La classe B, come tutte le classi (poichè in Java tutto è un Object), avrà sicuramente un metodo equals[inoltre ridefinendo il metodo equals si esegue un OVERLOADING cioè stesso nome ma firma differente]. Più in specifico se all'interno della classe B viene chiamato il metodo equals esso (se non ridefinito propriamente all'interno di B) verrà ricercato \"SCALANDO\" la catena di ereditarietà fino a quando non ne verrà trovato uno adeguato. Per esempio se ho definito un metodo equals per una classe Point: P1(x,y) nel quale paragono l'effettivo valore\r\n(x==((P)var).x && y=((P)var).y) [in questo caso la P si riferisce a quella del costruttore]\r\nse ora volessi paragonare due Point3D[sottoclasse di Point]: P2(x,y,z) P3(x,y,z)\r\nil metodo equals al quale si riferisce Point3D è quello di Point. Esso però mantiene semplicemente il paragone tra \"x\" e \"y\" quindi se P2 e P3 differissero solamente per il valore della \"z\" P2 e P3 sarebbero uguali.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4192,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 429,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "...",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4197,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "si si va bene <3.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4133,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "E' equivalente definire due oggetti uguali oppure identici? Perchè?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Uguali"
            },
            {
              "keyword": " identici"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4170,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo i set si chiamano Hashset?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": "Hashset"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4224,
          "asker": {
            "courseId": 4,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le proprietà di equals in java?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparator"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4214,
          "asker": {
            "courseId": 4,
            "askerId": 524,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il metodo \"equals\" della classe \"Object\"? E' possibile fare l'overriding di tale metodo? Se sì, come?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4129,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona e a cosa serve hashCode?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashCode"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4167,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 439,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "¿Il metodo hashCode(), presente esplicitamente o implicitamente in ogni classe, elabora i contenuti memorizzati nell'istanza di una classe e restituisce un hash a 32bit.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4233,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 540,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Il metodo hashCode() è fortemente legato al metodo equals(). Questo metodo restituisce un intero che rappresenta un codice hash per l'oggetto che verrà passato. Se due oggetti sono uguali per il metodo equals anche l'hashCode dovrà restituire per entrambi due valori uguali.\r\nQuesto metodo viene utilizzato nel caso di collection basate su hashTable (per esempio HashMap e HashSet) e il valore fornito serve alla collezione inizialmente per trovare il \"bucket\" all'interno della hashTable in cui inserire/trovare un elemento.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4251,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 461,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "hashCode() è un metodo che ogni classe eredita do Object, che serve a confrontare due oggetti e dire se sono uguali. Questo metodo confronta i due valori degli oggetti, ovvero guarda se sono uguali (n.b. non identici). Inoltre dal fatto che equals() implica hashCode() e non vale il viceversa si puo' dedurre che due oggetti non uguali secondo equals() (ovvero non identici), posso lo stesso avere lo stesso valore di hashCode().",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4234,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "hashCode() è un metodo presente in ogni classe in Java, in quanto parte di Object. Le applicazioni sono molteplici, ma l'idea è questa: per mezzo di un algoritmo di hashing, genero, a partire da un oggetto, un numero che me lo identifica univocamente in base al valore che possiede (in Java, un numero a 32bit). Importante notare che non è proprio univoco (ha solo 2^32 possibili valori), ma usando un buon algoritmo si possono evidenziare le piccole differenze e ridurne le ambiguità. È la stessa logica degli algoritmi di checksum MD5 e SHA1.\r\nUn esempio di applicazione sono i \"dizionari\": array che, invece di indicare l'offset dal puntatore per individuare una certa area di memoria, utilizzano le stringhe. Grazie all'hashcode, è possibile ottenerne l'offset usando la stringa identificativa dell'area di memoria. O ancora: per confrontare molte stringhe, invece di attraversarle iterandole, confronto i loro hashcode.\r\nPer l'implementazione di hashCode() per le stringhe, vedi bit.ly/ QarqCn",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4175,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 542,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "hashCode permette di controllare se due oggetti sono diversi senza usare la equals, assegnando ad un oggetto un intero, secondo un determinato algoritmo, in modo che ad oggetti uguali venga assegnato lo stesso intero, in questo modo, se due oggetti avessero diverso hashCode, questi sarebbero automaticamente diversi. Tuttavia questo meccanismo può assegnare a due oggetti diversi uno stesso hashCode, perciò non può sostituire la equals. Statisticamente parlando, però, è molto probabile che oggetti diversi abbiano hashCode diverso, se l'algoritmo che lo crea è studiato intelligentemente. Per questo, e per il fatto che la equals di un oggetto è generalmente molto più complicata del semplice confronto di due interi, conviene costruire questa funzione per risparmiare tempo nei calcoli al run time.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4152,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "HashCode è un metodo che restituisce un valore hash per un oggetto. \r\nServe, una volta istanziato un oggetto, ad avere un valore di hash che rimane uguale, a meno che non cambino i campi in cui viene calcolato. \r\nE' usato in molti ambiti, ad esempio nelle hashmap.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4194,
          "asker": {
            "courseId": 4,
            "askerId": 473,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che vantaggi ci sono ad implementare l'interfaccia Comparable?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4245,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "quando due oggetti sono in una classe dove nessun metodo equals per compararli è stato scritto quale criterio viene utilizzato dal sistema e perché?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "object"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4165,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 467,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Se usi equals senza fare l'override viene utilizzato l'equals di object che controlla se i due oggetti hanno lo stesso indirizzo di memoria.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4187,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "nel bel mezzo",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4189,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 520,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Viene utilizzata la equals di Object, perché è il metodo più generico possibile.\r\nLa equals di Object verifica l'identità, ovvero controlla che si stia comparando un oggetto con se stesso. La equals restituisce quindi true se e solo se l'operatore == restituisce true.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4257,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 593,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Non sono in grado di rispondere alla domanda.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4220,
          "asker": {
            "courseId": 4,
            "askerId": 576,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'interfaccia Comparable?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 3,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparable"
            },
            {
              "keyword": " interfaccia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4233,
          "asker": {
            "courseId": 4,
            "askerId": 593,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè map non può contenere chiavi duplicate?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "map"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4219,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Poiché lo scopo delle Maps è quello di non contenere chiavi duplicate. I dati contenuti nelle Maps sono indicizzati tramite chiave e valore. Ogni chiave ha al massimo un valore.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4242,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 547,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Una mappa è una collezione di oggetti che memorizza coppie chiave/oggetto e ha lo scopo di agevolare inserimento e ricerca di elementi, quindi è naturale che non si possano avere due chiavi uguali per oggetti diversi, ci sarebbe un'ambiguità non risolvibile e si perderebbe il senso di avere un'oggetto strutturato come la  mappa.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4227,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 523,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perché sono identici...",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4195,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 459,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Per il modo in cui è progettata  quella collection",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4185,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Perchè associa una chiave a dei valori, sarebbe come avere due valori [0] per un array",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4244,
          "asker": {
            "courseId": 4,
            "askerId": 545,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè nella slide 3 l'output è \"3 3 2 1\" e non \"3 2 3 1\"?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "output"
            },
            {
              "keyword": " 3"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4259,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 566,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "L'output è \"3 3 2 1\" perchè l'ArrayList ordina gli elementi inseriti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4202,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 479,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "perchè è così che funziona il programma",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4207,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "perchè nella slide prima si sottolinea come questo sia l'output proveniente da una stack che estende un hashset e quindi non si preserva l'ordine di estrazione. Nonostante sia un set (e quindi non dovrebbero esserci ripetizioni) il 3 compare 2 volte perchè il metodo equals è quello della classe object che verifica solo se 2 oggetti sono identici (ovvero occupano lo stesso indirizzo di memoria). ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4196,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 590,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Dalla slide:\r\npublic static void main(String[] args) { \r\n    Stack s=new Coda(); \r\n    s.inserisci(3);  s.inserisci(2); \r\n    s.inserisci(3);  s.inserisci(1); \r\n    for (int k=0;k<=4;k++) { \r\n       int v=s.estrai(); \r\n       System.out.println(v);  } \r\n } \r\n\r\nil risultato corretto 3 2 3 1, Ronchetti si è sbagliato",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4178,
          "asker": {
            "courseId": 4,
            "askerId": 592,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il metodo, delle istanze di classi, che ci permette di confrontarli tra di loro e stabilire   qual elemento è maggiore tra i considerati?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparator"
            },
            {
              "keyword": "comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4115,
          "asker": {
            "courseId": 4,
            "askerId": 541,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere le differenze tra il metodo equals() e l'operatore ==",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " uguaglianza"
            },
            {
              "keyword": " operatore =="
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4261,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 422,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "In Java, == compara solo due riferimenti (per gli oggetti non primitivi così è) - per esempio controlla se i due operandi si riferiscono allo stesso oggetto.\r\n\r\nAl contrario, il metodo equals() può essere \"overridden\" - così che due oggetti differenti possono essere di nuovo equivalenti (\"a.equals(b)\").\r\n\r\nPer esempio:\r\n\r\nString x = \"hello\";\r\nString y = new String(new char[] { 'h', 'e', 'l', 'l', 'o' });\r\n\r\nSystem.out.println(x == y); // false\r\nSystem.out.println(x.equals(y)); // true\r\n\r\nInoltre è buona cosa sapere che qualsiasi due stringhe costanti (prima di tutte, quelle indicate tra \"\", dette literals, ma anche combinazione di esse) finiscono nel riferirsi allo stesso oggetto. Esempio:\r\n\r\nString x = \"hello\";\r\nString y = \"he\" + \"llo\";\r\nSystem.out.println(x == y); // true!\r\n\r\nQui x e y sono riferimenti alla stessa stringa, perché y è una costante che equivale a \"hello\" ed è noto a compile-time.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4254,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "L'operatore == in Java è utilizzato principalmente per i tipi di dato primitivi.\r\nSupponendo di avere due oggetti da confrontare, scrivere semplicemente (X == Y) non verificherà l'uguaglianza tra le due istanze, ma tra i due riferimenti (X e Y) delle stesse!\r\nRicordando che un riferimento in Java può essere paragonato (si comporta in modo simile) ad un puntatore C/C++, con (X == Y) è come se verificassimo se X e Y si riferiscano (puntassero) alla stessa area di memoria (della medesima istanza).\r\nPoiché due istanze sono allocate sicuramente in due aree di memoria differenti, il confronto risulterà, nella maggior parte dei casi, sempre falso, anche se i valori delle istanze sono identici.\r\nPer risolvere questo inconveniente sul confronto degli oggetti, si è implementato il metodo equals(), che ogni classe può ridefinire a piacere (overriding), al fine di confrontare due oggetti così come ci si aspetterebbe siano paragonati.\r\nNotare che equals() della classe Object è pari al semplice ==",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4183,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 466,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Il metodo equals è un metodo di Object che verifica se due classi sono uguali, ma essendo la firma di equals un object equals è in grado di fare confronti solo su classi.\r\nL'operatore == verifica invece l'uguaglianza di primitivi, che non sono alcun tipo di classi.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4148,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 563,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Invocando l'operatore == viene confrontato il valore contenuto nella variabile, di conseguenza, nel caso di tipi primitivi, viene confrontato il valore vero, mentre nel caso di oggetti viene confrontato l?indirizzo di memoria a cui i puntatori fanno riferimento. Il metodo equals, invece, confronta gli oggetti puntati entrando quindi in merito al contenuto dell?oggetto. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4173,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 496,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo equals è un metodo della classe object, che in quanto tale viene ereditato da ogni classe. Esso permette di confrontare due oggetti e restituisce true se i due oggetti sono \"uguali\" altrimenti false.L' \"==\" è invece un operatore, e può invece essere applicato a elementi di base, come gli int, i float, i char ecc... ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4206,
          "asker": {
            "courseId": 4,
            "askerId": 516,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è lo scopo del metodo Equals() ?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Metodo"
            },
            {
              "keyword": " Equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4146,
          "asker": {
            "courseId": 4,
            "askerId": 437,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra HashMap e TreeMap?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Map "
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4163,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra equals() e hashCode() ?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": "hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4215,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 454,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "I metodi equals() e hashCode() sono due metodi della classe java.lang.Object che vengono usati per confrontare l'uguaglianza tra oggetti. In particolare, il metodo Equals() restituisce 'true' se due ogetti hanno lo stesso indirizzo; il metodo hashCode() invece ritorna un valore di codice hash per l'oggetto.\r\nQuando si sovrascrive il metodo equals() bisogna sovrascrivere anche il metodo hashCode() per soddisfare il contratto generale per Object.hashCode. La principale differenza tra i due metodi sta nel fatto che c1.equals(c2) implica che \r\nc1.hashCode()==c2.hashCode(), mentre il viceversa non funziona; il metodo hashCode() è necessario ma non sufficiente per il confronto.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4166,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Hashcode basa il sistema di riconoscimento delle uguaglianze in base a un numero identificativo univoco che viene confrontato.ad ogni elemento viene assegnato un valore che viene confrontato quando serve. Nel caso di equals invece vengono confrontati direttamente i valori. Per cui si avrà un solo valore, a differenza dell'hashcode in cui si potranno trovare anche dei duplicati, se sono stati inseriti",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4268,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 505,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "La equals di default(di Object) da sempre false se i due oggetti non sono identici(perchè controlla se fanno riferimento alla stessa zona di memoria) mentre hashcode mette a confronto due valori generati alla creazione dell'oggetto e che cambia in base al valore degli attributi dello stesso.\r\nComunque entrambi i metodi possono essere sovrascritti e implementati a piacimento.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4157,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "hashCode di solito viene usato per confrontare chiavi di ricerca mentre equals viene usato per verificare se due oggetti sono uguali. \r\nI due sono \"legati\" tra loro perchè se si fa l'override di Equals bisogna farlo anche per hashCode, in modo coerente a come si è fatto quello di Equals altrimenti non avrebbe senso.\r\nQuindi, se due oggetti sono uguali per Equals allora anche i loro hash devono essere uguali e viceversa, anche se, se due oggetti sono diversi possono avere hashCode uguali.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4207,
          "asker": {
            "courseId": 4,
            "askerId": 573,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le proprietà del metodo equals?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equal"
            },
            {
              "keyword": " proprietà"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4131,
          "asker": {
            "courseId": 4,
            "askerId": 486,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nel ridefinire il metodo equals della classe Object è necessario ridefinire il metodo hashCode della classe stessa?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Object"
            },
            {
              "keyword": "equals"
            },
            {
              "keyword": "hashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4147,
          "asker": {
            "courseId": 4,
            "askerId": 434,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Se viene definito correttamente, il metodo getHash permette di aumentare la velocità di confronto tra due oggetti definiti da un programmatore?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hash"
            },
            {
              "keyword": "oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4136,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve eseguire un override oppure un overloading del metodo equals (Object obj) della classe Object ?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " comparazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4114,
          "asker": {
            "courseId": 4,
            "askerId": 497,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'importante compito che svolge la funzione \"equals\" e quali complicazioni comporta?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " problemi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4195,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è implementata la hashCode di Object?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashCode"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4127,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra il metodo equals e il metodo comparator ?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4148,
          "asker": {
            "courseId": 4,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire due elementi uguali o identici equivale a dire la stessa cosa? Se è' no motivare la risposta.",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Uguale"
            },
            {
              "keyword": " identico"
            },
            {
              "keyword": " comparatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4164,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Esistono degli standard per l'utilizzo dell'operatore equals?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4232,
          "asker": {
            "courseId": 4,
            "askerId": 558,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "¿Come fa Java a sapere come rimettere in ordine un oggetto usando il metodo Comparable?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ordinamento"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4117,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra comparable e comparator? In che modo si utilizzano in una data classe?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable "
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4185,
          "asker": {
            "courseId": 4,
            "askerId": 584,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Sottolineare le differenze tra le firme dei metodi compare() e compareTo(), indicando il diverso modo di ordinazione delle interfacce a cui appartengono i metodi. ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodi"
            },
            {
              "keyword": " interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4186,
          "asker": {
            "courseId": 4,
            "askerId": 463,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "In una classe C definisco il metodo equals(C var) che se chiamato da un oggetto c di classe C lo confronta, secondo un certo criterio consistente e d'equivalenza, con un secondo oggetto di classe C. \r\nChe succede se faccio c.equals(qualcosa), dove qualcosa è un oggetto di una classe diversa da c?? \r\n",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " object"
            },
            {
              "keyword": " IsA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4181,
          "asker": {
            "courseId": 4,
            "askerId": 555,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa significa che due oggetti sono uguali? E che due oggetti sono identici? Qual è la differenza tra questi due concetti?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "uguaglianza"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4240,
          "asker": {
            "courseId": 4,
            "askerId": 448,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve estendere la classe Comparable?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4238,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Per cosa viene utilizzata l'interfaccia COMPARABLE?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": " interfaccia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4173,
          "asker": {
            "courseId": 4,
            "askerId": 511,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si parla di overriding e quando di overloading del metodo equals? quale dei 2 è altamente consigliato e perchè?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " overriding"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4258,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Si parla di overloading del motodo equals quando si definisce un altro metodo equals nella classe Object (la classe in cui è definito il metodo equals \"originale\"), mentre si parla di overriding quando si ridefinisce il metodo equals in una classe figlio di Object (ereditando le caratteristiche del metodo originale).\r\nIn entrambi i casi lo scopo è adattare il metodo equals alle nostre esigenze, renderlo meno generale e più specializzato; tuttavia è fortemente sconsigliato utilizzare l'overloading perché, al momento della chiamata, di default viene utilizzato il metodo originale, a meno di che non vi siano precise e corrette disposizioni (non è banale).\r\nInvece, utilizzando l'overriding, si è sicuri che il metodo equals chiamato nella classe figlio sia quello ridefinito, rendendo quindi la chiamata più comoda e soprattutto più sicura. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4221,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 531,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Si parla di overloading se viene cambiata la firm del metodo mentre di override quando viene modificata la definizione del metodo mantenendo la stessa firma. Nel caso di equals è consigliato usare l'override per poter specificare quando consideriamo due oggetti uguali in base ai loro attributi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4255,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Nel metodo equals e anche in generale si parla di overloading quando si ha nome diverso ma la firma è uguale mentre nell' overriding sovrascrive esattamente un metodo della superclasse. Ecco perchè nel metodo equals è meglio l'overriding perchè ti definisce solo la tua di classe e non la superclasse così rendendo il tutto un qualcosa di piu standard.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4274,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In generale (ed in particolare per equals) vale: l'overriding ridefinisce un metodo preesistente, quindi l'implementazione originaria di quest'ultimo viene rimossa e sostituita con quella fornita dal programmatore. L'overloading invece definisce un metodo completamente nuovo, che casualmente possiede lo stesso nome di uno preesistente, ma firma diversa.\r\nSu ciò che è \"altamente consigliato\" fare non vorrei esprimermi - dipende. Spesso però un semplice overloading del metodo equals non porta ai risultati voluti: infatti, molte costruzioni (come diverse collections) si rifanno esplicitamente al metodo equals(Object), e un overloading di equals non ne cambierà il comportamento. Ad esempio, se tutte le istanze di una certa classe C sono dichiarate uguali (mediante un overloading di equals), e se si aggiungono due istanze di C ad un \"HashSet\" S, S conterrà comunque due elementi, benché precedentemente dichiarati uguali (visto che S usa sempre equals(Object) per confrontare i suoi elementi).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4150,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Si parla di overloading quando si hanno metodi con lo stesso nome ma con parametri di ingresso diversi, di overriding invece quando un metodo viene riscritto in un altra classe ma che ha lo stesso nome e gli stessi parametri di quello presente nella superclasse.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4184,
              "task": {
                "taskId": 108,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Overriding è inteso come la ri-implementazione di un metodo che viene derivato, in un metodo con la stessa \"signature\" (stesso nome e lista parametri) ma più specifico per la classe che lo crea. L' Overloading indica l'aggiunta di un metodo con lo stesso nome ma diversa lista parametri.\r\nNel caso dell equals(Object obj) ci viene utile un override in cui specificare nel corpo quali campi confrontare per decretare se 2 oggetti della nostra classe sono uguali. Facendo overloading il metodo non sarebbe utilizzabile in automatico da alcuni automatismi del Java (come l'operatore ==) e risulterebbe superfluo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4215,
          "asker": {
            "courseId": 4,
            "askerId": 513,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità del metodo Hashcode() e in quali casi è veramente utile e in quali necessita di altri metodi?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Hashcode"
            },
            {
              "keyword": " utilità"
            },
            {
              "keyword": " metodi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4167,
          "asker": {
            "courseId": 4,
            "askerId": 565,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra COMPARABLE INTERFACE e COMPARATOR INTERFACE ?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " comparator"
            },
            {
              "keyword": " comparable"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4242,
          "asker": {
            "courseId": 4,
            "askerId": 500,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo se si modifica il metodo equals bisogna modicare anche l'hashCode?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4118,
          "asker": {
            "courseId": 4,
            "askerId": 529,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 104,
            "taskName": "Ask A Question"
          },
          "questionText": "quali sono le proprietà del metodo equals?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " proprietà"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 44,
      "lectureTitle": "Collections",
      "questions": [
        {
          "questionId": 4032,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste l' Iterator interface?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Iterator interface"
            },
            {
              "keyword": " interfaccia"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4031,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 501,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "E' una classe particolare che può essere definita su di una collection, che contiene una serie di metodi, i quali permettono di manipolare gli elementi della collection su cui l' Iterator è definito (per esempio restituendo l' elemento successivo oppure togliendo/aggiungendo elementi).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4072,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Iterator e' un'iterfaccia di java che permette di visitare gli elementi di una Collection.\r\nL'interfaccia dichiara (non definisce: non c'e' l'implementazione) 3 metodi:\r\nboolean hasNext(); che ritorna true se e solo se vi e' un elemento successivo all'oggetto \"puntato\" attualmente dall'iterator,\r\n<tipo_oggetto_contenuto_nella_Collection> next(); ritorna l'elemento successivo.\r\nvoid remove(); rimuove l'ultmo oggetto ritornato dall'iterator con la next().\r\n\r\nUtilizzo:\r\nsia lista un istanza di Collection (LinkedList, HashSet ecc..)\r\n\r\nIterator iter = lista.Iterator(); //Creo un iterator su lista\r\nif(lista.hasNext()){ //se lista contiene qualcosa (esiste un primo elemento)\r\nlista.next();\r\nlista.remove(); //rimuovo il primo oggetto dell'iterator da lista.\r\n}",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4026,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "L'Iterator interface è un'interfaccia che permette di avanzare in una collection usando la stessa sintassi per implementazioni diverse. Può essere utilizzata su qualunque tipo di collection, perciò non serve modificare tutto il programma se si cambia implementazione, ma basta modificare l'implementazione di Iterator.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4022,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'interfaccia \"List\" rispetti la \"Set\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3997,
          "asker": {
            "courseId": 4,
            "askerId": 593,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè occorre importare java.util nella slide 12?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 7,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " util"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4009,
          "asker": {
            "courseId": 4,
            "askerId": 559,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega il funzionamento di un iteratore in una collection.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iteratore"
            },
            {
              "keyword": "collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4102,
          "asker": {
            "courseId": 4,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra Set e List?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": " List"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4063,
          "asker": {
            "courseId": 4,
            "askerId": 434,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "I vettori in Java sono una classe a parte, oppure derivano dal Java Collections Framework?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "vettori"
            },
            {
              "keyword": "collections"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4059,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Se per vettori si intendono gli array tradizionali dello stesso tipo del C++ (ovvero quelli allocati con new Tipo[dimensione]) allora questi non derivano dal Java Collections Framework e sono classi a parte, in quanto sono caratterizzati da dimensione fissa e soprattuto non implementano l'interfaccia Collection.\r\nIn Java sono presenti anche altre implementazioni di vettori (Vector, ArrayList, LinkedList..)  che compongono degli oggetti molto simili agli array ma gestiti in modo dinamico (hanno quindi dimensione dinamica e molte altre funzionalità) . Tutte queste implementazioni implementano l'interfaccia Collection, e fanno quindi parte del framework.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4116,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 476,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In Java esiste la classe Vector, la cui gerarchia di dipendenza risulta essere la seguente: Object > AbstractCollection > AbstractList > Vector. La classe Vector implementa un array di oggetti che ha la caratteristica di poter crescere. Avendo peculiarità simili a quelle degli array, ogni componente può essere raggiunto mediante un indice e la dimensione di un vettore può aumentare o diminuire a seconda che vi vengano aggiunti o rimossi elementi. Occorre, però, segnalare anche che la classe Vector ha subito un'operazione di retrofit (un'aggiunta di funzionalità in modo da estenderne l'esistenza) così da implementare l'interfaccia List e, per questo motivo, la classe Vector fa anche parte del Java Collections Framework. In ultimo va detto che la classe Vector è pressoché equivalente alla classe ArrayList. L'unica eccezione sta nel fatto che quest'ultima non è sincronizzata (concetto legato al multithreading).  ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4119,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "I vettori (Array) in Java sono una classe NON inclusa nel Java Collections Framework. Infatti, nel momento di dichiarazione e inizializziazione di un Array, Java non fà assolutamente riferimento al J.C.F, bensì alla classe Array (ovvero http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Array.html)\r\nBisogna comunque precisare che nel J.C.F è inclusa una classe (la classe Arrays,con la 's' finale! http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html) che contiene vari metodi utili alla manipolazione di array. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4091,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 591,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Gli array non sono contenuti nella java collections framework, sono delle strutture dati che servono per contenere oggetti. Le dimensioni sono però fisse e non possono essere cambiate. Ciò rappresenta un problema per quei programmi in cui non è possibile conoscere a priori il numero di oggetti che verranno creati. Nella java collections framework troviamo allora l'ArrayList che non è altro che un'implementazione di List che gestisce la dimensione degli Array. Una volta che l'array è pieno, infatti, ne crea uno nuovo di dimensione maggiore e vi copia dentro tutti gli elementi del vecchio array. Merito un voto solo per lo sforzo di scrivere in italiano che me l'ero dimenticato e mi sta uccidendo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4101,
          "asker": {
            "courseId": 4,
            "askerId": 448,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende dicendo che le collezioni sono polimorfe?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4001,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si intende con hashset?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3974,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi riscontrabili utilizzando collezioni di elementi relativamente alla velocità di esecuzione del codice?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "velocità"
            },
            {
              "keyword": "collezioni"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4024,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è fra un'interface e una collection?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interface"
            },
            {
              "keyword": "collection"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4141,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": ".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4122,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Le interface sono concettualmente simili alle classi astratte, ma ancor più generali: infatti possono contenere solo dichiarazioni di metodi senza implementazione e di costanti. Le classi che implementano un'interfaccia devono obbligatoriamente implementare tutti i metodi dichiarati nell'interfaccia stessa; inoltre è possibile che una classe implementi più di un'interfaccia (cosa non possibile con le classi astratte), dato che, visto che tutti i metodi vengono ridefiniti nella classe, anche in caso di metodi con la stessa firma in interfacce diverse, non c'è il rischio di generare ambiguità. Collection è una particolare interaccia, che permette di lavorare con collezioni di oggetti, definendo i metodi di base necessari per lavorare su una struttura di questo tipo (aggiungere/togliere elementi, metodi per scorrere gli elementi, di ricerca/ordinamento, etc). In Java sono presenti anche alcne implementazioni dell'interfaccia Collection (ad esempio LinkedList) già pronte all'uso.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4105,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 489,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Un' interfaccia in Java ha una struttura simile ad una classe, con la differenza che essa può contenere solo metodi astratti e costanti. Una collection è invece un tipo di interefaccia, quella più generica, in cui non si definisce nè l'ordine degli elementi della collection nè se vi possono essere duplicati. Infatti una collection è un oggetto che raggruppa elementi multipli in un' unica entità, all' interno di cui i dati possono essere trattati o trasferiti da un metodo ad un altro.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4124,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "la collection è un'interface con dei metodi base:\r\nint size();\r\nboolean isEmpty();\r\nboolean add(Object);\r\nboolean contains(Object);\r\nboolean remuve(Object);\r\nIterator iterator();\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4093,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 590,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Una collezione è una struttura che raggruppa diversi dati, usualmente omogenei, mentre un interfaccia invece è una collezione di metodi headers senza la loro definizione (può anche dichiarare costanti)",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4040,
          "asker": {
            "courseId": 4,
            "askerId": 576,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali metodi implementa l'interfaccia iterator?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iterator"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4047,
          "asker": {
            "courseId": 4,
            "askerId": 592,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Nei linguaggi di programmazione ad oggetti, qual è l'interfaccia che deve implementare una classe affinché si possa comparare due istanze di essa tra di loro?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "oggetto"
            },
            {
              "keyword": "interfaccia"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4126,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Se per comparare si intende valutare con il fine di ordinare, si possono utilizzare due modalità distinte a seconda che si voglia definire un criterio di ordinamento naturale o addizionale (uno o più).\r\nNel primo caso, la classe dovrà implementare l'interfaccia COMPARABLE definendo un overloading del metodo int compareTo(\"classe a cui appartiene l'oggetto\" \"identificatore dell'oggetto\"), specificando al suo interno la relazione d'ordine tra i due oggetti.\r\nNel secondo caso, per ciascun criterio di ordinamento che si voglia definire, si dovranno creare più classi, ciascuna delle quali implementerà l'interfaccia COMPARATOR  e conterrà l'overloading del metodo int compare(T o1,T o2), (dove T=classe dell'oggetto e (o1 ,o2)=identificatori dei due oggetti), specificando (come nel metodo compareTo) la relazione d'ordine tra i due oggetti.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 4133,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 426,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "L'interfaccia list, che permette duplicati\r\n\r\npublic interface List<E>\r\nextends Collection<E>",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4136,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 566,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "L'interfaccia che deve implementare una classe affinchè si posso comparare due istanze di essa tra di loro è la \"compare\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4035,
          "asker": {
            "courseId": 4,
            "askerId": 444,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le collection e che vantaggi porta il loro utilizzo?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4110,
          "asker": {
            "courseId": 4,
            "askerId": 422,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "L'implementazione vista in classe di queue e stack hanno efficienza diversa. Il metodo estrai(), per simulare uno stack, percorre infatti tutta la lista chiamando .hasNext() dell'oggetto iteratore per poi estrarre solo l'ultimo elemento. Come si potrebbe risolvere questo problema? Esiste un'implementazione che permetta di fare, ad esempio:\r\n...\r\n... estrai() {\r\n   if(...)\r\n   {...}\r\n   return (stack.get(stack.size()-1));\r\n}\r\n\r\n\r\n???",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": "queue"
            },
            {
              "keyword": "efficienza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3995,
          "asker": {
            "courseId": 4,
            "askerId": 440,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze fra SET e LIST?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": " List"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4051,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'oggetto di tipo Iterator nelle collezioni?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iterator"
            },
            {
              "keyword": " collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4068,
          "asker": {
            "courseId": 4,
            "askerId": 516,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra un \"HashSet\" ed un \"ArrayList\"?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "HashSet"
            },
            {
              "keyword": " ArrayList"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3982,
          "asker": {
            "courseId": 4,
            "askerId": 523,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra un SET e una LISTA?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "SET"
            },
            {
              "keyword": " LISTA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4031,
          "asker": {
            "courseId": 4,
            "askerId": 480,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Se devo utilizzare un Array List nel mio programma, conviene definire la variabile in cui salvo la lista come Collection, o come una sua sottoclasse ( o sottointerfaccia) ?  Perché?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " ArrayList"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4055,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Se usi una variabile di tipo ArrayList in una funzione ti conviene dichiararla di tipo ArrayList, in questo modo potrai usufruire di tutti i metodi propri delle collection e, in più, dei metodi particolari di ArrayList non presenti nelle collection.\r\n\r\nSe stai progettando una classe che lavora con collezioni di dati, invece, dovresti cercare di essere il meno restrittivo possibile ed usare quindi una collection. In questo il tuo codice sarà più generale e più riusabile, quindi si adatterà situazioni diverse ed impreviste; in poche parole, sarà di qualità migliore.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4106,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Conviene definirla come una sua sottointerfaccia. Infatti l'ArrayList è una delle possibili implementazioni delle List che, assieme a Map e Set, costituiscono gli elementi delle Interfacce delle Collection.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4097,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Perché così posso utilizzare tramite l'ereditarietà tutti quei metodi già definiti nella libreria di Java appositamente per le Arraylist senza doverli ridefinire nuovamente",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4046,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Dipende dall'uso che devi fare di questa ArrayList:\r\nSe devi usare proprio una ArrayList ti conviene dichiararla come tale! Così facendo puoi, all'interno del programma, chiamare i metodi specifici di ArrayList. Se la definisci come Collection e poi vuoi chiamare, per esempio, il metodo set, il compilatore si arrabbia perché set non è un metodo della interfaccia Collection.\r\n\r\nSe invece non sai ancora che tipo di lista usare (perché magari viene decisa a runtime in base a delle scelte effettuate durante l'esecuzione programma) ti conviene dichiararla di tipo superiore (per esempio List) così la tua variabile potrà essere istanziata come un qualunque sottotipo (per esempio ArrayList e LinkedList)e tutto va bene (per il principio li Liskov)\r\n\r\nLa morale insomma è: se vuoi sfruttare il polimorfismo dichiara la classe/interfaccia più generica possibile che contenga tutti i metodi che ti servono.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4081,
          "asker": {
            "courseId": 4,
            "askerId": 591,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando e perchè è consigliabile definire delle collezioni come interfacce?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collezioni"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4004,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega in poche e semplici parole il diagramma mostrato nella slide 40. ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "spiega"
            },
            {
              "keyword": "diagramma"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4108,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra il compare e il compareTo?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4051,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 516,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "La differenza sostanziale è che il primo accetta due argomenti e confronta i due oggetti passati come tali, il secondo accetta un argomento e compara l'oggetto \"chiamante\" con l'oggetto passato per argomento.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4109,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 567,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Compare e CompareTo sono due metodi che servono a confrontare oggetti tra loro. Essi sono due metodi dell'interfaccia Comparator<>, e non sono metodi di Object. Il loro ruolo consiste nell'attribuire un ordinamento ad una certa collezione di oggetti.\r\nIn generale si sfrutta il metodo a1.comapareTo(a2), che verifica se a1 ed a2 sono identici e restituisce un booleano.\r\nIl metodo compare() invece si occupa del confronto tra float e double. Quindi int compare(a1, a2) confronta i tipi sopracitati e restituisce un intero negativo, nullo, o positivo a seconda che il primo sia minore, uguale o maggiore al secondo. \r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4035,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Il modo in cui i due metodi operano e i valori restituiti (intero negativo, 0, intero positivo) sono pressochè uguali, si ha la differenza nell'interfaccia di appartenenza: compareTo appartiene all'interfaccia Comparable, mentre compare appartiene a Comparator. La differenza sostanziale è che compare confronta due oggetti differenti, mentre comparable confronta l'istanza presa in considerazione (tramite \"obj1.compareTo(obj2)\") con un'altra. Si trae un lieve vantaggio ad usare compareTo: compare andrà definito in una classe implementante Comparator, mentre compareTo permette di creare confronti istantanei senza inserire ulteriori classi, ad esempio come condizione in un if: if(obj1.compareTo(obj2) < 0) {...}.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4140,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 477,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Entrambi sono metodi che restituiscono un intero, ma appartengono a classi astratte diverse ed hanno un diverso numero di parametri. \r\nIl metodo compareTo ha un unico parametro e deve essere implementato all'interno di una classe che implementa l'interfaccia Comparable. \r\nD'altra parte invece il metodo compare ha due parametri e viene definito in una apposita classe che implementa Comparator. \r\nI metodi sono utilizzati per riordinare una collection tramite il metodo statico sort di Collections, che è \"overloaded\" per essere usato con un Comparator o senza. Nel primo caso bisognerà aver instanziato una classe che implementa il metodo compare, mentre nel secondo l'oggetto contenuto deve aver implementato il metodo compareTo perché la collezione sia ordinata secondo l'ordinamento naturale definito da questo metodo. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4143,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "compare() e compareTo() sono due metodi che permettono di confrontare due oggetti in base ad una relazione d'ordine fissata dal programmatore. Entrambi restituiscono un intero, che descrive la relazione che intercorre tra i due oggetti comparati. Ecco alcune differenze tra questi due metodi:\r\n- compare() è un metodo dell'interfaccia Comparator, definita nel package java.util, mentre compareTo() è un metodo dell'interfaccia Comparable, definita nel package java.lang.\r\n- I due metodi hanno una firma diversa, cioè \"compare (Object o1, Object o2)\" contro \"compareTo (Object o)\". Questo allude ad una differenza logica tra i due metodi: mentre compare() confronta fra loro i suoi due argomenti, compareTo() confronta il suo unico argomento con \"this\".\r\n- L'interfaccia Comparable impone un ordine naturale sulle istanze di una determinata classe, mentre l'interfaccia Comparator impone un ordine totale su di esse. compareTo() e compare() rispettivamente sono i metodi che permettono di paragonarle.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4076,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per multiereditarietà di una classe dichiarata interface?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " multiereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4048,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Una classe puo ereditare da piu interfacce, superando, in parte, la mancanza di ereditarietà multipla",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4063,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Si intende semplicemente che l'interfaccia, a differenza di una classe (contenendo soltanto metodi e non oggetti), può essere inclusa in varie classi, anche completamente diverse tra loro. \r\nDa qui la definizione di multiereditarietà, nel senso che può ereditare fattori completamente differenti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4131,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Nelle interfacce java si parla di ereditarietà multipla nel momento in cui vi è una classe (es. C2) che eredita da una classe C1 e da una o più interfacce (es. I1 e I2). In questo caso si dice che C2 \"implementa\" I1 e I2. Le interfacce avranno solo metodi astratti, non si ereditano campi (in quanto non li hanno), non si ereditano implementazioni di metodi ma accetto solo la loro dichiarazione.\r\nIn un esempio di multiereditarietà si ha quindi: una classe C2 che eredita da una classe C1; la stessa C2 implementa le due ipotetiche interfacce I1 e I2.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4061,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "una classe che eredita un'interfaccia ( implements \"nomeinterfaccia\" ) definisce tutti i metodi definiti nell'interfaccia stessa. Nel caso di multiereditarietà la classe implementa più di un interfaccia ( implements \"interfaccia1\",\"interfaccia2\") e quindi la classe dovrà definire i metodi sia della prima che della seconda interfaccia.  ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4068,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 524,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un' interfaccia in Java è una sorta di contenitore che può avere al suo interno solo metodi astratti (che sostanzialmente non fanno nulla) e costanti. In questo modo è alla stregua di una classe padre. Un' interfaccia può avere sottoclassi senza problemi (si dice che \"implementino l'interfaccia\"), a patto che ogni sottoclasse realizzi i metodi astratti dell'interfaccia da cui deriva (con la stessa intestazione, ovviamente).",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4053,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è lo scopo e dove viene usata l'interfaccia Map?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Map"
            },
            {
              "keyword": " interfaccia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4058,
          "asker": {
            "courseId": 4,
            "askerId": 570,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve iterator?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iterator"
            },
            {
              "keyword": " funzionamento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3980,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Se io ho un Set e una List, e all'interno della list ho 2 elementi uguali, se io inserisco tutti gli elementi della list nel set gli elementi identici vengono mantenuti entrambi?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": "List"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4012,
          "asker": {
            "courseId": 4,
            "askerId": 513,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un Iterator e qual è la sua utilità?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4007,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega l'uso di un oggetto iterator.",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4019,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nell'implementazione di Coda tramite Collections (slide 24), l'assegnazione di x è forzata tramite cast a \"Number\"?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4076,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Credo funzioni anche senza cast esplicito.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4040,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 505,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": " x = (Number)iter.next(); \r\nviene effettuato il cast perchè iter è stato creato su una lista di oggetti non parametrizzata quindi mi ritorna un object e devo essere io programmatore ad assicurarmi che sia un oggetto di tipo Number e quindi castarlo dicendo al compilatore che mi io prendo la responsabilità di questo passaggio.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4129,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 540,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Perchè da \"iter.next()\" ritorna un object, quindi per farci ritornare l'oggetto di cui abbiamo bisogno (Number) bisogna fare il Down Casting.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4085,
          "asker": {
            "courseId": 4,
            "askerId": 478,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponendo di avere una collection \"c\" già istanziata e riempita con vari elementi, per svuotarla è più conventiente fare c.clear() o c.removeAll(c)?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " complessità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4050,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "hmm.. io non c'ero alla lezione quindi non so che cosa ha detto prof per quanto riguarda quale metodo è mogliore, però posso supporre che c.clear() sarebbe piu conveniente :)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4130,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "È più conveniente usare c.clear() a causa del diverso funzionamento dei due metodi:\r\n- c.clear() elimina semplicemente tutti gli elementi contenuti nella Collection c\r\n- c.removeAll(c) per definizione \"elimina tutti gli elementi in c che siano contenuti anche in c\".\r\nQuindi, nel nostro caso, i due metodi hanno lo stesso effetto, ma c.removeAll(c) è meno conveniente in quanto, prima di eliminare gli elementi di c, deve controllare che tali elementi siano contenuti nella nostra Collection; dunque tale controllo rende il metodo meno efficiente.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4104,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 553,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "c.clear() dice direttamente al gc: \"Fai il tuo lavoro! Cancella tutto in un passaggio solo!\" e quindi è il migliore. Il removeAll invece servirebbe ad altro... Di solito si usa per cancellare le copie dalle collection in questo modo: c.removeAll(d) così il gc fa uno scan degli elementi di c, poi fa uno scan degli elementi di d, e cancella dalla lista c tutti gli elementi che ci sono già nella lista d. Se si vogliono cancellare tutti gli elementi di una lista scegliendo di fare c.removeAll(c) si fa fare al gc un bubblesort per niente, perchè ci sarebbe l'opzione c.clear molto più semplice e veloce.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4049,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con il termine \"collection\"?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3987,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo le collection favoriscono e semplificano il polimorfismo?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4055,
          "asker": {
            "courseId": 4,
            "askerId": 566,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona e a cosa serve \"iterator\"?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " interfaccia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4082,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza intercorre tra le interfacce List e Set della Collections?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "List"
            },
            {
              "keyword": " Set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4073,
          "asker": {
            "courseId": 4,
            "askerId": 578,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra set e list?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Interfaces"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4107,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si \"costruisce\" una Collections\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4067,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 495,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Una Collection è una collezione, per l'appunto, di oggetti. Di fatto, i vari tipi di Collection sono degli oggetti essi stessi e, quindi, si costruiscono in modo del tutto uguale ad ogni altro oggetto. Per prima cosa si sceglie che tipo di Collection usare a seconda delle proprie necessità (ArrayList, HashSet, ...) ed infine si procede ad allocare sia la memoria per l'identificatore in Stack che la Collection vera e propria in Heap con il solito uso dell'operatore new. Ad esempio \"List listaDiProva = new ArrayList();\" crea una Collection formata da un identificatore a List che punta ad un oggetto di tipo ArrayList (da notare che questa operazione è perfettamente legale in quanto ArrayList è una classe che implementa l'interfaccia List). Il tutto è comunque subordinato a specificare al compilatore che tutte le cose che stiamo usando esistono da qualche parte: basta aggiungere la riga di comando \"import java.util.*;\"",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4114,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "(Sto supponendo che tu sia interessato alla classe Collections  e non abbia sbagliato nella s finale) Questa è una classe pubblica contenente soltanto tre costanti e metodi statici che operano su o ritornano Collection(tra questi ci sono binarySearch, copy, fill, frequency, indexOfSubList, min, max, nCopies, replaceAll, reverse, rotate, shuffle, sort, swap, ?); la sua dichiarazione è\r\npublic class Collections extends Object{\r\nstatic  List EMPTY_LIST;\r\nstatic Set EMPTY_SET;\r\nstatic map EMPTY_MAP;\r\n...(implementazione di tutti i metodi della classe che trovi in Java Tutorials)..\r\n}\r\nSe tu invece ti stessi riferendo (come l'articolo indeterminativo lascia intendere) all'interfaccia Collection devi tenere presente che questa è estensione dell'interfaccia Iterable, completamente generale e con un unico metodo: iterator(); una Collection è una qualunque istanza di una classe che estende l'interfaccia e si \"costruisce\" nel modo che già conosciamo partendo da List o Set o da loro estensioni.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4103,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "che domanda!...LOL",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4032,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 429,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Collettions è un' interfaccia che esiste già nella java.util e quindi non è necessario costruirla.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4058,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 563,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Le CollectionS non sono \"costruibili\" poiché si tratta di una classe già predefinita che contiene metodi a cui puoi solo far riferimento.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4029,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa permette di fare il seguente comando per le Collection?\r\nimport java.util.*;",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4069,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "I vari tipi di Collections sono pronti all'utilizzo o vanno definiti dal programmatore?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4070,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "elencare vantaggi e svantaggi dell'implementazione delle classi pila e coda utilizzando le collezioni",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " coda"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4061,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi offerti dall'uso di interfacce rispetto alle classi astratte?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " classi astratte"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4102,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 557,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il principale vantaggio dell'usare un'interfaccia piuttosto che una classe astratta sta nel fatto che se voglio definire una superentità astratta di una classe, se utilizzo una classe astratta essa potrà sì essere estesa dalle sottoclassi, ma non insieme ad altri classi astratte; l'interfaccia invece, la quale non può contenere codice al suo interno ma solo definire tipi di astratti, ha la possibilità di essere implementata insieme ad altre interfacce, cosa che non si può fare con le classi (concrete o astratte che siano).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4023,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Con l'uso delle interfacce si è obbligati ad implementare un metodo di cui essa dispone; per esempio la Comparator -> compareTo(), mentre la Comparable -> equals(), ma il vantaggio sta nel fatto che una classe può implementare diverse interfacce. \r\nLe classi astratte invece obbligano il programmatore ad implementare TUTTI i metodi che sono stati definiti all'interno, ma la classe non può avere due \"extends\", quindi limita la flessibilità di un progetto.   ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4065,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 496,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "L'uso di interfacce permette di avere una sorta di ereditarietà multipla, cosa che in Java non può essere fatta con le classi astratte.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4034,
          "asker": {
            "courseId": 4,
            "askerId": 459,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa servono le Collections in java e che utilità portano al programmatore?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4039,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano gli iteratori ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collezioni"
            },
            {
              "keyword": "Iteratori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3988,
          "asker": {
            "courseId": 4,
            "askerId": 527,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una collection e qual è la sua funzione? ",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4090,
          "asker": {
            "courseId": 4,
            "askerId": 554,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa devo fare per utilizzare la Class Collection , se voglio implementare nel mio codice una lista circolare con i propri metodi (add, remove, ecc.)?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "implementazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4043,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 542,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Devi costruirti quello che ti serve.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4021,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 467,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Devi importare la java.util.Collection",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4100,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "E' necessario implementare il metodo Comparator",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4044,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 490,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "...",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4104,
          "asker": {
            "courseId": 4,
            "askerId": 487,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa differiscono mappe e set?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Mappe"
            },
            {
              "keyword": " Set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4030,
          "asker": {
            "courseId": 4,
            "askerId": 557,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "In che situazioni e perché è opportuno usare una struttura TreeMap piuttosto che una struttura TreeSet e viceversa? (Basta un esempio per ciascuno e dire perché)",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "set"
            },
            {
              "keyword": " map"
            },
            {
              "keyword": " tree"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4125,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 575,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "TreeMap è più generale, infatti l'implementazione di TreeSet si basa sull'implementazione di TreeMap.\r\nLa struttura Map associa chiave-valore e coincide con la struttuta Set quando la chiave è l'hash-code del valore. Inoltre possiamo pensare alla chiavi come ai valori dei nodi negli alberi. Inoltre sia TreeSet che TreeMap dispongono di metodi logaritmici per le operazioni di base e di sottoclassi ordinabili. Quindi credo si possa pensare alle due strutture come alternative.\r\nDetto questo, per esempio volendo realizzare una classe Studenti è più opportuno usare TreeMap infatti la matricola identifica univocamente uno studente e quindi può essere usata come chiave. Mentre per realizzare una classe MazzoDiCarte possiamo usare TreeSet (la chiave che identifica univocamente una carta certamente si può trovare ma non è così ovvia come quella nel caso dello studente).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4110,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Le differenze sostanziali sono:\r\n1) TreeMap permette duplicati (sul valore e non sulla chiave) mentre TreeSet non lo permette (per definizione di Set)\r\n2)TreeSet salva un oggetto solo per volta e lo mette in ordine, mentre TreeMap necessita di chiave e valore. Il valore sarà usato anche come identificativo, e la chiave come criterio per ordinare l albero.\r\n\r\nQuindi sceglierà un TreeMap quando avrò bisogno di avere un collezione di oggetti non confrontabili direttamente. Mi basterà associargli una chiave per ogni elemento per tenerli in ordine ad esempio NomePersona/Età. Il TreeSet è utile nel caso di collezioni con valori ordinabili non ripetibili come un agenda per prenotazioni in cui inserire man mano i giorni e tenerli comunque ordinati",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4096,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 595,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Sia Set che Map fanno un sorting dei loro elementi.\r\nSet non ammette duplicati i duplicati.\r\nMap si basa su entità chiave-valore, ma non ci possono essere due chiavi con lo stesso valore.\r\nesempio TreeMap:utile quando devo inserire tanti valori ad una sola chiave(es:anagrafe).\r\nesempio TreeSet:utile quando voglio avere una lista ordinata di elementi (es: elenco telefonico).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4078,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 445,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "la TreeMap abbina agli oggetti contenuti al suo interno delle chiavi di ricerca e non possono esserci degli elementi duplicati ad esempio l'anagrafe e gli si può abbinare come chiave il codice fiscale.\r\nil TreeSet non abbina chiavi ma ha al suo interno oggetti che possono essere ordinati o meno e non ci sono chiavi di ricerca abbinati agli oggetti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4092,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 478,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "TreeSet e TreeMap sono due classi concrete che implementano le interfacce Set e Map usando un albero per contenere i dati. (simili ad HashMap e HashSet)\r\nEntrambe sono pensate per la ricerca binaria tuttavia hanno qualche differenza.\r\nTreeSet essendo una implementazione di Set non permette duplicati.\r\nTreeMap implementa Map (una collection che serve per salvare dati con un sistema chiave-valore) sempre come un albero di ricerca tenuto ordinato su di un campo chiave che deve essere \"comparable\", e non permette campi nome duplicati.\r\nTreeSet siccome è iterabile è particolarmente comoda se si devono scorrere gli elementi in sequenza, TreeMap è una soluzione molto più flessibile e si usa soprattutto nell'implementazione di basi dati (DataBase) e più in generale nello storage di oggetti.\r\nDa notare come, stando alle API di java, un TreeSet sia tenuto in piedi da un'istanza di TreeMap che di solito è anche più facile da gestire.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4059,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "che cos'è l'Iterator?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4006,
          "asker": {
            "courseId": 4,
            "askerId": 568,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "cos'è una collection?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "una"
            },
            {
              "keyword": "cosa"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4080,
          "asker": {
            "courseId": 4,
            "askerId": 445,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "che differenza c'è tra una List e un set? quali possono essere i vantaggi dell'usare uno piuttosto che un altro?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4027,
          "asker": {
            "courseId": 4,
            "askerId": 437,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzionalità di un hashset? Quali sono le sue applicazioni?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashset  "
            },
            {
              "keyword": " collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4083,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra classi astratte e interfacce?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Classi astratte"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4111,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 435,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Un'interfaccia può contenere solo firme di metodi e costanti, e dev'essere quindi implementata da una classe, e inoltre non può contenere variabili d'istanza o implementazioni di metodi. Una classe astratta invece può contenere metodi con la loro implementazione e variabili d'istanza, e al suo interno si possono definire dei metodi astratti che andranno poi implementati da una classe. Generalmente le classi astratte vengono utilizzate per implementare classi che contengono metodi che hanno la stessa implementazione e differiscono solo per delle variabili o qualche metodo. Un'interfaccia viene utilizzata invece per implementare classi che condividono la stessa struttura di base, come ad esempio dei metodi con la stessa firma ma che hanno bisogno di implementazioni diverse nelle diverse classi",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4027,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 504,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Le due cose sono molto simili: entrambe definiscono metodi abstract, ma non li implementano. La differenza, però, riguarda l'ereditarietà, infatti solo per le interfacce vale il concetto di ereditarietà multipla(ovvero una classe può derivare da 2 o più interfacce), proprio perchè esse(sono strutture base in java) sono state costruite in modo tale da non       creare problemi di disambiguità tra metodi o costanti(valide solo per le interfacce).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4139,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 549,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Una classe astratta viene creata non per derivarne istanze ma per derivare altre classi che definiranno specificandole le operazioni dichiarate. \r\nDato che la classe astratta è una base per le classi figlie e i suoi metodi non sono pienamente definiti non si potrà mai creare un oggetto del tipo di classe astratta anche se è possibile creare una referenza della classe astratta che punterà a una sottoclasse.\r\nL?interfaccia è analoga a una classe ma costituisce a sua differenza, una pura specifica di comportamenti. Si limita a dichiarare i metodi senza implementarli. Ha una struttura simile a una classe, ma può contenere solo metodi d'istanza astratti e costanti (quindi non può contenere costruttori, variabili statiche, variabili di istanza e metodi statici). Le interfacce possono essere utilizzate ad esempio, per definire Tipi di Dati Astratti o per evidenziare funzionalità comuni a più classi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4142,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 517,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "1.I metodi di un'interfaccia sono implicitamente astratti e non possono avere implementazioni. Una classe astratta può avere metodi di istanza che implementano un comportamento predefinito. 2.Le variabili dichiarate in un'interfaccia sono per default finali. Una classe astratta puo' avere variabili non definitive. 3.I membri di una interfaccia sono predefiniti pubblici. Una classe astratta può avere i stessi tipi di membri della classe. 4.L'interfaccia si attua con la parola chiave \"strumenti \";Una  classe astratta si estende con la p.chiave  \"estende \". 5.Un'interfaccia può estendere solo un'altra interfaccia, una classe astratta può estendere un'altra classe (o solo una classe astratta) e implementare più interfacce. 6.L'interfaccia è assolutamente astratta e non può essere un'istanza; Una classe astratta non può creare un'istanza, ma può essere invocata se un main () esiste. 7.Le interfacce, paragonate alle classi astratte, sono lenti in quanto richiedono indirezione aggiuntiva.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4053,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Sostanzialmente le interfacce sono delle \"descrizioni di comportamento\" che dovranno avere le classi che le implementano. Utilizzo la parola \"descrizione\" perché all'interno dell'interfaccia non ci possono essere delle effettive implementazioni di metodi ma soltanto la definizione degli stessi. Quindi con le interfacce vengono definite delle regole che lo classi implementanti devono seguire.\r\nUna classe astratta può invece combinare sia definizioni di metodi che effettive implementazioni, le quali posso essere utilizzate senza problemi dalle classi figlie.\r\nInoltre una classe può ereditare da una sola classe astratta mentre può implementare più si una sola interfaccia.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4095,
          "asker": {
            "courseId": 4,
            "askerId": 430,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'é tra una List e un Set?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "List"
            },
            {
              "keyword": " Set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4103,
          "asker": {
            "courseId": 4,
            "askerId": 486,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi che derivano dall'uso delle Collection ?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4064,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "cos'è un HashSet e che caratteristiche ha?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collezioni"
            },
            {
              "keyword": " interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3993,
          "asker": {
            "courseId": 4,
            "askerId": 435,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un Iterator e a cosa serve?\r\n",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 22,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " Collection "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3978,
          "asker": {
            "courseId": 4,
            "askerId": 425,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e a cosa serve l'iteratore?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " iteratore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4043,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa fa la funzione \"Iterator iterator()\" ??",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": " iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4016,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra un Hashset e un Treeset?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Hashset"
            },
            {
              "keyword": " Treeset"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4094,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 521,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Hashset è un'estensione di abstactset e fornisce un'implementazione all'interfaccia set. Crea una collezione che usa una hashtable per memorizzare, ovvero utilizza un meccanismo hashing che automaticamente associa ad un'informazione una chiave utilizzata anche per evitare che informazioni già esistenti siano memorizzate.I dati non sono ordinati.\r\nTreeset a sua volta fornisce un'implementazione all'interfaccia set. E' implementata utilizzando una struttura ad albero (red-black tree),ed è utilizzata in particolar modo per memorizzare grandi quantità d'informazioni che devono essere poi trovate velocemente.\r\nIn definitiva se vogliamo un set veloce dobbiamo utilizzare un hashset, se invece vogliamo un set 'ordinato' dobbiamo usare un treeset.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4017,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Un HashSet  conserva elementi in base al loro codice hash, ma il loro ordine non é garantito, invece in un TreeSet tramite un confronto di oggetti ed ordinati ad albero <3 ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4115,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 433,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "TreeSet implementa l'interfaccia SortedSet (e quindi anche la Set), quindi garantisce un ordinamento degli elementi, garantisce un tempo logaritmico per eseguire le operazioni base (aggiungi, rimuovi, contiene).\r\nL'HashSet implementa solamente l'interfaccia Set (e non la SortedSet); ogni elemento ha una chiave univoca che lo identifica (Hash). Rispetto al TreeSet, l'HashSet non garantisce che gli elementi restino ordinati nel tempo, però garantisce un tempo costante per eseguire le operazioni base (aggiungi, rimuovi, contiene)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4070,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 497,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Un HashSet è semplicemente una interfaccia Set (più precisamente: HashSet implementa Set), che però si basa sulla particolare proprietà della Hash Table per la quale, dato un insieme di coppie di tipo chiave-valore, si può risalire alla posizione in cui si trova l'elemento conoscendo soltanto la chiave.\r\nUn TreeSet invece è un Set (precisamente: TreeSet implementa Set) avente le caratteristiche di un albero, in cui gli elementi sono quindi ordinati. \r\nInoltre, gli elementi che vengono aggiunti in un TreeSet vengono posizionati sulla base di confronti tra oggetti, in un HashSet in base al loro codice hash.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4011,
          "asker": {
            "courseId": 4,
            "askerId": 585,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali parametri per decidere quale collection utilizzare in un programma...?:)",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4071,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 479,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Le principali caratteristiche di una collection sono se essere ordinata [List/SortedSet], disordinata [Set], ammette duplicati [List] o meno [Set]",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4144,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 502,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "se vuoi che nel tuo programma gli elementi vengano inseriti in ordine utilizzi list, altrimenti se vuoi che vengano inseriti senza un ordine ben preciso usi set.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4128,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Le Collection si dividono principalmente in 2 grandi gruppi: List e Set.\r\n\r\nLe Liste consentono duplicati, mantengono l'ordine di inserimento degli elementi, possono essere ordinate in modo semplice. Ogni elemento è associato a un indice che il programmatore può usare per manipolare la lista.\r\nLe principali implementazioni di List sono ArrayList e LinkedList; come suggeriscono i nomi, la prima è implementata con un array mentre la seconda con una lista concatenata. Se si aggiungono e rimuovono spesso gli elemementi dalla Lista, allora la seconda è migliore; negli altri casi meglio optare per un ArrayList.\r\n\r\nI Set non consentono duplicati e non garantiscono il mantenimento dell'ordine degli elementi inseriti. Le principali implementazioni di Set sono HashSet e TreeSet. HashSet utilizza il metodo hashCode di Object per estrarre velocemente gli elementi dalla collezione e equals per eliminare i duplicati, quindi è indispensabile riscrivere entrambi questi metodi gli oggetti da inserire.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4013,
          "asker": {
            "courseId": 4,
            "askerId": 533,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale  motivo utilizzo  un interfaccia, anzichè un abstract, per implementare una Collection? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " VS "
            },
            {
              "keyword": " interfaccia"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4028,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 551,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Nel framework Collections, i diversi tipi di collezioni sono dichiarati come interfacce e non come classi astratte poiché ciò rende possibile un utilizzo polimorfo del codice e non vincolato dalle specifiche restrizioni di una classe astratta. Qualsiasi classe può implementare un'interfaccia: in questo modo, essa potrà essere utilizzata in maniera uniforme (proprio perché conforme ad un'interfaccia) da un chiamante esterno, indipendentemente dalla sua gerarchia di derivazione.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 4107,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 469,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Per implementare una collection usiamo un'interfaccia perché tramite l'interfaccia si può realizzare l'ereditarietà multipla che con una classe abstract non si può ottenere.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4042,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'interfaccia Iterator?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4100,
          "asker": {
            "courseId": 4,
            "askerId": 475,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che offrono le collections?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vantaggi"
            },
            {
              "keyword": "collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4105,
          "asker": {
            "courseId": 4,
            "askerId": 521,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "che cosa è una collection? e come è legata a classi e intefacce?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4038,
          "asker": {
            "courseId": 4,
            "askerId": 432,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un'interfaccia e quali sono i suoi utilizzi",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4005,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qualè la differenza tra interface e  abstract class?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interface"
            },
            {
              "keyword": "abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4069,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 513,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "L'interfaccia contiene solo firme di metodi e costanti e ogni metodo deve essere implementato nelle varie classi che la implementano, mentre l'abstract class è una classe che più contenere metodi e variabili e costante come ogni altra classe e solo i metodi definiti abstract devono essere implementati nella sottoclasse. Un'altra differenza è che una classe più implementare più interfacce ma può estendere solo una abstract class.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4132,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 547,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Entrambe classi astratte e interfacce non possono essere istanziate poiché definiscono solo metodi e proprietà che dovranno poi essere implementati da classi derivate.\r\nUn'interfaccia è una collezione di firme e metodi non implementati, mentre nelle classi astratte  sono implementati metodi e proprietà astratte. Ogni metodo di un'interfaccia deve essere dichiarato pubblico, mentre in una classe astratta può essere definito con qualsiasi visibilità.\r\nUna classe  può implementare più di un'interfaccia, ma estendere una sola classe astratta.\r\nDal punto di vista pratico si ha che: le classi astratte forniscono un legame più stretto con le classi a loro derivate, ne rappresentano il tipo base e definiscono un comportamento comune, mentre le interfacce danno un modello più generico, un comportamento comune a classi di più vario genere.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4077,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 422,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Interfacce\r\n-----------------\r\nUn'interfaccia è un contratto: il tipo che scrive l'interfaccia dice: \"hey, accetto qualsiasi cosa che rispetti queste regole\", e il tipo che usa l'interfaccia dice: \"Ok, la classe che scrivo rispetta le regole che hai imposto\".\r\n\r\nUn interfaccia è una \"empty shell\". Ci sono solo i prototipi dei metodi (nomi, parametri e valore di ritorno). I metodi non contengono nulla. L'interfaccia di per sé non può fare nulla. È solo un pattern.\r\n\r\nClassi astratte\r\n-----------------\r\nLe classe astratte, al contrario, sono classi. Sono più costose da utilizzare perché sia il compilatore che il runtime ne devono fare un lookup quando si scrivono classi che ereditano da una classe astratta.\r\n\r\nLe classi astratte sembrano simili alle interfacce, ma hanno qualcosa di più: si può definire un loro comportamento. È come se il tipo di prima dicesse: \"Queste classi devono avere questo set di metodi in comune, quindi riempi semplicemente gli spazi vuoti!\"",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4118,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "La differenza più importante è che l'interface può contenere solo metodi non implementati e non può contenere variabili, mentre le classi astratte possono avere metodi implementati e variabili.\r\nQuesto fa sì che una classe possa implementare più di una interface alla volta, perché quando si chiama un metodo dichiarato nelle interface, questo è per forza presente e implementato nella classe \"implementante\".\r\nAl contrario, non è possibile che una classe erediti da due classi astratte contemporaneamente, perché se viene chiamato un metodo non sovrascritto dalla sottoclasse ed implementato in entrambe le superclassi astratte, ci sarebbe l'abiguità di andare a pescare da una superclasse piuttosto che dall'altra.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4081,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 585,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "l'interfaccia la usi quando devi solo definire un metodo di cui non vuoi esplicitarne il comportamento (ossia l'implementazione) , mentre invece la classe astratta si usa quando devi fornire l'implementazione di alcuni metodi e altri invece li metti abstract di modo che chi estende tale classe li possa implementare",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4048,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega brevemente a cosa serve un iteratore.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " iteratori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4015,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa ritorna questa stringa?\r\nnew int[3][4].getClass().getName()",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "getName"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4145,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Purtroppo non lo so.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4123,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 461,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Questa stringa ritorna il nome completo del package della classe a cui appartiene la matrice di interi composta da 3 righe e 4 colonne. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4134,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 440,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Ritorna la classe dove ci si trova ed il suo nome",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4098,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 425,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Ritorna una stringa con il nome della classe di quell'oggetto. In questo caso ritornerà \"int\"",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4097,
          "asker": {
            "courseId": 4,
            "askerId": 595,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i modi principali per ordinare una collezione?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " Set"
            },
            {
              "keyword": " List"
            },
            {
              "keyword": "  Map"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4088,
          "asker": {
            "courseId": 4,
            "askerId": 500,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo nelle Collections si sono scelte quelle particolari operazioni base (isEmpty, contains, add, remove, iterator)?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Basic Operator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4041,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "parla delle collections",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 2,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4071,
          "asker": {
            "courseId": 4,
            "askerId": 473,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra una Collection di tipo Set e una di tipo List?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " set"
            },
            {
              "keyword": " list"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4098,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra le interfacce Comparator e Comparable?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ordinamenti"
            },
            {
              "keyword": " comparable"
            },
            {
              "keyword": " comparator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4018,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Il Comparator (java.util.Comparator) permette di confrontare due oggetti differenti, Comparable (java.lang.Comparable) invece confronta se stesso con un altro oggetto.\r\nEntrambe le interfacce consentono di confrontare due oggetti non misurabili.\r\nPer definire qual è il termine di paragone dobbiamo implementare un Comparator o un Comparable.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4014,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Comparator mette a confronto mentre comparable si assicura che si possa mettere a conftronto",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3994,
          "asker": {
            "courseId": 4,
            "askerId": 558,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "¿Qual è la differenza tra Set e List?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": " List"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4052,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci sono vantaggi ad avere già definite dal linguaggio le interfacce di Liste, Alberi, Mappe ecc. ?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " collezioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4094,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra una map e un hash?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " hash"
            },
            {
              "keyword": " map"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4077,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Come fa l'oggetto Iterator a capire come operare su una specifica collezione?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Iterator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4015,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "IntSet: oggetto ?iteratore su IntSet? con metodi: next() per restituire l?elemento su cui si è posizionati e muoversi su quello successivo; hasNext() per verificare se siamo sull?ultimo elemento.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4113,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 581,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Chiamando il metodo iterator() della collection viene restituito un iterator che punta all'inizio della collection chiamante.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4066,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "L'oggetto Iterator opera su una Collection quindi per le regole del polimorfismo sa come operare perchè opera sempre in modo uguale",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4054,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 470,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Ogni iteratore è definito nella collezione stessa.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4018,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra list e set?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4078,
          "asker": {
            "courseId": 4,
            "askerId": 524,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è LA caratteristica fondamentale delle interfacce?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4112,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "La caratteristica fondamentale delle interfacce è quella di fare da punto di incontro tra componenti simili che hanno una struttura interna diversa. Infatti solitamente un'interfaccia rappresenta un tipo paragonabile alla classe ma con ulteriori restrizioni, risulta così composta  di soli metodi astratti ed eventualmente da insiemi di campi visibili all'esterno.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4049,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Puoi implementarne più di una in una classe poiché non si possono definire variabili all'interno, e inoltre contiene metodi senza implementazione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4127,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 460,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Un'interfaccia ha una struttura simile a una classe, ma con una fondamentale differenza: può contenere soltanto costanti, metodi di default, metodi statici e metodi astratti (che avranno perciò le loro firme ma non le loro implementazioni). Un'interfaccia non è perciò istanziabile: è invece implementabile, da una o più classi, che devono implementare tutti i metodi dichiarati (ed eventualmente altri), oppure essere classi astratte. Ciò permette a un'interfaccia di essere utilizzata anche come tipo di dati astratto, cioè permette di definire variabili di un nuovo tipo (corrispondente alla nostra interfaccia) tali che ogni oggetto assegnato ad esse dovrà essere istanza di una classe che implementa l'interfaccia. \r\nInoltre le interfacce hanno almeno un'altra caratteristica degna di essere menzionata che le differenzia dalle classi: una classe può infatti implementare più interfacce contemporaneamente (mentre può estendere una sola classe).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4079,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Non direi che le interfacce hanno UNA caratteristica in particolare, sarebbe un po' riduttivo.\r\nHanno le loro proprietà, starà poi al programmatore decidere quali sono quelle davvero importanti e necessarie a seconda delle esigenze del momento.\r\nIn ogni caso le interfacce:\r\n(*) possono essere viste come un'insieme di firme (o prototipi) di metodi/funzioni non ancora definite\r\n(*) vi si possono dichiarare costanti, ma non variabili\r\n(*) non possono essere istanziate, ma possono essere usate come \"tipo\" per i riferimenti (vedi polimorfismo)\r\n(*) una qualsiasi classe può ereditare da due o più interfacce (differenza particolare che le distingue dalle classi astratte)\r\n(*) \"ereditare\" un'interfaccia costringe il programmatore ad implementarne (definirne) i metodi, spesso secondo uno standard prestabilito, integrato con altre funzionalità (si veda ad esempio le interfacce \"comparator\" o \"comparable\")\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3998,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un Iterator?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3996,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "quali sono i vantaggi di implementare pila e coda con le collection?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " coda"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3985,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra una list e un set ? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " set"
            },
            {
              "keyword": " collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3991,
          "asker": {
            "courseId": 4,
            "askerId": 529,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra Set e List?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": " List"
            },
            {
              "keyword": " Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4017,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano gli iteatori?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iteratori"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4062,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali condizioni o per quali scopi viene utilizzata l'interfaccia Iterator in Java?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "inteface"
            },
            {
              "keyword": " iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4050,
          "asker": {
            "courseId": 4,
            "askerId": 488,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'idea che sta alla base delle collections?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "idea"
            },
            {
              "keyword": " collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4021,
          "asker": {
            "courseId": 4,
            "askerId": 483,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono i Design Pattern?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "DesignPattern"
            },
            {
              "keyword": "OOP"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4030,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "I Design Pattern; o \"schemi progettuali\", sono dei istruzioni/modelli logici progettati per la risoluzione di un problema ricorrente all'interno di un progetto. Più in particolare in programmazione i design pattern orientati agli oggetti  sono \"schemi\" che mostrano relazioni,interazioni e interconnessioni tra classi,sottoclassi e oggetti, senza specificarne il modello applicativo finale. Più semplicemente: la creazione di un Design Pattern in un progetto, semplifica ESTREMAMENTE le connessioni logico-strutturali; poichè esso non definisce mai una \"soluzione\"(in programmazione un modello applicativo ) finale e specifica, ma solamente una ad un livello superiore e più \"generale\"",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4029,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un design pattern descrive una soluzione generale a un problema di progettazione ricorrente, gli attribuisce un nome, astrae e identifica gli aspetti principali della struttura utilizzata per la soluzione del problema, identifica le classi e le istanze partecipanti e la distribuzione delle responsabilità, descrive quando e come può essere applicato. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4041,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 592,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Si può definire come \"una soluzione progettuale generale ad un problema ricorrente\", ovvero è una descrizione o modello logico da applicare per la risoluzione di un determinato problema, che può presentarsi più volte nella realizzazione di un software.\r\nCiò permette di risolvere il problema senza ogni volta ripensare alla soluzione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4117,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Un design pattern è una soluzione generale ad un problema ricorrente che si verifica comunemente nella progettazione di un software. Si tratta di un modello logico o descrizione della soluzione di un problema che può presentarsi in diverse situazioni durante le fasi di progettazione e sviluppo di un software. Esso non è un framework e non si può \"tradurre\" direttamente in codice, ma è molto utile per imparare soluzioni a problemi già riscontrati da altri, ed essendo identificati da un nome permettono di avere un linguaggio comune tra gli sviluppatori. I design pattern orientati agli oggetti tipicamente mostrano relazioni ed interazioni tra classi o oggetti. Ne esistono di 3 tipi: architetturali, creazionali e comportamentali. Il loro scopo, facendo pieno utilizzo del paradigma della programmazione ad oggetti, è aumentare il decoupling tra le classi e rendere facilmente estensibile e più generico il codice. I più noti sono il pattern Singleton, Strategy, Abstract Factory, Repository.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4025,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Un Design Pattern è un modello creato per la risoluzione di un problema ricorrente nello sviluppo di un software. Esso generalmente comprende indicazioni sulle caratteristiche del problema che deve essere risolto e fornisce un metodo che deve essere applicato per poter giungere alla risoluzione del suddetto problema. Le indicazioni fornite per la risoluzione però sono di tipo astratto: non si fa in alcun modo riferimento al tipo di implementazione che si deve utilizzare per realizzare la soluzione proposta. L'esempio che abbiamo visto in classe è il pattern dell'iteratore il quale, pur avendo sempre gli stessi scopi e le stesse funzioni, viene implementato in maniera completamente diversa a seconda dell?implementazione di Collection che viene utilizzata.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4111,
          "asker": {
            "courseId": 4,
            "askerId": 555,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali problemi nasconde la seguente riga di codice?\r\n\"List s = new List();\"",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " LinkedList"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4066,
          "asker": {
            "courseId": 4,
            "askerId": 537,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'interfaccia \"Iteratore\" in una collection ?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "search"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4020,
          "asker": {
            "courseId": 4,
            "askerId": 426,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa è una collection?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3975,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra List, Set e Map? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "TreSet"
            },
            {
              "keyword": " Map"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4042,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 518,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Le List servono nel caso in cui i dati possano essere duplicati. Due comportamenti analoghi di List sono Stack (pila) e Queue (coda) che implementano il paradigma LIFO (Last In First Out) e FIFO (First In First Out), in cui l'accesso ai dati è permesso soltanto sul primo elemento.\r\nI Set si utilizzano nel caso in cui i dati non devono avere valori replicati. Benché i set non siano ordinati, esiste l'interfaccia SortedSet che estende Set in cui gli elementi sono ordinati. HashSet è una classe implementante.\r\nLa filosofia della Map è quella di salvare una coppia chiave - valore. L'informazione \"importante\" è il valore, mentre la possibilità di accesso a tale valore è la chiave. Benché i dati non siano ordinati nell'interfaccia Map, proprio come per i Set esiste SortedMap la cui implementazione è TreeMap in cui i valori sono ordinati per chiave.La Map non è iterabile, ma si può accedere sia alla lista delle chiavi o alla lista dei valori per poterli iterare singolarmente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4036,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 480,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "La principale differenza che possiamo evidenziare è quella tra List e Set che derivan da Collection, mentre Map costituisce una classe a parte.\r\nEssendo, per l'appunto, collection, List e Set sono utilizzati per creare ragguppamenti di oggetti che differiscono principalmente nella possibilità di contenere o meno oggetti uguali.\r\nMentre una List (tramite le sue implementazioni ArrayList e LinkedList) rappresenta una lista generica di oggetti che possono essere ripetuti più volte e ordinati per inserimento, un set rappresenta una struttura diversa nella quale ogni elemento è unico e viene ordinato secondo specifici criteri.\r\nLe Map, invece, vengono utilizzate tipicamente per creare raggruppamenti di elementi identificabili attraverso una particolare chiave che ne permette comodamente la ricerca e l'identificazione (dinamica key-value). ",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 4088,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Set è una collection che non ammette duplicati,gli elementi non possono essere estratti tramite un indice e gli elementi inseriti non mantengono l'ordine di inserimento. \r\nList in parole povere è il contrario di set ammette duplicati ecc.\r\nMap invece è simile al campo id nei database infatti non ammette duplicati e ogni chiave identifica uno ed uno solo oggetto.\r\nAd esempio nel listino di un  negozio l'oggetto Prodotto sarà legato al suo barcode per fare ciò utilizzerò Map.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4020,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "List e Set sono strutture dati che estendono Collection mentre Map vive indipendentemente.\r\nLa prima contiene dati ordinati e i duplicati sono ammessi, la seconda contiene dati non necessariamente ordinati e non sono ammessi i duplicati, infine la terza struttura è caratterizzata dal fatto che i dati sono indicizzati tramite chiave (che non possono essere multiple) a cui viene associata al massimo un valore e l'ordine non conta.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3976,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze fra i vari tipi di liste affrontati nella lezione riguardante le Collections ?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "liste"
            },
            {
              "keyword": "collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4033,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è utile usare il Java Collection Framework?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " implementazioni"
            },
            {
              "keyword": "algoritmi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4025,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali differenze ci sono fra lists e sets?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Lists"
            },
            {
              "keyword": " Sets"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3977,
          "asker": {
            "courseId": 4,
            "askerId": 501,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo Iteratore implementato nelle Collezioni? ",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collezione"
            },
            {
              "keyword": " Iteratore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4075,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Gli iteratori sono uno strumento molto utile per spostarsi materialmente all'interno delle collezioni, infatti essendo esse delle librerie, non ci permettono di vedere quale sia il codice che le implementa, essendo questo codice \"nascosto\" non si possono fare assunzioni a riguardo.\r\nGli iteratori sono stati resi disponibili per rendere semplice spostarsi all'interno delle collezioni senza per forza conoscere come è scritto il codice che le implementa.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4083,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 558,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "E' un entità che permette di scorrere all'interno di una Collezione.\r\nIn una Lista non è così importante perché basterebbe chiedere la posizione del primo elemento e, avendo la nozione di posizionamento, si riuscirebbe a scorrere all'interno di essa.\r\nIn un Set non avendo la nozione di elemento che si trova in una certa posizione serve un meccanismo per scorrere la Collezione, e questo è il metodo Iteratore!¡",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4108,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 503,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Iteretor è un interfaccia, o più semplicemente una classe astratta che non presenta variabili di istanza (nota: essendo interfaccia permette l'eredità multipla!). Iteretor è un dunque un oggetto e non un metodo, strettamente legato alla struttura della collection scelta, poiché sà come visitarla.\r\nI metodi propri dell'interfaccia Iteretor sono:\r\n-boolean hasNext(): ritorna true se la collezione presenta ancora elementi,ovvero se esiste           l'elemento seguente;\r\n-Object next(): ritorna l'elemento seguente;\r\n- void remove():rimuove l'elemento.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4037,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 466,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Il metodo Iteratore serve per riuscire a navigare in una collezione. Si chiede se in una collezione un elemento ha un successivo con il metodo hasNext() se il valore di ritorno è il booleano true allora posso usare il metodo next() per andare nell'elemento successivo a quello dato nella collezione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4085,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 459,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "per poter avere un sistema generale per lavorare con le collections",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4045,
          "asker": {
            "courseId": 4,
            "askerId": 579,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze fra un set e una list e quando si puo usare indifferentemente una o l'altra?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4086,
          "asker": {
            "courseId": 4,
            "askerId": 573,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le operazioni base delle Collections?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " operazioni base"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3990,
          "asker": {
            "courseId": 4,
            "askerId": 590,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la differenza fra i vari tipi di collections spiegati in classe",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " differenza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4054,
          "asker": {
            "courseId": 4,
            "askerId": 549,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa fa la funzione Object[] toArray(); nella slide 19 delle Collections?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " object"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4052,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Ritorna un array che contiene tutti gli elementi della collezione ordinati secondo l'ordine che da l'iteratore della collezione (se è previsto). L'array ritornato può essere modificato liberamente perché non conserva nessuna referenza con la collezione da cui è stato creato.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4095,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Permette di operare su un oggetto Object[] (inteso come una collection) per trasformarlo in un Array (il cui tipo andrà passato come parametro).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4101,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Nella funzione della slide 19 vengono introdotti gli operatori basici. Il metodo add viene definito generalmente sufficiente in modo che abbia senso per le collezioni che permettono duplicati, così come quelli che non lo fanno. Esso garantisce che la raccolta conterrà gli elementari specificati dopo la chiamata completata, e restituisce true se l'insieme cambia come conseguenza della chiamata.\r\nIl metodo remove è definito per rimuovere una singola istanza dell'elemento specificato da collezione, assumendo la collezione contenente l'elemento, e di ritornare true se la collezione è stata modificata come un risultato.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4138,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 578,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Fa un casting, cioè converte l'oggetto in un array",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4112,
          "asker": {
            "courseId": 4,
            "askerId": 505,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Sapresti usare una lista di oggetti senza le collection in java? Se si, spiega come faresti.",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection "
            },
            {
              "keyword": " list"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4072,
          "asker": {
            "courseId": 4,
            "askerId": 517,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono gli bulk operations e in cosa sono differenti e/o simili  con le aggregate operations?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "bulk operations"
            },
            {
              "keyword": " aggregate operations"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4135,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 500,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Le Bulk Operations sono traducendo letteralmente operazioni di ampliamento/rinforzo e quest'ultime in qualche \"simulano\" le operazioni insiemistiche (unione, intersezione, differenza,...). Per quanto riguarda le Aggregate Operations sinceramente non so cosa sono e non le ho nemmeno trovate tra le slide perciò posso rispondere solo alla domanda sulle Bulk.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4034,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 520,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Le bulk operations sono operazioni complessive sulla collezione, mentre le aggregate operations permettono operazioni tra arrays.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4086,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 593,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Le Bulk operations eseguono un operazione su un intera collezione. Le aggregate operation sono utilizzate con le lambda expression per rendere il programma più capibile e con meno righe di codice.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4099,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Le Bulk operations (boolean containsAll(Collection c); boolean addAll(Collection c); boolean removeAll(Collection c); boolean retainAll(Collection c); void clear();) sono dei metodi che eseguono delle operazioni su una Collection, con lo scopo di modificarla (per esempio per aggiungere/rimuovere degli elementi). Le Aggregate operations, che sono state recentemente introdotte in Java, operano sempre su una Collection, ma senza modificarla.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4120,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 430,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Le bulk operations sono genericamente delle operazioni che operano da una collezione ad  un'altra: ad esempio il removeAll rimuove tutti gli elementi di una collezione iterabile da un'altra (quella sulla quale viene chiamato), quindi l'utente deve specificare due collezioni con le quali eseguire in questo caso operazioni insiemistiche. Le aggregate operations invece sono operazioni che non usano l'iterazione interna e per le quali va specificato al più un parametro di tipo espressione lambda che specifichi come devono essere gli elementi e non quali. Infatti le a.o. agiscono concettualmente su di uno stream di dati.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3984,
          "asker": {
            "courseId": 4,
            "askerId": 497,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra list e set?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "List"
            },
            {
              "keyword": " set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3992,
          "asker": {
            "courseId": 4,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e a cosa servono le \"Bulk operations\"?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "bulk operations"
            },
            {
              "keyword": " collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4002,
          "asker": {
            "courseId": 4,
            "askerId": 552,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una collection? :>",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": "Cos'è"
            },
            {
              "keyword": "Una"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4003,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella slide 40 c'è un diagramma. Spiegalo in poche e semplici parole.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "spiega"
            },
            {
              "keyword": "diagramma"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4065,
          "asker": {
            "courseId": 4,
            "askerId": 575,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può usare LinkedList per realizzare una pila?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "LinkedList"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3981,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Per cosa vengono utilizzate le interfacce?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4047,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "In Java l'interfaccia ha una struttura simile a una classe, ma può contenere SOLO metodi d'istanza astratti e costanti (quindi non può contenere costruttori, variabili statiche, variabili di istanza e metodi statici).  Il metodo delle interfacce è quindi ampiamente riutilizzabile e inoltre viene garantita anche la massima estendibilità: non si ha infatti alcun vincolo sulle classi che implementano l'interfaccia e nulla vieta, ad esempio, di includere funzionalità avanzate. Ecco perchè sono comode se in un futuro voglio implementarle in un diverso modo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4024,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Nel linguaggio Java un' interfaccia è una struttura simile a una classe che però non può contenere nulla se non costanti e metodi d'istanza astratti. \r\nLa classe che implementa una data interfaccia deve fornire una realizzazione per tutti i metodi astratti dell'interfaccia fornendo metodi con la stessa firma e con lo stesso corpo  descritta dall'interfaccia. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4019,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "le interfacce vengono utilizzate per definire cosa un determinato oggetto potrà/dovrà fare. sono molto utili perché possono esser implementate più interfacce all'interno di ogni classe ,ad esempio e quella classe contiene oggetti di tipi diversi. i metodi delle interfacce devono comunque esser sovrascritti perché sono in maggior parte Abstract per poterli utilizzare. fondamentalmente le interfacce definiscono come agire con un oggetto",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4057,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Le interfacce consentono di implementare l'ereditarietà multipla, cosa che in Java non è possibile tra classi. Inoltre permettono di creare un' interfaccia appunto, una vista che permetta al programmatore client di sapere che cosa fa una determinata classe, quali sono le sue funzionalità, ma non come viene implementata. In sostanza nasconde l'interfaccia dall'implementazione.  ",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4008,
          "asker": {
            "courseId": 4,
            "askerId": 572,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le collections? Quali sono i suoi svantaggi e vantaggi?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4014,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le operazione di base delle collection? Sono simili?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " operazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4087,
          "asker": {
            "courseId": 4,
            "askerId": 545,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Come faccio a trasferire una collection da un metodo a un altro?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "trasferimento_dati"
            },
            {
              "keyword": " metodo"
            },
            {
              "keyword": " collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4109,
          "asker": {
            "courseId": 4,
            "askerId": 581,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare una libreria?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "libreria"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4046,
          "asker": {
            "courseId": 4,
            "askerId": 577,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un iteratore?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " iteratore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3989,
          "asker": {
            "courseId": 4,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una collezione?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " collezione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3979,
          "asker": {
            "courseId": 4,
            "askerId": 551,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali differenze ci sono tra un Set ed una List?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": " List"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3999,
          "asker": {
            "courseId": 4,
            "askerId": 519,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che avrei ad utilizzare (tramite ereditarietà o altro) una collection anziché implementare una classe che svolga lo stesso compito, ma più semplice e adatta alle mie esigenze?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4099,
          "asker": {
            "courseId": 4,
            "askerId": 563,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare una libreria nell'ambito delle collection?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Librerie"
            },
            {
              "keyword": " Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4028,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il principale vantaggio dell'uso delle collection?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4057,
          "asker": {
            "courseId": 4,
            "askerId": 442,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale differenza c'è tra l'instanziare un set anzichè un arraylist e come si dichiara correttamente una collection?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " set "
            },
            {
              "keyword": "array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4089,
          "asker": {
            "courseId": 4,
            "askerId": 457,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare una collection?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3986,
          "asker": {
            "courseId": 4,
            "askerId": 427,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "che vantaggi porta utilizzare una libreria ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "libreria "
            },
            {
              "keyword": " java "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4074,
          "asker": {
            "courseId": 4,
            "askerId": 477,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile ordinare una lista in Java?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " ordered list"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4090,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Sì. In alcuni casi c'è da fare un passo in più.\r\nFinchè sono liste di tipi di dato \"standard\", come int e double, tutto va bene: basta importare il package Collections e chiamare Collections.sort(miaLista), che te lo ordina in modo crescente, oppure Collections.sort(miaLista, Collections.reverseOrder()) per farlo in ordine decrescente.\r\nLe cose diventano più difficili quando vuoi un altro criterio di ordinamento e/o vuoi ordinare liste di strutture dati, di cui non si può sapere secondo quale campo vuoi ordinare la tua lista (es: elenco telefonico: prima secondo Città, poi secondo Cognome). In questo caso o fai un override del metodo compareTo() che appartiene all'interfaccia Comparable, o meglio ancora implementi una funzione di ordinamento che applichi con Collection.sort(miaLista, mioCriterioOrdinamento()).\r\nPurtroppo lo spazio per rispondere è poco, e sono costretto a mettere dei link per poter dare degli esempi: bit.ly/ 1ijOW85 ;; bit.ly/ 1dQr0MA (senza spazio dopo lo /, ovvio)",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4082,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Si è possibile riordinare una lista purché il tipo della lista abbia implementato il metodo compareTo dell'interfaccia Comparable altrimenti non è possibile stabilire se un elemento viene prima di un altro.\r\nPer riordinarla il metodo sort da utilizzare è definito dentro Collections.\r\nEsempio:\r\n\r\npublic class Libro implements Comparable<Libro>\r\n{\r\n    string titolo;\r\n\r\n    public Libro(string titolo)\r\n    {\r\n        this.titolo = titolo;\r\n    }\r\n    public int compareTo(Libro l)\r\n    {\r\n        if (this.titolo.compareTo(l.titolo)<0)\r\n            return -1;\r\n        else if (this.titolo.equals(l.titolo))\r\n            return 0;\r\n        else\r\n            return 1;\r\n    }\r\n}\r\n\r\nList<Libro> libri = new ArrayList<Libro>();\r\nlibri.add(new Libro(\"Titolo2\"));\r\nlibri.add(new Libro(\"Titolo1\"));\r\nlibri.add(new Libro(\"Titolo3\"));\r\nCollections.sort(libri);   <-- Riordinamento",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4080,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Si, basta usare il metodo lista.sort(). Tuttavia, per funzionare questo metodo necessita che l'interfaccia Comparable sia implementata, ovvero il metodo compare(object o) sia presente. Per i tipi predefiniti (String, int, float, ...) è già presente, mentre per le classi definite dal programmatore bisogna scriverlo.\r\nIn questo modo si può decidere come e perchè due classi devono essere uguali, a seconda del contesto.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4106,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con Collections?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4096,
          "asker": {
            "courseId": 4,
            "askerId": 541,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare brevemente la differenza tra Map e SortedMap e tra Set e SortedSet",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "map"
            },
            {
              "keyword": " sortedmap"
            },
            {
              "keyword": " set"
            },
            {
              "keyword": " sortedset"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4092,
          "asker": {
            "courseId": 4,
            "askerId": 565,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra SET e LIST?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " interfaces"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4037,
          "asker": {
            "courseId": 4,
            "askerId": 511,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Array, lista linkata array, albero binario.. fin qua tutto ok.. ma bag? O.o",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "bag"
            },
            {
              "keyword": " dubbio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4056,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra set e list e in quali contesti è preferibile scegliere set anzichè list e viceversa?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "set"
            },
            {
              "keyword": "list"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4091,
          "asker": {
            "courseId": 4,
            "askerId": 489,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per HashSet?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "HashSet"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3983,
          "asker": {
            "courseId": 4,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "quali sono le limitazioni di classi/metodi dichiarati abstract?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4056,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Una classe dichiarata abstract può portare ad avere problemi se si ha la necessità di creare una classe che erediti da due o più classi astratte contemporaneamente. Le classi astratte infatti, a differenza delle interfacce, non consentono l'ereditarietà multipla.\r\nSe ad esempio ho la necessità di creare una classe \"Auto\" che deve implementare allo stesso tempo i metodi di due classi \"Motore\" e \"Ruote\", queste ultime due classi dovranno per forza essere dichiarate come interfacce.\r\n\r\nLe classi astratte inoltre non possono essere istanziate.\r\n\r\nUna limitazione dei metodi astratti invece consiste nel fatto che possono essere dichiarati solamente in classi astratte ed inoltre non possono essere definiti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4038,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "L'inizializzazione.\r\nLe classi abstract sono tali perchè contengono metodi abstract. Un metodo è di questo tipo quando è dichiarato nella classe ma NON implementato. Ciò comporta che una classe abstract non possa essere inizializzata, in quanto priva di una parte che rimane appunto \"astratta\". \r\nL'utilità di questo tipo di classe sta nell'organizzazione del codice, ovvero quando ci si trova ad aver a che fare con oggetti abbastanza simili da avere parte del codice in comune ma abbastanza diversi da funzionare in modo decisamente differente si può creare una classe abstract contente il codice in comune che poi verrà subclassata e completata dalle sottoclassi. Tutto questo potrebbe essere ottenuto anche con una classe normale, ma la keyword \"abstract\" permette una miglior LEGGIBILITA' del codice perchè comunica all'istante a chi legge che si tratta di una classe di supporto.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4016,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Le classi dichiarate abstract non possono essere istanziate cioè non posso fare:\r\nClasseAstratta p = new ClasseAstratta();\r\nInoltre devono essere sottoclassate, cioè devono avere delle sottoclassi.\r\n\r\nI metodi astratti invece sono solo delle dichiarazioni che poi dovranno essere sovrascritte nelle sottoclassi. Per esempio:\r\n\r\npublic abstract class Stack {\r\n    public void inserisci(int) { ... }\r\n    public void cresci() { ... }\r\n    public abstract int estrai();    // Metodo astratto solo dichiarato\r\n}\r\n\r\npublic class Pila extends Stack {\r\n    public int estrai() { ... }    // Metodo implementato da quello astratto\r\n}\r\n\r\nInoltre i metodi astratti non possono essere contenuti in una classe non astratta.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4075,
          "asker": {
            "courseId": 4,
            "askerId": 428,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le 'collection'? Con che scopo vengono utilizzate in genere?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " entità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4084,
          "asker": {
            "courseId": 4,
            "askerId": 461,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa diferiscono le collections dagli array?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4064,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Collections di che tipo prima di tutto? Se parliamo di liste, la principale differenza sta nella dimensione, un array ha dimensione fissa mentre una lista è dinamica.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4045,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Una Collection è un interfaccia più generica, non definisce nè l?ordine in cui sono memorizzati gli elementi nè se ci possono essere elementi duplicati.\r\nA differenza degli Array tutte le collection non possono contenere tipi primitivi ma solamente oggetti, per inserire tipi primitivi è necessario usare un oggetto wrapper.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4121,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 481,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "le collections sono un classe che deriva da object in cui sono state implementate funzioni che modificano o restituiscono collections. Gli array invece sono un insieme di dati omogenei con cui si puo accedere con un indice",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4022,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Fondamentalmente un array è semplicemente un insieme di dati, mentre la collection è un insieme di dati, ma al suo interno vi sono anche i metodi per trattare quei dati.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4036,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con pattern?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pattern"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4079,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "perché nell'implementazione di coda e pila come estensioni di una LinkedList è necessario definire una classe Number?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4039,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Nell'implementazione di una coda e pila come Linkedlist non è \"necessario\" definire una classe Number, in quanto era un metodo di esempio per far capire come funzionasse la Linkedlist con la sequente classe nulla di più.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4084,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 548,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "La classe Number non è necessaria, viene implementata solamente come esempio nelle slide del professore.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4023,
          "asker": {
            "courseId": 4,
            "askerId": 540,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le collections? Fornisci un esempio pratico",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4044,
          "asker": {
            "courseId": 4,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "List, Set e Map sono tutte collections? Quali sono le differenze principali tra di esse? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4137,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 444,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Le interfacce Set e List estendono Collection mentre Map no. Un oggetto List contiene oggetti ordinati in base all?ordine di inserimento, può contenere duplicati e permette di inserire e ottenere gli elementi in base all?indice. Set contiene invece oggetti non ordinati, non ha elementi duplicati ed essi non sono accessibili tramite indice. Map è un entità che abbina oggetti a chiavi  di inserimento/ricerca, ovverosia una tabella. Map non puo&#768; contenere chiavi duplicate: ciascuna chiave è univocamente in relazione con un oggetto.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4073,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 468,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "List permette di raggruppare elementi e di mantenerne l'ordine di inserimento, inoltre in una list si posso inserire anche elementi che sono già presenti o duplicati.\r\nIn un set invece non è possibile inserire elementi duplicati,  ed inoltre gli elementi inseriti non mantengono l'ordine di inserimento. \r\nUna map non è altro che un insieme di oggetti raggruppati secondo una 'chiave' che identifica gli oggetti in modo univoco ad esempio un ID oppure il codice fiscale. Ovviamente non è possibile avere chiavi duplicate.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4062,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": " List e Set sono strutture dati che estendono Collection mentre Map vive indipendentemente. Una Collection è un contenitore di un insieme di valori, una sorta di array dinamico. A seconda dell'utilità, si possono usare diverse implementazioni dell'interfaccia Collection. Essa infine può essere tipizzata, ossia contenere solo dati di un certo tipo, tale tipo si indica attraverso i Generics (indicandolo fra parentesi angolari). Siccome il tipo è un oggetto, per esprimere primitivi come int bisogna usare i wrapper come Integer.\r\n",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 4060,
          "asker": {
            "courseId": 4,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve e come si implementa l'oggetto iterator?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4000,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono le collection? a cosa servono?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4067,
          "asker": {
            "courseId": 4,
            "askerId": 469,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra l'uso di un set o di una list nelle collection??",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": "list"
            },
            {
              "keyword": "collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4010,
          "asker": {
            "courseId": 4,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Dammi una esaustiva definizione di collection ??? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Esaustiva"
            },
            {
              "keyword": " definizione"
            },
            {
              "keyword": " collection "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4093,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Si dica cosa sono le COLLECTIONS e in cosa consiste il loro utilizzo.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": "dati"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 4026,
          "asker": {
            "courseId": 4,
            "askerId": 530,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 102,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può dire che un interfaccia è una convenzione tra il programmatore che la scrive e quello che poi la utilizzerà?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Interfaces"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4033,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Un interfaccia è un mezzo per assicurare che una classe implementi determinati metodi (e in alcuni casi campi) astratti definiti all'interno di essa. Le interfacce sono utilizzate ad esempio all'interno di Java e dei linguaggi .Net perché permettono l'ereditarietà multipla, a differenza delle classi. Le interfacce permettono quindi ad esempio di sapere che la particolare classe che la implementa può essere ordinata (comparable) quindi sì, sotto un certo punto di vista, si possono definire convenzioni tra programmatore che scrive codice e programmatore che poi utilizzerà suddetto codice.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 4074,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Sì, perché nelle interfacce vengono solamente definite firme e metodi, senza implementazione. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4087,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 499,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "È un modo corretto di considerare la questione, cioè vedere le interfacce come un accordo che il programmatore del 'passato' e quello del 'presente' fanno. Una delle funzioni principali delle interfacce è proprio quella di porre dei vincoli alle classi che le implementeranno, cioè se un programmatore definisce una interfaccia A caratterizzata da alcuni metodi astratti (privi di codice), un nuovo programmatore che vuole definire una classe B implements A sarà obbligato a implementare tutti i metodi presenti in A. Questo consente di creare delle speciali relazioni tra alcune classi, cioè classi che implementano la stessa interfaccia sono simili esternamente (hanno metodi con nome, tipi di input e output identici) ma internamente hanno una struttura differente (i metodi possono essere radicalmente diversi). Un?altra caratteristica delle interfacce è l?ereditarietà multipla: in Java non è ammissibile l?ereditarietà multipla di classi ma è possibile che una classe erediti da più interfacce.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4060,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 541,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Sì, perchè il programatore che la scrive immagina di quali metodi potrà avere bisogno una certa categoria di classi e quindi prevede uno \"schema\" che il programmatore che utilizzerà l'interfaccia deve seguire nella creazione delle suddette classi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4089,
              "task": {
                "taskId": 105,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 456,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Si può dirlo, nel senso che da un'interfaccia non è possibile istanziare alcun oggetto e che in essa possono essere definiti solo metodi astratti, i quali devono essere obbligatoriamente riscritti in un'estensione dell'interfaccia. Ciò implica che i membri lì definiti sono solo delle linee guida, delle consegne, che chi implementa l'interfaccia lascia al programmatore che la estenderà. Questo è il vero e proprio contratto, o convenzione, tra l'implementatore dell'interfaccia e l'implementatore di una sua estensione.",
              "notes": "-",
              "rating": 4,
              "coins": []
            }
          ]
        }
      ]
    },
    {
      "lectureId": 43,
      "lectureTitle": "Polimorfismo",
      "questions": [
        {
          "questionId": 3953,
          "asker": {
            "courseId": 4,
            "askerId": 453,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo viene gestita la scelta dei metodi (es. estrai()) ereditati da una superclasse mantenendo la stessa firma ma una definizione diversa?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "dynamic binding"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3878,
          "asker": {
            "courseId": 4,
            "askerId": 450,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze in un downcast e un upcast??",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "downcast "
            },
            {
              "keyword": " upcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3935,
          "asker": {
            "courseId": 4,
            "askerId": 547,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono vantaggi e svantaggi del dynamic binding?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "dynamic bindig"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3939,
          "asker": {
            "courseId": 4,
            "askerId": 495,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "La seguente affermazione è corretta?\r\n\"Una classe è abstract se e solo se possiede al proprio interno metodi abstract.\"",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3963,
          "asker": {
            "courseId": 4,
            "askerId": 524,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Se in una sottoclasse viene un nuovo oggetto (chiamiamolo 'a') con le specifiche caratteristiche dell' immediata superclasse, ma al momento della chiamata \"new\" l'oggetto 'a' viene definito come oggetto della sottoclasse (che estende la super per 1 solo oggetto), come viene definito l'oggetto 'a'? Di quali funzionalità è fornito?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "casting"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3843,
          "asker": {
            "courseId": 4,
            "askerId": 529,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "come funziona il processo di sostituzione di Liskov?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Liskov"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3926,
          "asker": {
            "courseId": 4,
            "askerId": 563,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando del polimorfismo, cosa vuol dire fare un \"downcast\"?",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 5,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Downcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3965,
          "asker": {
            "courseId": 4,
            "askerId": 478,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra static binding e dynamic binding?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " java c++"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3873,
          "asker": {
            "courseId": 4,
            "askerId": 483,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché non serve l'operatore di downcast per chiamare un metodo che fa l'override di un metodo della classe padre?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "downcast"
            },
            {
              "keyword": "override"
            },
            {
              "keyword": "polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3934,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 575,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Supponiamo di avere: classe A avente il metodo f() <--IS-A-- classe B avente il metodo f()\r\ndove il metodo f() della classe B fa overriding del metodo f() della classe A (stesso nome e stessi parametri).\r\nSe scriviamo B pippo; pippo = new B(); pippo.f(); il compilatore controlla che nella classe B ci sia il metodo f (che c'è). Tale metodo viene poi eseguito a run-time.\r\nSe scriviamo A pippo; pippo = new B(); pippo.f(); il compilatore per il principio di sostituzione di Liskov accetta la creazione di pippo e poi controlla che nella classe A ci sia il metodo f (che c'è) e quindi non serve usare l'operatore di downcast ovvero non serve dire al compilatore che deve cercare il metodo f() dentro B. A run-time invece viene eseguito il metodo f() della classe B poichè a run-time pippo è un B.",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3995,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 487,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Non è necessario l'utilizzo dell'operatore di Downcast poiché in fase di compilazione del programma il compilatore verifica che il metodo chiamato esista prima all'interno della classe che lo chiama e solo nel caso in cui non sia presente in tale classe andrà a cercarlo nella classe padre. In questo caso dopo aver eseguito l'override, ovvero la riscrittura di un metodo già presente nella classe padre, il metodo vive anche nella classe figlio e quindi quando verrà chiamato il compilatore lo troverà subito nella classe figlio, senza doverlo andare a cercare altrove. It's a matter of scope!",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3891,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 531,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "non riesco a capire la domanda",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3957,
          "asker": {
            "courseId": 4,
            "askerId": 554,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi  del polimorfismo in Java?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3943,
          "asker": {
            "courseId": 4,
            "askerId": 540,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il polimorfismo?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " liskov"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3872,
          "asker": {
            "courseId": 4,
            "askerId": 444,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere i due differenti tipi di binding, quale è utilizzato in java? quale in c++?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Compilatore"
            },
            {
              "keyword": " Runtime"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3910,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 579,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Ci sono due tipi di binding, statico e dinamico. Il binding statico viene risolto a livello di compilazione, il binding dinamico viene risolto a run time.\r\nJava li usa entrambi, il c++ solo il secondo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3904,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 513,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "In c++ viene utilizzato lo Static Binding, il quale viene eseguito in tempo di compilazione. In Java invece viene usato il Dynamic Binding, nel quale differentemente avviene in tempo di run-time. In generale se un oggetto viene dichiarato come una superclasse e poi viene indirizzato verso un blocco di memoria riservato ad una sottoclasse ereditaria, lo static binding implica che l'oggetto non acquisisce nulla dalla sottoclasse, differentemente dal dynamic binding che fa in modo che la classe della variabile viene estesa alla sottoclasse e quindi è possibile utilizzarne i metodi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3887,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 469,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "I due tipi di binding sono lo static binding e il dynamic binding, lo static binding è utilizzato da c++ e consiste nel prendere i metodi della classe la quale e' stata dichiarata all'inizio quindi come l'esempio che abbiamo visto a lezione. A differenza il dynamic binding usato da java,prende  i metodi di una classe a runtime invece che come lo static binding al momento della compilazione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3914,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 497,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Esistono due tipi di binding: \"static binding\" e \"dynamic binding\". Il primo, utilizzato in C++, si limita a verificare la correttezza della nostra inizializzazione (per esempio Pila s = new Coda()) a livello di dichiarazione. Il secondo invece viene utilizzato in java e consiste in una procedura più complessa, in quanto controlla l'area di memoria a cui la nostra dichiarazione si riferisce, e quindi cosa contiene.\r\n(per fare un \"dynamic binding\" in C++ bisogna accostare al tipo della funzione, il metodo \"virtual\": per esempio virtual int estrai();)",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3985,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 524,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il binding può essere statico o dinamico, ciò significa che opera in due situazioni diverse. \r\nQuello statico (?static binding?) avviene al ?compile time? (tempo di compilazione), mentre quello dinamico (?dynamic binding?)  al ?run time? (tempo di esecuzione).\r\nLo ?static binding? opera quando si usano classi semplici, quello dinamico nel momento in cui si introducono sottoclassi e metodi virtuali, perchè il compilatore non sa esattamente quali metodi chiamare fino al momento dell' esecuzione.\r\nIn  Java, come detto sopra, dipende da come è stato scritto il codice. Stesso discorso vale per il c++.\r\nInfatti, non esiste metodo giusto o sbagliato, ma metodo adatto alla situazione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3931,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 437,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il binding è quel processo che definisce le azioni che dovranno essere implementate dalla macchina per eseguire i nostri comandi (binding &#8594; avvolgere, fissare, impegnare) ci sono due tipi di binding, il dinamic binding (Java) e lo static binding (C++).  Lo static binding avviene al momento della compilazione del codice, all'interno del codice compilato possiamo già trovare ben definiti tutti i vari processi e le varie azioni che verranno poi assegnate alla macchina. Nel dinamic binding il codice non viene subito legato alle varie locazioni di memoria e alle azioni che lo implementeranno effettivamente, questo ci da la possibilità di scrivere codice polimorfo (->capacità di una classe di utilizzare i metodi reimplementati da una sua sottoclasse, rende il codice più resistente, portabile ma soprattutto leggibile!), c'è solo un unico piccolo problema: al programmatore è dato il compito di scrivere cose sensate, infatti un programma che compila, può crashare a runtime. ",
              "notes": "-",
              "rating": 5,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3945,
          "asker": {
            "courseId": 4,
            "askerId": 502,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano \"Try\", \"Catch\" e \"Finally\"?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Try"
            },
            {
              "keyword": " Catch"
            },
            {
              "keyword": " Finally "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3944,
          "asker": {
            "courseId": 4,
            "askerId": 541,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare brevemente i concetti di Downcast e Upcast (aiutandosi anche con un esempio)",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Upcast"
            },
            {
              "keyword": " Downcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3904,
          "asker": {
            "courseId": 4,
            "askerId": 496,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Se B è una sottoclasse di A, b è un oggetto di tipo B e a è un oggetto di tipo A, è possibile eseguire l'istruzione \"b=a;\"? Se si quali metodi saranno accessibili da b dopo l'esecuzione di tale istruzione?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " assegnazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3868,
          "asker": {
            "courseId": 4,
            "askerId": 439,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "¿Che cosa si intende con il termine \"static binding\"?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " significato"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3884,
          "asker": {
            "courseId": 4,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono il downcast e l'upcast?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "downcast"
            },
            {
              "keyword": " upcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3929,
          "asker": {
            "courseId": 4,
            "askerId": 515,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'utilità di definire una classe o un metodo abstract ?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": "classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3937,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 523,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Per poi poter ereditare le funzioni e ridichiararle.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3981,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "anzitutto, non si può definire un metodo abstract nella classe qualsiasi, cioè una classe non abstract non può contenere un metodo abstract. per quanto riguarda una classe abstract, è utile perchè contiene solo dichiarazioni dei metodi, invece le diverse implementazioni vengono scritti direttamente nelle  sottoclassi. quindi in questo caso non si fa confusione con overriding, poichè implementi un metodo come ti pare nella sottoclasse dove avrai bisogno:) ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3918,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 546,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "L'utilita' di utilizzare classi o metodi abstract e' quella di una migliore organizzazione logica dell'albero delle classi. Puo' risultare piu' comodo definire una classe abstract che raccoglie gli elementi comuni di altre 2 o piu' classi che erediteranno da essa (Coda e Pila ereditano da Stack per esempio, concettualmente piu' vicino a ciò che pensiamo), inoltre spesso si vuole evitare che questa classe venga istanziata abstract impedisce cio' (errore a compile-time).\r\nUn ulteriore esempio: si supponga di voler creare un albero di classi che rappresenti la classificazione degli animali.\r\nSi creera' una classe Animale con alcuni parametri comuni (numero zampe...), pero' si vorrebbe evitare che essa venisse istanziata in quanto \"animale\" e' un concetto astratto e una sua istanza sarebbe priva di significato, stessa cosa per mammifero ecc tutte queste si dichiareranno abstract. In questo modo si crea una gerarchia ben strutturata, intuitiva e che utilizza in modo efficace l'ereditarieta'",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3946,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 423,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Caratteristica utile di una classe astratta è il non poter istanziarla, e ciò permette alle classe figlie, dotate necessariamente dei metodi della superclasse, di modificarli secondo le necessità (risulta utile in confronto ad una classe non astratta perchè altrimenti certi metodi andrebbero modificati apposta, mentre nelle astratte basta definirli nuovamente). Inoltre le classi astratte sono utili perchè rappresentano concetti non descrivibili perchè non concreti, quindi si possono creare classi astratte con determinate proprietà da cui deriveranno altre classi che avranno quelle proprietà in comune. ",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3919,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 475,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "E' di obbligare i programmatori a definire sottoclassi, e di evitare la complicazione di metodi predefiniti inutili e che questi metodi siano ereditati per errore.\r\n",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3930,
          "asker": {
            "courseId": 4,
            "askerId": 490,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Static binding e Dynamic binding?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dinamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3952,
          "asker": {
            "courseId": 4,
            "askerId": 457,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos' è esattamente il polimorfismo? Un algoritmo o una funzione? E cos' ha a che fare con le pile o le code?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " pile"
            },
            {
              "keyword": " code"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3871,
          "asker": {
            "courseId": 4,
            "askerId": 552,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Spettabile studente,\r\navendo un NamedPoint p; posso istanziarlo come Point p, a si?\r\n",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3891,
          "asker": {
            "courseId": 4,
            "askerId": 592,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa afferma il principio di Liskov basato sul polimorfismo?\r\nDi conseguenza qual è il grande vantaggio offerto da un linguaggio orientato ad oggetti, grazie al polimorfismo?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Liskov"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3834,
          "asker": {
            "courseId": 4,
            "askerId": 423,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali ambiti può essere utile usare classi dichiarate abstract piuttosto che normali?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3841,
          "asker": {
            "courseId": 4,
            "askerId": 426,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per polimorfismo?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3881,
          "asker": {
            "courseId": 4,
            "askerId": 509,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando del Polimorfismo in Java, cosa significa e in che cosa consiste un upcast implicito?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "upcast"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3928,
          "asker": {
            "courseId": 4,
            "askerId": 488,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Se creo una classe persona e una sua sottoclasse studente, che problemi incontro se scrivo:\r\nstudente p = new persona(); ?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classe"
            },
            {
              "keyword": " sotto classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4002,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 555,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Va qui ricordato che l'ereditarietà altro non è che l'implementazione della relazione \"is-a\": siccome la classe \"studente\" è definita come una sottoclasse di \"persona\" (e quindi ogni studente \"è-una\" persona), le regole di programmazione permettono di usare un'istanza di \"studente\" ogniqualvolta il contesto richiede un'istanza di \"persona\". Pertanto, il codice\r\n   persona q = new studente();\r\nè corretto, dato che q è di tipo \"persona\" e punta ad uno \"studente\", che però \"è-una\" \"persona\".\r\nD'altra parte, non è in generale vero che ogni persona \"è-uno\" studente, e quindi non è lecito fornire un'istanza di \"persona\" quando il contesto ne richiede una di \"studente\". Per questo motivo, il codice\r\n   studente p = new persona();\r\nnon è corretto - in particolare, esso produce un errore a compile-time (il compilatore si sofferma esclusivamente sui tipi quando controlla il codice, e nota che in questo caso non sono compatibili).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4008,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 577,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Il seguente codice da un errore in compile-time, infatti viene segnalato un \"incompatible types: persona cannot be converted to studente\". C'è da sottolineare che in questo caso si sta cercando di fare una specie di downcast implicito, che non è assolutamente possibile, innanzitutto perchè i downcast devono essere espliciti e poi perchè l'oggetto creato non contiene niente che possa ricondurre ad un downcast a studente, ad esempio:\r\n\r\npersona p = new studente(); //upcast implicito, p contiene (\"holds\") le informazioni riguardanti studente (non utilizzabili senza un downcast)\r\nstudente s = (studente)p; //downcast esplicito senza problemi",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3877,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 436,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Non posso farlo perché studente è una sottoclasse di persona e quindi non può essere istanziato come tale.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3983,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 519,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "L'operazione effettuata è un errore senza mezzi termini, il codice nemmeno può essere compilato se contiene tale istruzione.\r\nIl polimorfismo ci permette, riassumendo da un punto di vista pratico, di dichiarare una variabile/riferimento di una classe ed assegnarli, successivamente, un'istanza di una qualsiasi sottoclasse.\r\nIn quest'esempio si fa l'opposto: ad una \"variabile studente\" si vuole assegnare un'istanza di \"persona\", ma è, come già detto, un errore.\r\nLa (presunta) versione corretta avrebbe assegnato un'istanza di \"studente\" ad una \"variabile di persona\":\r\npersona p = new studente();\r\nè corretto, poiché \"studente\" è una sottoclasse di \"persona\", \"studente\" è una -is a- \"persona\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4001,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 505,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Da errore perché una persona non è uno studente... Il compilatore si aspetta di poter chiamare tutti i metodi di studente su quella persona, cosa che non può fare e quindi non compila",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3867,
          "asker": {
            "courseId": 4,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra quello che viene chiamato polimorfismo verticale e quello che viene chiamato polimorfismo orizzontale?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3846,
          "asker": {
            "courseId": 4,
            "askerId": 446,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestita l'ereditarietà in relazione all'utilizzo di polimorfismi?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3849,
          "asker": {
            "courseId": 4,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "cos`e il polimorfismo?)",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " significato"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3866,
          "asker": {
            "courseId": 4,
            "askerId": 436,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra static e dinamic binding?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " dinamic"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3916,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 433,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Static e Dynamic binding sono due modi differenti per risolvere un problema di ambiguità riguardo il polimorfismo, ovvero se abbiamo dichiarato un oggetto di tipo classePadre, ma lo abbiamo istanziato come classeFiglio, se ciamiamo i metodi su questo oggetto, il sistema può far riferimento alla dichiarazione di tipo (quindi alla classe padre) o all'istanzazione (classe figlio), e questi sono rispettivamente static binding (quindi si fa riferimento al tipo) o dynamic binding (si fa riferimento al tipo di istanzazione).\r\nStatic binding viene usato da C++, mentre Dynamic Binding viene usato da Java",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3944,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 499,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Consideriamo una classe A e una classe B che eredita da A. Con il principio di sostituzione di Liskov è possibile avere una scrittura di questo tipo: A a =  new B(), cioè è possibile sostituire un oggetto dichiarato appartenente a una classe padre (A in questo caso) con un oggetto del tipo di una sua sottoclasse (B). Supponiamo ora che in entrambe le classi sia definito un metodo con lo stesso nome e gli stessi parametri in entrata ( aggiungi(int x) {-}). Se ora viene eseguito un codice che contiene la seguente scrittura A a = new B(); a.aggiungi(3); si presentano due possibili scenari: viene invocato il metodo della classe A (static binding) oppure quello della classe B (dynamic binding).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3973,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 460,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "La differenza fra static e dynamic binding è il momento in cui viene effettuato il binding, cioè il momento in cui gli identificatori vengono associati agli indirizzi contenenti i rispettivi dati e/o parti di codice: nel primo caso a compile time, nel secondo a run time. In particolare si può parlare di binding di variabili, metodi, strutture e, in generale di una qualsiasi entità di un programma.\r\nIn pratica, se il binding è statico viene creata già a compile time una parte di codice (glue code) che associa la parte di codice da eseguire al suo \"nome\".\r\nIl dynamic binding invece  permette di rimandare il binding a run time, rendendo l'oggetto in questione una sorta di \"scatola vuota\" fino all'esecuzione del programma: esso è di fondamentale importanza nella programmazione ad oggetti perché permette  il polimorfismo degli oggetti, seppur a discapito di una certa efficienza (infatti C++ utilizza di default lo static binding, al contrario di Java che utilizza esclusivamente il dynamic).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3907,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 542,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Lo static binding avviene al compile time, se il compilatore può risolvere con esattezza quale metodo chiamare (ad esempio se il metodo è static), invece il dinamic binding, che avviene al run time, risolve quale metodo usare nel momento in cui questo non sia stato fatto al compile time (ad esempio se si hanno due metodi con lo stesso nome, ma firma diversa, al run time verrà deciso quale dei due va usato in base alla firma).",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3909,
          "asker": {
            "courseId": 4,
            "askerId": 564,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "qual è la differenza fra overloading e overriding?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": "overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3851,
          "asker": {
            "courseId": 4,
            "askerId": 498,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nell'esempio visto a lezione (slide n. 10), è corretto dichiarare s come Pila e non come Coda?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3956,
          "asker": {
            "courseId": 4,
            "askerId": 476,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è fra l'utilizzo di static binding e dynamic binding?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "compile time"
            },
            {
              "keyword": " types"
            },
            {
              "keyword": " instance"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3915,
          "asker": {
            "courseId": 4,
            "askerId": 473,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la diffferenza tra UpCast e DownCast?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "upcast"
            },
            {
              "keyword": " downcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3938,
          "asker": {
            "courseId": 4,
            "askerId": 505,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "IL polimorfismo può essere utilizzato anche su metodi astratti?\r\nMotiva la risposta.",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3886,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 455,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "I metodi astratti, in quanto tali, non hanno implementazione. Spetta quindi alla sottoclasse implementare tutti i metodi astratti della classe madre. Il polimorfismo non può essere applicato a metodi astratti perché bisogna fornire l'implementazione e non la dichiarazione perché è già presente nella super classe, se cambia dunque la firma di un metodo verrà visto come un altro metodo diverso da quello della super classe. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3950,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 553,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Si: una classe che contiene metodi astratti deve essere, a sua volta, dichiarata abstract e non può quindi essere istanziata direttamente. Occorre definire una sottoclasse che fornisca l'implementazione dei metodi mancanti. Questo è proprio il caso in cui si vuole obbligare l'utilizzo del polimorfismo. In pratica, si introducono dei metodi privi di implementazione facendoli precedere dalla parola chiave \"abstract\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4011,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Sì, è possibile ?applicare il polimorfismo ad un metodo astratto?.\r\nDal punto di vista implementativo il polimorfismo dei metodi si compone di due parti: overload e override. \r\nCirca l'overload, ovvero l'avere metodi con lo stesso nome ma con firma differente, non ci sono problemi se si parla di metodi astratti, in quanto questi si comportano nello stesso modo dei metodi \"normali\".\r\nPer quanto riguarda l'overriding riporto un esempio: sia ?abstract C? la nostra classe astratta dove è definito il metodo \"leggi()\"; sia A una classe che eredita da C e che ovviamente ridefinisce il metodo \"leggi()?; infine sia B una classe che eredita da A e che, a sua volta, ridefinisce \"leggi()?. Allora si ha: \r\nC objA = new A();\r\nC objB = new B();\r\nobjA.leggi(); // chiama il metodo descritto nella classe A\r\nobjB.leggi(); // chiama il metodo descritto nella classe B\r\nVisto che entrambi i punti sono soddisfatti, si può affermare che i metodi astratti godono di polimorfismo",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3965,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 448,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "I metodi astratti definiscono che il metodo deve essere implementato nella classe che eredita direttamente da questa, e quindi il poliformismo si applica nel caso in cui ci fosse un'altra classe che eredita da quella che implementa il metodo astratto. Le due cose non sono direttamente collegate.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3993,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 478,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Si parla di polimorfismo facendo riferimento alle classi, non ai metodi.\r\nForse quello che intendi tu è fare OVERRIDING di un metodo, sostanzialmente la ridefinizione, in una sottoclasse, di un metodo ereditato da una superclasse. \r\nNel caso specifico di classi astratte, un metodo astratto deve per forza essere definito in una classe figlia.\r\nPer fare un confronto con il C++, potremmo dire che un metodo astratto in Java equivale ad un metodo virtuale puro del C++.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3978,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 498,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il polimorfismo di un programma non è riferito direttamente ai metodi, ma alle classi. Se quindi la domanda voleva essere riferita alle classi astratte (che possono avere metodi astratti), allora la risposta è sì.\r\nInfatti un oggetto può essere dichiarato di tipo di classe astratta, per poi essere istanziato con le sue sottoclassi (Principio di Liskov), in modo da poter determinare solo a runtime quale precisa sottoclasse avrà l'oggetto; in seguito sarà quindi possibile chiamare i metodi (anche quelli dichiarati abstract nella superclasse), visto che faranno riferimento a sottoclassi non astratte che sono \"compatibili\" con quella astratta dichiarata inizialmente (relazione Is-A).",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3970,
          "asker": {
            "courseId": 4,
            "askerId": 442,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Come fa la JVM a riconoscere una funzione polimorfa e cosa accade se si modifica la funzione madre da cui le altre ereditano le proprietàa.",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " finzioni"
            },
            {
              "keyword": " modifica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3969,
          "asker": {
            "courseId": 4,
            "askerId": 595,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il principio di Liskov?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Liskov"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3950,
          "asker": {
            "courseId": 4,
            "askerId": 499,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "vantaggi e svantaggi di static binding e dynamic binding, quali programmi ne fanno rispettivamente uso e perché.",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dynamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3919,
          "asker": {
            "courseId": 4,
            "askerId": 579,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il polimorfismo e come funziona?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " - "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3898,
          "asker": {
            "courseId": 4,
            "askerId": 484,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste un modo in Java per compilare in modo tale che una classe creata sia invocata staticamente invece che dinamicamente?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dynamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3840,
          "asker": {
            "courseId": 4,
            "askerId": 527,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è giusto scrivere \r\n\r\nPoint p=new NamedPoint();\r\np.move(3,4);\r\n\r\nmentre \r\n\r\nNamedPoint p=new Point();\r\np.move(3,4);\r\n\r\nmi da errore?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 4,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " sottotipo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4012,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 581,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Perché NamedPoint è anche Point, mentre non è vero il contrario; inoltre nel primo caso c'è upcast implicito",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3952,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 461,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Questo accade perchè c'è la relazione ISA (NamedPoint È UN Point) che mi permette di scriverlo, infatti essendo Point la superclasse di Point, NamedPoint ha tutte le caratteristiche di Point e alcune in più. ll contrario invece non è lecito proprio perchè la relazione ISA non c'è, infatti Point non ha tutte le proprietà di NamedPoint.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3991,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 548,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il primo esempio è perfettamente lecito, se voglio dichiarare un Point e poi durante l'esecuzione scegliere se sarà NamedPoint o Point3d lo posso fare mentre il secondo esempio è errato e inutile dato che se dichiaro un NamedPoint implicitamente posso richiamare anche i metodi di point a meno che non siano stati sovrascritti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3927,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 428,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Da errore perché named point è una sottoclasse di point e non viceversa.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3996,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 501,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Perché nel primo caso p è un oggetto di tipo Point a cui viene assegnato un oggetto NamedPoint, il quale essendo una sua sottoclasse è considerato un Point mentre nel secondo caso p è un NamedPoint, a cui non posso assegnare un Point in quanto quest' ultimo manca di alcuni metodi e/o variabili di istanza proprie di NamedPoint.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3973,
          "asker": {
            "courseId": 4,
            "askerId": 449,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per polimorfismo^",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "definizione"
            },
            {
              "keyword": "completa"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3962,
          "asker": {
            "courseId": 4,
            "askerId": 448,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra lo static binding e il runtime binding?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3835,
          "asker": {
            "courseId": 4,
            "askerId": 531,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo il polimorfismo semplifica la programmazione?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 24,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Vantaggi"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3910,
          "asker": {
            "courseId": 4,
            "askerId": 432,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile \"emulare\" in java lo static binding con specifici comandi? Stessa cosa per il c++, si può emulare il dynamic binding?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3897,
          "asker": {
            "courseId": 4,
            "askerId": 445,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Dove c'è un Point posso mettere un NamedPoint? Perché?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Point"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3934,
          "asker": {
            "courseId": 4,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Si illustrino le differenze tra static binding e dynamic binding, indicando quale dei due comportamenti è di default in Java e quale in C++.",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " static"
            },
            {
              "keyword": " dynamic"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3947,
          "asker": {
            "courseId": 4,
            "askerId": 422,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando qualcuno chiede: \"cos'è il polimorfismo?\", può essere \"overloading\" o \"overriding\" una risposta accettabile?\r\n\r\nCredo ci sia qualcosa di più da dire. Se ad esempio avessi una classe base astratta che definisce un metodo senza implementazione, ed in una sotto-classe lo si implementa, è ancora corretto parlare di \"overriding\" del metodo?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": "polymorphism"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3890,
          "asker": {
            "courseId": 4,
            "askerId": 538,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "spiegare la differenza tra static binding e dynamic binding discutendo l'output del codice nella slide 10. Qual è il modo di operare di Java?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "compile time"
            },
            {
              "keyword": " run time"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3920,
          "asker": {
            "courseId": 4,
            "askerId": 507,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "È utile poter fare l'overriding di un metodo in un linguaggio di programmazione orientato agli oggetti come Java?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": " oop"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3888,
          "asker": {
            "courseId": 4,
            "askerId": 504,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra downcast e upcast?",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 4,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Cast"
            },
            {
              "keyword": "Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3869,
          "asker": {
            "courseId": 4,
            "askerId": 578,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra static binding e dynamic binding?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Concetti fondamentali"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3905,
          "asker": {
            "courseId": 4,
            "askerId": 433,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra STATIC BINDING e DYNAMIC BINDING?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static_binding"
            },
            {
              "keyword": " dynamic_binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3971,
          "asker": {
            "courseId": 4,
            "askerId": 581,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Java utilizza Static Binding e/o Dynamic Binding, e per quale motivo?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3924,
          "asker": {
            "courseId": 4,
            "askerId": 559,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra static binding e dynamic binding?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " dynamic"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3839,
          "asker": {
            "courseId": 4,
            "askerId": 565,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Liskov substitution principle?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " sottotipi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3932,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 503,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Principio di Liskov: se oggetti di tipo T di un programma possono essere sostituiti da oggetti di tipo S senza alterarne alcuna proprietà desiderabile, allora si dice che T è un sottotipo di S.\r\nQuesto principio definisce il concetto di ereditarietà di una classe, concetto molto importante in linguaggi di programmazione ad oggetti come é Java.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3984,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 511,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Si intende quella proprietà che si instaura tra classe padre e classe figlia quando istanzio la classe figlia su una variabile di tipo padre. Un rapido esempio fa capire meglio: NamedPoint eredita da Point, faccio Point p=new NamedPoint().\r\n\r\nIn questo caso nessuna proprietà di Point viene alterata. Se poi si vuole usare un metodo di NamedPoint con la variabile p, bisogna procedere con opportuni downcast.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3901,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 550,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Il principio di sostituzione di Liskov, nella programmazione orientata agli oggetti, è una definizione di sottotipo che afferma che se S è un sottotipo di T, è possibile sostituire gli oggetti di tipo T di un programma con degli oggetti di tipo S, senza alterare le poprietà e le funzioni del programma.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3908,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 484,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Per Liskov substitution principale si intende quando si ha una sottoclasse e si può creare un istanza invocando la sua superclasse.\r\nPer esempio se ho la classe Point e come sottoclasse NamedPoint, allora posso fare \"Point p = new NamedPoint();\" e poi chiamare i metodi di Point per esempio \"p.move(3,4);\".",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3925,
          "asker": {
            "courseId": 4,
            "askerId": 519,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "L'overloading di funzioni riguarda/\"attiva\" il meccanismo di binding?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3964,
          "asker": {
            "courseId": 4,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in un programma oggetti di tipo T possono essere sostituiti da oggetti di tipo S , se S è sottotipo di T? ( slide 9)",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "sottotipo"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3933,
          "asker": {
            "courseId": 4,
            "askerId": 516,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi del dynamic binding rispetto allo static?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " dynamic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3972,
          "asker": {
            "courseId": 4,
            "askerId": 430,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "class A { void f1()\r\n{System.out.println(\"f1\");} }\r\nclass B extends A { void f2()\r\n{System.out.println(\"f2\");} }\r\nclass C extends B { void f3()\r\n{System.out.println(\"f3\");} } \r\n\r\npublic class Test {\r\n    public static void main(String a[]) {\r\n        new Test();\r\n    }\r\n\r\n    Test() {\r\n        A a;\r\n        B b = new B();\r\n        a=b;\r\n        a.f1();\r\n        ((B)a).f2();\r\n    }\r\n}\r\n\r\nQual è l'output dell'esecuzione del meetodo main?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "errori"
            },
            {
              "keyword": " cast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3892,
          "asker": {
            "courseId": 4,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le sezioni \"Upcast & Downcast\" ??",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "upcast"
            },
            {
              "keyword": " downcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3917,
          "asker": {
            "courseId": 4,
            "askerId": 551,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa enuncia il principio di sostituzione di Liskov? Quale \"garanzia\" assicura nella progettazione di un programma orientato agli oggetti?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Liskov"
            },
            {
              "keyword": " Polimorfismo"
            },
            {
              "keyword": " Correttezza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3922,
          "asker": {
            "courseId": 4,
            "askerId": 460,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Abbiamo visto a lezione che per un programmatore che utilizza un linguaggio orientato agli oggetti è di fondamentale importanza il principio di sostituzione di Liskov. Come funziona?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Principio"
            },
            {
              "keyword": " sostituzione"
            },
            {
              "keyword": " Liskov"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3886,
          "asker": {
            "courseId": 4,
            "askerId": 501,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il sistema di gestione degli errori(try-catch-finally)?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Errori"
            },
            {
              "keyword": "Exception"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3911,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 474,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Il sistema \"try-catch-finally\" è un meccanismo che permette di gestire in modo flessibile ed efficiente imprevisti che possono emergere durante l'esecuzione del codice.\r\nPer poter utilizzare questo sistema di gestione degli errori è necessario creare un blocco chiamato try contenente le istruzioni desiderate, un blocco catch contenete le istruzioni da eseguire in caso di errori e un blocco finally (facoltativo).\r\nNel caso in cui non ci siano imprevisti durante l'esecuzione delle istruzioni contenute nel blocco try, il programma continua eseguendo le istruzioni \"finally\" e proseguendo con il suo funzionamento.\r\nSe invece durante l'esecuzione delle istruzioni \"try\" viene generata un eccezione, vengono eseguite le opportune istruzioni contenute nel blocco catch senza che il metodo o l'intero programma deva essere terminato.\r\nLe istruzioni contenute in finally vengono eseguite per ultime e in qualunque caso, anche se ad esempio nei blocchi try o catch sono contenute istruzioni \"return\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3945,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "try-catch-finally è uno strumento per individuare eccezioni, ossia situazioni anomale all'esecuzione che, se non ben gestite, potrebbero portare anche all'interruzione dell'esecuzione.\r\nIl blocco try contiene le istruzioni che potrebbero \"sollevare\" delle eccezioni e, nel caso in cui ciò succeda, impedisce che questa \"si propaghi\".\r\nI blocchi catch eseguono un controllo su tale eccezione, per individuare se questa appartiene alla classe di eccezione specificata tra le parentesi tonde. Se tale classe di eccezione viene individuata, vengono eseguite le istruzioni di quel blocco. In questo caso si dice che l'eccezione è stata \"catturata\".\r\nIl blocco finally è falcoltativo, se espresso almeno un catch. In esso sono presenti istruzioni che vengono sempre eseguite, sia che sia stata sollevata un'eccezione che meno, sia che questa sia stata catturata che meno.\r\nNOTA: Se l'eccezione è stata sollevata ma non catturata, viene passata al metodo chiamante.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3955,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 528,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "In Java gli errori (in fase di esecuzione) sono detti Exception (eccezioni), ed esiste una classe Exception, da cui derivano svariate sottoclassi corrispondenti ai vari tipi di errore, che ne consente la gestione tramite i blocchi try-catch-finally, mettendo a disposizione alcuni metodi che consentono di ottenere informazioni sull'eccezione.\r\nPer gestire gli errori si utilizzano i blocchi try e catch, e opzionalmente il blocco finally:\r\n-Try: include la porzione di codice che si ritiene essere a rischio di errore;\r\n-Catch: contiene le istruzioni da eseguire in caso nel blocco try si sia verificata un'eccezione; prima del blocco di istruzioni deve essere dichiarato un riferimento ad un oggetto di tipo Exception. E' buona norma che il tipo di eccezione dichiarata sia il più specifico possibile: per questo motivo è possibile avere più blocchi catch, uno per ciascun tipo di errore che potrebbe verificarsi.\r\n-Finally (opzionale): contiene istruzioni da eseguire in ogni caso.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4003,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Quando si verifica qualcosa di non previsto viene lanciata un'eccezione che viene passata al metodo chiamante e questo per default termina l'esecuzione, se invece il è previsto dal sistema che possa verificarsi un'eccezione questa può essere catturata dal metodo chiamante, e trattata con opportune istruzioni senza causare necessariamente la terminazione del programma.\r\nIl sistema try-catch-finally è così strutturato:\r\nInizialmente vengono eseguite le istruzioni contenute nel try: se l'esecuzione termina senza fallimenti, si eseguono le eventuali istruzioni contenute nel blocco finally e si termina.\r\nAltrimenti, se un'istruzione presente nel blocco try lancia un'eccezione, si eseguono le istruzioni contenute nel blocco catch e successivamente le eventuali istruzioni contenute nel blocco finally e si termina.\r\nE' bene ricordare che le istruzioni contenute nel blocco finally vengono sempre eseguite.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3927,
          "asker": {
            "courseId": 4,
            "askerId": 489,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per upcast e downcast in Java?",
          "totalDifficultyLevel": 1,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "upcast"
            },
            {
              "keyword": " downcast"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3899,
          "asker": {
            "courseId": 4,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "spiega brevemente cos'è il Polimorfismo",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3836,
          "asker": {
            "courseId": 4,
            "askerId": 424,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "cos'è un modificatore? cos'è e come funziona l'abstract?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": " abstract"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3850,
          "asker": {
            "courseId": 4,
            "askerId": 585,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi del Polimorfismo all'interno di un qualsiasi programma...? ",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3990,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 563,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Non ne ho idea.\r\nMi spiace tanto.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3917,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il vantaggio del Polimorfismo è principalmente uno, la possibilità di creare delle  sottoclassi che hanno caratteristiche in parte simili ad una classe \"padre\", senza dover riscrivere completamente ogni volta il codice, ma facendo un'estensione della classe \"padre\" stessa.\r\nQuesto oltre a semplificare molto il codice e a renderlo più leggibile, fa sì che il lavoro del programmatore sia più rapido.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3923,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 504,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Esso rende molto flessibile il linguaggio, per esempio permettendo di dichiarare un riferimento senza doverlo specificatamente definire, e da estensibilità al codice per possibili  aggiornamenti futuri grazie all'uso delle interfacce e dei metodi astratti. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3902,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 453,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "I vantaggi del polimorfismo sono quelli che permettono di avere una struttura ad oggetti\r\n1)estendibile: invocare nuovi metodi personalizzati all'interno di una classe apposita;\r\n2)resistente: permette di implementare nuovi metodi fornendo una nuova classe;",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3930,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 439,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "¿Grazie al polimorfismo, un metodo può cambiare il suo comportamento in base all'oggetto sul quale viene richiamato. Il programma, quindi, tratta egualmente diversi tipi di oggetti indipendentemente dalla loro struttura.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3873,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 534,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "La gestione della memoria è migliore e si possono usare diversi tipi di pile e code e utilizzare più variabili con lo stesso nome che abbiano contenuti differenti.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3858,
          "asker": {
            "courseId": 4,
            "askerId": 491,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa dice il principio di sostituzione di Liskov ?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Coda"
            },
            {
              "keyword": " Pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3960,
          "asker": {
            "courseId": 4,
            "askerId": 486,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Il linguaggio di programmazione C, a differenza di JAVA, permette di scegliere se agire secondo una prospettiva static binding o dynamic binding. Anche se questo potrebbe sembrare particolarmente conveniente, qual' è la pericolosità che si nasconde dietro tale scelta?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dynamic binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4013,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 562,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Nel c si deve sempre sapere con cosa si sta lavorando questo comporta dei pro e dei contro, ovviamente a seconda di cosa si deve gestire può risultate comodo o meno.\r\nLa pericolosità sta nel confondere i due sistemi che può comportare memory leak o cose simili.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3876,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 488,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "La pericolosità che si cela dietro questa scelta è, nel caso di varie classi, la difficoltà nel capire a quale metodo si fa riferimento.. Quindi se definisco due classi che hanno la stessa struttura ma differiscono per il metodo x, quando vado a definire classe 1 = new classe 2; e richiamando il metodo x non so a quale classe sto facendo riferimento.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3974,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 438,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Considerando le due modalità e tenendo conto che Java agisce sotto Dynamic binding, la pericolosità è di lasciare troppa libertà al programmatore e quindi non permettere una corretta esecuzione del codice.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4010,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 541,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Va inizialmente premesso che la domanda presenta alcune imprecisioni.\r\nIl linguaggio di programmazione C consente solo l'uso di static binding mentre C++ e Java entrambe (anche se con la differenza che Java di default applica il dynamic binding mentre C++ lo static binding).\r\n\r\nFatta questa precisazione posso rispondere alla parte della domanda relativa alla convenienza/pericolosità relative all'uso delle stesse.\r\nIl dynamic binding presenta le seguenti criticità: ha delle performance peggiori inoltre nella maggior parte delle implementazioni i metodi devono avere differenti nomi ad ogni chiamata, il che comporterebbe la necessità di un dizionario dispendioso nonchè di meccanismi per la risoluzione di conflitti di overriding.\r\nInoltre implementare utilizzando dynamic binding non consente al calcolatore in fase di compilazione di verificare eventuali problemi di conflitto tra tipi di dati che invece posso insorgere in run time.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3890,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 592,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Lo svantaggio maggiore sta nel fatto che si aumenta la possibilitata di incorere in errori da parte dell'utente. Cio e dovuto alla difficolta di comprendere su quale metodo sia meglio eseguire lo static o dynamic binding.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3967,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 476,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "La scelta fra static e dynamic binding in C può, effettivamente, rivelarsi sorgente di problemi. Al momento della scelta dell'approccio (se static o dynamic per l'appunto), il programmatore da un lato guadagna e dall'altro perde alcune funzionalità. Se opta per lo static binding, approccio che prende luogo at compile-time, sarà immediato rilevare la presenza di errori nel codice, in quanto il compilatore verifica direttamente che le dichiarazioni siano formalmente corrette, ma non sarà più possibile effettuare modifiche al tipo di binding durante l'esecuzione del programma. Se, invece, si decide di utilizzare il dynamic binding, approccio che prende luogo at runtime, sarà possibile scrivere un codice più flessibile, maneggevole nel quale è possibile scegliere il tipo durante l'esecuzione, come si è visto a lezione per Pila e Coda. Il prezzo da pagare, però, è che per il compilatore sarà più difficile individuare errori all'interno del codice.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3845,
          "asker": {
            "courseId": 4,
            "askerId": 467,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve una classe abstract?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3865,
          "asker": {
            "courseId": 4,
            "askerId": 497,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "In che cosa consiste il \"dynamic binding\" e come lo si può ottenere in C++?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "dynamic binding"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3912,
          "asker": {
            "courseId": 4,
            "askerId": 577,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra l'overloading e l'overriding di un metodo?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodo"
            },
            {
              "keyword": " overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3932,
          "asker": {
            "courseId": 4,
            "askerId": 572,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Se ho un oggetto di tipo Pila e lo istanzio come coda (Pila a = new Coda()) ed entrambe le classi hanno un metodo estrai, quale metodo estrai verrà richiamato quando eseguo l'istruzione a.estrai()?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Assegnazione"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3913,
          "asker": {
            "courseId": 4,
            "askerId": 546,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze fra static binding e dynamic binding? Perche' C++ se non diversamente specificato utilizza static binding mentre Java preferisce usare dynamic binding?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dynamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3968,
          "asker": {
            "courseId": 4,
            "askerId": 570,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono upcast e downcast?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "upcast"
            },
            {
              "keyword": " downcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3847,
          "asker": {
            "courseId": 4,
            "askerId": 522,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa servono le interfacce?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3875,
          "asker": {
            "courseId": 4,
            "askerId": 566,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Posso avere uno static binding in java?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Pila"
            },
            {
              "keyword": " Coda"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3949,
          "asker": {
            "courseId": 4,
            "askerId": 468,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare un compilatore a runtime ? ",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "compilatore"
            },
            {
              "keyword": " runtime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3885,
          "asker": {
            "courseId": 4,
            "askerId": 452,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il Dynamic Binding è essenziale per il polimorfismo di un linguaggio?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Dynamic Binding"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3949,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 515,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il Dynamic Binding è un meccanismo che a runtime permette di identificare un metodo tramite il nome e i sui parametri, senza questo tipo di meccanismo non sarebbe possibile dichiarare metodi con lo stesso nome, ma con parametri differenti.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3915,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 482,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Perchè permette a runtime di inizializzare oggetti differenti a seconda delle scelte dell'utente. Polimorfismo significa appunto \"più forme diverse\".",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3912,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "Il Binding dinamico, ovvero la possibilità di assegnare durante l'esecuzione il metodo adatto alla classe, è fondamentale per il polimorfismo di un linguaggio perchè senza di esso non si potrebbe avere. Infatti se il binding fosse statico e deciso a priori o in fase di compilazione, non si avrebbe più la possibilità di scegliere come tipo una superclasse e poi in fase di esecuzione usare una variabile di tipo sottoclasse. Questo perchè i metodi sarebbero già stati assegnati e potrebbero non funzionare per la sottoclasse. Al contrario con il binding dinamico ciò non accade essendo scelti ogni volta in base al tipo assegnato. Con questa proprietà un linguaggio può permettersi quindi di sfruttare il polimorfismo.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3948,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 565,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "In realtà hai già risposto tu alla domanda perchè il Dynamic Binding è essenziale proprio ai fini del polimorfismo di un linguaggio.\r\nAnyway il binding dinamico è \" essenziale per il polimorfismo \" poichè a differenza dello static binding l'identità dei metodi e delle variabili viene determinata a RUNTIME in base al flusso di esecuzione e non può essere stabilita a priori a tempo di compilazione. \r\nQuesto permette:\r\n-ad oggetti differenti (ma collegati tra loro) di rispondere in modo differente allo stesso tipo di messaggio.\r\n-la facilità di manutenzione del codice.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3921,
          "asker": {
            "courseId": 4,
            "askerId": 466,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra Static Binding e Dynamic Binding?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": "Dynamic"
            },
            {
              "keyword": "Binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3946,
          "asker": {
            "courseId": 4,
            "askerId": 458,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si ha nel codice di un Polimorfismo uno switch(type){\r\ncase 1: s=new Coda(); break;\r\ncase 2: s=new Pila(); break; }\r\ne successivamente si richiama la funzione s.estrai(): quale verrà scelto tra l'estrai di Coda o di Pila?\r\n",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Compiler"
            },
            {
              "keyword": " runtime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3893,
          "asker": {
            "courseId": 4,
            "askerId": 576,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con static binding e dynamic binding?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 3,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3958,
          "asker": {
            "courseId": 4,
            "askerId": 477,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è uno svantaggio in termini di prestazioni in esecuzione per avere la funzionalità di dynamic binding rispetto allo static binding?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "prestazioni"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3943,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 537,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Il principale svantaggio nell'uso del dynamic binding concerne la velocità di esecuzione del programma. Ciò deriva dal fatto che il programma conoscerà solo in fase di esecuzione (run-time) la classe alla quale far riferimento per le chiamate dei metodi, contrariamente al caso dello static binding.  ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3953,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 570,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Lo svantaggio è che il compilatore deve gestire il binding in maniera automatica ed utilizzare risorse per trovare i riferimenti, mentre nello static binding questi erano esplicitati nel codice dal programmatore",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3899,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 446,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Il dynamic binding fornisce maggiore \u0013flessibilità perch\u0014e permette\r\ndi assegnare a un nome un tipo \u000bovvero un oggetto a una determinata classe\u000e\r\nsolo al momento dell'esecuzione\u0001.\r\nQuesto si rivela uno strumento molto potente in mano al progettista e al programmatore\t chiamato polimor\u0007smo.\r\nOvviamente tale meccanismo genera una maggiore vulnerabilit\u0007a agli errori e un calo di prestazioni dovuto all'assegnazione della struttura durante l'esecuzione del programma.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3942,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 496,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il dynamic bindind, rispetto allo static binding è svantaggioso in termini di prestazioni perchè la JVM non deve semplicemente eseguire il codice, ma deve \"decidere\" a runtime quale funzione va chiamata!!! Questa operazione ovviamente richiede un tempo aggiuntivo durante l'esecuzione del programma.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3999,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 477,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Lo static binding, utilizzato ad esempio in C++, utilizza le informazioni dichiarate dal programmatore per invocare il metodo opportuno su una instanza di una classe.\r\n\r\nJava invece implementa il dinamic binding, una funzionalità che permette il polimorfismo nella scrittura del codice di un'applicazione. In fase di esecuzione infatti viene eseguito un controllo sul tipo di dato instanziato e viene invocato il metodo appropriato.\r\n\r\nSe ad esempio B è una sottoclasse di A, ed entrambe implementano il metodo f(), nel seguente codice:\r\n\r\nA a = new B();\r\na.f();\r\n\r\nVerrà utilizzato il metodo f() di B, nonostante 'a' sia di tipo A, grazie al controllo eseguito in esecuzione sul tipo di dato instanziato.\r\n\r\nIl dinamic binding quindi prevede un controllo sul dato instanziato prima di invocare il relativo metodo mentre il programma è in esecuzione, cosa che non avviene con lo static binding.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3902,
          "asker": {
            "courseId": 4,
            "askerId": 487,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché Java implementa sia il dynamic che lo static binding mentre C++ implementa soltanto l'ultimo dei due?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "polimorfismi"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3881,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 552,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Perché privilegia l'efficienza e non fa un controllo runtime ma solo a compiletime",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3905,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 557,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Perché il fondamento del C++ è l'essere il più efficiente possibile dal punto di vista esecutivo, mentre Java si basa sull'essere più flessibile e meno limitato.\r\nDunque, Java implementa entrambi i tipi di binding per permettere all'utente di spaziare di più nella struttura del sorgente, consentendo la creazione di strutture più articolate ma allo stesso tempo più leggibili.\r\nDal canto suo, il C++ non permette il dynamic binding in modo da garantire una miglior performance di esecuzione utilizzando meno risorse.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3971,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 517,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Java ha un approccio per cui e' importante sviluppare un codice robusto e per questo usa entrambi i binding (nonostante i cosi che questo comporta, ma avendo nel contempo anche maggiore possibilita' d'espressione). Java usa static binding per  metodi overloaded e dynamic binding per i metodi overrided. C++ avendo un approccio verso l'economia e l'efficienza del utilizzo delle risorse (quindi programmatore esperto) utilizza i binding specificando quale dei due usa il metodo in questione.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 4006,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 540,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Premettendo che C++ implementa anche il dynamic binding (il quale dev'essere richiesto esplicitamente tramite la parola chiave virtual, mentre di default verrebbe utilizzato uno static binding), Java implementa entrambe utilizzando di default il dynamic binding. Questo meccanismo viene utilizzato in quanto diretta conseguenza del polimorfismo e dell?overriding, elementi fondamentali della programmazione in Java.\r\nP.s. La domanda per come è posta risulta ambigua nonché errata. :)",
              "notes": "-",
              "rating": 5,
              "coins": []
            },
            {
              "answerId": 3883,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 479,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Lo static binding significa che le referenze sono risolte al momento della compilazione.\r\nIl dynamic binding viene invece risolto a run time.\r\nJava li permette entrambi per dare al programmatore più possibilità decisionale e più controllo del codice.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3911,
          "asker": {
            "courseId": 4,
            "askerId": 584,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Per la risoluzione di quali problematiche è stato introdotto il concetto di polimorfismo ?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " problematiche "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4004,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 440,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il concetto di Polimorfismo è stato introdotto per far fronte al problema dell' utilizzo di diversi metodi con lo stesso nome. Un metto è polimorfo quando è in grado di adattare il suo comportamento allo specifico oggetto su cui deve operare.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3922,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 590,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Con polimorfismo ci si riferisce al fatto che una espressione il cui tipo sia descritto da una classe A può assumere valori di un qualunque tipo descritto da una classe B (sottoclasse di A)\r\n...Tramite l'overriding dei metodi (o delle proprietà) permette che gli oggetti appartenenti alle sottoclassi di una stessa classe rispondano diversamente agli stessi utilizzi.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3975,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 512,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Il polimorfismo è una proprietà delle classi che nasce come naturale conseguenza dell'ereditarietà. Senza di esso la programmazione a oggetti mancherebbe di molti vantaggi e l'ereditarietà garantirebbe solo di non riscrivere le stesse parti di codice in classi derivate.\r\nCon il polimorfismo riusciamo a far utilizzare al consumer classi derivate con la stessa interfaccia, anche se al loro interno hanno implementazioni diverse, in quanto dall'esterno molti metodi saranno comuni. Inoltre si riesce a migliorare la relazione padre-figlio tra classi garantendo che una classe A possa \"diventare\" un oggetto della sua sottoclasse B.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3980,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 486,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il polimorfismo (capacità di un oggetto di assumere più forme) è stato introdotto, più che per risolvere problematiche, per agevolare nella scrittura del codice. Difatti è solo grazie al polimorfismo se all'interno di una classe è possibile definire l'overloading (definizione di più metodi con lo stesso nome ma con lista di parametri diversa) ed è sempre grazie al polimorfismo che si può definire un' istanza di una classe specifica, a partire dalla dichiarazione di una variabile che ha come tipo una superclasse (purché tra classe e superclasse esista un vincolo di ereditarietà).\r\n(ESEMPIO : superclasse->animali   classe \"specifica\"->rana \r\n     senza POLIMORFISMO:\r\n          rana r=new rana ();\r\n     grazie al POLIMORFISMO:\r\n          animali r=new rana(); (sfruttamento legame IS-A)\r\n)",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3894,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 424,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il polimorfismo permette di fare uso di diversi oggetti con la stessa interfaccia ma implementazioni differenti. Se utilizzato bene il polimorfismo permette di scrivere un codice resistente (cioè poter invocare nuovi metodi includendoli in una classe nuova) e resistente(perché nuove esigenze per il programma potranno essere implementate aggiungendo una nuova classe ad hoc).",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3936,
          "asker": {
            "courseId": 4,
            "askerId": 492,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che vantaggio c'è nella dichiarazione di classi abstract?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " modificatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3923,
          "asker": {
            "courseId": 4,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il \"binding\"? Qual'è la differenza tra static e dynamic binding?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dynamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3863,
          "asker": {
            "courseId": 4,
            "askerId": 425,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è nel BINDING tra il java ed il c++? Cosa comporta questa differenza per quanto riguarda le prestazioni del codice?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3880,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 508,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il bindind è il processo che associa il metodo corretto ad ogni invocazione; quando è presente una gerarchia complessa di classi possono esserci più metodi candidati a causa del principio di sostituzione di Liskov.\r\n\r\nEsistono due soluzioni al problema: binding statico e dinamico. Il binding statico avviene in compile-time e si basa sul tipo statico dell'oggetto, ovvero quello dichiarato nel codice; nella slide 11 il tipo statico è Pila e quindi verrebbero invocati i metodi definiti in Pila.\r\nIl binding dinamico, invece, avviene in run-time e si basa sul tipo dinamico dell'oggetto, non conosciuto durante la compilazione. Eseguendo il codice della slide 11 la JVM si accorgerebbe che il tipo dinamico di s è in realtà Coda e chiamerebbe quindi i metodi di Coda.\r\n\r\nChiaramente il binding statico è molto più vantaggioso di quello dinamico in quanto il codice per bindare i metodi viene eseguito in compile-time e non in run-time. C++ permette di scegliere, Java usa quello dinamico.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3903,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 466,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "Il Binding in Java è dinamico, mentre quello del c++ è statico; il binding dinamico permette di applicare polimorfismo e deciderà a Runtime quale sarà il tipo di una variabile, mentre in quello statico la forma viene decisa una volta per tutte da compiler e non cambierà a Runtime rendendo l'esecuzione più efficiente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3906,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 595,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Abbiamo due tipi di Binding:\r\n-STATIC Binding:Definito a tempo di compilazione e utilizzato in c++.\r\n     Nel prendere le decisioni, mi baso puramente sulle dichiarazioni, quindi la decisione\r\n     può essere presa dal compilatore.\r\n-DINAMIC Binding:Definito a tempo di esecuzione e utilizzato in Java. \r\n     Le decisioni vengono prese a runtime(ho un costo di efficienza maggiore) seguendo   \r\n     il flusso di esecuzione, quindi mi permettono di implementare oggetti polimorfici.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3951,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 538,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "In Java il binding è dinamico(stabilito a tempo di esecuzione) mentre in C++ è statico(stabilito a tempo di compilazione) a meno che il metodo non sia dichiarato virtual.\r\nPer capire le differenze tra i due si faccia riferimento alla slide 10 supponendo di essere nel caso 1: s è una coda ma formalmente considerata come pila.In C++ il compilatore trovandosi a decidere quale metodo applicare prima dell'inizializzazione dell'oggetto,che avviene a run time, sceglierà sempre il metodo della superclasse. L'output sarà 4.\r\nIn java invece verrà scelto il metodo corrispondente alla classe propria dell'oggetto; l'output sarà 3. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3935,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 431,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il binding del C++ di default è statico, mentre quello del Java è dinamico.\r\nBinding statico significa che l'associazione tra il metodo chiamato e l'oggetto che lo contiene viene fatta a livello del compilatore e non può essere cambiata a run-time.\r\nBinding dinamico significa che quest'associazione non viene fatta fino a run-time. Il che comporta un'aggiunta al codice di un'istruzione, che chiamerà il metodo di una classe piuttosto che di un'altra.\r\nNelle prestazioni del codice il binding statico permette un minor numero di istruzioni, quindi una maggior velocità, a scapito però di una minor flessibilità.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3970,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 463,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "In C++ per ogni metodo si può scegliere se utilizzare un binding  di tipo statico o dinamico, mentre in java il binding è sempre dinamico. Ricordiamo che nel binding statico il sistema assegna il tipo a compile-time (in base alla dichiarazione) mentre nel dinamico il tipo viene deciso a run-time (in base all'istanziazione, che potrebbe per esempio essere dentro un if e quindi non la si conosce finché il programma non gira). \r\nIl binding dinamico si rivela più flessibile perché ad esempio permette di utilizzare oggetti polimorfi che possono acquistare tipi diversi durante diverse esecuzioni dello stesso programma. Il binding statico è però più efficiente in termini di prestazioni.\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3861,
          "asker": {
            "courseId": 4,
            "askerId": 558,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende con il termine \"dynamic binding\"¿",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "dinamic binding"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3966,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il binding è il processo tramite cui viene effettuato il collegamento fra una entità di un software ed il suo corrispettivo valore.\r\nNei termini della programmazione a oggetti, la decisione circa l'attributo o il metodo da richiamare in un dato momento dell'esecuzione del programma viene effettuata grazie al binding.\r\nTale decisione può essere stata stabilita in anticipo in maniera fissa, e in tal caso si parla di binding statico (o early binding); oppure può essere presa a tempo di esecuzione, in maniera dinamica, e in tal caso si parla di binding dinamico (o late binding).",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3997,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 567,
                "courseId": 4,
                "courseFinalScore": 21
              },
              "answerText": "Il dinamic binding si contrappone allo static binding. Esso è un concetto strettamente correlato con polimorfismo ed ereditarietà.\r\nIl dinamic binding permette di ritardare la procedura di chiamata di determinate sequenze di codice o funzioni al momento stesso del run-time: fa in modo che si conosca il codice che viene eseguito solo al momento stesso dell'esecuzione. Infatti in precedenza il compilatore controlla soltanto la correttezza del codice a livello logico, ma non semantico.\r\nIl forte legame con polimorfismo ed ereditarietà è proprio dato dalla possibilità di definire alcune parti del codici solo durante il runtime, a dipendenza anche di scelte dell'utente, non prevedibili al momento della stesura del codice.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3909,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 533,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Nella programmazione orientata ad oggetti l'ereditarietà è uno dei concetti fondamentali, infatti il programmatore può costruire nuove classi estendendo quelle già esistenti. All'interno di una catena di ereditarietà in particolare il DYNAMIC BINDING permette di non specificare direttamente un metodo da legare a una classe, posticipando così la possibilità di scelta del metodo al momento del RUNTIME. Nel binding dinamico, quindi, l'identità delle variabili è determinata a seconda del flusso di esecuzione; esso è molto importante nella programmazione orientata agli oggetti perché permette di implementare oggetti polimorfici.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3885,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 432,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Con il termine dynamic binding si intende il modo in cui il compilatore si approccia ai casi di polimorfismo. Al contrario dello static binding, dove ad un oggetto polimorfo viene attribuito il suo tipo originario, nel dynamic binding si decide al momento dell'esecuzione il tipo dell'oggetto. Il compilatore crea un tipo particolare di switch nel caso critico (che non genera errori in fase di compilazione) che permette di entrare nel caso più consono a run-time : ad esempio le istruzioni {Pila s; s=new Coda(); s.insert(4)} in caso di static binding faranno riferimento ai metodi di Pila, mentre con il dynamic binding si riferiranno ai metodi di Coda",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3954,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 451,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "la Dynamic Binding è una procedura usata per collegare particolare chiamata di procedura a una specifica sequenza del codice solo a run-time. Cioè fino all'esecuzione del programma non si ha conoscenza della specifica relazione che c'è tra codice e la sua effettiva esecuzione. In altri termini durante la fase di compilazione, questa particolare riga di codice non avrà nessun link a nessun altra chiamata di codice e sarà lasciata \"in sospeso\"",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3844,
          "asker": {
            "courseId": 4,
            "askerId": 447,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che scopo ha definire una classe abstract???",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " slide"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3940,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 522,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Definire una classe abstract può essere utile in determinati casi, poiché al suo interno è possibile dichiarare metodi e/o variabili senza doverli implementare (se dichiarati abstract anche loro).\r\nPer spiegare meglio, ecco un esempio:\r\nsupponiamo di dover implementare delle classi per alcune figure geometriche (quadrato, pentagono, esagono...). Tutte le figure geometriche hanno delle caratteristiche comuni come: numero di vertici, lunghezza lato, posizione, etc.\r\nQuindi possiamo dire che una classe Quadrato ha come classe padre Figurageometrica.\r\nPoiché ogni figura geometrica si disegna in modi leggermente differenti da un' altra, è possibile dichiarare i metodi relativi al \"come disegnare\" come abstract nella classe padre obbligando quindi le classi figlie ad implementarli, mentre il metodo relativo alla \"posizione\" è comune e quindi è possibile implementarlo all'interno della classe padre(abstract) come un metodo non abstract, rendendolo così utilizzabile poiché già implementato.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3986,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 430,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Una classe astratta è una classe che può contenere campi e implementazioni di metodi ma che esprimendo un concetto generico che non può essere concretizzato in se, se non in un modo più specializzato, non può essere implementata ma soltanto ereditata ed usata in modo polimorfico.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3889,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 573,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Una classe abstract si limita a definire solo l'interfaccia della struttura, definendo dei metodi che verranno implementati in altre sottoclassi in un secondo momento. È molto utile per creare più sottoclassi specializzate aventi una base comune, che potranno poi essere utilizzate in modo diverso.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3992,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 459,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Serve a definire classi di ordine generale definendo metodi (implementandoli oppure no ) e attributi. Per esempio la classe animale ha un metodo Mangia() (dato che tutti gli animali mangiano) che verrà implementato dalle classi che estendono la classe animale in base a come l' animale mangia.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4007,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 578,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Fa in modo che le sotto-classi che ereditano dalle classi abstract possano estendere le proprie funzionalità implementandone i metodi.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3852,
          "asker": {
            "courseId": 4,
            "askerId": 553,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci sono dei vantaggi a dichiarare costanti tramite un'interfaccia? Motivare la risposta.",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3954,
          "asker": {
            "courseId": 4,
            "askerId": 480,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo una classe definita come abstract deve essere necessariamente derivata?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 4,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": " abstract"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3879,
          "asker": {
            "courseId": 4,
            "askerId": 533,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Se faccio un  DOWNCAST di questo tipo:\r\nA a; \r\n B b = new B(); \r\n a=b; \r\na.f1();\r\n((B)a).f2();\r\nnel caso dovessi ridefinire \r\nA a = new A(); \r\ncosa accadrebbe?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ridefinire"
            },
            {
              "keyword": " dopo"
            },
            {
              "keyword": " DOWNCAST"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3842,
          "asker": {
            "courseId": 4,
            "askerId": 455,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il costrutto try-catch-finally? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "try"
            },
            {
              "keyword": "  catch "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3968,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 559,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Il costrutto try-catch-finally serve per intercettare e gestire le eccezioni generate durante l'esecuzione di un programma. Il concetto base sta nell'incapsulare il codice sorgente di errori all'interno del blocco try e di inserire le eventuali operazioni da eseguire nel caso di errore all'interno di catch. In finally si può decidere di inserire del codice che verrà eseguito sia con presenza che con non presenza di errori. Il costrutto è fondamentale per gestire le frequenti exception generate da java. Inoltre in java si possono generare delle singolari eccezioni in modo da gestire ed organizzare il codice in maniera più funzionale ed intelligente.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4005,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In java quando durante l'esecuzione di un programma si verifica un imprevisto (es. input sbagliato) viene lanciata un'eccezzione dal metodo attivo, quest'ultimo provoca il termine del programma (stampando un messaggio di errore).\r\nTRY: serve per racchiudere una chiamata di metodo che potrebbe generare un'eccezzione (ad esempio può contenere l'istruzione \"Input.readInt()\" seguita da altre);\r\nCATCH: come ci fa intuire il nome, serve a catturare un'eccezzione per fare in modo che il programma non termini qualora si verificasse. Va posto in seguito ad un blocco TRY e contiene le istruzioni da eseguire nel caso in cui si verifichi un errore nell'esecuzione del TRY (esempio tipo di input sbagliato come una lettera al posto di un numero)\r\nFINALLY: posto in seguito a catch contiene una serie di istruzioni, queste verranno eseguite nel caso in cui l'esecuzione del blocco TRY avvenga senza fallimenti (esempio se inserisco un intero come input come richiesto dal TRY ).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3938,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 452,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Il costrutto try-catch-finally viene utilizzato per catturare le eccezioni generate dal programma e gestirle in maniera diversa dalla terminazione improvvisa ad opera del sistema operativo. Il segmento di codice che ci si aspetta generi un'eccezione viene inserito nel blocco try e, al di sotto di esso, vengono aggiunti vari blocchi catch che gestiscono ognuno una tipologia di eccezione diversa. Il tipo di eccezione viene specificato attraverso l'argomento del catch, che è sempre un'istanza di Exception o di una sua sottoclasse. Successivamente ai blocchi catch può essere inserito nel codice un blocco finally che viene eseguito per qualsiasi eccezione generata dopo il catch corrispondente. In sintesi, se viene generata un'eccezione in un blocco try, il programma cerca tra i catch quello che prende come argomento quel tipo di eccezione, lo esegue e successivamente, se presente, esegue il blocco finally.",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3994,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 481,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "il costrutto try-catch-finally serve per trovare gli errori a runtime. Con try si fa fare al programma quello che si vuole fare, se avviene un errore lo si prende e lo si gestisce con il catch e infine con il finally si esegue un istruzione che viene esaguita sempre",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3878,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 506,
                "courseId": 4,
                "courseFinalScore": 28
              },
              "answerText": "Per rilevare e gestire le eccezioni",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3837,
          "asker": {
            "courseId": 4,
            "askerId": 508,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è preferibile usare un'interfaccia e quando una classe astratta? Perché?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interface"
            },
            {
              "keyword": " abstract"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3959,
          "asker": {
            "courseId": 4,
            "askerId": 555,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra \"static binding\" e \"dynamic binding\"? Quale di queste due versioni è usata in Java? E quale (almeno di default) in C++?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dynamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3857,
          "asker": {
            "courseId": 4,
            "askerId": 590,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la differenza fra static e dynamic binding (.....riferito ai concetti di pila e coda)",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": " code"
            },
            {
              "keyword": " pile"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3882,
          "asker": {
            "courseId": 4,
            "askerId": 428,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che caratteristiche hanno le classi dichiarate \"abstract\"?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "caratteristiche"
            },
            {
              "keyword": " abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3882,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 543,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Le classi dichiarate abstract sono speciali perche non possono esser istanziate direttamente. L'unico modo per utilizzarle è quello di far ereditare la classe da un'altra classe e fare overriding delle funzioni dichiarate abstract. Sono molto utilizzate perché permettono di creare un oggetto generico che verrà specificato dalle classi figlie (ad esempio un oggetto struttura con classi figlie stack e pila)",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3875,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 551,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "Una classe astratta, dichiarata mediante l'uso del modificatore \"abstract\", è una particolare classe che non può essere istanziata e deve essere subclassata. Lo scopo principale di queste classi è di consentire di riutilizzare codice comune a diverse sottoclassi senza doverlo replicare in unità (file) diverse del codice. A differenza di un normale rapporto superclasse-sottoclasse, attraverso le classi abstract è possibile dichiarare esplicitamente che la classe \"madre\" non può avere istanze proprie.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3987,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 473,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Le classi dichiarate con \"abstract\" vengono chiamate classi astratte. Le classi astratte sono un particolare tipo di classe in cui è possibile definire dei metodi e attributi in modo tradizionale (chiamati completi) oppure metodi astratti, ovvero metodi definiti soltanto mediante firma ma non con il corpo, su cui poi dovrà essere fatto un overriding nelle classi figlie.\r\nProprio per il fatto che alcuni metodi delle classi astratte non hanno il corpo queste non possono essere istanziate bensì solo estese. È possibile utilizzarle come tipo di dato grazie al polimorfismo.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3936,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 585,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Una classe astratta è una classe che definisce una interfaccia senza implementarla completamente; essa, infatti, risulta necessaria per generare una o più cla ssi specializzate aventi tutte la stessa interfaccia di base, le quali potranno poi essere utilizzate in modo polimorfico da programmi che conoscono l'interfaccia base della classe astratta.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3929,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 492,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Una classe astratta (abstract) è la base per lo sviluppo di sottoclassi aventi una classe ''generale'' come base di partenza. È simile a una classe regolare: può avere attributi (tipi primitivi, classi (static), istanze di oggetti) e metodi che possono essere anche dichiarati ma non implementati (abstract). A differenza delle classi normali  non si possono istanziare oggetti della classe e deve avere almeno una sottoclasse nella quale tutti i metodi dichiarati abstract devono essere implementati. Se ciò non avviene, anche la sottoclasse sarà astratta. Avere le classi astratte è molto utile perché ci permette di definire dei concetti generali specificati nelle sottoclassi e quindi di scrivere il codice polimorfo.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3960,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 447,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Una classe astratta è una classe che definisce la sua struttura senza  implementarla completamente (metodi, dichiarati appunto astratti, VUOTI). Questo serve come base per generare una o più classi (figlie) specializzate aventi tutte la stessa base ma le quali sono OBBLIGATE a implementare quel metodo astratto non definito esplicitamente dalla classe madre. Ogni sottoclasse la implementerà in modo diverso in base alla sua funzione.\r\nIl concetto \"abstract\" è una funzione molto formale poichè è un mezzo con il quale il programmatore comunica a qualcuno che potrebbe voler modificare il codice in futuro che è necessario che una sottoclasse di quella specifica classe necessita obbligatoriamente di quel metodo.\r\nNegli esempi fatti a lezine con [stack-pila-coda], stack aveva il metodo estrai astratto cioè le sue sottoclassi [pila,coda] avranno OBBLIGATORIAMENTE un  metodo estrai personalizzato!!!!\r\nUn passo sucessivo alla funzione abstract sono le interfacce, oggetto delle proxime lezioni!!!!",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3908,
          "asker": {
            "courseId": 4,
            "askerId": 482,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la differenza fra upcast e downcast",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "downcast"
            },
            {
              "keyword": "upcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3914,
          "asker": {
            "courseId": 4,
            "askerId": 506,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il polimorfismo?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "motivazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3876,
          "asker": {
            "courseId": 4,
            "askerId": 440,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "come si scrive e a cosa serve l'utilizzo di un downcast?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "downcast"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3880,
          "asker": {
            "courseId": 4,
            "askerId": 454,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si intende per upcast e downcast?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": " cast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3838,
          "asker": {
            "courseId": 4,
            "askerId": 470,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per polimorfismo ?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " definizione"
            },
            {
              "keyword": " poliformismo "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3893,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 429,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Il polimorfismo è un concetto fondamentale della programmazione ad oggetti.\r\nIl concetto di polimorfismo è relativo proprio al suo significato ovvero avere più forme, più aspetti. Per chiarire il concetto possiamo fare un semplice esempio di applicazione del polimorfismo nella vita reale: quando facciamo riferimento ad un computer probabilmente useremo lo stesso termine (computer, appunto) sia per identificare un computer desktop, un portatile o un netbook. Questo tipo di generalizzazione viene effettuata in quanto gli oggetti cui abbiamo fatto riferimento sostanzialmente effettuano le stesse operazioni... ma queste operazioni vengono fatte da oggetti con forme diverse (polimorfismo).\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3896,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "In informatica, il termine polimorfismo (dal greco &#960;&#959;&#955;&#965;&#956;&#959;&#961;&#966;&#959;&#963; composto dai termini &#960;&#959;&#955;&#965; molto e &#956;&#959;&#961;&#966;&#942; forma quindi \"avere molte forme\") viene usato in senso generico per riferirsi a espressioni che possono rappresentare valori di diversi tipi (dette espressioni polimorfiche). In un linguaggio non tipizzato, tutte le espressioni sono intrinsecamente polimorfiche.\r\nIl termine viene associato a due significati specifici:\r\nnel contesto della programmazione orientata agli oggetti, si riferisce al fatto che una espressione il cui tipo sia descritto da una classe A può assumere valori di un qualunque tipo descritto da una classe B sottoclasse di A (polimorfismo per inclusione);\r\nnel contesto della programmazione generica, si riferisce al fatto che il codice del programma può ricevere un tipo come parametro invece che conoscerlo a priori (polimorfismo parametrico).",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3976,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il polimorfismo è uno dei tre concetti fondamentali della programmazione ad oggetti, insieme all'incapsulamento e all'ereditarietà. La parola polimorfismo indica la possibilità per uno stesso oggetto di assumere più forme, ovvero di rappresentare a runtime istanze di classi diverse. Grazie al principio di sostituzione, una funzione può conoscere una caratteristica generale di un oggetto, come l'interfaccia della sua superclasse, e lasciare all'oggetto la responsabilità di comportarsi secondo le sue caratteristiche particolari, cioè in base alla particolare implementazione dei metodi della superclasse.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3957,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 549,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Nel nostro caso, ovvero quello della programmazione ad oggetti, il termine ?polimorfismo? si utilizza per indicare come sia possibile che un?espressione il cui tipo è definito in una determinata classe, possa assumere i valori di un tipo descritto da una sua qualsiasi sottoclasse. \r\nE come quindi, le istanze di una sottoclasse, possano essere utilizzate al posto di quelle della superclasse e gli oggetti appartenenti alle sottoclassi, possano rispondere diversamente agli stessi utilizzi.\r\nPer esempio, il comportamento di un programma può cambiare in base alle sottoclassi che sono istanziate a tempo di esecuzione e restituire valori diversi alla chiamata della stessa funzione. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3982,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 495,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Letteralmente significa \"avere più forme\", che è esattamente ciò succede: un oggetto può essere dichiarato come appartenente ad una classe ma può essere istanziato come ogni sua sottoclasse, avendo quindi la possibilità di assumere una forma diversa per ogni sottoclasse. Più nello specifico, quando dichiaro una variabile (es.: Point p;) sto allocando staticamente in stack un identificatore che non ha nessun riscontro materiale con l'oggetto in heap. Quando poi vado a chiamare il comando new (es.: p = new NamedPoint;) sto contemporaneamente allocando spazio in heap per un oggetto di tipo NamedPoint ed associando il suo indirizzo all'identificatore p in stack. Tutto ciò è perfettamente legale in virtù del fatto che NamedPoint IS-A Point! Con questo meccanismo potrebbero verificarsi errori a compile-time o a run-time dovuti al fatto che, ad esempio, p è formalmente un Point ma strutturalmente un NamedPoint, quindi chiamare p.name dà errore in ct ma non in rt, ma il \"cast\" risolve tutto.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3963,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Per polimorfismo si indica la possibilità per una espressione di poter rappresentare tipi diversi. \r\nNel caso di Java, vuol dire che possono esistere due metodi con lo stesso nome e gli stessi parametri di input e output, creati in due classi diverse.\r\nI problemi nascono se una classe B eredita da A (dove sia B che A hanno lo stesso metoto print() ), poi instanzio B ed eseguo il casting (ovvero dico al compilatore di trattare B come se fosse di tipo A) e poi chiamo print(), quale metodo verrà eseguito? Quello di B o quello di A?\r\nNel caso di Java, viene eseguito quello di A,poichè Java effettua il dinamic binding.\r\nIl vantaggio del polimorsifmo è la possibilità di avere metodi con lo stesso nome ma che si comportano in modo diverso a seconda delle situazioni.",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3848,
          "asker": {
            "courseId": 4,
            "askerId": 534,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci sono dei casi in cui è sconsigliato l utilizzi dell'ereditarietà? Se si quali?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3896,
          "asker": {
            "courseId": 4,
            "askerId": 542,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Presi A,B,C come nelle slides,\r\nTest () {\r\nA a;\r\nC c=new C();\r\na=c; \r\n((C)a).f3();\r\n}\r\nIn questo caso il downcast è lecito?\r\n",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "downcast"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3900,
          "asker": {
            "courseId": 4,
            "askerId": 575,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le classi astratte?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classe astratta"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3948,
          "asker": {
            "courseId": 4,
            "askerId": 567,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Sia data una superclasse A che possiede due sottoclassi, B e C. In A è definito un metodo alpha(), che viene sovrascritto sia in B che in C con istanze differenti. Poniamo di avere inizializzato un oggetto a come: A a; Ora poniamo che sia a scelta dell'utente se definire \"a = new B\" oppure \"a = new C\". Cosa si intende dire con la scrittura ((C).alpha())? Essa assume sempre un significato coerente?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3966,
          "asker": {
            "courseId": 4,
            "askerId": 517,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual e' la differenza fondamentale e la funzionalità comune tra ereditarietà multipla di C++ e la sua alternativa in Java? ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "differenza"
            },
            {
              "keyword": " funzionalità"
            },
            {
              "keyword": " ereditarietà multipla"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3894,
          "asker": {
            "courseId": 4,
            "askerId": 481,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Dove viene utilizzata l'ereditarietà multipla in Java?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3951,
          "asker": {
            "courseId": 4,
            "askerId": 456,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra un tipo di binding statico e uno di tipo dinamico? Quali i vantaggi e gli svantaggi? Di quale di questi Java fa uso? ",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": " istanziazione"
            },
            {
              "keyword": " dichiarazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3937,
          "asker": {
            "courseId": 4,
            "askerId": 475,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa è un sottotipo?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "sottotipo"
            },
            {
              "keyword": "?"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3961,
          "asker": {
            "courseId": 4,
            "askerId": 520,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per dynamic binding?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "dynamic binding"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3887,
          "asker": {
            "courseId": 4,
            "askerId": 573,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può parlare di overloading solamente per le funzioni?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3877,
          "asker": {
            "courseId": 4,
            "askerId": 591,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "in che situazione è utile utilizzare il polimorfismo?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3883,
          "asker": {
            "courseId": 4,
            "askerId": 528,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la differenza tra static binding e dynamic binding, mettendo in evidenza quale sia il ragionamento alla base dell'uno e dell'altro.",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3864,
          "asker": {
            "courseId": 4,
            "askerId": 431,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile scegliere se chiamare un metodo di una classe impostando lo static binding?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 4009,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 422,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "Non riesco a capire la domanda per due motivi:\r\n1. \"Se chiamare un metodo\" o meno lo sceglie il programmatore quando scrive il programma, e comunque esistono dei costrutti condizionali di esecuzione (if, ma anche i loop for, while).\r\n2. Lo static binding non è un \"flag\" che si può impostare o rimuovere.\r\nMentre lo static binding avviene a compile-time, il dynamic binding avviene a runtime e in qualsiasi caso trattano due casi molto differenti tra loro.\r\n\r\nDue esempi molto chiari si trovano a questo indirizzo: http://javarevisited.blogspot.it/2012/03/what-is-static-and-dynamic-binding-in.html",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3988,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 576,
                "courseId": 4,
                "courseFinalScore": 29
              },
              "answerText": "No, non è possibile perché con lo static binding la decisione viene presa al momento della compilazione; per fare ciò è necessario utilizzare il dynamic binding.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3925,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 507,
                "courseId": 4,
                "courseFinalScore": 31
              },
              "answerText": "In generale, non è possibile \"forzare\" lo static binding in Java. A seconda dei casi, infatti, viene usato lo static binding oppure il dinamic binding.\r\n\r\nDurante la compilazione, viene usato lo static binding. Il compilatore utilizza lo static binding per tutti i metodi dichiarati come private, static o final, perchè in questi casi è sempre in grado di individuare il metodo corretto a compile-time (i metodi privati e quelli finali non possono essere sovrascritti, quindi sono unici; i metodi statici sono invocati attraverso la classe, non attraverso instanze della stessa, quindi sono univocamente individuabili).\r\n\r\nQuando il compilatore non è in grado di determinare il tipo di un oggetto a compile time, viene usato il binding dinamico; a runtime, a seconda del tipo dell'oggetto viene invocato il metodo corretto.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3962,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 547,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "Premetto che penso di non aver capito ben la domanda, forse non è formulata molto chiaramente o sono io che mi sto perdendo qualcosa.\r\nComunque, con lo static binding tutti i richiami a metodi vengono risolti a compile time, cioè il compilatore lascia chiamare solo metodi che appartengano (propri o ereditati da una sopraclasse) alla classe a cui è stato inizializzato un oggetto. ",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3903,
          "asker": {
            "courseId": 4,
            "askerId": 548,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli aspetti positivi di Static e Dynamic Binding?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " dynamic "
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3918,
          "asker": {
            "courseId": 4,
            "askerId": 557,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Sia PIPPO una classe e PIPPOANCHIO una sua sottoclasse. Entrambe le classi presentano il metodo QUANTO, che in entrambe le classi è un void che stampa POCO se riferita a PIPPO, mentre stampa TANTO se riferita a PIPPOANCHIO.\r\nDichiarando MeMedesimo di tipo PIPPO, come posso far sì che MeMedesimo esegua il metodo QUANTO riferito alla classe PIPPOANCHIO?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overriding"
            },
            {
              "keyword": " static e dynamic binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3941,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 566,
                "courseId": 4,
                "courseFinalScore": 19
              },
              "answerText": "(PIPPOANCHIO)MeMedesimo.QUANTO();",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3958,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 530,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "La parola chiave è CAST. Ovvero, chiamando il metodo \"quanto\" ed effettuando nello stesso momento anche un downcast, è possibile forzare il compilatore a fare la chiamata al metodo della sottoclasse invece che a quello della classe stessa.\r\nLa sintassi sarebbe la seguente:\r\n\r\n(PIPPOANCHIO)MeMedesimo.QUANTO();\r\n\r\nCon i downcast occorre tuttavia fare attenzione, perchè se nella funzione \"Quanto\" della sottoclasse Pippoanchio sono presenti riferimenti a variabili di istanza non propri della classe Pippo, avviene un errore a Runtime, in quanto la JVM non è in grado di rispondere a queste chiamate. Questo problema non si pone naturalmente quando si effettuano degli upcast. \r\nInoltre è da notare che questa volta è possibile effettuare il cast grazie al fatto che Pippo e Pippoanchio sono sullo stesso albero gerarchico di sottoclassi... Non sarebbe stato possibile castare Pippo in Paperino!",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3926,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 450,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Questo è il programma:\r\n\r\npackage esercizio;\r\npublic class Esercizio {\r\n    public static void main(String[] args) {\r\n        new Esercizio();}\r\n    \r\n    Esercizio(){\r\n       PIPPO MeMedesimo;\r\n        PIPPOANCHIO X= new PIPPOANCHIO();\r\n        MeMedesimo=X;\r\n        ((PIPPOANCHIO)MeMedesimo).QUANTO();\r\n    }\r\n\r\nclass PIPPO {\r\n    public void QUANTO(){\r\n        System.out.println(\"POCO\");\r\n    }    \r\n}\r\n\r\nclass PIPPOANCHIO extends PIPPO {\r\n    public void QUANTO(){\r\n        System.out.println(\"TANTO\");\r\n    }\r\n   }\r\n}\r\n\r\nIl trucco sta nel fare un downcast per supportare il metodo della superclasse di nome PIPPOANCHIO ad una variabile dichiarata PIPPO.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3933,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 521,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Dal punto di vista del compilatore va tutto bene perchè la \"is a \" è rispettata in quanti pippoanchio è un pippo quindi non da errori ma ciò che usa è il metodo di pippo.. in quanto memedesimo è istanziato come pippo.. se volessi invece stampare tanto dovrei mettere  \"if memedesimo istance of pippoanchio\"\r\nmemedesimo.quanto=tanto",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3961,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 516,
                "courseId": 4,
                "courseFinalScore": 22
              },
              "answerText": "L'oggetto MeMedesimo si dichiara di tipo PIPPO e si istanzia di tipo PIPPOANCHIO sfruttando il polimorfismo come segue:\r\n\r\npackage testclassi;\r\n\r\npublic class TestClassi {\r\n    static public class PIPPO{\r\n        void PIPPO(){}\r\n        void QUANTO(){\r\n            System.out.println(\"POCO\");\r\n        }\r\n    }\r\n\r\n    static public class PIPPOANCHIO extends PIPPO{\r\n        void PIPPOANCHIO(){}\r\n        void QUANTO(){\r\n            System.out.println(\"TANTO\");\r\n        }\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        PIPPO MeMedesimo;\r\n        MeMedesimo = new PIPPOANCHIO();\r\n        MeMedesimo.QUANTO();\r\n    }    \r\n}",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3853,
          "asker": {
            "courseId": 4,
            "askerId": 438,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è preferibile usare una interfaccia e quando una classe astratta? Perché?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " classe astratta"
            },
            {
              "keyword": " preferibile"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3874,
          "asker": {
            "courseId": 4,
            "askerId": 550,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con i termini \"overloading\" e \"overriding\"?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3892,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 467,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Overloading = quando ho metodi con lo stesso nome ma diverso numero di parametri\r\nvoid funz(int a) {\r\n...\r\n}\r\nvoid funz(int a, int b){\r\n...\r\n}\r\n\r\nOverriding = quando riscrivo un metodo già definito in una classe di livello superiore\r\nEs. Il toString() è già definito ma noi lo ridefiniamo nella nostra classe per fargli stampare quello che vogliamo\r\n ",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3924,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 525,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Il significato di queste due parole si può anche dedurre dalla singola traduzione letterale dall'inglese. Infatti dal termire overloading, cioè sovraccarico, si intende il fatto che si \"carica\", cioè si creano due metodi con lo stesso nome ma con firme (numero di elementi di input) diverse; mentre con il termine overriding, sovrascrivere, si indica infatti la creazione in una classe di un metodo con lo stesso nome e stessa firma di un altro facente parte di una classe superiore.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3947,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 454,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Con il termine overloading si intende che due funzioni coesistono con uguale nome e diversa firma;con overriding invece si indica la ridefinizione di una funzione in una sottoclasse, mantenendo immutata la firma.\r\nSi ha overloading per esempio se si definiscono le funzioni move(int dx, int dy) e poi move(int dx, int dy, int dz); si ha overriding ad esempio quando si utilizza la funzione estrai() di Pila e Coda, che è una sottoclasse di Pila. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3939,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 490,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Overloading (sovraccaricare): Si intende la scrittura di un metodo, o costruttore che che va a sovraccaricarne un altro, ossia viene scritto nuovo metodo che ha come nome lo stesso nome di un'altro metodo già esistente, ma firma diversa.\r\n\r\nOverriding (passare sopra): Si intende la ridefinizione in una sottoclasse, di un metodo ereditato da una superclasse. ",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3942,
          "asker": {
            "courseId": 4,
            "askerId": 451,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "static binding e dynamig binding sono legati rispettivamente a c++ e java. quali sono le differenze? in c++ non potro' mai programmare con dynamic binding? e java e static binding?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3884,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 568,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Binding statico(static), le chiamate ai metodi sono collegate alla versione del metodo prestabilita a tempo di compilazione, basandosi sul tipo statico del riferimento. E? efficiente, ma non flessibile standard in C, default in C++, assente in Java.\r\n\u0001Nel binding dinamico(dinamic)\u0001le chiamate ai metodi sono collegate alla versione \r\ndel metodo determinata a run-time, basandosi sul tipo dinamico dell?oggetto referenziato in quel momento. Un po? meno efficiente, ma molto flessibile.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3998,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 500,
                "courseId": 4,
                "courseFinalScore": 20
              },
              "answerText": "Le differenza tra Static e Dynamic binding è che il primo risolve le reference durante la compilazione e il secondo le risolve durante l'esecuzione del programma. Sia C++ che Java supportano entrambi ma C++ di default ha lo Static binding, Java invece il Dynamic binding. Per avere il caso non di default basta specificarlo. (Nota che era da fare solo una domanda però!)",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3900,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 426,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "Java e c++ offrono diversi meccanismi di binding. In c++ ce ne sono due, statico e dinamico. A run-time viene deciso se usare la prima o la seconda. In quella statica le decisioni sono fatte con un puntatore o una referenza statica, mentre in quella dinamica con l'attuale tipo di oggetto a cui abbiamo puntato.\r\nIn java viene sempre applicata la dynamic-binding.\r\nQuindi con c++ posso usare entrambi mentre con java solo dynamic.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3920,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 470,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "Nel binding statico i tipi delle variabili sono determinati univocamente, e quindi vengono determinate univocamente le operazioni che possono essere effettuate sulle variabili; il compilatore genera il codice per chiamare un dato metodo ogni volta che quel metodo viene applicato ad un dato oggetto; questa associazione non può essere più modificata durante l'esecuzione. In questo caso il compilatore non genera una volta per tutte, all'atto della compilazione, il codice per l'assegnazione dei valori delle variabili in funzione delle chiamate dei metodi, o il codice per calcolare quale metodo chiamare in funzione delle informazioni provenienti dall'oggetto - come nel binding statico - ma invece genera un codice che verrà utilizzato per calcolare quale metodo richiamare di volta in volta.\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3895,
          "asker": {
            "courseId": 4,
            "askerId": 474,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra upcast e downcast?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "upcast"
            },
            {
              "keyword": " downcast"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3856,
          "asker": {
            "courseId": 4,
            "askerId": 593,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "quando si verifica un downcast illecito?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "downcast"
            },
            {
              "keyword": " illecito"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3967,
          "asker": {
            "courseId": 4,
            "askerId": 512,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "In una classe abstract è possibile dichiarare metodi non astratti ? Se sì, spiegare a cosa potrebbero servire, altrimenti spiegare perché non è possibile.",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": "metodi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3940,
          "asker": {
            "courseId": 4,
            "askerId": 513,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e che differenza c'è tra \"Static Binding\" e \"Dynamic Binding\" e quale viene adottato dal linguaggio Java?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Dynamic"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3931,
          "asker": {
            "courseId": 4,
            "askerId": 437,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Se io utilizzassi un operatore di cast su di un oggetto all'interno del mio codice, il tipo dell'oggetto a posteri del cast varierebbe o rimarrebbe uguale?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "cast "
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3855,
          "asker": {
            "courseId": 4,
            "askerId": 537,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè un cast \"illecito\" provoca un errore in fase di esecuzione (run-time) e non in fase di compilazione (compile-time)?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "dynamic binding"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3928,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 593,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "perchè durante la compilazione il programma risulta corretto senza errori di scrittura",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 4000,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 558,
                "courseId": 4,
                "courseFinalScore": 24
              },
              "answerText": "¡Un cast \"illecito\" può provocare un errore in fase di esecuzione e non in fase di compilazione perchè a livello formale il metodo richiamato fa parte della classe del cast, quindi compila. In run-time può esserci un errore perchè si fa un downcast illecito, si esegue su un elemento di una classe che non ha le caratteristiche per farlo¡",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3888,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 509,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Bisogna ricordare che il compilatore vede le cose diversamente dagli esseri umani e pensa che il programmatore sa quello che sta facendo. Ma, nel caso del cast illecito, l'errore si trova in fase di esecuzione. \r\nQuando una variabile in run-time punta a una classe che non la contiene avviene questo cast illecito, quando in fase di compilazione l'errore non era stato rilevato in quanto il compilatore si fida del programmatore.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3913,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 483,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Un errore di questo tipo può avvenire nel caso io dichiari una variabile di un certo tipo, e poi provi a 'castarla' ad un tipo 'figlio', ma che non è un diretto 'is-a' con quello di partenza (che si trova quindi da qualche parte in fondo all'albero di ereditarietà del tipo di partenza). Il compilatore permette l'operazione perché appunto vede il tipo presente nell'albero dei tipi figli, ma a runtime può succedere di tutto e l'operazione potrebbe non essere permessa (assegnazione e/o chiamata di variabili e/o metodi inesistenti).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3969,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 442,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "V.O.T.A.T.E. ed io ricambio\r\n\r\nperchè spetta al programmatore effettuare il cast in modo opportuno, perciò il compilatore accetta tutti i tipi di casting (tranne quelli che che chiamano tipi diversi e non derivati dalla funzione madre), mentre in fase run-time il cast errato genera errore poichè la JVM non sa quale tipo assegnare all'oggetto.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3979,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 545,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Perchè non è possibile testare se un cast è corretto o meno finchè non conosci il valore della variabile, il che avviene durante l'esecuzione del programma.\r\n\r\n***Approfondimento***\r\nPer correttezza è necesario ricordare che ci sono due modi in cui si riscontra un errore:\r\n\r\n-il primo se tu stai castando due oggetti completamente differenti tra loro e il computer ti stoppa.\r\n\tesempio:\r\n\r\n\tString o = \"str\";\r\n\tInteger str = (Integer)o; //la compilazione fallisce\r\n\r\n\r\n-il secondo se c'è una stessa gerarchia ma un cast \"illecito\" e l'errore verrà riscontrato al cast-time.\r\n\tesempio:\r\n\t\r\n\tNumber o = new Integer(5);\r\n\tDouble n = (Double)o; //ClassCastException\r\n\r\nHai violato la fiducia del compilatore dicendogli che l'oggetto era di un determinato tipo e in realtà non lo è (e il computer/compilatore se ne rende conto solo a run-time).",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3859,
          "asker": {
            "courseId": 4,
            "askerId": 568,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Egregio utente,\r\nLa domanda è la seguente:\r\nSe, in tante cose, coda e pila sono equivalenti,\r\nin cosa sono differenti?\r\n",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 3,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "coda"
            },
            {
              "keyword": "pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3907,
          "asker": {
            "courseId": 4,
            "askerId": 521,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "In che senso java può essere considerato dynamic bounding ?Come viene definito invece c++?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": "dynamic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3854,
          "asker": {
            "courseId": 4,
            "askerId": 543,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "attuando un polimorfismo tra la classe A(contenente le funzioni f,g) e la sua figlia B(contenente anch'essa le funzioni f,g, ma diverse da quelle di A), quando viene invocata la funzione f oppure g viene invocata la funzione della classe A oppure quella di B?\r\n\r\nscrivo lo spezzone di codice per rendermi più chiaro:\r\n\r\nclass A{\r\n   void f(){...};\r\n   void g(){...};\r\n}\r\n\r\nclass B extends A{\r\n   void f(){...};\r\n   void g(){...};\r\n}\r\n\r\n//MAIN\r\n{\r\n   A a = new B;\r\n   a.f();\r\n   a.g();\r\n}",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3862,
          "asker": {
            "courseId": 4,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa s'intende per overloading e overriding?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3889,
          "asker": {
            "courseId": 4,
            "askerId": 461,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi del polimorfismo?",
          "totalDifficultyLevel": 1,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "-"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3860,
          "asker": {
            "courseId": 4,
            "askerId": 549,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa bisogna fare in java perche si utilizzi lo static binding piuttosto che il dynamic binding?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "poliformismo"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3895,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 456,
                "courseId": 4,
                "courseFinalScore": 26
              },
              "answerText": "In Java non è possibile decidere, la scelta di default è il dynamic binding. Evitare di utilizzarlo significa non implementare codice che dia luogo a una scelta in fase di runtime tra due tipi, rimuovere cioè la condizione che il compilatore risolve tramite il dynamic binding. ",
              "notes": "-",
              "rating": 4,
              "coins": []
            },
            {
              "answerId": 3956,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 502,
                "courseId": 4,
                "courseFinalScore": 25
              },
              "answerText": "In java non è possibile \"forzare\" il binding.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3977,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 554,
                "courseId": 4,
                "courseFinalScore": 18
              },
              "answerText": "Ecco come:\r\npublic class Nuovaclase{\r\n     public static void main(String args[])  {\r\n       Tipo1 x = new Tipo2(); // Tipo2 viene usato come oggetto ma riferito al Type Tipo1\r\n       Nuovaclasse p = new  Nuovaclasse();\r\n       p.orologio(x);     \r\n    }  \r\n//Il metodo orologio prede come parametro Tipo1\r\n    public Tipo1 orologio(Tipo1 x){\r\n        System.out.println(\"Sono le tre!\");\r\n        return c;\r\n    }\r\n//L'altro metodo in overload prende come parametro Tipo2 che è una sottoclasse di Tipo1\r\n     public Tipo1 orologio(Tipo2 y){\r\n        System.out.println(\"Sono le 5 e tutto va bene!\");\r\n        return y;\r\n    }      \r\n}\r\nIn questo modo quando eseguiamo il programma restituirà il metodo con parametro Tipo1 perché  durante il tempo di compilazione la scelta del metodo è  basata sul type della variabile.",
              "notes": "-",
              "rating": 2,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3955,
          "asker": {
            "courseId": 4,
            "askerId": 500,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale ragione in java si è deciso di adottare il dinamic binding di default invece dello static binding del C++?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " static e dinamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3941,
          "asker": {
            "courseId": 4,
            "askerId": 545,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che il polimorfismo comporta?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3916,
          "asker": {
            "courseId": 4,
            "askerId": 459,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra STATIC e DINAMIC BINDING?. Quale dei due tipi java implementa? perchè?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": "dinamic binding"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3870,
          "asker": {
            "courseId": 4,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Gentile studente, mi dia una chiara e delucidante spiegazione di static binding & dynamic binding, soffermandosi sulle peculiarità di una e dell'altra categoria, spiegando quando viene usata una categoria e quando l 'altra.\r\nSaluti.",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "programmazione"
            },
            {
              "keyword": "static"
            },
            {
              "keyword": "dynamic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 3906,
          "asker": {
            "courseId": 4,
            "askerId": 511,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè una classe non-abstract non può contenere metodi abstract?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3879,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 491,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Un metodo astratto è un metodo privo di implementazione. In pratica viene definito solo il suo prototipo, è compito della sottoclasse implementare correttamente il metodo. Un metodo astratto può essere presente soltanto se la classe è astratta, altrimenti il compilatore genera un errore, forzando l'inserimento del modificatore \"abstract\" nella definizione.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3921,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Il modificatore abstract diciamo che è l'antitesi del modificatore final.\r\nAbstract può essere applicato sia a metodi che alle classi, ma non a variabili in quanto dichiarare una variabile astratta non avrebbe nessun senso logico. Iniziamo con il dire che se vogliamo definire un metodo astratto, dobbiamo variare la sintassi per la scrittura di tale metodo in quanto dovremo eliminare le parentesi graffe. Un metodo astratto si definisce nel seguente modo:\r\n\r\npublic abstract tipoDiRitorno nomeMetodo();\r\n\r\nQuindi come possiamo vedere un metodo astratto non implementa nessun pezzo di codice, ma si limita ad essere una sorta di definizione.\r\nSe all'interno di una classe dichiariamo un metodo astratto, anche la classe dovrà essere definita come tale. Una classe, se definita astratta, non può essere in alcun modo istanziata e ciò è coerente con la definizione di oggetto in quanto un oggetto è una realizzazione concreta di una classe, ma ciò non è possibile se la classe è astratta.\r\n",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3972,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 518,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Le classi di tipo abstract son pensate per rappresentare superclassi o interfacce, e sono definite da metodi non definiti(scusa il gioco di parole) questo permette alle classi figlie di utilizzare i metodi implementandoli a loro volta mantenendo però la stessa firma. Questo si fa per mantenere un livello di astrazione tale da permettere l'utilizzo di peculiarità presenti in classi astratte su sotto-classi non-abstract.Per questa ragione una classe non-abstract non può contenere metodi abstract, sarebbe un controsenso concettuale.",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3898,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 445,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "una classe abstract è una classe che deve essere assolutamente sub-classata quindi non ha senso usare metodi per la classe abstract in una classe non-abstract come dicono i nomi delle classi stesse.",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3989,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "Perché un metodo abstract deve avere la propria implementazione in una sottoclasse della classe in cui è contenuto, ma non è detto che tale classe, se è non-abstract, abbia una sottoclasse. \r\nUna classe abstract, invece, ha sempre una sottoclasse, quindi ha senso che un metodo abstract sia contenuto in una classe abstract. ",
              "notes": "-",
              "rating": 1,
              "coins": []
            }
          ]
        },
        {
          "questionId": 3901,
          "asker": {
            "courseId": 4,
            "askerId": 503,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 98,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un CAST? E a cosa serve?",
          "totalDifficultyLevel": 2,
          "totalInterestingnessLevel": 2,
          "totalRelevanceLevel": 2,
          "numEvaluators": 1,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Cast"
            },
            {
              "keyword": " -"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 3897,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 572,
                "courseId": 4,
                "courseFinalScore": 27
              },
              "answerText": "Un cast nei linguaggi di programmazione serve a convertire un tipo di dato in un altro in modo esplicito o implicito.\r\n\r\nEsplicito:\r\n\r\n(int)14.5\r\n\r\nImplicito:\r\n\r\ndouble d;\r\nint i;\r\n\r\nd = i;",
              "notes": "-",
              "rating": 2,
              "coins": []
            },
            {
              "answerId": 3959,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 4,
                "courseFinalScore": 23
              },
              "answerText": "con CAST si intende il passaggio di una variabile da un tipo all'altro secondo uno schema riguardante la conversione esplicita uguale a quello del C++.",
              "notes": "-",
              "rating": 1,
              "coins": []
            },
            {
              "answerId": 3874,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 468,
                "courseId": 4,
                "courseFinalScore": 30
              },
              "answerText": "Il cast non è altro che la dichiarazione di un nuovo oggetto ad esempio new test() è possibile che il compilatore faccia un upcast o un downcast ovvero che tratti un oggetto di tipo b (che estende la classe a) come un oggetto di a. (non è vero il contrario a meno che il programmatore non lo specifichi ad esempio (b)a).metodo() ).",
              "notes": "-",
              "rating": 3,
              "coins": []
            },
            {
              "answerId": 3964,
              "task": {
                "taskId": 100,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 4,
                "courseFinalScore": 0
              },
              "answerText": "Con cast si intende la conversione del tipo di una variabile in un altro. In Java viene utilizzato per semplificare l'interazione con gli oggetti,trattandoli come se fossero di un tipo primitivo.",
              "notes": "-",
              "rating": 3,
              "coins": []
            }
          ]
        }
      ]
    }
  ]
}
