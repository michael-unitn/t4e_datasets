{
  "courseId": 100,
  "version": 2,
  "courseName": "Linguaggi Programmazione 1",
  "lectures": [
    {
      "lectureId": 59,
      "lectureTitle": "Lecture 7-8",
      "questions": [
        {
          "questionId": 5441,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Dare una definizione dettagliata di \"polimorfismo\" nel linguaggio di programmazione Java, spiegando i concetti fondamentali.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5526,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'ereditarietà in java?Quali sono i problemi che possono insorgere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5511,
          "asker": {
            "courseId": 100,
            "askerId": 893,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra binding statico e dinamico? Fare un esempio in C++ ed uno in Java ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "bindingstatico"
            },
            {
              "keyword": "bindingdinamico"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5550,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In merito alle relazioni tra classi, che differenza c'è tra relazione \"has-a\" e quella \"part-of\"? È sempre possibile scegliere in maniera univoca una delle due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "has-a"
            },
            {
              "keyword": "part-of"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5480,
          "asker": {
            "courseId": 100,
            "askerId": 751,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che problematiche possono esserci con l'ereditarietà in java? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " ereditarità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5534,
          "asker": {
            "courseId": 100,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità dei costruttori/distruttori?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "costruttori"
            },
            {
              "keyword": " distruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5811,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "I costruttori garantiscono la giusta inizializzazione e pulizia. Il compilatore, infatti, non ci permette di creare oggetti senza le necessarie chiamate del costruttore e questo dona il giusto controllo e la completa sicurezza. Il distruttore, invece, libera lo spazio di memoria da tutti gli oggetti dando la possibilità di non avere in memoria oggetti inutili che non utilizzeremo più e che, quindi, potrebbero rallentare il processo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4594,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4446,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4166,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4500,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5778,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 771,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "I costruttori e i distruttori permettono di fare eseguire una serie di operazioni automaticamente quando un oggetto viene allocato o deallocato.\r\nQueste operazioni sono generalmente di inizializzazione/deinizializzazione e quindi se il costruttore/distruttore non venisse chiamato automaticamente alla creazione/distruzione di oggetti questi metodi dovrebbero essere chiamati esplicitamente dal programmatore che usa la classe per permettere l'uso corretto dell'oggetto o per evitare memory leak.\r\nE' possibile definire più costruttori con diverse firme e l'unica differenza per chi alloca un oggetto di quella classe sarà il numero e/o tipo di parametri attuali da dare a new.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4597,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4165,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4503,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4448,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5893,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 897,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'utilità dei costruttori/distruttori è di permettere di inizializzare i membri di una classe, allocare risorse e rilasciare le risorse allocate. Sono funzioni che possiamo usare ogni volta che vogliamo creare un nuovo oggetto in una classe o quando deve essere rilasciato.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4502,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4596,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4164,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4447,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5813,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'utilità dei costruttori è quella di inizializzare un tipo di dato, allocando dinamicamente la memoria per quell'oggetto. I distruttori invece fanno l'esatto contrario, ovvero deallocare la memoria per quel dato oggetto rendendola disponibile per altre operazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4595,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4445,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4167,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4501,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5520,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In che cosa consiste il polimorfismo? è legato al concetto di ereditarietà?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5468,
          "asker": {
            "courseId": 100,
            "askerId": 836,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel caso in cui sono presenti varie classi che rappresentano le varie figure geometriche, perchè è meglio avere una classe padre che raccoglie le generità di queste ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "object"
            },
            {
              "keyword": " ereditarietà"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5522,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa fa \"finally\" quando usato prima di un blocco? Perchè si usa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "finally"
            },
            {
              "keyword": "blocco"
            },
            {
              "keyword": "perchè"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5525,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza esiste tra una relazione del tipo \"Is-a\", un' aggregazione del tipo Has-a e una composizione del tipo Part-of?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Is-a "
            },
            {
              "keyword": " Part-of "
            },
            {
              "keyword": " Has-a"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5529,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali differenze ci sono tra le relazioni tra classi HAS-A e IS-A? Più in particolare, la relazione HAS-A può essere di 2 tipi, HAS-A e PART-OF, quali sono le differenze tra queste 2 relazioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "relazioni"
            },
            {
              "keyword": " is-a"
            },
            {
              "keyword": " has-a"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5493,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Abbiamo il seguente codice:\r\n\r\nclass A{\r\n    int f(){ return 1;}\r\n}\r\n\r\nclass B extends A{\r\n      void f(){ return 2;}\r\n}\r\n\r\n[...]\r\n\r\nA b = new B();\r\nint r = b.f();\r\n\r\nChe valore acquisirà la variabile r? Per quale motivo? Analizzare il codice nel caso fosse scritto in Java e confrontarlo con un codice equivalente scritto in C++.",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Dynamic/Static Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5851,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 791,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Nel caso in cui fosse scritto in Java il valore restituito sarebbe 2, in quanto Java fa un confronto a runtime, cioè durante l'esecuzione del programma, per questo il return sarebbe quello della classe B. Se invece fosse scritto in C++ il programma verrebbe letto di default dal compilatore che vedrebbe b come un istanza di A, quindi il return sarebbe 1. Un modo sennò per realizzare il polimorfismo in C++ è usare funzioni virtuali: si dichiara precedendo il suo prototipo con la parola chiave virtual nella classe base.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4304,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4563,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5785,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 899,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Nessuno perché il codice è errato, la procedura f di B  non si aspetta alcuna return.\r\nA questo punto potremmo modificare il tipo di metodo, per esempio in intero, allora il codice è valido e r=2. Il motivo sta nella dichiarazione dell'oggetto, infatti b è un nuovo oggetto B, poco importa se è stato dichiarato come base class, f.A viene sovrascritto da f.B (overriding) e si usa quello. In c++ il seguente codice è equivalente a quello della domanda:\r\n\"using namespace std;\r\n#include <iostream>\r\n\r\nclass A{\r\npublic: \r\n  int f(){return 1;}\r\n};\r\n\r\nclass B : public A{\r\npublic: \r\n  int f(){return 2;}\r\n};\r\n\r\nint main() {\r\n  A* b= new B;\r\n  int r = b->f();\r\n  return 0;\r\n}\"\r\n\r\nIn C++ r=1 perchè non avviene fatto alcun overriding, b avrà anche le funzionalità di B ma, a parità di signature userà i metodi di A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4302,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4562,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5770,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 748,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Per prima cosa il codice scritto per la classe B non compilerà perché si tenta di far restituire qualcosa ad un metodo dichiarato void.\r\nSe il metodo f() della classe B avesse avuto come valore di ritorno int, in tal caso la variabile r avrebbe avuto valore 2 in java(motivo: overriding) mentre in c++ avrebbe avuto valore 1 (a causa del dinamic e static binding presenti rispettivamente in java e c++). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4564,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4303,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5449,
          "asker": {
            "courseId": 100,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Funzioni in Java: cosa si intende per \"overriding\" e \"overloading\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5462,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Static Binding e Dynamic Binding? Come si differenziano in questo caso Java e C++?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static Binding"
            },
            {
              "keyword": " Dynamic Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5760,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Static Binding:\r\n\u0001Le chiamate ai metodi sono collegate alla versione del metodo prestabilita a tempo di compilazione, basandosi sul tipo statico del riferimento. E? efficiente, ma non flessibile.\r\n\u0001Standard in C, default in C++, assente in Java.\r\n\r\nDynamic Binding:\r\n\u0001Le chiamate ai metodi sono collegate alla versione del metodo determinata a run-time, basandosi sul tipo dinamico dell?oggetto referenziato in quel momento. Un po? meno efficiente, ma molto flessibile.\r\n\u0001Non presente in C, possibile a richiesta in C++ (virtual), default in Java.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4575,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4276,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4578,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4158,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5858,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il binding è il processo mediante il quale si viene a creare un meccanismo che collega i vari metodi alle proprie implementazioni. Questo processo può avvenire a tempo di compilazione (static binding) oppure a tempo di esecuzione (dynamic binding). Entrambi si trovano sia in C++ che in Java, ma se nel primo l'utilizzo del dynamic binding deve essere esplicitamente richiesto, nel secondo viene impiegato di default, a meno che non si impieghino metodi \"static\", \"private\" o \"final\", oppure in caso di overloading di metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4572,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4576,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4159,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4273,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5825,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 823,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con static e dynamic binding si intendono due diversi metodi di determinare il tipo dell'oggetto istanziato nel caso si abbia overriding di metodi tra super e sottoclassi o overloading di metodi con firme differenti.\r\nPiù nello specifico, lo static binding consiste nell'istanziare l'oggetto at compile time, quindi il tipo è \"statico\", deciso al momento della compilazione.\r\nIl dynamic binding invece permette di compilare il codice senza specificare a priori il tipo di un determinato oggetto, quindi è possibile definirlo col tipo della superclasse e gestire la sua istanzazione at runtime.\r\nIl C++, privilegiando la velocità, di default utilizza lo static binding, benché si possa forzare il dynamic dichiarando un metodo \"virtual\". Il Java utilizza anch'esso lo static binding in caso di overloading e dynamic binding in caso di overriding; in ogni caso, i metodi \"private\", \"final\" e \"static\" forzano lo static binding in quanto non possono subire overriding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4274,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4577,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4573,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4157,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5799,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 921,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Queste sono due modalità che i compilatori utilizzano quando viene eseguito un programma in base al linguaggio in cui è scritto il suddetto programma. La differenza tra queste due opzioni sta nella valutazione che il compilatore fa di un oggetto, delle classi ereditarie e dei metodi che a esso sono riferiti. Lo static binding è un tipo di compilazione che consente velocità al programma (es: programma c++) perchè quando il programma incontra per la prima volta la chiamata di un metodo di una classe le successive chiamate non valuteranno più il tipo dell'oggetto che sta chiamando il metodo ma userà il \"bind statico\" che era stato creato alla prima chiamata. Al contrario invece un programma scritto per esempio in java utilizza il dinamic binding che permette invece una maggiore flessibilità al programma a costo della sua velocità verificando a ogni chiamata di un metodo l'oggetto riferito alla chiamata così da permettere il possibile uso di metodi in classi con ereditarietà.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4275,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4156,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4579,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4574,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5464,
          "asker": {
            "courseId": 100,
            "askerId": 894,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Se definissi due funzioni in Java:\r\ndoSomething(int a, int b);\r\ndoSomething(int a);\r\n\r\nSarebbe permesso? Motivare la risposta. E se fossero definite in C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Firma"
            },
            {
              "keyword": "Ambiguità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5476,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende con funzione polimorfa? ",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5820,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Innanzitutto il termine \"polimorfismo\" significa \"molte forme\". Una funzione polimorfa è una funzione che cambia forma a seconda dei casi presentati. L'idea è quindi quella di scrivere una funzione che si adatti a più casi, in sostituzione a più funzioni simili tra loro che differiscono l'una dall'altra per una condizione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4220,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4394,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4309,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5888,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un metodo è detto polimorfo quando ha la capacità di comportarsi diversamente a seconda del tipo di dato dato in input.\r\nSi parla di Static Binding quando, effettuato un overloading, Java decide at Compile time quale funzione invocare.\r\n \r\nEs: Supponiamo di aver definito una classe Operazioni con i metodi \r\nDivisione (int a, int b) e Divisione(double a, double b). Il compilatore decide quale metodo utilizzare a seconda che si abbiano 2 interi o 2 double in input.\r\n\r\nSi ha a che fare con un Dynamic Polymorphism quando, effettuato un override di un metodo su una subclass, Java decide at Run Time se invocare il metodo nativo (quando gli viene passato la super class) oppure quello sovrascritto (quando gli viene passato la subclass).\r\n \r\nEs:Supponiamo di aver definito un oggetto chiamato NumNaturali su cui è definito un metodo Differenza. Poi definiamo la subclass NumInteri su cui Differenza è esteso a ogni coppia di numeri. A seconda dell'oggetto richiamato, si invoca la corretta funzione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4390,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4218,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4307,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5797,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 767,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una funzione polimorfa è una funzione che si comporta in modo diverso a seconda del modo in cui viene chiamata.\r\n\r\n(es.: la funzione 'estrai' se viene chiamata da una pila oppure da una coda sarà implementata in modi differenti)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4216,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4305,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4392,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5829,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 800,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Come si deduce dal termine stesso \"polimorfismo\", che vuol dire \"multiforma\", una funzione polimorfa è una funzione che cambia forma a seconda dei casi presentati e quindi la sua struttura deve essere tale da adattarsi a più casi e non uno solo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4217,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4393,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4308,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5882,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Nel contesto della programmazione orientata agli oggetti, si riferisce al fatto che una espressione il cui tipo sia descritto da una classe A può assumere valori di un qualunque tipo descritto da una classe B sottoclasse di A. L'overriding è appunto la pratica di sostituire o meglio specificare una funzione o metodo dichiarato nella classe madre da una delle sottoclassi utilizzando lo stesso nome e stessi argomenti. In questo modo gli oggetti si comportano in modo dinamico e non statico e predefinito. \r\nQuesto in alcuni linguaggi come il C e C++ è possibile ma non predefinito perchè normalmente il compilatore agisce secondo uno static binding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4306,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4219,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4391,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5434,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali rischi derivanti dall' ereditarietà multipla?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà-multipla"
            },
            {
              "keyword": " rischi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5852,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 802,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Uno dei principali rischi è che se una classe eredita membri con lo stesso nome da più di un genitore, avviene un conflitto",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4290,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4088,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5876,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 883,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'ereditarietà multipla differisce dalla semplice ereditarietà singola perché può ereditare funzionalità e caratteristiche da più superclassi senza doverle ridefinire. Comporta diversi rischi, uno su tutti il \"diamond problem\", ovvero: se due classi B e C ereditano da una classe A e la classe D a sua volta eredita sia da B che da C, se un metodo in D chiama un metodo definito in A, non si sa con certezza da quale classe questo metodo possa venire ereditato. Tuttavia in Java è possibile ereditare da più classi base solo le interfacce, ma dati e metodi vengono ereditati solo da una specifica superclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4090,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4289,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5849,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Tra i principali rischi, c'è il problema legato alle classi che utilizzano un metodo che è definito in entrambe le classi che esso eredita. Ciò è rischioso in quanto il compilatore può utilizzare a sua discrezione o uno o l'altro, causando così errori nel codice a volte difficile da rintracciare.\r\nUn'altro problema è causato dal polimorfismo, ossia quando chiamo un metodo che è presente sia nella classe che utilizzo sia in quella madre. Per esempio se dichiaro:\r\nPoint p = new NamedPoint  (in cui NamedPoint eredita da Point) ed entrambi presentano il metodo insert, nel momento in cui richiamo insert su p, a seconda del compilatore, egli può utilizzare il metodo di Point, in quanto inizialmente p è stato dichiarato come Point  (static binding), oppure quello di NamedPoint (dynamic binding).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4089,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4292,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5884,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Quando una classe è una SOTTOCLASSE di una SUPERCLASSE, la sottoclasse eredita dalla superclasse tutte le sue variabili d'istanza e metodi. In alcuni casi, una sottoclasse può ereditare da più sottoclassi e questo può creare dei problemi.\r\n\r\nIl problema principale si verifica quando nella sottoclasse viene utilizzato un metodo presente in entrambe le superclassi, creando così delle ambiguità in quanto non è possibile dire con certezza da quale superclasse quella sottoclasse stia ereditando.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4091,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4291,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5486,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come avviene il passaggio dei parametri alle funzioni in Java? \r\nCosa cambia se il tipo del parametro è un tipo primitivo o un oggetto?\r\nIn Java è possibile passare un parametro di tipo primitivo per referenza?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "parametri"
            },
            {
              "keyword": " funzioni"
            },
            {
              "keyword": " referenza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5879,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il passaggio di parametri avviene per referenza quando vengono passati degli oggetti mentre nel caso dei tipi di dati primitivi viene passata una copia del dato.\r\nAnche in java è possibile passare i dati primitivi per riferimento ma bisogna  esplicitarlo a differenza degli oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4629,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4476,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4472,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4208,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5809,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 926,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il passaggio di parametri alle funzioni in Java avviene per riferimento nel caso in cui si tratti di un oggetto o per valore nel caso in cui si tratti di un tipo primitivo. In Java non è possibile passare per referenza un tipo primitivo(in alternativa è possibile usare la classe del tipo primitivo (per esempio Integer, Float ecc.) ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4630,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4207,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4478,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4474,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5861,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 878,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Le variabili associate a tipi primitivi sono passate a un metodo come valore cioe' viene fatta una copia e questa e' passata al metodo, gli oggetti invece sono passati ai metodi per riferimento percio' l'oggetto referenziato puo' essere modificato dal metodo.\r\n\r\nComunque, il riferimento stesso e' passato per valore, cioe' viene fatta una copia del valore dell'indirizzo in memoria dell'oggetto.\r\n\r\nSebbene ci siano dei sistemi per simulare il passaggio per riferimento di variabili primitive, normalmente tale funzione non è supportata da java, al contrario ad esempio del c o c++.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4477,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4210,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4627,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4473,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5807,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 790,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il passaggio dei parametri avviene, se è un oggetto di una classe, per riferimento, altrimenti,  se è una primitiva, per copia.\r\nSi è possibile passare un parametro primitivo per referenza usando una classe associata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4475,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4628,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4479,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4209,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5507,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in Java (eccetto nell'ultima versione) non è permessa l'ereditarietà multipla? e che alternativa è stato applicato come soluzione? ",
          "totalDifficultyLevel": 21,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 21,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5862,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La motivazione è puramente di carattere gestionale: supponendo di avere la possibilità di gestire ereditarietà multiple tra le classi si complicherebbe molto il diagramma delle classi, complicando quindi la gestione delle stesse e complicando la comprensione di cosa una classe eredita da un'altra. Esplicitamente, l'albero di rappresentazione del diagramma delle classi si trasformerebbe in un grafo, complicandone notevolmente leggibilità e manutentibilità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4518,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4374,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4231,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4526,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5764,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "In Java non era permessa l'eredità multipla fino alla versione precedente in quanto presenta alcuni problemi come, ad esempio, l'ambiguità dei nomi e la maggiore difficoltà di gestione dovuta alla localizzazione dei metodi. Le alternative applicate consistono nell'uso di interfacce e, se vogliamo (in parte), da un opportuno utilizzo del \"cast\", ossia specificare nella singola stringa di codice qual è la classe a cui si fa riferimento per accedere a un determinato metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4229,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4372,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4524,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4517,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5788,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Java non possiede (possedeva) la possibilità di ereditare da più di una singola classe per una scelta di design del linguaggio : l'ereditarietà multipla può infatti portare a diverse ambiguità. Per risolvere il problema del diamante (così definita l'ambiguità che nasce dall'eredit. multipla) è possibile utilizzare le interfacce. In questo modo, una classe ha la possibilità di ereditare più interfacce, risolvendo eventuali problemi di implementazione senza creare ambiguità. Per esempio:\r\nSia definita la classe 'VeicoloTerra' e la classe 'VeicoloAcqua'. Dobbiamo implementare una classe 'VeicoloAnfibio' che erediti caratteristiche di entrambe le classi definite in precedenza. Come fare? Usando le interfacce:\r\npublic class VeicoloTerra implements CaratteristicheTerra {}\r\npublic class VeicoloAcqua implements CaratteristicheAcqua {}\r\npublic class VeicoloAnfibio implements CaratteristicheTerra,CaratteristicheAcqua {}\r\nIn aggiunta, è possibile utilizzare classi del tipo abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4376,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4528,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4520,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4233,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5792,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'ereditarietà multipla, pur essendo un concetto utile nella programmazione ad oggetti, rende il linguaggio molto più complicato da un punto di vista tecnico: basta pensare che il diagramma UML delle relazioni tra classi, che se si considera solo l'ereditarietà singola è un albero, diventerebbe un grafo non necessariamente aciclico.\r\nPer ottenere comunque alcuni dei benefici dell'ereditarietà multipla, Java introduce le interfacce (collezioni di metodi che possono essere ereditati da classi non necessariamente correlate).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4519,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4230,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4373,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4523,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5833,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'ereditarietà multipla può essere causa di confusione.\r\nIl problema è che se una classe eredità da più classi aventi un metodo con la stessa firma ci sarebbe un problema di conflitto e allora la sottoclasse non saprebbe quale dei due prendere.\r\nEsempio: se due classi B e C ereditano dalla classe A, la classe D eredita sia da B che da C,il metodo in D chiama un metodo definito in A, da quale classe viene ereditato? \r\nLa soluzione è che se si eredita dalla classe abstract non ci sarebbero problemi perchè viene ignorato da uno già definito.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4522,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4525,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4375,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4232,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5896,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'ereditarietà multipla si ha quando una sottoclasse eredita da più superclassi:\r\nessa deriva il suo codice non solo da una, ma da più classi. Nonostante l'idea sia buona, ci sono alcuni problemi:\r\n- la struttura gerarchica delle classi si complica e da albero diventa grafo, dunque sarà più complesso seguire il codice e capire cosa farà il compilatore;\r\n- ci sono ambiguità sintattiche per la gestione di variabili strutturali e/o comportamentali che risultano eredità comune di più superclassi.\r\nIn Java si è adottato questo compromesso: una classe può ereditare le interfacce da più di una classe base - cioè esporre all'esterno gli stessi metodi delle interfacce delle classi base - ma può ereditare i dati ed i metodi effettivi da una sola classe base.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4377,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4234,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4521,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4527,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5545,
          "asker": {
            "courseId": 100,
            "askerId": 824,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Se una nuova classe A viene dichiarata all'interno (come sottoclasse) di una classe B che cosa eredita? Se si dichiara un oggetto di tipo B esso puó essere inizializzato poi con il costruttore della classe A?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": " sottoclasse"
            },
            {
              "keyword": " ereditarietà "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5488,
          "asker": {
            "courseId": 100,
            "askerId": 861,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che tipo di accorgimenti bisogna tenere conto quando si ricorre all'ereditarietà fra classi per evitare di incorrere in ambiguità? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "problema"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5547,
          "asker": {
            "courseId": 100,
            "askerId": 788,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "La programmazione orientata agli oggetti offre diversi strumenti per rendere il codice flessibile e compatibile con diverse istanze dello stesso problema a  run time. Come si chiamano queste caratteristiche FI questo paradigma di programmazione ? Canne un esempio che le racchiuda.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " polimorfismo"
            },
            {
              "keyword": " oop"
            },
            {
              "keyword": " caratteristiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5527,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Enuncia e spiega brevemente il Pincipio di Sostituzione di Liskov.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Liskov"
            },
            {
              "keyword": " subtitution"
            },
            {
              "keyword": " principle"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5541,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con il concetto di eredità parlando di classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5446,
          "asker": {
            "courseId": 100,
            "askerId": 844,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual é la differenza principale nella gestione del polimorfismo tra i linguaggi C++ e Java? E quali sono i vantaggi e gli svantaggi dei due diversi modi di gestione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "C++"
            },
            {
              "keyword": "Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5533,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa significa polimorfismo nella programmazione object-oriented? Porta dei vantaggi? Se sì, quali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " vantaggi"
            },
            {
              "keyword": " oggetti"
            },
            {
              "keyword": " object-oriented"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5515,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "C++ e Java utilizzano lo stesso tipo di binding? Quali sono i principali vantaggi del binding dinamico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Dinamic binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5456,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In java si può fare overloading del metodo Main? \r\nSe si ha errore di che tipo lo si ha?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5819,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "è possibile fare overloading del metodo Main, ma questo non viene riconosciuto come errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4332,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4214,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4132,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5824,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 848,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì, in Java si può fare overloading del metodo Main (), ma quando verrà eseguito il programma verrà utilizzata solamente la public static void main (String [] args) {}.\r\nQuindi, non verranno visualizzati errori a schermo, ma verranno ignorate le altre classi implementate chiamate main.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4136,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4212,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4333,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5800,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Si, in Java è possibile effettuare l'overloading del metodo main e non vengono generati errori. Bisogna però tenere conto che per eseguire un programma Java la JVM andrà comunque in cerca del metodo \"public static void main(String[] args) {...}\" (cioè il metodo main con firma standard) e non del metodo main con parametri diversi, qualunque siano i parametri \"attuali\" (passati da linea di comando). Invece, per eseguire il metodo main con firma diversa è sufficiente, per esempio, chiamarlo all'interno del metodo main con firma standard e con i parametri necessari.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4133,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4335,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4211,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5828,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Sì, in Java è consentito l'overloading del main tramite la modifica del numero o del tipo dei parametri negli altri metodi main implementati. \r\nSi potrà avere un errore a compile-time qualora l'overloading del metodo main sia effettuato in modo errato, ad esempio variando il tipo di ritorno del metodo main (es: public static int (String[] args) ) oppure modificando il nome del parametro formale ma non il numero o il tipo di parametri (es: public static void main(String[] a) ). \r\nSi ricordi infine che, qualunque sia il numero di argomenti specificati a esecuzione del programma, l'unico metodo che verrà chiamato come main sarà: \r\n\"public static void main(String[] args)\"\r\nCiò permette comunque la chiamata di altri metodi main all'interno del programma o del main stesso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4215,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4336,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4134,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5791,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Si, il compilatore non segnala come un errore. Ma durante l'esucuzione sempre prima entrerà  dentro il main originale. Verrà eseguito \"main overloaded\" se solo se viene chiamato al interno del main originale oppure dentro una funzione.\r\n\r\nEsempio: \r\nclass Simple{  \r\n     public static void main(int a){                 //main overloaded\r\n                 System.out.println(a);  \r\n     }   \r\n     public static void main(String args[]){    //main originale\r\n               System.out.println(\"main() method invoked\");  \r\n               main(10);  \r\n     }  \r\n}  \r\n\r\nOutput sarà:\r\n>>main() method invoked\r\n>>10",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4334,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4135,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4213,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5475,
          "asker": {
            "courseId": 100,
            "askerId": 764,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono l'aggregazione e la composizione nella Unified Modeling Language (UML) e che cosa in particolare le differenzia l'una dall'altra.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " aggregazione"
            },
            {
              "keyword": " composizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5435,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è fra binding statico e dinamico? Quale bisogna avere per poter sfruttare il polimorfismo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static binding"
            },
            {
              "keyword": " dynamic binding"
            },
            {
              "keyword": " polymorphism"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5460,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il problema dell'avere il polimorfismo (inteso come \"estendere tante classi in un unico colpo\") in un linguaggio di programmazione orientato agli oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " problemi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5458,
          "asker": {
            "courseId": 100,
            "askerId": 790,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Abbiamo parlato di ereditarietà, concetto fondamentale nella programmazione ad oggeti; che relazioni corrono fra le classi ereditarie ed ereereditate? Cioè : che cosa è possibile fare fra e con esse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi ereditarie"
            },
            {
              "keyword": " relazioni"
            },
            {
              "keyword": " ereditarietà "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5499,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come possiamo avere 'effetti collaterali' sui tipi primitivi in Java? Portare un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "effetti"
            },
            {
              "keyword": "collaterali"
            },
            {
              "keyword": "esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5531,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra la relazione di aggregation e quella di composition? Fare un esempio per tipo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "aggregation"
            },
            {
              "keyword": " composition"
            },
            {
              "keyword": " realazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5487,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Si enunci il principio di sostituzione di Liskov e lo si spieghi con un esempio.",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " principio di sostituzione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5874,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Se S è un sottotipo of T, allora oggetti di tipo T in un programma possono essere sostitituiti da oggetti di tipo S, senza alterare alcuna proprietà desiderabile del programma. \r\nPoint p=new\r\nPoint();\r\np.move(3,4);\r\nOvunque ce un Point posso mettere un NamedPoint.\r\nPoint p=new NamedPoint();\r\np.move(3,4);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4569,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4612,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4417,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4257,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5889,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Il principio di sostituzione di Liskov (LSP) afferma che se S è un sottotipo di T, allora oggetti di tipo T in un programma possono essere sostituiti da oggetti di tipo S senza alterare alcuna proprietà desiderabile del programma stesso.\r\nIn in altre parole si può dire che moduli che usano oggetti di un tipo devono poter usare oggetti di un tipo derivato senza accorgersi della differenza. Significa che il comportamento della sottoclasse deve essere compatibilie con la specifica della sopraclasse.\r\nESEMPIO: \r\nclass Mammifero{\r\n   vivere();\r\n   mangiare();\r\n   dormire();\r\n}\r\nclass Cane extends Mammifero{\r\n   // La classe Cane eredita tutti i metodi di Mammifero. Faccio un Override dei metodi della superclasse per specificare i comportamenti della classe Cane. \r\n}\r\nPosso scrivere tranquillamente \"Mammifero cane = new Cane();\" poiché Cane (IS A) Mammifero. Quindi non sto alteranto la struttura base della mia superclasse e posso riferirmi a Cane dicendo semplicemente che è un Mammifero.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4419,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4258,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4570,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4611,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5767,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nella programmazione orientata agli oggetti il principio di sostituzione di Liskov è una particolare definizione di sottotipo, introdotta da Barbara Liskov nel 1993. \r\nLa formulazione sintetica del principio è la seguente:\r\n\r\n\"Se q(x) è una proprietà che si può dimostrare essere valida per oggetti x di tipo T, allora q(y) deve essere valida per oggetti y di tipo S dove S è un sottotipo di T.\"\r\n\r\nQuesta nozione di sottotipo è quindi basata sulla nozione di sostituibilità secondo cui, oggetti dichiarati in un programma di tipo T possono essere sostituiti con oggetti di tipo S senza alterare la correttezza dei risultati del programma. D'altra parte, questo principio pone alcuni vincoli sulle modalità d'interazione:\r\n\r\n- I prerequisiti richiesti ad una superclasse devono essere almeno altrettanto vincolanti di quelli richiesti alle sottoclassi;\r\n- Le postcondizioni e gli invarianti in una sottoclasse devono essere almeno altrettanto vincolanti di quelle delle sue superclassi;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4613,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4256,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4418,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4571,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5492,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzione dell'abstract e a cosa serve.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5516,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il blocco Try-Catch in Java? In che modo si possono gestire le eccezioni?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Try"
            },
            {
              "keyword": " Catch"
            },
            {
              "keyword": " Eccezioni"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5771,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Attraverso il blocco \"Try\" riesco a produrre delle eccezioni che sostanzialmente contengono la descrizione di un errore avvenuto durante lo svolgimento del programma che posso catturare con il comanda \"catch\". Una volta che ho catturato l'eccezione posso semplicemente stamparne la stinga o dedicarmi a soluzioni più fantasiose. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4102,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4460,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4416,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4111,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4505,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4488,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5774,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 900,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": " Il costrutto try catch serve per catturare le eccezioni che si possono formare in Java",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4110,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4457,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4485,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4104,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4504,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4413,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5784,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 859,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In java le eccezioni sono degli eventi che vengono generati in circostanze anormali.\r\nLa cattura di una eccezione avviene tramite il costrutto try/catch : nel blocco try deve essere inserito il pezzo di codice che potrebbe generare un'eventuale eccezione e nel blocco catch il codice di gestione dell'eccezione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4415,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4103,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4506,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4112,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4459,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4487,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5808,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un modo per gestire le eccezioni è rappresentato dal blocco Try-Catch, che si costruisce nel seguente modo:\r\n\r\nTry {\r\n} Catch (Exception e) {\r\n  }\r\n\r\nNel Try viene inserito un pezzo di codice nel quale si pensa che possano avvenire degli errori; se effettivamente si verificano degli errori, allora questi vengono \"catturati\" (rilevati) dal Catch, che può essere pensato come come una funzione a cui viene passata l'eccezione, e viene eseguita solo se l'errore si è veramente verificato.\r\n\r\nPer gestire le eccezioni, nel Catch è possibile che ci sia un comando che porta a richiamare nuovamente il Try, permettendo all'utente di capire che qualcosa non è andato a buon fine; oppure è chiamata la funzione printStackTrace() che indica dove è avvenuto l'errore; è anche possibile chiamare la funzione Finally, che dà informazioni sull'errore avvenuto. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4507,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4109,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4458,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4101,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4414,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4486,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5521,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare il concetto di estensione di una classe (ad esempio, spiegare in che modo una classe Class2 estende una sua superclasse Class1)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "extends"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5459,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con polimorfismo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5502,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Posso dichiarare un oggetto object e inizializzarlo come stringa?(Motivare la risposta)",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "subclassing"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5776,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Questo tipo di istaziazione di un oggetto è permessa grazie al legame di ereditarietà che lega le due classi(in quanto tutte le classi ereditano da Object), quindi dato che String IS-A Object il compilatore valuta corretta la seguente riga di codice:\r\n     Object o = new String();\r\nquesto è possibile perchè essendo String una classe che estende Object essa eredita metodi e attributi di Object, ne aggiunge di nuovi oppure ne sovrascrive alcuni(override di un metodo) quindi non sorgono problemi nel trattare un oggetto di tipo String come se fosse un Object (String ha tutto ciò che ha Object), chiaramente non è vero il contrario.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4381,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4632,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4228,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5887,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 766,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si è possibile perchè la classe object è una superclasse, diretta o indiretta, di ogni classe e definisce lo stato e il comportamento base che ciascun oggetto deve avere.\r\nInfatti alla classe object è aggregata dalle classi string, int, float ecc... L' importante è ricordarsi che quell'oggetto non può usufruire dei metodi della classe string. In questo caso da un errore di compilazione.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4383,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4633,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4226,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5845,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "No il tipo non lo prevede, neanche per mezzo di cast espliciti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4382,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4227,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4631,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5548,
          "asker": {
            "courseId": 100,
            "askerId": 886,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza fra Static Binding e Dynamic Binding, e cosa usano rispettivamente C++ e Java a riguardo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5498,
          "asker": {
            "courseId": 100,
            "askerId": 800,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Esplicitare i concetti di sottoclasse, overriding ed overloading.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Subclass"
            },
            {
              "keyword": " overriding"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5505,
          "asker": {
            "courseId": 100,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Se b è una sottoclasse di a, b può utilizzare i metodi di a? E viceversa, l'utilizzo è possibile? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "sottoclasse"
            },
            {
              "keyword": " b"
            },
            {
              "keyword": " a"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5553,
          "asker": {
            "courseId": 100,
            "askerId": 880,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire brevemente cosa sono l'overloading e l'overriding.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5769,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'overloading è l'esistenza contemporanea di due metodi con nomi uguali, ma con firma (ovvero tipo e numero di parametri formali) diversa, che appunto grazie a questa funzionalità possono coesistere (per esempio possono coesistere due metodi costruisci: il compilatore in base al numero e al tipo dei parametri passati deciderà quale delle due usare). L'overriding consiste invece nella ridefinizione di un metodo in una sottoclasse, che mantiene uguale firma rispetto alla superclasse (questo può rendersi necessario ad esempio quando creiamo una classe Lista e due sottoclassi Coda e Pila: le due dovranno avere un costruttore diverso, che deve essere però dichiarato nella superclasse e quindi definito diversamente in funzione delle due sottoclassi):",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4553,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4235,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4324,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4489,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4129,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5798,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Per overloading, si intende una famiglia di funzioni che possono coesistere nonostante i nomi di queste siano uguali. Ciò è dovuto al fatto che le firme sono differenti tra loro avendo un diverso numero di argomenti.\r\nEsempio:\r\nfunz_a (int n1, float n2);\r\nfunz_b (int n1, float n2, char n3);\r\n\r\nPer overriding, si intende la ridefinizione in una sottoclasse di un metodo ereditato da una superclasse. E' però obligatorio che questi due metodi abbiano la stessa firma e che il metodo della superclasse non sia 'private'.\r\nEsempio:\r\nla funzione estrai() nel caso della 'pila' e della 'coda' visto a lezione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4127,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4490,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4555,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4327,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4238,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5859,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 901,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'overloading in Java identifica quella particolare occasione in cui due metodi con lo stesso nome ma con firma differente coesistono nello stesso programma.\r\nL?ereditarietà consente ad una classe figlia di ereditare le proprietà ed i metodi delle sue classi antenate (purché non siano definiti con l?access specifier ?private?). La possibilità di riprogrammare i metodi ereditati nella classe figlia, sovrascrivendone dunque il comportamento, viene definita overriding. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4236,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4557,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4491,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4325,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4131,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5804,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "L'overloading Consiste nell'avere funzioni con lo stesso nome ma diversa firma, ovvero funzioni che hanno parametri diversi (per numero e/o per tipo).\r\n\r\nL'overriding consiste invece nel riscrivere la stessa funzione in una sotto classe mantenendo però la stessa lista di parametri ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4130,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4493,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4237,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4326,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4554,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5780,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il termine Overloading indica la possibilità di avere due funzioni con stesso nome e firma diversa (Ex.: pippo(int, int)   pippo(char) )\r\nIl termine Overriding indica la possibilità di poter ridefinire in una sottoclasse una funzione presente nella superclasse, mantenendo la firma immutata ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4556,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4239,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4492,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4328,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4128,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5443,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega che cosa si intende per polimorfismo, cercando di riportare come utilizzarlo riportando se possibile uno o più esempi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " significato"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5439,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il costrutto \"try...catch\"? Qual'è la sua utilità?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "try"
            },
            {
              "keyword": "catch"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5448,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Pila s = new Coda();\r\n\r\nCome si comporta java con questa riga di codice? E come invece c++? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " lezione7"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5552,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per binding? E in che modo questo processo può influenzare la corretta esecuzione di una programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5467,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Il polimorfismo delle funzioni in Java può creare deglli errori, quali e come si possono evitare ?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "problemi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5856,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si possono generare errori quando proviamo a chiamare un metodo di una classe figlia, la quale è assegnata ad una variabile di tipo della classe padre. Proprio per questo motivo il compilatore non ha definiti i nuovi metodi implementati nella classe figlia. Ciò si risolve con il downcast della variabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4120,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4343,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4093,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4310,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4469,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5860,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Seguendo l'esempio visto a lezione, in presenza di relazioni di tipo IS-A è lecito dichiarare Point p=new NamedPoint(), ove, formalmente, p è un identificatore di tipo Point: potrò accedere a tutti i campi della classe Point, ma non a quelli della sottoclasse NamedPoint, anche se, di fatto, p è associato ad una struttura di tipo NamedPoint.\r\nIn presenza di blocchi condizionali risulta difficile conoscere a priori il tipo di dato che realmente verrà istanziato, perciò l unico controllo che potrò avere a compile-time sarà di tipo formale: p è di tipo Point, dunque tutto ciò che dichiaro dovrà essere compatibile con la sua definizione (riscontrando un errore se cercherò di accedere al campo name). \r\nÉ possibile tuttavia aggirare questo problema bypassando il compilatore, mediante l utilizzo di cast nel caso in cui si ha la certezza di ciò che verrà istanziato a runtime (responsabilità del programmatore), oppure, ricorrendo al costrutto istanceof, nel caso in cui questo non sia possibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4346,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4094,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4117,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4313,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4471,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5892,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il polimorfismo può generare errori in quanto è possibile istanzare oggetti di una classe B con riferimento alla superclasse A\r\nEsempio:\r\n A a = new B (...)\r\nTuttavia ciò non garantisce al mio oggetto \"a\" di usare i metodi della classe B. Per risolvere a ciò, nella classe A vengono creati dei metodi virtuali che saranno ridefiniti dalla classe B, cosicché \"a\" può usare i metodi definiti con B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4311,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4118,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4344,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4470,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4095,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5816,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Nel polimorfismo vi sono molti vantaggi ma anche molte insidie. Possono infatti crearsi alcuni errori sia in fase di compilazione sia a runtime. Un errore comune è la chiamata di valori della funzione figlio nella funzione padre. Es: se abbiamo la classe A (padre) e la classe B (figlio) e nella classe figlio abbiamo un void f2(), e A a; B b; non potremo chiamare f2 dalla funzione padre. Questo tipo di errore può essere risolto attraverso il downcast e l'upcast (Es: per correggere l'esempio precedente si farà un ((B)a).f2(); . A loro volta però essi possono generare errori a runtime (come il downcast illecito) come il java.lang.ClassCastException, i quali possono essere corretti attraverso il \"try\" e \"catch\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4092,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4468,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4119,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4345,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4312,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5484,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra aggregazione (\"is a\") e composizione (\"part of\")? Sottolinea la differenza mediante un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Aggregazione"
            },
            {
              "keyword": " composizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5497,
          "asker": {
            "courseId": 100,
            "askerId": 917,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "spiega brevemente cos'è il polimorfismo (per inclusione cioè il polimorfismo del Paradigma object-oriented), cosa ci permette di fare e perché è  così importante.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "object-oriented"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5513,
          "asker": {
            "courseId": 100,
            "askerId": 858,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè l'ereditarietà multipla in Java è stata introdotta solo nell'ottava versione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " eredeitarietà multipla"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5447,
          "asker": {
            "courseId": 100,
            "askerId": 910,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra HAS-A e PART-OF? Come fare a sapere quale usare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "has-a"
            },
            {
              "keyword": " part-of"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5539,
          "asker": {
            "courseId": 100,
            "askerId": 901,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In UML cos'è il Class Diagram?\r\n\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Class Diagram"
            },
            {
              "keyword": "UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5450,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è più conveniente basarsi su un abstract esterno per istanziare i metodi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Metodi"
            },
            {
              "keyword": " istanze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5444,
          "asker": {
            "courseId": 100,
            "askerId": 823,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare le analogie e le differenze tra le relazioni di aggregation e composition.",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 25,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " UML"
            },
            {
              "keyword": " aggregation"
            },
            {
              "keyword": " composition"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5870,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "La differenza fondamentale è che una relazione di tipo aggregation (\"has a\")permette agli oggetti relazionati l'esistenza dell'uno senza l'altro (macchina->passeggero). Viceversa la relazione di composition semplificata con l'espressione \"part of\" rende un oggetto parte di un altro e di conseguenza senza il primo il secondo non può esistere (Uccello->Ali). In alcuni casi la relazione non è così chiara da definire (macchina->ruota) ma è neccessario stabilire sempre il tipo di relazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4619,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4299,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4172,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4423,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4454,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5897,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le relazioni di aggregation (HAS-A) e di composition (PART-OF) hanno in comune il fatto di utilizzare la nozione di ereditarietà, ossia se ho due classi A e B che interagiscono secondo lo schema A -->B, la variabili di B può utilizzare metodi e variabili della classe A. Come si può intuire poi dalla terminologia tra parentesi, la differenza principale tra aggregation e composition consiste che nella prima la class A ha senso di esistere senza che debba essere definita anche B (per esempio una camera, ha senso di esistere anche senza che ci siano persone all'interno), mentre nella seconda non vale quest'affermazione e quindi le due classi devono coesistere sempre per avere un senso logico (per esempio un tavolo non ha alcun senso di esistenza se è sprovvisto di gambe, che appunto lo compongono).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4621,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4296,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4456,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4168,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4425,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5841,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sia la relazione di aggregation che quella di composition sono relazioni tra classi in cui la prima classe contiene un riferimento alla seconda, ad esempio come tipo di una sua variabile d'istanza. La differenza è nel concetto. La composition si usa quando la seconda classe è una parte della prima, un suo componente. In questo caso la classe riferente non puo' esistere senza l'altra. Nella composition la classe riferita è un attributo dell'altra classe, ma quest'ultima non necessita di tale classe per essere pensata. Per stabilire quale delle due relazioni esiste però non è solo necessario conoscere le classi coinvolte ma anche il problema. In alcuni problemi infatti un tipo di conoscenza sulla classe può risultare necessaria (composition) o superflua (aggregation).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4169,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4452,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4298,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4620,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4421,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5880,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'aggregazione e la composizione sono delle associazioni che specificano una relazione whole-part (tutto-parte) tra l'aggregato e le parti componenti.\r\nL'aggregazione è una relazione \"non-forte\", ovvero le classi parte possono esistere anche senza il tutto.\r\nUn esempio:\r\nQuadro--------------------<>Museo<>--------------------Statua\r\n\r\nLa composizione invece è una relazione \"forte\", ovvero in cui le classi parte dipendono dal tutto.\r\nUn esempio:\r\nFoglie----------------------<>Albero<>--------------------Radici",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4173,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4623,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4300,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4422,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4453,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5812,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La relazione composition implica che un oggetto non può esistere senza gli elementi che gli appartengono (es: un tavolo e le sue gambe), mentre con aggregation un oggetto esiste indipendentemente dalla presenza o meno degli elementi che contiene o che gli appartengono (es: l'aula studio e gli studenti).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4424,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4170,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4455,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4297,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4618,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5872,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nei casi in cui c'è una relazione tra A e B possiamo utilizzare il collegamento di Aggregation, B può essere aggregata anche ad altre classi non esclusivamente solo ad A.\r\nAggregation non afferma in alcun modo che A possiede B, né che vi sia una relazione padre-figlio tra i due, di solito è utilizzato per sottolineare il fatto che A non è il contenitore esclusivo di B, come di fatto B ha un altro contenitore.\r\n\r\nNel caso in cui c'è una forte dipendenza del ciclo di vita tra A e B, quindi quando A viene eliminato anche B viene eliminato, si utilizza Composition.\r\nComposition mostra che una classe ha la proprietà esclusiva su altre classi, il che significa che l'oggetto contenitore e le sue parti costituiscono un rapporto padre-figlio .\r\nDiversamente dall'Aggregation, nel rapporto di Composition, la classe composta non può apparire come un tipo di ritorno o parametro della classe, pertanto i cambiamenti nella classe non possono essere propagate al resto del sistema.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4451,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4420,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4301,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4622,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4171,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5510,
          "asker": {
            "courseId": 100,
            "askerId": 925,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa si differenziano le tecniche di overloading e overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5542,
          "asker": {
            "courseId": 100,
            "askerId": 802,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire e proporre un esempio del principio di sostituzione di Liskov.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "liskov"
            },
            {
              "keyword": " sostituzione"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5465,
          "asker": {
            "courseId": 100,
            "askerId": 756,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando un metodo deve essere dichiarato abstract?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5796,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Un metodo deve essere dichiarato abstract nella superclasse (anc'essa abstract) quando questo metodo deve essere implementato diversamente nelle sottoclassi. Per esempio in una classe forma devo dichiarare il metodo disegna abstract perchè questo ha una sua implementazione particolare per ogni forma. Importante è che se in una classe ho un metodo abstract anche la classe stessa deve essere abstract!!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4432,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4246,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4320,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5836,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Quando ho più classi con attributi e metodi in comune (esempio, le classi quadrato, triangolo e cerchio, che sono tutte figure geometriche e si possono raccogliere sotto la classe \"forma\"), è buona prassi raccogliere questi elementi e creare una super-classe contenente questi ultimi. Se le sottoclassi hanno un metodo con la stessa firma ma diversa implementazione (esempio, il metodo disegna, proprio della figura), nella superclasse dichiarerò questo metodo appunto \"abstract\", e non scriverò la sua implementazione poiché essa sarà demandata alle classi figlie (esempio, le tre classi si disegnano in maniera diversa; dichiarerò nella classe forma il metodo astratto disegna, e lascerò alle sottoclassi il compito di specificare il \"come\")",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4319,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4245,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4433,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5898,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un metodo astratto è un metodo che non ha implementazione ma ha solo il suo prototipo ed è definito all?interno di una classe astratta o in un?interfaccia, è sempre seguito, inoltre, da un punto e virgola. I metodi astratti hanno una o più implementazioni fornite, per esempio, in sottoclassi che contengono metodi concreti che a loro volta implementano il metodo astratto. Tutte le sottoclassi (non astratte) devono, infatti, implementare i metodi astratti. Dichiarando un metodo astratto comporta che ogni sottoclasse concreta dovrà avere una propria implementazione del metodo attraverso l?overriding.\r\nLe classi astratte non possono creare oggetti ma i loro oggetti sono oggetti di sottoclassi.\r\nIl metodo deve essere dichiarato abstract, per esempio, nella classe FORMA, l?implementazione di un metodo che disegni una forma geometrica generica potrebbe non essere facile da creare. Le istruzioni per disegnare le diverse forme vengono introdotte, perciò, in sottoclassi concrete.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4430,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4247,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4321,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5763,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Si dichiara una classe astratta e quindi anche dei metodi astratti quando non serve conoscerne l'implementazione ma serve un la firma di un per raccogliere tutti i metodi dello stesso tipo di altre classi in cui sono implementati. Per esempio come visto a lezione con le forme, la classe Forma aveva il metodo disegna abstract perché non poteva sapere come disegnare tutte e tre le forme, ma viene usato per richiamare i metodi del altre classi in base al bottone che veniva schiacciato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4323,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4434,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4249,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5765,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un metodo deve essere dichiarato abstract in due istanze:\r\n\r\n1. Quando si vuole rilasciare solo la firma del metodo e non implementare il corpo. \r\n2. Quando l'implementazione del metodo non è pre-definibile (implementabile,decidibile) a priori, perchè la sua funzione può variare a seconda della sottoclasse che lo eredità.\r\n\r\n- Un esempio di un metodo che deve essere dichiarato abstract è il metodo estrai() per gestione delle strutture dati, in quanto, il metodo estrai() della Pila(LIFO) differisce dal metodo estrai() della Coda(FIFO), supponendo che entrambe ereditino da una superclasse chiamata Stack, il metodo estrai() sarà dichiarato {abstract tipo estrai();} nella superclasse.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4248,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4431,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4322,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5445,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Conviene prima scrivere il main, avendo in mente già uno schema di tutte le altre classe oppure conviene prima crearsi tutte le classi necessarie e poi passare al main?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Procedimento"
            },
            {
              "keyword": " Classi"
            },
            {
              "keyword": " Main"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5504,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire la differenza tra un linguaggio object oriented e object based. ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "object"
            },
            {
              "keyword": " based"
            },
            {
              "keyword": " oriented "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5864,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "In un linguaggio object based manca il concetto di ereditarietà, ovvero la possibilità di definire degli oggetti che acquisiscono le proprietà di altri, aggiungendo informazioni o metodi. Così il codice viene riutilizzato efficacemente per descrivere situazioni in cui esiste un concetto generale declinato nelle sue varie specializzazioni.\r\nIl concetto di ereditarietà è presente in un linguaggio object oriented.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4435,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4261,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4106,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4464,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4360,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5835,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La differenza fondamentale tra un liguaggio OO e un linguaggio OB sta nella mancanza di supporto all'ereditarieta' ed al polimorfismo di quest'ultimo.\r\n\r\nUn linguaggio OB si basa sugli oggetti ma non ammette l'estensione delle sottoclassi da piu' classi madre.\r\n\r\nL'esempio osservato a lezione prendeva come oggetto la classe Point, le sottoclasse NamedPoint e Point3D ed una terza sottoclasse NamedPoint3D.\r\nIl linguaggio OO supporta l'estensione di NamedPoint3D sia da NamedPoint sia da Point3D.\r\n\r\nLa schematizzazione grafica del linguaggio OB trova una struttura gerarchica ad albero. Il linguaggio OO invece e' rappresentabile invece come un grafo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4361,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4466,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4262,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4108,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4437,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5781,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 881,
                "courseId": 100,
                "courseFinalScore": 9
              },
              "answerText": "Un linguaggio \"object based\" è un determinato tipo di linguaggio di programmazione che incapsula dati e operazioni all'interno di oggetti. Esso, tuttavia, seppur faccia uso di oggetti, non necessariamente soddisfa i criteri di incapsulamento, ereditarietà e polimorfismo.\r\nInvece un linguaggio \"object-oriented\", che per definizione è anche un linguaggio \"object-based\" (in quanto opera su oggetti che interagiscono fra di loro) deve soddisfare questi 3 criteri. Con incapsulamento si intende la proprietà per cui i dati di un oggetto e i suoi metodi sono accessibili da altri metodi ma non dal client stesso. Con ereditarietà si intende la proprietà di passare gli attributi di una classe padre ad una classe figlia, per poi modificarli o aggiungerne di nuovi. Con polimorfismo si intende la possibilità di utlizzare lo stesso codice eseguibile avente istanze di classi diverse, con, tuttavia, una superclasse comune.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4359,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4436,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4465,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4260,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4107,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5823,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sostanzialmente i linguaggi object based hanno tutte le funzionalità della programmazione OOP (object oriented programming) tranne il polimorfismo e l'ereditarietà.\r\nLa definizione di linguaggi object based è stata introdotta per denotare alcuni linguaggi che non potevano essere propriamente considerati object oriented. Dunque praticamente i linguaggi object based non sono object oriented, mentre gli object oriented sono anche object based. \r\nJava, Pyton, Ruby sono esempi di linguaggi object oriented, mentre VisualBasic e JavaScript sono object based.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4105,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4438,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4259,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4467,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4358,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5482,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi porta l'ereditarietà in Java? Quali possono essere le varie implicazioni e quali accortezze bisogna prestare per definire una sottoclasse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "sottoclasse"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5514,
          "asker": {
            "courseId": 100,
            "askerId": 849,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali difficoltà sorgono permettendo l'ereditarieta multipla?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 4,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " multipla"
            },
            {
              "keyword": " sottoclassi"
            },
            {
              "keyword": " sottoclasse"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5883,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 783,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Java permette di utilizzare l'ereditarietà multipla, in cui una classe può ereditare funzionalità e caratteristiche da più di una classe base.L?ereditarietà multipla è uno strumento potente che consente di affrontare problemi complessi con eleganza\r\nLa sua implementazione nativa però può generare un lieve decadimento delle performances anche quando non viene usata.\r\nL'ereditarietà multipla, inoltre, può essere causa, in alcuni contesti, di qualche confusione; una possibile causa di ambiguità è la seguente: se due classi B e C ereditano dalla classe A e la classe D eredita sia da B che da C, se un metodo in D chiama un metodo definito in A, da quale classe viene ereditato? In Java si è adottato questo compromesso: una classe può ereditare le interfacce da più di una classe base, cioè esporre all'esterno gli stessi metodi delle interfacce delle classi base, ma può ereditare i dati ed i metodi effettivi da una sola classe base. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4277,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4287,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4450,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4181,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4174,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5777,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La difficoltà che sorge permettendo l'ereditarietà multipla è la seguente;se due classi B e C ereditano dalla classe A e la classe D eredita sia da B che da C, se un metodo in D chiama un metodo definito in A non si è certi da quali delle due classi figlie di A viene ereditato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4278,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4175,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4449,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4180,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4288,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5440,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cosa sono Overloading e Overriding e che cos?è la firma, portando anche degli esempi.",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " Overriding"
            },
            {
              "keyword": " Firma"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5831,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Overloading e overriding sono concetti fondamentali per utilizzare il Polimorfismo offerto da Java. L'overloading è una tecnica molto utilizzata e, tradotto, significa ?sovraccarico?. Per capire questo concetto è necessario fare un esempio:\r\npublic int somma(int a, int b){\r\nreturn a + b;\r\n}\r\npublic float somma(float a, float b){\r\nreturn a + b;\r\n}\r\nPerciò la parola overloading significa che con uno stesso nome per un metodo (somma in questo caso) si da la possibilità di effettuare una somma sia tra due interi sia tra due float, l?importante è che abbiano una firma diversa.\r\nLa firma di un metodo<modif> <tipo> <nome> (<tipo1> <par1>, ... ,<tipon> <parn>) è la sequenza (<nome>, <tipo1>, ..., <tipon>). \r\nL'overriding è una tecnica che ci permette di \"sovrascrivere\" un metodo presente.Non si può fare l'override di un metodo dichiarato final e soprattutto non si può modificare la signature del metodo (int somma(int a, int b)) e non si può diminuire la visibilità del metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4582,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4591,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4161,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4565,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5834,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dato un oggetto, per firma di un suo metodo si intende il nome e i parametri in input. La firma di un metodo è unica. Se all'interno di un oggetto si hanno due metodi che hanno in comune il nome ma diversi parametri in numero e/o tipo, allora si parla di OVERLOADING, o sovraccarico. Da notare che il tipo restituito non fa parte delle firma: int gamma(int a, int b); float beta(int a, int b); hanno la stessa firma e non sono permessi. Per overriding si intende la dichiarazione di un metodo, all'interno di una sottoclasse, che è stato ereditato da una classe principale. Quindi \"overwrite\", cioè, sovrascrittura. Le differenza più evidente è che l'overloading avviene nella stessa classe, mentre l'overwrite \"richiede\" una classe base e una classe figlia. Un'altra notevole differenza è che il primo avviene at Run-time, il secondo at Compile-time. Per questo motivo l'overloading da' migliori performance. Inoltre, le private class possono essere overloaded ma non possono essere overwritten.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4160,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4567,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4592,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4583,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5890,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 749,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "L'Overloading permette di \"sovraccaricare\" un metodo di una classe con più varianti in base ai parametri d'ingresso(questo usando firma diversa nei vari casi), ad esempio:\r\n- Prodotto(int a,int b)\r\n- Prodotto(int a, int b, int c)\r\nL'Overriding permette di sovrascrivere un metodo con una classe figlia andando così a riprogrammare il metodo delle classi antenate, ad esempio:\r\n- public class Studente{\r\n  ...\r\n  public string getInfo()\r\n {\r\n  return ?Nome: ? + nome + ?\\n? + ?Classe: ? + classe;\r\n }\r\n }\r\n  public class Insegnante extends Studente{\r\n  ...\r\n  public string getInfo()\r\n {\r\n  return ?Nome: ? + nome + ?\\n? + ?Classe: ? + classe + ?\\n? + ?Materia: ? + materia;\r\n }\r\n }\r\nLa firma di un metodo è individuata dal nome del metodo e dai tipi dei parametri d'ingresso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4568,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4580,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4593,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4163,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5869,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "L'overloading (sovraccaricamento) si ha quando funzioni/subroutine aventi lo stesso nome, differiscono negli argomenti. Viene utilizzato per poter istanziare due funzioni diverse (ma che di base agiscono nella stessa maniera) utilizzando lo stesso nome e variando il numero o il tipo degli argomenti. ES:\r\npoint(int x, int y) \r\npoint(int x, int y, int z) \r\nL'overriding (sovrascrittura) è la ridefinizione, in una sottoclasse, di un metodo ereditato dalla classe padre. ES:\r\nsupponendo che Stack sia la classe padre di Pila e Coda e contenga un metodo estrai(), definendo un altro metodo estrai() in Pila o Coda avente gli stessi argomenti, verra ridefinito (all'interno della sottoclasse)\r\nsi richiede anche che il metodo della classe padre non sia di tipo private o final.\r\nLa firma o signature di un metodo è un insieme di informazioni che identificano univocamente il metodo fra quelli della sua classe, e sono il nome, il numero e il tipo dei parametri (ma non il loro nome).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4590,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4566,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4162,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4581,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5442,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega con un esempio il \"try-catch-finally\" in java",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "try"
            },
            {
              "keyword": " catch"
            },
            {
              "keyword": " finally"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5886,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 786,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Se una chiamata di metodo può generare un'eccezione, possiamo racchiuderla in un blocco try, seguito da uno o più blocchi catch contenenti le istruzioni da eseguire se l'eccezione viene lanciata. Se c'è almeno un blocco catch, allora il blocco finally è facoltativo. \r\n\r\nIn un qualsiasi esempio si eseguono le istruzioni try, se l'esecuzione termina senza fallimenti, si eseguono le eventuali istruzioni finally e si termina. Altrimenti, se un'istruzione contenuta in try lancia un'eccezione \"ecc\", si cerca il primo blocco catch in grado di gestirla. Se un tale blocco esiste, si eseguono le istruzioni catch ed infine si eseguono le eventuali istruzioni finally. L'eccezione è stata catturata con successo. Altrimenti vengono comunque eseguite le eventuali istruzioni finally e l'eccezione viene passata al chiamante.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4357,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4331,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4508,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5891,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "public class TestExeption {\r\n   public static void main(String[] args) {\r\n      try {\r\n         System.out.println(Divisione.div(7, 0));\r\n        }\r\n      catch (ArithmeticException ex) {\r\n         System.out.println(ex.getMessage());\r\n      }catch (RuntimeException ex) {\r\n         System.out.println(\"Può essere una qualsiasi eccezione RuntimeException\");\r\n      }\r\n      finally{\r\n        System.out.println(\"in ogni caso, buona giornata!\");\r\n      }  \r\n  }\r\n}\r\nNel caso in cui un metodo possa generare un'eccezione, è possibile racchiuderla in un blocco try, seguito da uno o più blocchi catch che hanno il compito di catturare e gestire le eccezioni. I blocchi vengono scorsi tutti finché non viene trovato quello che gestisce il partcolare tipo di eccezione e quindi viene eseguito. Il caso in questione tratta la divisione per 0; se ad esempio viene generata un'eccezione di tipo AritmeticException verrà eseguito il primo blocco catch. Le istruzioni nel finally vengono eseguite in ogni caso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4355,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4510,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4329,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5805,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il try-catch-finally è un costrutto che, in caso di errore, fa si che il programma non termini. Viene utilizzato nel modo seguente:\r\ntry { <istruzioni> }\r\ncatch { <istruzioni_catch> }\r\nfinally { <istruzioni_finally> }\r\nSe le istruzioni all'interno del blocco \"try\" vengono eseguite senza errori, allora il costrutto termina eseguendo le istruzioni del \"finally\"; se all'interno del blocco \"try\" ci sono errori, viene generata un'eccezione che viene catturata dal \"catch\", e il costrutto termina eseguendo le istruzioni contenute in tale blocco. Ci possono essere anche più blocchi \" catch\", per catturare più eccezioni diverse.\r\nUn esempio:\r\n\r\nint num;\r\ntry {\r\n     System.out.print(\"Inserisci un numero intero: \");\r\n     num = Int.parseInt(console.readLine());\r\n} catch {\r\n     System.out.print(\" Non hai inserito un numero intero!\");\r\n} finally {\r\n     System.out.print(\"Hai inserito il numero \" + num);\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4330,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4356,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4509,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5461,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi comporta il \"Liskov substitution principle\" ai fini della programmazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Liskov"
            },
            {
              "keyword": " principle"
            },
            {
              "keyword": " programmazione"
            },
            {
              "keyword": " utente"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5512,
          "asker": {
            "courseId": 100,
            "askerId": 921,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Overload e override. Sono operazioni che si applicano a cosa e in che modo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overload"
            },
            {
              "keyword": " override"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5508,
          "asker": {
            "courseId": 100,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per classe \"Abstract\" ed in quali casi può essere necessario il suo utilizzo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " abstract"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5506,
          "asker": {
            "courseId": 100,
            "askerId": 881,
            "courseFinalScore": 9
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel passaggio dei parametri, cosa si intende per \"essere passati per copia\"? E \"per referenza\"?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 22,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "copia"
            },
            {
              "keyword": " referenza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5772,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per \"essere passati per copia\" si intende che il parametro della funzione o procedura è una copia della variabile attuale e di conseguenza essa non viene modificata direttamente. \"Per referenza \" invece si intende che vi è una copia dell'indirizzo della variabile attuale , quindi il parametro della funzione è a tutti gli effetti la variabile attuale e di conseguenza la modifica avviene direttamente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4496,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4255,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4121,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4513,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5837,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili associate a tipi primitivi sono passate a un metodo come valore, cioe' viene fatta una copia e questa e' passata al metodo. Modifiche al valore passato non influenzano la variabile nel codice che richiama il metodo. Java tratta le variabili collegati ad oggetti come riferimento agli stessi. Questo riferimento contiene l'indirizzo in memoria di un oggetto. Ma a differenza dei puntatori C++ e' impossibile conoscerne il valore, i valori del riferimento non possono essere alterati, e' possibile convertirli solo a superclassi o sottoclassi dello stesso oggetto, mai a altri tipi di dati. Gli oggetti sono passati ai metodi per riferimento. Percio' l'oggetto referenziato puo' essere modificato dal metodo. Comunque, il riferimento stesso e' passato per valore, cioe' viene fatta una copia del valore dell'indirizzo in memoria dell'oggetto. Cosi' se la variabile corrispondente nel metodo e' modificata, non si avra'alcun effetto sulla variabile originale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4494,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4122,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4252,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4515,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5793,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 925,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando un parametro viene \"passato per copia\", si parla di passaggio di parametri per valore. Alla funzione viene passata appunto una copia dell?argomento. Grazie a questo meccanismo il valore della variabile nel programma chiamante non viene modificato.\r\nNel passaggio di parametri per riferimento (o reference), invece, alla funzione viene passato l?indirizzo e non il valore dell?argomento. Questo approccio richiede meno memoria rispetto alla chiamata per valore, e soprattutto consente di modificare il valore delle variabili che sono ad un livello di visibilità (scope) esterno alla funzione o al metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4512,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4495,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4123,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4254,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5817,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per copia si passa il valore della variabile ma non la variabile stessa. operando modifiche a quel valore il contenuto della cella della variabile di partenza non cambia.\r\nPer referenza invece si passa l'indirizzo della cella, deferenziandolo si potrà operare sul valore della cella modificandone il valore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4126,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4253,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4497,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4514,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5822,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si intende passato per copia, quando viene fatta una copia del valore in un'altro indirizzo di memoria. Ad esempio immaginiamo di voler passare int a = 5 per copia alla variabile int b di una funzione funct. Sia int a sia int b valgono 5 ma sono dislocati in due indirizzi di memoria.\r\n\r\nPer riferimento invece é il contrario ovvero int a e int b condividono lo stesso indirizzo e quindi le modifiche effettuate a b nella funzione verranno contemporaneamente effettuate anche a a. Se per esempio la nostra funct facesse b++(normale operazione do incremento) nel primo caso b sarà 6 e a rimarrà 5, mentre nel caso per riferimento entrambi i valori saranno 6 perché rappresentanti della stessa cella di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4498,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4125,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4516,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4251,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5838,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "In Java esistono due modi per passare i parametri a un metodo: per copia e per riferimento; nel primo caso viene fatta appunto una copia che viene passata al metodo così che le modifiche fatte a questa variabile valgano solo all'interno di quest'ultimo, infatti quando il metodo termina il parametro riprenderà il valore che aveva prima della chiamata.\r\nInvece quando il parametro è un oggetto si usa il passaggio per referenza il quale permette al metodo di accedere direttamente all'oggetto portando delle modifiche le quali saranno visibili anche al di fuori di quest'ultimo, infatti alla fine del metodo l'oggetto conserverà le modifiche ricevute.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4499,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4124,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4511,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4250,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5551,
          "asker": {
            "courseId": 100,
            "askerId": 855,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si implementa una pila per farla diventare una coda?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " coda"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5455,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il ruolo di \"proxy\" nella comunicazione tra \"browser\" e \"server\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "proxy"
            },
            {
              "keyword": " browser"
            },
            {
              "keyword": " server"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5543,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In c++ e in java è permessa l'ereditarietà multipla? Nel caso non lo fosse, spiegarne il motivo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " multipla"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5503,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per UML? E qual'è il suo utilizzo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": "  standard"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5477,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In UML (Unified Modeling Language), cos'è un Class Diagram? Quali sono i principali componenti e le principali relazioni? Spiegare le differenze tra varie relazioni e il loro uso.",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ClassDiagram"
            },
            {
              "keyword": " Is-A"
            },
            {
              "keyword": " Has-A"
            },
            {
              "keyword": " Part-Of"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5775,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 811,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un Class Diagram è un diagramma che rappresenta graficamente una o più classi e le eventuali relazioni tra loro. Ogni classe è composta da un nome, dei metodi e degli attributi.\r\nLe relazioni che possono sussistere tra una coppia di classi sono:\r\n-l'ereditarietà, in cui una classe viene \"estesa\" a partire dall'altra per mezzo di modifiche e/o aggiunte di metodi e/o attributi;\r\n-l'aggregazione, in cui una classe ha l'altra come attributo, il quale non deve necessariamente essere istanziato;\r\n-la composizione, identica all'agregazione ma la classe contenuta deve necessariamente essere istanziata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4179,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4197,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4116,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4282,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4617,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5877,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Un class Diagram rappresenta le classi e gli oggetti che compongono i sistema , i relativi attributi e le relazioni inoltre specifica i vincoli che legano tra loro le classi mediante le associazioni .I componenti sono le classi e le relazioni che si differenziano in \"is-a\" dove le 2 classi in questione hanno un rapporto di ereditarietà, aggregazione(has-a) dove nessuno degli elementi dipende dal' altro e infine composizione(part-of) dove un elemento dipende dal' altro perché ne fa parte . \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4200,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4115,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4615,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4280,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4178,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5830,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il class diagram rappresenta le classi e gli oggetti    che compongono il sistema,  ed i relativi attributi ed operazioni.  Specifica in oltre i vincoli che legano tra loro le classi. Ci sono varie relazioni come: l'ereditarietà che associa gerarchicamente due classi, in pratica una classe assume il ruolo di padre e l'altra di figlia, così facendo si ha che la classe figlia eredita tutti gli attributi e i metodi del padre ed eventualmente ne implementa di propri. L'aggregazione si compone con due classi distinte associate una all'altra ma che possono esistere indipendentemente una dall'altra. La composizione si compone di due classi dipendenti una dall'altra ossia una classe non può esistere senza l'altra. (Es. Il tavolo non é un tavolo senza le gambe).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4279,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4199,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4114,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4616,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4177,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5842,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Un Class Diagram è un tipo di diagramma in UML utile a descrivere sistemi con un approccio simile al \"object-oriented\", rappresentando le classi e gli oggetti, con i rispettivi attributi e operazioni, che lo descrivono.\r\nIn un Class Diagram solitamente abbiamo dei rettangoli divisi in tre parti. Nella prima è indicato il nome della classe. Le altre due, invece, contengono la lista degli attributi che le appartengono e quella delle operazioni definite su di essa che permettono al resto del mondo di interagire con lei. Le Associazioni sono delle linee che collegano due classi indicando che tra di esse c'è una relazione:\r\n-\"is-a\": rappresenta il concetto di Ereditarietà; è una freccia dalla punta triangolare dalla classe figlia alla classe padre.\r\n-\"has-a\"/\"part-of\": rappresentano Aggregazione/Composizione. I loro significati sono simili, nel primo però il contenuto/parte esiste indipendentemente dal contenente, nel secondo no. Si usa una freccia con punta a rombo dalla parte all'intero.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4176,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4113,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4198,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4281,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4614,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5549,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come influisce l'attributo abstarct nelle classi in java? quali sono le situazioni dove è richiesto? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " class"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " attributo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5479,
          "asker": {
            "courseId": 100,
            "askerId": 811,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi dell'ereditarietà multipla?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5761,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "I vantaggi sono maggiore flessibilità (soprattutto per il polimorfismo) e possibilità di riutilizzo di codice, tuttavia a costo di una maggior difficoltà di gestione.\r\nAlcuni possibili problemi: durante la risoluzione delle chiamate alle superclassi bisogna prestare attenzione ai cicli che si formano nel grafo rappresentante la gerarchia delle classi; nell'ereditare vi possono essere sovrapposizioni di identificatori e firme per variabili e metodi.\r\n\r\nPer cercare di conservare i vantaggi e mitigare gli effetti negativi si spesso viene scelto un modello a ereditarietà singola con l'aggiunta del concetto di interfacce: una \"classe\" che contiene solo firme di metodi; una classe che implementa un'interfaccia dovrà fornire l'implementazione (una classe astratta svolge la stessa funzione nell'ereditarietà multipla). Un altro modello che mitiga gli effetti indesiderati è il method hiding esplicito coadiuvato dal method renaming (modello adottato ad esempio da Eiffel).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4370,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4542,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5821,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 907,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I vantaggi dell'ereditarietà sono molteplici: ogni classe figlia eredità tutte le funzioni della classe madre, ciò permette di avere sempre \"a portata di mano\" funzioni utili legate alla classe madre, permette una generalizzazione del codice, codice più facile da organizzare e da implementare evitando la ridondanza.\r\nGli svantaggi principali sono legati al casting tra classi dove bisogna stare attenti a cosa si accede e dove.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4539,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4367,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5794,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il fatto che Java supporti l'eredità multipla ci permette di far si che una classe erediti le caratteristiche di più di una classe base, questo ci permette di creare oggetti appartenenti a una classe dotata di certe caratteristiche, ma facente parte anche di una classe dotata di altre caratteristiche, che la prima classe non possiede, ad esempio l'elemento \"cane\" appartiene alla classe \"mammifero\" ma anche a quella \"quadrupede\", ma le due classi pur avendo elementi comuni non coincidono, questo può essere utile per catalogare o ordinare elementi, ma si può incorrere anche nel cosiddetto \"problema del diamante\", che consite nel determinare, nel caso in cui due classi ereditino dalla stessa classe di base e poi una quarta classe erediti dalle prime due, un metodo definito nella prima classe da quale classe viene ereditato, in Java si è deciso che il metodo può essere ereditato da una sola classe base mentre altri linguaggi come il C++ hanno risolto in modo diverso",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4540,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4371,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5802,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 836,
                "courseId": 100,
                "courseFinalScore": 19
              },
              "answerText": "I vantaggi sono che si possono comporre oggetti complessi in modo rapido e una classe può avere diverse funzionalità, gli svantaggi sono che c'è una notevole complicazione del linguaggio che la implementata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4538,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4368,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5814,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "L'ereditarietà multipla è quella properietà di un linguaggio di programmazione orientato agli oggetti che permette ad una classe di ereditare metodi e attributi da più classi. E' quindi un grande vantaggio poter ereditare da più classi per avere un codice più compatto e che presenta meno ripetizioni di istruzioni. Tuttavia questo crea delle grandi complicazioni nella comprensione del codice sorgente del programma in quanto le relazioni di ereditarietà non sono più esprimibili da un albero, ma bensì da un grafo(sicuramente di meno immediata comprensione). Per questi motivi alcuni linguaggi (e.g. C++, che mirano alla massima efficienza, implementano l'ereditarietà multipla, mentre altri(e.g. Java), hanno deciso di non renderla possibile.(Gli sviluppatori di Java stanno pensando di implementarla per le prossime versioni, sicuramente prendono le opportune precauzioni per mantenerne la facilità di comprensione).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4369,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4541,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5519,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Static binding e dinamic binding: cosa sono? quali sono le differenze? \r\nRispondere facendo riferimento ai due metodi usati da Java e C++.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " dinamic"
            },
            {
              "keyword": " binding"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5453,
          "asker": {
            "courseId": 100,
            "askerId": 873,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il diagramma delle classi? A cosa serve? Che gerarchie rispetta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Diagramma"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5470,
          "asker": {
            "courseId": 100,
            "askerId": 762,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si intende con ereditarietà?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " ereditarietà"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5438,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra \"static binding\" e \"dynamic binding\"? Quale espediente andrebbe utilizzato in C++ per fare in modo che il binding sia dinamico (ovvero stabilito a tempo di esecuzione)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " C++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5437,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "E' bene che una funzione sia polimorfa?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": " polimorfa"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5773,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "certamente,  in quanto il polimorfismo permette al programma di fare uso di oggetti che espongono una stessa interfaccia, ma implementazioni diverse. Infatti, l'interfaccia del tipo base definisce un contratto generale che sottoclassi diverse possono soddisfare in modi diversi ma tutti conformi alla specifica comune stabilita dal tipo base. Di conseguenza, la parte del programma che fruisce di questa interfaccia chiamata in gergo client tratta in modo omogeneo tutti gli oggetti che forniscono un dato insieme di servizi, a prescindere dalle loro implementazioni interne definite dalle rispettive classi. In virtù di questa possibilità, si può utilizzare lo stesso codice personalizzandone o modificandone anche radicalmente il comportamento, senza doverlo riscrivere, ma semplicemente fornendogli in input una differente implementazione del tipo base o dei tipi base.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4428,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4411,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4603,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4601,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4139,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5878,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il polimorfismo ha dei notevoli vantaggi, permette infatti di evitare molti cicli if e di rendere in generale il codice molto più versatile e flessibile e di allegerirlo alla lettura. Il fatto che le decisioni vengano prese a runtime costa però diversi cicli macchina, e questo è il principale svantaggio del polimorfismo. \r\nIn generale possiamo però dire che in \r\nJava il fatto che una funzione sia polimorfa sia un bene; mentre in C++, dove l'obiettivo principale rimane la creazione di un codice che sia veloce, lasciare che le scelte siano fatte a runtime non è di nessuna utilità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4426,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4600,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4140,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4605,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4409,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5818,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, in quanto é facile capirlo nel seguente esempio:\r\nse studente é una sottoclasse di persona, possiamo definirlo cosi: Persona lui = new Studente(); in quanto studente prende tutti i metodi di Persona e in più definirá dei nuovi metodi che persona non possiede, per questo se scrivessi Studente lui = new Persona(); sarebbe sbagliato. Da questo semplice esempio si può notare come a destra dell'uguale va indicata la sottoclasse ea sinistra la superclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4138,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4604,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4412,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4429,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4598,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5847,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ha dei vantaggi; perché permette di definire una funzione in modo generale, nel senso che permette di accettare valori (tipi) anche senza saperli nello specifico. \r\nEsempio: Possiamo definire una classe Figura che ha un metodo x(), e indipendentemente da successive assegnazioni come Cerchio, o come Quadrato, quando invochiamo figura.X() il sistema saprà invocare il metodo corrispondente all'istanza corretta di Figura, ciò è corretto poiché sia Quadrato che Cerchio sono entrambe sottoclassi di Figura e condividono lo stesso template. Il polimorfismo permette di ottenere un certo livello di astrazione e rende il codice più \"aperto\".\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4410,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4137,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4602,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4427,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4599,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5546,
          "asker": {
            "courseId": 100,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale caso si utilizza has-a in in quale caso part-of? E' sempre chiara la distinzione tra aggregazione e composizione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Aggregazione"
            },
            {
              "keyword": " composizione"
            },
            {
              "keyword": " has-a"
            },
            {
              "keyword": " part-of"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5457,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando una classe \"usa\" un'altra classe si può parlare di \"aggregazione\" oppure di \"composizione\". Qual è la differenza?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Aggregazione"
            },
            {
              "keyword": " Composizione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5782,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Prendo la classe A, e la sottoclasse B che la estende.\r\nA si aggrega a B (relazione \"has-a\") se A è definita per poter funzionare autonomamente. Esempio: la classe A, Point, fatta dagli interi x e y per le coordinate e metodi, estesa da B, NamedPoint, che aggiunge una stringa nome. Possiamo usare un' istanza di A senza inizializzarla come una di B, se vogliamo.\r\nMetafora: l'aggregazione è come mettere un tappo a una penna, che scriverebbe comunque.\r\nA si compone di B (relazione \"part-of\") se B contiene dei metodi o definizioni di cui A necessita per poter essere usata in un programma. Esempio: definiamo la classe A, Shape, che contiene i campi dimensione, posizione e colore. Per poter disegnare una figura(shape), dobbiamo creare una sottoclasse come B, Triangle, che contiene un metodo che partendo dalla posizione specificata imposta determinati pixel dello schermo al colore specificato, con la dimensione come scala.\r\nMetafora: una bici non viaggia senza ruote, di cui deve comporsi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4294,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4461,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4626,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4379,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5827,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Quando una classe  B 'usa' un altra classe C possiamo parlare di una relazione importante tra classi, che è quella di aggregazione. Il termine 'Usa' deriva dal fatto che una variabile di istanza della classe B è un oggetto di tipo C. Questa relazione è rappresentata anche da un disegno di rombo il cui significato è una relazione di tipo HAS - A. Quindi possiamo anche dire B has-a C. In caso di aggregazione anche se le classi che vengono 'usate' smettono di esistere , la classe che 'Usa' (che contiene le altre classi) , continua ad esistere e non perde il suo significato, quindi non può avere valore null. Mentre la relazione di Composizione, è una relazione simile a HAS-A, rappresentata da PART-OF ,ma in questo caso con la perdita delle classi 'usate' anche la classe contentente delle altre perde il suo significato,quindi può avere il valore null.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4380,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4463,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4625,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4295,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5857,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nell'aggregazione il lifecycle delle due classi è differente, quindi una può operare mentre l'altra non è attiva. Al contrario, si parla di composizione quando una classe dipende strettamente dall'altra per il suo corretto utilizzo (es. classe fondamenta e classe edificio).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4378,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4462,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4293,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4624,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5451,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è fra linguaggi \"object-based\" e \"object-oriented\"? ",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Object"
            },
            {
              "keyword": "linguaggi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5790,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 829,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La differenza tra il linguaggio objected-oriented e l'objected-based è che nel secondo non vi sono i concetti di polimorfismo ed ereditarietà",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4607,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4194,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5832,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Alcuni linguaggi vengono definiti object-based poiché possiedono alcune caratteristiche\r\ndei linguaggi object-oriented, ma differiscono per degli aspetti fondamentali. Per esempio,\r\ni linguaggi object-based (come Javascript) non hanno il meccanismo l'ereditarietà e \r\nil polimorfismo, a differenza di altri linguaggi (come C++, Java etc.) object-oriented.   ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4610,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4196,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5787,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un linguaggio \"object-based\" è in un certo senso una versione limitata di quello \"object-oriented\", cioè si ha una o più delle seguenti restrizioni:\r\n-manca il polimorfismo;\r\n-manca l'ereditarietà (almeno non è presente per forza);\r\n-non tutto è un oggetto (nella object-oriented tutto, anche i tipi basilari sono oggetti).\r\nAd esempio Javascript è object-based, Java è object-oriented.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4193,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4608,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5873,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In un linguaggio ?object-based? è presente il concetto di oggetto (non di classe), caratterizzato da un meccanismo clonazione per la creazione di nuovi oggetti, ma senza una struttura statica predefinita. Mentre un linguaggio ?object-oriented? è definito tale quando permette di implementare incapsulamento, ereditarietà e polimorfismo usando la sintassi nativa del linguaggio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4192,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4606,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5868,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 838,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La differenza essenziale tra questi due tipi di linguaggi è che il primo non ha l'ereditarietà (cioè la possibilità di estendere una classe con delle classi figlie che ne riutilizzano parte del codice, senza doverlo riscrivere tutto), mentre il secondo sì.  \r\nJava è un linguaggio object-oriented,  mentre ad esempio JavaScript è object-based. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4195,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4609,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5478,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Enunciare il Principio di Sostituzione di Liskov e spiegare se l'applicazione \r\ndi esso possa provocare dei potenziali 'undefined behavior' all'interno di un programma.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "liskov"
            },
            {
              "keyword": " polimorfismo"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5537,
          "asker": {
            "courseId": 100,
            "askerId": 745,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che offre l'ereditarietà nella programmazione ad oggetti? Che cosa si intende con i termini overloading e overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5495,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano l'ereditarietà e il polimorfismo? Quando si parla di Overloading e Overriding? Se è possibile fare un esempio.  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " Polimorphysm"
            },
            {
              "keyword": " Overloading"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5535,
          "asker": {
            "courseId": 100,
            "askerId": 897,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa fa riferimento il binding dinamico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " binding dinamico"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5483,
          "asker": {
            "courseId": 100,
            "askerId": 848,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi dell'ereditarietà in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5452,
          "asker": {
            "courseId": 100,
            "askerId": 850,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "UML: qual'e la differenza tra aggregation (has-a) e composition (part of)? In quali casi puo esserci ambiguita?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " aggregation"
            },
            {
              "keyword": " compositiin"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5472,
          "asker": {
            "courseId": 100,
            "askerId": 859,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi il concetto di ereditarietà e in cosa consiste la relazione is-a",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5538,
          "asker": {
            "courseId": 100,
            "askerId": 759,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i benifici del polimorfismo della programmazione ad oggetti ?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " programmazione ad oggetti"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5803,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 852,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il vantaggio nella programmazione ad oggetti sta nel fatto di creare codice utilizzabile per diverse situazioni.\r\nSi crea un' astrazione maggiore sul codice cosi da poter rappresentare, mediante oggetti, più casi che si possono presentare al'interno dello stesso programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4403,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4284,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4352,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4148,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5810,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il polimorfismo permette di creare una struttura gerarchica nel codice (UML tanto per capirci) dove delle sottoclassi estenderanno la struttura di una classe padre creando una gerarchia tra classi.\r\nIl polimorfismo (tramite l'ereditarietà) ci permette di scrivere meno codice e avere un sistema più facilmente adattabile a degli aggiornamenti/modifiche poiché basterà cambiare una singola classe, crearne di nuove o integrare nuove classi estendendo quel che già abbiamo.\r\nQuindi, ricapitolando, i benefici del polimorfismo sono: \r\n+ Scrivere poco codice\r\n+ Struttura molto più forte (se pensata in maniera corretta)\r\n+ Rapida adattabilità a nuove situazioni (riciclo del codice delle classi)\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4354,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4147,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4286,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4402,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5895,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Il grande vantaggio di polimorfismo è la libertà, ovvero il polimorfismo permette al programma di fare uso di oggetti che espongono una stessa interfaccia, ma implementazioni diverse. Es:padre-Figura,figli-Cerchio e Triangolo,Triangolo e Cerchio sono sottoclassi di figura è possono essere instanziati come tale(Figura uno=new Triangolo(); non vale il contrario!).Per quanto riguarda le funzioni,Java mantiene traccia della classe effettiva di un dato oggetto e seleziona sempre il metodo più specifico anche se la variabile che lo contiene appartiene ad una classe più generica.\r\nRiassumendo il codice diventa più flessibile e più soggetto ad astrazione. Basti pensare che ogni oggetto all'interno del codice può essere riferito come object(classe object è padre di tutte le altre classi),comodo no? \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4353,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4146,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4285,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4401,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5768,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Il polimorfismo permette l'associazione tra classe padre e classe figlio, rendendo possibile la dichiarazione di variabile solo in modalita padre e creando l'oggetto in modalita padre o figlio in base  a quello che necessita il programma.bisogna stare attenti pero al tipo di binding che usa il linguaggio di programmazione utilizzato. E richiesto infatti il binding dinamico affinche si utilizzino le funzioni del padre e/o del figlio in base a come e stata creata la variabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4351,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4283,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4149,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4400,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5536,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In ambito UML, che cosa si intende per \"Aggregation\" e per \"Composition\". Esibire un esempio per ciascuno.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " Diagramms"
            },
            {
              "keyword": " Relations"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5491,
          "asker": {
            "courseId": 100,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consistono l'overloading e l'overriding? Quali sono le differenze tra i due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "O"
            },
            {
              "keyword": "O"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5473,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra l'aggregazione (has-a) e la composizione (part-of)? \r\n\r\nA lezione è stato citato come esempio il rapporto ambiguo tra Car e Wheel: fare un esempio di composizione e aggregazione con questi due elementi e mostrare che, al variare del contesto, può variare anche il loro rapporto . ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Aggregazione"
            },
            {
              "keyword": " composizione"
            },
            {
              "keyword": " part-of"
            },
            {
              "keyword": " has-a"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5517,
          "asker": {
            "courseId": 100,
            "askerId": 749,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra \"has-a\"(Aggregazione) e \"part-of\"(Composizione)?\r\nE' possibile che a seconda del contesto si possa utilizzare una o l'altra per due oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " composizione"
            },
            {
              "keyword": " aggregazione"
            },
            {
              "keyword": " uml"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5544,
          "asker": {
            "courseId": 100,
            "askerId": 815,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega il concetto legato ad \"abstract\".",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5489,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il comando try-catch-finally? Quando deve essere utilizzato?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " eccezioni"
            },
            {
              "keyword": " try-catch-finally"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5854,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 815,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il comando try-catch-finally viene utilizzato nei casi in cui c'è la necessità di \"contenere\" una certa eccezione.\r\n\r\nIl comando si compone di 3 keywords le quali identificano altrettanti blocchi di istruzioni.\r\nTry: indica il blocco da \"provare\", ovvero una serie di istruzioni di cui verrà controllata la correttezza (ad esempio concordanza tra tipi).\r\nCatch: indica il blocco delle \"eccezioni\", ossia nel caso in cui si sono riscontrate delle inesattezze all'interno del blocco \"try\" (e quindi delle \"Exception\") quest'ultime vengono assegnate ad una certa variabile e di conseguenza vengono impartite ulteriori istruzioni specifiche.\r\nFinally: indica il blocco delle istruzioni impartite in qualsiasi caso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4142,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4243,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4404,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5843,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 853,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il comando try-catch-finally viene usato per gestire le eccezioni generate durante l'esecuzione di un programma. Il blocco try contiene un insieme di istruzioni che potrebbero generare eccezioni, se si verifica un'eccezione la gestione passa al blocco catch (è possibile avere più blocchi catch). La finally è solitamente usata per garantire la coerenza dello stato degli oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4405,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4242,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4144,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5762,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Consente di gestire alcuni o tutti i possibili errori che possono verificarsi in un determinato blocco di codice in esecuzione.\r\nSe si prevede il verificarsi di una determinata eccezione nel corso di una particolare sezione di codice, inserire il codice in un blocco Try e utilizzare un blocco Catch per mantenere il controllo e gestire l'eccezione nel caso in cui si verifichi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4141,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4407,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4241,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5840,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il comando try-catch-finally si utilizza quando la chiamata di un metodo può lanciare un'eccezione, ossia quando potenzialmente possono verificarsi situazioni di errore. Per catturare un'eccezione bisogna necessariamente invocare il metodo all'interno di un blocco try. Dopaver completato o il blocco try ci devono essere uno o più blocchi catch, ognuno dei quali contiene le istruzioni da eseguire  per gestire un particolare tipo di eccezione generata nel blocco try. Se nel blocco try viene lanciata un'eccezione che non viene catturata da nessun blocco catch, allora il metodo termina l'esecuzione e tale eccezione viene \"passata\" al metodo chiamante. \r\nLe istruzioni contenute nel blocco finally vengono eseguite in ogni caso dopo aver completato tutte le operazioni del try, anche se è stata lanciata un'eccezione ( ad esempio il blocco finally può contenere delle istruzioni che chiudono dei files oppure rilasciano delle risorse).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4143,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4244,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4408,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5855,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Se una chiamata di un metodo può generare un'eccezione, possiamo racchiuderla in un blocco try, seguito da uno o più blocchi catch contenenti le istruzioni da eseguire se l'eccezione viene lanciata.\r\n\r\nIl funzionamento avviene in questo modo:\r\n-Si eseguono le istruzioni del blocco try\r\n-Se l'esecuzione termina senza fallimenti, si eseguono le eventuali istruzioni finally e si termina\r\n-Altrimenti se un'istruzione try lancia un'eccezione ecc, si cerca il primo blocco catch tale che ecc sia l'istanza di entrata nel blocco: \r\n--se questo esiste lo si esegue e infine si eseguono le eventuali istruzioni finally.\r\n--se invece ecc non è istanza in nessuna entrata di un blocco, allora vengono comunque eseguite le eventuali istruzioni finally e l'eccezione viene passata al chiamante.\r\n\r\nE' importante considerare che le istruzioni finally vengono sempre eseguite, inoltre i costrutti try-catch-finally possono essere annidati a piacere\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4240,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4406,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4145,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5500,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'UML in Java? Spiegane l'utilizzo, l'utilità e in che campi di Java viene applicato.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " utilizzi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5432,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il binding in java, ed in c++? Cosa significa inoltre polimorfismo e come si può implementare questo in c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": "dinamico"
            },
            {
              "keyword": "statico"
            },
            {
              "keyword": "polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5490,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono l'overriding e l'overloading? Da cos'è formata la signature di un metodo?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 24,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": " overloading"
            },
            {
              "keyword": " firma"
            },
            {
              "keyword": " signature"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5885,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 849,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'overriding è la dichiarazione, in una sottoclasse, di metodi o variabili già presenti nella superclasse. Istanziato il relativo oggetto, in caso di ambiguità, esso accede prima di tutto a metodi e variabili dello scope più ristretto, ovvero della sottoclasse, e solo dopo a quelli appartenenti alle classi più alte nella catena dell'ereditarietà.\r\n\r\nL'overloading è la dichiarazione di funzioni omonime con firma diversa. La scelta della funzione dipende dalla quantità e dal tipo dei parametri passati.\r\n\r\nLa firma (signature) di un metodo è l'insieme del nome della funzione, del numero e del tipo dei parametri formali. Questa identifica univocamente il metodo, anche se ne esistesse un altro omonimo. Il tipo di dato ritornato non è considerato, in quanto non incluso nella chiamata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4439,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4584,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4339,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4182,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5795,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 100,
                "courseFinalScore": 16
              },
              "answerText": "Override significa ridefinire il funzionamento di una funzione già esistente.\r\nSuccede per esempio quando si estende una classe e si eredita un metodo che non deve comportarsi come quello definito nella classe madre, o quando si implementa una interfaccia.\r\n\r\nOverload significa assegnare, sotto uno stesso nome di funzione, diverse funzioni che si differenziano per il tipo di valore di ritorno e/o la lista di parametri (tipo, ordine e numero).\r\nPer esempio, se faccio una funzione che somma i parametri e restituisce il risultato: int somma(int, int), int somma(int, int, int), double somma(double, double), ...\r\n\r\nLa signature di un metodo sono le sue caratteristiche, ovvero il tipo di ritorno, il nome della funzione, la lista di parametri (tipo, ordine e numero).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4442,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4588,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4183,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4338,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5866,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 863,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "La signature(=firma) di un metodo è formata dal nome e dal numero e tipo dei parametri formali.\r\nL'overloading consiste nel creare un metodo con stesso nome e diversi parametri(cambiando così la firma).\r\nL'overriding consiste nella redefinizione di un metodo in una sottoclasse della classe originaria, mantenendo la stessa firma. Gli oggetti della sottoclasse utilizeranno quindi il nuovo metodo ridefinito invece di quello originalmente presente nella superclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4441,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4585,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4187,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4340,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5844,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'override consiste nello scrivere una nuova definizione di un metodo ereditato dalla classe padre. Quando si chiama quel metodo all'interno della classe figlia, verrà eseguita quella ridefinizione del metodo, non il metodo padre.\r\nL'overloading consiste nello scrivere più metodi che hanno lo stesso nome ma parametri diversi. \r\nLa signature di un metodo è la sua \"firma\", che identifica quel metodo in modo univoco. In Java è composta dal nome del metodo, e dal numero e dal tipo dei suoi parametri.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4341,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4440,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4587,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4184,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5863,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Parliamo di OVERLOADING quando abbiamo la coesistenza di due funzioni con ugual nome e diversa firm. Es: muovi(int dx, int sx) muovi(int dx, int sx, int zd).\r\nAbbiamo, invece, un caso di OVERRIDING nel momento in cui in una extends di una classe in una sua sottoclasse vi è la ridefinizione di una funzione(mantenendo la firma immutata). Es: estrai() in Coda e Pila.\r\nLa SIGNATURE o FIRMA di un metodo è formata dal suo nome e i suoi parametri.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4185,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4443,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4337,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4586,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5881,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 769,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per overload si intende la riscrittura di più metodi identificati dallo stesso nome che però hanno in ingresso parametri di tipo e/o numero diverso.\r\nCon il termine override invece si intende una vera e propria riscrittura di un certo metodo di una classe che abbiamo ereditato. Dunque, possiamo affermare che l'override implica l'ereditarietà. \r\nLa firma di un metodo (in inglese signature) rappresenta un insieme di informazioni che identificano univocamente il metodo stesso fra quelli della sua classe di appartenenza. Le informazioni presenti costituiscono generalmente: il tipo ed il numero dei suoi parametri ed il tipo del valore di ritorno (il valore che restituirà il metodo).  La firma ha anche l'ulteriore funzione di costituire l'insieme minimo di informazioni necessarie per utilizzare correttamente il metodo, ovvero per richiamarlo o invocarlo in modo sintatticamente e semanticamente coerente con la sua definizione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4342,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4589,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4444,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4186,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5540,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per aggregazione e composizione? Dare degli esempi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Aggregazione"
            },
            {
              "keyword": "composizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5436,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa é il polimorfismo in java? Questa caratteristica cosa permette di fare? Fare un esempio di polimorfismo( tipo quello visto a lezione).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "Java "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5454,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende, in java, con il termine \"polimorfismo\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": "java"
            },
            {
              "keyword": "class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5494,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una classe abstract e quali sono le sue caratteristiche? ",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 25,
          "totalRelevanceLevel": 26,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5783,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Una classe abstract è una classe che viene definita per fungere da schema, base, per altre classi che successivamente, ereditando da essa, estenderanno la sua interfaccia.\r\nUna caratteristica importante delle classi abstract è che non può essere instanziata, quindi esiste per essere ereditata. \r\nSolo le classi abstract possono definire metodi abstract. Tali metodi poi dovranno essere obbligatoriamente definiti nelle classi che ereditano dalla classe madre abstract.\r\nL'utilizzo principale di tali classi è creare un livello di astrazione tale da poter rendere possibili il polimorfismo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4206,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4152,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4387,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4548,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5815,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "Una classe che contiene almeno un metodo abstract deve essere anch'essa abstract. La keyword abstract indica un metodo non richiamabile, perché non inizializzato. Esso serve solo per specificare l'esistenza di un metodo che raggruppa altre classi che realmente poi userò. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4150,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4544,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4205,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4384,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5871,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe abstract è tipo di classe caratterizzata dal fatto di non essere implementata completamente. Non può essere istanziata, viene però utilizzata come classe generatrice per definire diverse classi derivate che ne ereditano i metodi. \r\n\r\nJava considera una classe astratta anche se contiene un solo metodo astratto e pertanto deve essere dichiarata come tale (abstract) e non può essere istanziata direttamente.\r\n\r\nE' opportuno sapere che in Java una classe derivata, prima di essere istanziata, deve implementare tutti i metodi astratti ereditati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4154,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4201,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4385,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4545,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5867,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Una classe astratta è una classe con solo metodi astratti (privi del proprio blocco di codice). Una classe dichiarata come astratta non può essere inizzializzata. Consideriamo la seguente classe astratta:\r\npublic abstract class Strumento{\r\n   public String nome;\r\n   public abstract void suona();\r\n}\r\nQuesta classe ha senso se inserita in un sistema in cui l'oggetto Strumento è troppo generico per definire un nuovo tipo di dato da istanziare.\r\nLe sottoclassi che estendono la classe astratta Stumento devono, tramite l'override, ridefinire il metodo astratto suona() con il relativo blocco o essere una classe astratta.\r\nEsempio:\r\npublic class Chitarra extends Strumento{\r\n   public void suona(){ //impementa il metodo per la chitarra }\r\n}\r\npublic abstract class StrumentoAFiato extend Strumento{\r\n   //Classe di nuovo astratta che eredita il metodo ancora astratto suona()\r\n}\r\nIl vantaggio che offre una classe astratta è che \"obbliga\" le sottoclassi ad implementare un comportamento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4203,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4388,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4546,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4155,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5839,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 762,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe astratta è un tipo particolare di classe che per essere Utah lizzata deve essere obbligatoriamente ereditata.  Al suo interno oltre alle variabili, metodi e proprietà è possibile dichiarare un'altra serie di metodi detti metodi e proprietà astratti che devono essere obbligatoriamente implementati dalle classi che ereditano essa. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4543,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4389,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4151,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4202,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5853,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per utilizzare la caratteristica di ereditarietà dei linguaggi orientati agli oggetti, è necessario creare un albero di classi. Le classi base possono rappresentare oggetti non definiti. Se la classe contiene un metodo non implementabile o si vuole evitare che vengano creati oggetti di quella specifica classe, essa viene dichiarata abstract (astratta). Queste classi non possono essere istanziate e tutte le classi derivante devono definire i metodi astratti della classe di base, oppure essere classi astratte a loro volta. Vengono quindi utilizzate per definire i metodi e le variabili necessarie nelle classi derivante (l'interfaccia). Le classi astratte possono avere da nessuno a tutti i metodi dichiarati abstract. Per esempio la classe abstract Indumento ha metodo indossa() abstract, che sarà definito nelle classi derivate Pantalone, Camicia, Gonna. La classe abstract Segnale ha metodi attiva() e disattiva() abstract, che saranno definiti nelle classi SegnaleAcustico, SegnaleVisivo. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4547,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4204,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4153,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4386,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5474,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è una firma. E spiega cos'è lo static binding nella pila e il dynamic binding nelle code.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " new coda o new pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5509,
          "asker": {
            "courseId": 100,
            "askerId": 878,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "è possibile forzare l'utilizzo del binding statico in java, allo scopo di migliorarne le prestazioni? ed invece utilizzare quello dinamico in c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " binding"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5530,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Overriding e Overloading di una funzione? Quali sono i vantaggi che garantiscono l'uno e l'altro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5518,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa significa definire un metodo \"abstract\" in Java? \r\nÈ equivalente a definire un metodo \"virtual\"  in C++? ",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": "  virtual"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5766,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Partiamo da un presupposto: in Java possiamo parlare di binding dinamico, mentre in C++ di binding statico. Dichiarare un metodo \"abstract\" in Java significa dichiarare un metodo senza implementazione al suo interno, per un semplice motivo: quel metodo DEVE essere subclassato ed implementato all'interno di ogni sottoclasse, in modo da essere chiamato nello stesso modo, ma utilizzato in maniera differente. \r\nAnche il metodo \"virtual\" del C++ non prende nè restituisce alcun valore ed è in sostanza molto simile al metodo \"abstract\" di Java.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4268,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4314,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4480,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4533,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5786,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Un metodo abstract in java e' un metodo che e' definito nella classe ma manca di implementazione, quindi dovra' necessariamente essere ridefinito nella classe figlia tramite overriding. E' importante sapere che una classe che contiene anche un solo metodo abstract e' anche essa una classe che non puo' essere istanziata direttamente e quindi dovra', nella definizione di classe, contenere la keywork abstract, ad esempio nel seguente modo: \r\npublic abstract class Forma(){   .........}\r\npoiche' al suo interno esiste una particolare funzione: \r\npublic abstract void disegna();\r\nIn c++ l'efficienza e' posta al primo posto , infatti data una funzione definita in una classe e nella sua classe figlia, la funzione chiamata sara' quella data dal tipo di dato dell'oggetto e non dal tipo di oggetto istanziato.\r\n\r\nAnimale a= new Cane();\r\na.verso(); (funzione di Animale e non di Cane)\r\n\r\nIntroducendo la parola virtual durante la dichiarazione della funzione e' possibile utilizzare il polimorfismo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4316,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4270,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4481,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4537,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5779,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Solitamente un metodo abstract in java viene definita su una \"superclasse\" e serve per \"implementare\" il polimorfismo. Questo metodo viene solo dichiarato nella superclasse per dire che tale metodo esiste, ma verrà implementato in maniera specifica nelle \"sottoclassi\" perché non esiste una sola versione di tale metodo applicabile alle classi figlie.\r\nVirtual in c++ ha la stessa funzione di abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4272,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4484,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4318,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4536,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5759,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Dichiarare un metodo abstract significa creare conseguentemente una classe abstract, ossia non istanziabile, che sarà poi parent class di un altra o altre subclasses; inoltre il fatto di avere un determinato metodo abstract viene sfruttato nel classificare le sottoclassi: se esse non hanno il metodo che nella classe parent è dichiarato abstract non possono essere legate alla parent dalla IS-A. In c++ la keyword virtual viene utilizzata per segnalare al compilatore il controllo del tipo a run-Time dato che il linguaggio c a differenza di Java ha lo static binding come controllo di dafault.(es. se io creo un oggetto Pila p=new Pila()/Coda() dipendentemente da un if o switch(supponendo che coda extends pila) il compilatore saprà in quale blocco trovare il metodo p.estrai()).In realtà virtual ha un significato leggermente diverso rispetto ab abstract: in c mi dice: questo metodo può andare bene per la child class, ma può essere sovrascritto in caso ce ne sia bisogno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4269,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4482,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4535,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4315,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5789,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Definire un metodo abstract in una classe significa obbligare le sottoclassi di questa ad implementare tale metodo. Un metodo abstract è una funzione \"virtuale\", senza implementazione nella classe stessa. Se c'è anche solo un metodo abstract in una classe anche quest'ultima deve essere abstract. Virtual in C++ è simile ad abstract di Java ma non uguale: la virtual può essere implementata nella classe di dichiarazione, come si diceva prima, con la abstract ciò non è possibile. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4271,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4317,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4483,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4534,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5524,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Posso istanziare una classe che contiene la parola ABSTRACT in uno dei suoi metodi? Quali vantaggi mi fornisce l'utilizzo di questa keyword?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": "utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5431,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per polimorfismo? Perche' e' vantaggioso il suo utilizzo? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5471,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è opportuno usare il comando System.runFinalization() e il System.gc()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " distruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5485,
          "asker": {
            "courseId": 100,
            "askerId": 896,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "1)Si spieghi in breve il principio di sostituzione di Liskov.\r\n2)Se ho una classe Coda che eredita dalla classe Pila, con i metodi Inserisci ed Estrai, che rispettivamente immettono/stampano un elemento singolo alla volta, si scriva l'output del seguente segmento di codice in C++:\r\nPila s = new Coda (); s.Inserisci(2); s.Inserisci(3); s.Estrai;\r\n3)Se l'intenzione era di implementare una coda, che problema c'è nel precedente codice C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Liskov"
            },
            {
              "keyword": " sostituzione"
            },
            {
              "keyword": " polimorfismo"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5501,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In UML abbiamo visto che all'interno della class A possimo trovare 'public void setS(int)' e 'public int getS()' sono delle funzioni già predefinite? E a cosa servono? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "set"
            },
            {
              "keyword": " get"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5528,
          "asker": {
            "courseId": 100,
            "askerId": 434,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra overriding e overloading?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5466,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per poliformismo? Cosa differenzia il polimorfismo di Java (compilazione RUN-TIME) da quello di C/C++(compilazione COMPILE TIME)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Poliformismo"
            },
            {
              "keyword": " Static binding"
            },
            {
              "keyword": " Dynamic binding"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5496,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "I packages vengono utilizzati solo per aumentare la leggibilità e l'ordine del codice raggruppando varie classi e sottoclassi o svolgono anche una qualche funzione utile allo sviluppo di un programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Packages "
            },
            {
              "keyword": " funzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5433,
          "asker": {
            "courseId": 100,
            "askerId": 862,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si presentano le classi abstract e i metodi virtuali in relazione al overriding e overloading. Specificare le differenze tra abstract e virtual e le differenze tra override e overload.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": "virtual"
            },
            {
              "keyword": " overload"
            },
            {
              "keyword": "override"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5481,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "In UML \"aggregation\" e \"composition\" sono due tipi di relazioni tra classi. In che cosa sono simili e in cosa differiscono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " aggregation"
            },
            {
              "keyword": " composition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5523,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Che significato ha la keyword \"abstract\"? In quali casi è utile farne uso?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 19,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5894,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La keyword abstract indica un metodo o una classe astratta che dimostra la sua utilità quando non è necessario per il programmatore l'utilizzo di oggetti ma non esclude l'implementazione di tutti i suoi metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4559,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4347,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4530,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4551,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5826,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "La keyword abstract serve per dichiarare un metodo in una superclasse che deve essere per forza re-implementato da una sottoclasse. Un metodo astratto deve essere contenuto in una classe astratta. E' utile utilizzare la keyword abstract quanto si sa che all'interno di alcune sottoclassi deve essere presente un metodo ma non si sa come esso deve essere implementato. L'esempio fatto a lezione era il metodo disegna() che era stato implementato abstract nella classe Forma in quanto il metodo disegna doveva essere presente anche nelle classi Cerchio e Triangolo ma non si poteva sapere a priori come implementarlo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4532,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4561,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4549,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4348,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5806,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "\"Abstract\" può essere riferito ad una classe o ad un metodo; una classe abstract non può essere istanziata ma può essere subclassata, mentre un metodo abstract viene dichiarato senza implementazione. Se una classe contiene metodi abstract allora tale classe è abstract e una sua sottoclasse contiene l'implementazione di tutti i metodi abstract della superclasse; se non è così, allora anche tale sottoclasse deve essere abstract.\r\nL'utilizzo di classi e metodi abstract è comodo nel caso in cui diverse classi abbiano lo stesso metodo ma lo implementino in modo diverso. In tal caso si potrà avere una superclasse abstract che contiene la dichiarazione del metodo e ogni sottoclasse estenderà la superclasse abstract implementando tale metodo tramite overriding. \r\nAd esempio potremmo avere un metodo abstract pianoDiStudi() nella classe abstract Studente e ogni sottoclasse implementerà tale metodo in modo specifico. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4350,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4529,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4550,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4558,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5846,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 917,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "la keyword \"abstract\" serve per dichiarare delle classi abstract ovvero delle classi che contengono delle funzioni dichiarate anch'esse abstract che non vengono definite al interno della classe ma vengono definite al interno delle sottoclassi di essa.\r\nle classi abstract non possono essere istanziate ma sono molto utili per l'utilizzo del polimorfismo perché così facendo posso scrivere un programma usando solo il tipo della classe abstract e associarci uno qualunque degli oggetti generati dalle sottoclassi senza nessun problema.\r\nciò garantisce una forte riutilizzabilità del codice e una maggiore flessibilità nella scrittura del programma a discapito di maggiori costi di esecuzione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4349,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4560,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4552,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4531,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5469,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Come aiuta il programmatore l'uso di una UML ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5463,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "spiega cosa è la parte grafica in java",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " grafica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5532,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 160,
            "taskName": "Ask A Question"
          },
          "questionText": "Il garbage collector, seppur chiamato esplicitamente dal programmatore potrebbe non venire eseguito. Per quale motivo? Come può essere risolto questo problema? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage collector"
            },
            {
              "keyword": " problema"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5875,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 831,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il gc, seppur chiamato dal programmatore, potrebbe non essere effettivamente eseguito nel caso in cui, per esempio, la chiamata al gc sia l'ultima del programma.\r\nes. class Program{\r\n.......\r\nSystem.gc();\r\nSystem.exit(1);\r\n}\r\nIn tal caso l'esecuzione del gc sarebbe inutile dato che sarà compito del SO deallocare la memoria riservata al programma in questione.\r\nQuesto problema si può risolvere chiamando la System.runFinalization() subito dopo la System.gc();\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4266,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4365,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4097,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4225,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4397,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5850,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 835,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il garbage collector interviene solo quando serve memoria; può essere chiamato dal programmatore attraverso il System.gc, ma a volte non viene eseguito perchè non ritenuto necessario oppure perchè il programma termina prima. Questo problema può essere risolto chiamando il metodo System.runFinalization subito dopo aver chiamato il System.gc",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4098,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4264,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4223,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4363,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4398,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5848,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 756,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il garbage collector è una particolare classe che libera lo heap da tutti gli oggetti (non più utilizzati) allocati durante l'esecuzione del programma.\r\nSe il garbage collector viene invocato come ultima istruzione, questo non verrá fatto partire perchè comunque il programma terminerá all'istruzione successiva; quindi nessuno degli oggetti allocati durante l'esecuzione del programma verrà più utilizzato. \r\nSe voglio far partire il garbage collector come ultima istruzione, per essere sicuro che tutti i dati vengano effettivamente cancelati dalla memoria, devo chiamare prima la funzione \"System.runFinalization()\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4395,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4263,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4096,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4222,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4362,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5801,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il programmatore ha la possibilità di richiamare esplicitamente il garbage collector, tramite il metodo \"System.gc()\"; ciò potrebbe però non avvenire se il programma è destinato a terminare. Ciò potrebbe comportare dei problemi, perché in tal caso il metodo finalize() degli oggetti presenti in memoria non viene chiamato. Se si ha assoluta necessità che esso venga eseguito su tutti gli oggetti prima della fine del programma, è necessario far precedere la chiamata al garbage collector dalla chiamata del metodo \"System.runFinalization()\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4224,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4366,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4267,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4100,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4396,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5865,
              "task": {
                "taskId": 161,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il  garbage collector potrebbe non essere eseguito in quanto,essendo chiamato alla fine del programma,nulla assicurerebbe al programmatore che non vi sia nel codice un'istruzione che termina anticipatamente l'esecuzione del programma.Per ovviare a ciò si utilizza il comando Run finalization il quale obbliga il compilatore ad eseguire il comando ad esso associato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4364,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4399,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4099,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4221,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4265,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 161,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "lectureId": 64,
      "lectureTitle": "Lecture 19 - Animation",
      "questions": [
        {
          "questionId": 6056,
          "asker": {
            "courseId": 100,
            "askerId": 850,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa per comporre un path con il metodo drawPath()? Spiega brevemente...",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Path"
            },
            {
              "keyword": " composizione"
            },
            {
              "keyword": " spiega"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6007,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare il concetto di Event Chain, possibilmente fornendo un piccolo esempio",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventChain "
            },
            {
              "keyword": " concetto "
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6028,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una KeyFrame? Spiegare ponendo almeno un esempio di utilizzo visto a lezione",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "keyframe"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6038,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le Transitions in JavaFX? Elenca i principali tipi di Transitions.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " Transition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6095,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un keyframe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " animation "
            },
            {
              "keyword": " keyframe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6094,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è e a cosa serve la classe KeyFrame.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javaFX"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6042,
          "asker": {
            "courseId": 100,
            "askerId": 788,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Un oggetto di tipo Timeline permette di definire l'animazione di un oggetto tramite dei \"fotogrammi importanti\". Descrivere il funzionamento della classe e elencare quali altre classi sono coinvolte.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " keyframe"
            },
            {
              "keyword": " keyvalue"
            },
            {
              "keyword": " duration"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6099,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Illustrare con due esempi il funzionamento della classe timeline e in particolare delle keyFrames evidenziando i due possibili approcci nell'implementazione di un'animazione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " keyframes"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6043,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile andare a definire il movimento di un oggetto passando solo il punto di partenza e il punto di arrivo? E se volessi complicare il percorso da esso compiuto, per esempio facendogli percorrere una linea spezzata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " percorso"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6092,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale ruolo svolgono i KeyFrame all'interno di una Timeline? Si dia un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": "KeyFrame"
            },
            {
              "keyword": " Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6011,
          "asker": {
            "courseId": 100,
            "askerId": 844,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le classi Keyframe e Timeline? C'è una qualche relazione di ereditarierà tra le due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Keyframe"
            },
            {
              "keyword": "Timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6021,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile cambiare le coordinate di un oggetto posizionato da un Pane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gettranslate"
            },
            {
              "keyword": "coordinate"
            },
            {
              "keyword": "timeline"
            },
            {
              "keyword": "transition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6068,
          "asker": {
            "courseId": 100,
            "askerId": 814,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i \"KeyFrame\" e come vengono implementati all'interno di una \"Timeline\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": "Timeline"
            },
            {
              "keyword": "KeyFrame"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6008,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una timeline? A cosa serve?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 24,
          "totalRelevanceLevel": 24,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6369,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "La Timeline è una classe di java fx che lavora in \"simbiosi\" con la classe keyframe, entrambe queste classi servono a realizzare le animazioni. Possiamo dire che nello specifico, la classe Timeline indica la \"vita\" dell'animazione, infatti con il metodo getKeyFrames() individua i frame che compongono l'animazione e in seguito con il metodo play() la fa partire.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6691,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7077,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7126,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7050,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6932,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6377,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La timeline può essere usata per definire un'animazione di qualsiasi oggetto grafico derivato da JavaFX.E' definita da almeno 1 keyframe,inoltre processa individualmente,sequenzialmente e ordinatamente ogni keyframe.La timeline processa keyframe individuali in occasione(o dopo che sono trascorsi)determinati intervalli di tempo.Non garantisce la tempistica del keyframe quando questo è processato: ovvero in caso di rallentamenti del sistema l'animazione potrà rallentare,ma verrà sempre riprodotta interamente seppur con ritardi.Un'animazione è guidata dalle sue proprietà associate,come dimenzione,locazione,colore,ecc.La Timeline provvede ad aggiornare propriamente il valore che riguarda la progressione del tempo (dell'animazione).Nel keyframe di un'animazione,la transizione animata della scena è dichiarata dallo \"start\" e finisce con l'ultimo keyframe della sequenza in un determinato momento.Il sistema può generare automaticamente l'animazione: la può stoppare,fermare, far ripartire,anch",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6689,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7048,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7128,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6930,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7074,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6390,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Un'animazione possiede alcune proprietà modificabili come la dimensione, la posizione, il colore ecc. Un oggetto di tipo Timeline offre la possibilità di cambiare e aggiornare in ogni singolo fotogramma o arco di tempo desiderato tutte queste proprietà per creare l'animazione desiderata. Si può anche decidere di fermarla, metterla in pausa, riprenderla e settare il numero di volte che deve essere eseguita anche al contrario. Per esempio il codice per spostare un rettangolo dalla posizione x di 100 a 300 in 500 ms è:\r\nRectangle rectBasicTimeline = new Rectangle(100, 50, 100, 50);\r\nTimeline timeline = new Timeline();\r\ntimeline.setCycleCount(Timeline.INDEFINITE); //il ciclo continua all'infinito\r\ntimeline.setAutoReverse(true); //il rett. tornerà indietro\r\nKeyValue kv = new KeyValue(rectBasicTimeline.xProperty(), 300); //setta la posizione di arrivo\r\nKeyFrame kf = new KeyFrame(Duration.millis(500), kv);\r\ntimeline.getKeyFrames().add(kf); //aggiunge il keyframe definito\r\ntimeline.play(); ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7045,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6931,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6690,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7075,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7127,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6396,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Timeline è una classe di java che eredita dalla classe Animation, ed é quindi un particolare tipo di animazione. Più precisamente è usata per manipolare proprietà di vari oggetti nel corso di un intervallo di tempo diviso in KeyFrame. Tali proprietà, definite in KeyFrame.Values, si evolvono in base alla loro durata. Se non è definito un KeyFrame per l'intervallo 0s, tale è automaticamente creato con le proprietà del target all'istante dell'inizio dell'animazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6688,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6929,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7124,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7046,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7079,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6399,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "E' Contenitore sequenziale di frame che verranno eseguiti in ordine secondo il timing dato alla timeline. La timeline è una sequenza che va programmata per far susseguire i frame coi tempi desiderati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6933,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6692,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7076,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7125,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7047,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6460,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Timeline in JavaFX è una sottoclasse di Animation. Viene utilizzata per definire una animazione in cui variano alcune proprietà di uno o più oggetti in un tempo definito. Essa è formata da una sequenza di KeyFrame. Ogni KeyFrame definisce l'insieme di proprietà che subiscono delle variazioni durante l'animazione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6928,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7049,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7078,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7123,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6687,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6055,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si utilizza una TimeLine? Enunciare come si compone.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6000,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa a cambiare le coordinate di un oggetto posizionato da un Pane? ",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "pane"
            },
            {
              "keyword": " coordinate"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6414,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 835,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per ottenere le coordinate di un oggetto posizionato da un Pane si usa getTranslateX() e getTransletY(). Per cambiarne la posizione basta inserire delle nuove coordinate con setTranslateX(double value) e setTranslateY(double value).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6808,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6661,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6831,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6739,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7113,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6382,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si utilizza il metodo relocate, ereditato dalla classe node. Si può anche usare translateX e translateY ma questo è più diretto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6809,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6660,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6740,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6832,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7112,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6416,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "E' possibile cambiare la posizione di qualsiasi Node posizione all'interno di un Pane utilizzando i metodi : .getLayoutX, .getTranslateX , .setTranslateX (I rispettivi esistono anche per la coordinata Y).\r\nI metodi get/set TranslateX/Y servono ad ottenere o modificare la proprietà translateX/Y; utilizzata per traslare il Node di una certa posizione X/Y.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7111,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6810,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6833,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6659,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6741,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6025,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestito il percorso che un oggetto deve fare in una finestra grafica? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": " graphics"
            },
            {
              "keyword": " path"
            },
            {
              "keyword": " percorso"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6044,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali transition? Descrivile brevemente.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Transition"
            },
            {
              "keyword": " animazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6081,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono Timeline e Transition? Quali sono le differenze tra i due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": " Transition"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6049,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cos'è e come è composta la 'Event Chain'? Quale funzione hanno Handler, Filter e Cutter?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": " EventChain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6097,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo il metodo getTranslateX() è definito final? Mostrare un esempio del suo utilizzo.",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": " getTranslateX"
            },
            {
              "keyword": " Layouts"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6421,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 773,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "GetTranslateX() e' definito final in quanto verra' calcolato la posizione finale e stabile del nodo con eventuali aggiustamenti da parte del getTranslateX(). Quindi e' possibile dichiarare questo metodo final perche' e' stabile e non modificabile; cioe' e' una classe completa che non necessita di specializzazioni o estensioni.\r\n\r\nball.setScaleX(scale+0.01);\r\n //ball.setCenterX(ball.getCenterX() + 2*dx);\r\n //ball.setLayoutX(ball.getLayoutX() + 2*dx);\r\n ball.setTranslateX(ball.getTranslateX() + 2*dx);\r\n ball.setTranslateY(ball.getTranslateY() + 1*dy); ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6771,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6668,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6873,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6799,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6408,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Il metodo getTranslateX() è un metodo che restituisce il valore che corrisponde alla transazione che l' oggetto ha subito sulla' asse delle x.\r\nPer eseguire il calcolo che permette di ottenere il valore il metodo somma il TraslateX con il layautX dove il layoutX rappresenta la posizione effettiva dell' oggetto sulla scene e Traslate x invece rappresenta la transizione che viene apportata all' oggetto sull' asse delle x . \r\nQuesta è una misurazione dinamica invece il LayoutX è statica.\r\nIl metodo per il imporre il TransateX è setTranslateX().\r\n\r\nEs: \r\nfinal Circle ball = new Circle(50, 50, 20);\r\nSystem.out.println(ball.getTranslateX());\r\nball.setTranslateX(ball.getTranslateX());\r\n\r\nIl metodo è stato dichiarato volutamente final perché è un metodo che funziona tramite un calcolo molto complicato e la modifica da parte dell' utente non sarebbe risulta semplice.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6772,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6874,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6669,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6800,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6427,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo getTranslateX(); è definito final in quanto questo metodo non deve essere modificato.  \r\n ball.setTranslateX(ball.getTranslateX() + 2*dx);\r\n ball.setTranslateY(ball.getTranslateY() + 1*dy); ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6872,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6667,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6770,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6798,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6381,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando un metodo è dichiarato final significa che non è modificabile da un ente esteriore(Esempio: Programmatore). Il metodo getTranslate() è dichiarato final in modo da non permettere al programmatore di effettuare un \"overrinding\" del metodo. Questo non implica che l'esisto del metodo non sia variabile; infatti, anche se il metodo non può essere modificato dall'esterno, il sistema può variarne l'esito. Un tipico utilizzo del metodo è :\r\n\r\nKeyFrame moveBall = new KeyFrame(Duration.seconds(frameDuration),\r\n  new EventHandler<ActionEvent>() {\r\n   public void handle(ActionEvent event) {\r\n     ball.setTranslateX(ball.getTranslateX() + 2*dx); \r\n     ball.setTranslateY(ball.getTranslateY() + 0*dy);\r\n  }\r\n});\r\n, che serve a cambiare la posizione di un oggetto, in questo caso di \"ball\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6871,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6769,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6797,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6666,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6459,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il metodo getTranslateX() al pari di getTranslateY() ritorna rispettivamente il valore di TranslateX e TranslateY di un nodo posizionato all'interno di un layout(come Pane).\r\nE' possibile chiamare il metodo direttamente da un nodo e da qualsiasi sua sottoclasse. Definendo getTranslateX() come final, non sara' possibile effettuarne l'override da parte delle sottoclassi garantendone cosi' il medesimo funzionamento su qualsiasi nodo esso venga chiamato. Nell'esempio della slide intitolata \" Animazione 1.2 v-1 \"\r\nsi puo' notare come l'oggetto \"ball\", che e' l'identificatore di una classe Circle  (sottoclasse di Shape e quindi di Node), eredita i metodi get/set Translate X/Y() di node;(codice)\r\n[...]ball.setTranslateX(ball.getTranslateX() + 2*dx);\r\nball.setTranslateY(ball.getTranslateY() + 0*dy);[...]\r\nQuesti metodi vengono invocati all'interno di un handle permettendo di modificare le coordinate del nodo ad ogni evento ottenendo cosi' uno spostamento del nodo ad ogni evento di [2x] e [0y].",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6665,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6796,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6870,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6768,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6454,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "il metodo getTranslateX è final per evitare di fare macelli con gli altri metodi di traslazione. È infatti necessario mantenere il principio che:\r\n\r\n\"The node's final translation will be computed as layoutX + translateX, where layoutX establishes the node's stable position and translateX optionally makes dynamic adjustments to that position.\"\r\n\r\nNiente esempio per augurare un buon esame a tutti coloro che hanno seguito questo corso di programmazione. Vi auguro il meglio, vi auguro di passare l'esame alla prima botta ma in fondo va bene anche la seconda o la terza o anche la quarta. L'importante è non rinunciare e non demoralizzarsi, ma continuare a impegnarsi e soprattutto ricordare che ciò che guida tutti quanti noi in questo percorso è la passione e la voglia di costruire qualcosa che tutto il mondo potrà apprezzare.\r\nBuona carriera accademica a tutti quanti!!!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6773,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6670,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6801,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6875,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6050,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze e i collegamenti tra le classi animation, timeline e transition?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 22,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " transition"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6436,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La principale differenza tra le classi timeline e transition è che usando transition bisogna impostare la durata dell'animazione (del ciclo) e definire la posizione del oggetto ad ogni istante (tramite precentuali sul tempo che scorre). Con la classe timeline (e l'utilizzo di dei keyframe) ci si può invece limitare a definire una posizione iniziale ed una finale e il precorso tra le due viene generato in automatico (anche con trame barocche). Volendo si possono usare le due classi in modo analogo le due classi, definendo anche con timeline tutte le posizioni intermedie.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6909,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6821,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7003,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6727,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6403,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'animazione in JavaFX può essere divisa in animazione timeline e transizioni. Questo capitolo fornisce esempi di ogni tipo di animazione. Timeline e transizione sono sottoclassi della classe javafx.animation.Animation. \r\nLe transizioni in JavaFX forniscono i mezzi per integrare le animazioni in una timeline interna e possono essere composte per creare più animazioni che vengono eseguite in parallelo o in sequenza. Una Timeline animation è guidata dalle sue proprietà associate, come la dimensione, la posizione e il colore ecc Timeline offre la possibilità di aggiornare i valori di proprietà lungo la progressione del tempo. JavaFX supporta l'animazione fotogramma chiave. Nell'animazione fotogramma chiave, le transizioni di stato animate della scena grafica sono dichiarati da inizio e fine istantanee dello stato della scena in determinati momenti. Il sistema può eseguire automaticamente l'animazione. Si può fermare, mettere in pausa, riprendere e riprendere un movimento quando richiesto",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6722,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6904,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6816,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7001,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6401,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe che gestisce le animazioni in generale in Java FX è la classe Animation.\r\nLe sottoclassi che utilizzeremo sono Transition e Timeline. Transition serve a definire un'animazione che opera su una proprietà di un dato oggetto. L'animazione si muove tra un valore massimo e un valore minimo secondo un andamento stabilito da un Interpolator che di default è lineare. L'interpolator stabilisce un output per un input di tempo da 0 a 1. TimeLine invece si basa su un'imitazione della struttura a fotogrammi cinematografica. Durante l'animazione vengono mostrate in sequenza le varie KeyFrame. Nei momenti non corrispondenti esattamente ad un KeyFrame è possibile specificare le azioni da intraprendere dai i KeyFrame che comprendono l'intervallo di tempo. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6820,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6726,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6908,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6999,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6417,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Innanzitutto Timeline e Transition sono (estendono) la classe astratta Animation che fornisce gli \"strumenti\" di base per gestire le animazioni (es. impostare n° e durata dei cicli, far partire e fermare l'animazione, ecc...).\r\nLa classe Timeline permette di creare animazioni a partire da KeyFrame (cioè i valori in uno specifico istante di un gruppo di variabili) e il momento in cui devono presentarsi. Il compito, poi, di \"interpolarli\" (cioè calcolare tutti i valori intermedi tra i key frame forniti) viene svolto dal sistema, tenendo conto eventualmente di alcuni parametri che si possono impostare, come il tipo di interpolatore.\r\nLa classe Transition è una classe astratta e richiede a noi di definire il metodo per interpolare \"void interpolate(double frac)\", il quale gestirà l'animazione in ogni istante (cioè nella frazione di tempo \"frac\" della durata di un ciclo). Esistono diverse classi derivate da Transition che implementano già diversi tipi di transizioni (es. PathTransition).\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6818,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6724,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6906,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6998,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6437,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si verifica quando questa sequenza temporale ha completamente terminato la riproduzione e non entrerà più nel periodo attivo.\r\nL?evento Completed informa l?utente quando Timeline viene completata. Una sequenza temporale si considera completata dopo aver raggiunto la fine del periodo attivo e quando non verrà più riprodotta a meno non venga riavviata in modo interattivo. Si noti che il termine \"completato\" non corrisponde a \"riproduzione arrestata\": l?arresto di una sequenza temporale non attiva l'evento Completed (a differenza del passaggio al periodo di riempimento della sequenza temporale).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6819,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6725,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6907,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7002,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6438,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe Animation è la classe che permette le animazioni in Java FX. È una classe abstract quindi deve essere istanziata tramite le sue sottoclassi Transition e Timeline. La classe Transition permette tramite il metodo interpolate di dare comandi al programma che verranno eseguiti ad ogni frazione di tempo della durata totale dell'animazione. Transition ha diverse sottoclassi più specifiche come TranslateTransition e FadeTransition. Timeline invece permette di definire come cambiano nel  tempo le proprietà degli oggetti presenti attraverso i Key-Frame. Questi sono oggetti che permettono di definire le singole parti di un'animazione attraverso la definizione delle proprietà in momenti specifici.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6723,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6905,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7000,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6817,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6088,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Facendo riferimento al file Animation spiegare il funzionamento delle classi Timeline, KeyFrame, KeyValue e la loro relazione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6059,
          "asker": {
            "courseId": 100,
            "askerId": 759,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è listener ? Viene attivato subito dopo l'esecuzione del programma o dopo ? Quali sono i vantaggi e svantaggi di avere listener al interno o esteno ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " vantaggi"
            },
            {
              "keyword": " svantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6002,
          "asker": {
            "courseId": 100,
            "askerId": 772,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze principali tra le sottoclassi Transition e Timeline ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Transition"
            },
            {
              "keyword": " Timeline"
            },
            {
              "keyword": " Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6031,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "a cosa servono i keyframe e le timeline? devo usarli sempre insieme?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "keyframe"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6046,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze principali tra le classi Transition e Timeline? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": " Transition. Timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6023,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile inserire un bottone o un oggetto in un gruppo in modo che si adatti allo stesso e che quindi per esempio allargando la finestra questo diventi più grande in proporzione al gruppo stesso?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 19,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Oggetti "
            },
            {
              "keyword": " dimensioni"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6439,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Un modo che può essere considerare le dimensioni della Scene/Region come ObservableValue<>,che quindi ogni volta cambiate diventano osservabili da un ascoltatore(Listener) che in questo caso è di tipo ChangeListener.Esendo un interfaccia(ChangeListener),bisogna fare il override del metodo changed(),che contiene come parametri il valore observable,il vecchio valore e il nuovo valore.Dentro al changed() viene implementata la modifica che deve avvenire con l'alterazione del valore interessato.Passando alla pratica: Se il bottone lo inserisco in un  StackPane, faccio :\r\n stackpane.widthProperty().addListener(new ChangeListener<Number>() {\r\n@Override: public void changed(ObservableValue<? extends Number> ov, Number t, Number t1) { btn.setPrefWidth(t1.doubleValue()); }  });\r\noppure posso registrare l'ascoltatore alla Scena: scene.widthProperty()..Ogni volta si cambia la dim(width) della Scene,cambia anche il width del bott.Se il bott è in 1 Group l'ascoltatore si può registra solo alla Scene",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7067,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6806,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6685,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6716,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6732,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6419,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo più semplice secondo me per ottenere questa adattabilità e settare la grandezza del bottone in questo modo:\r\n   bottone.setPrefSize(gruppo.getHeight/100*20,gruppo.getWidth/100*20);\r\nIn questo modo ad esempio il bottone avrà dimensioni 20% rispetto all'altezza e 20% rispetto alla larghezza del gruppo. Ovviamente questo non è l'unico modo, ce ne sono anche altri.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6681,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6728,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7066,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6802,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6712,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6433,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "No, non è possibile. E' possibile fare in modo che un bottone o un oggetto si adattino alla finestra usando per esempio l'AchorPane e andando a definire le distanze che in bottone deve mantenere dalla finestra; per esempio \r\n\r\nButton btn = new Button();\r\nAnchorPane anchorpane = new AnchorPane();\r\nanchorpane.getChildren().add(btn);\r\nAnchorPane.setBottomAnchor(btn, Double d);\r\n\r\ncosì facendo setto la distanza che btn deve avere sempre dal basso della finestra; allo stesso modo posso definire la distanza che esso deve mantenere da ogni lato della finestra.\r\n\r\nSe invece l'AnchorPane (o qualsiasi altro pane) viene messo all'interno di un Group, queste costrizioni non vengono più considerate, e il bottone non si allarga più con la finestra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6683,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6730,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6714,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6804,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7069,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6386,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "È possibile farlo tramite comandi appositi questi  però non sono stati trattati a lezione e quindi vanno visti e provati guardando in internet",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6805,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6731,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7065,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6684,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6715,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6364,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "No non è possibile.\r\nSe si guarda il codice, quando si vuole inserire un oggetto nella scena si usano le seguenti righe :\r\n     Scene   scene   =   new   Scene(root,   300,   250);\r\n     primaryStage.setScene(scene);\r\n     primaryStage.show();\r\n\r\nDove root può essere qualsiasi combinazione degli elementi di layout visti nella lezione 17 inseriti in un Group.\r\nNon inserendo gli elementi in un root ma inserendoli direttamente nella scena l'elemento diventa più grande allargando la finestra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6807,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6733,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7070,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6686,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6717,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6404,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, il come non mi è dato saperlo, però si può",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6713,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6803,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6729,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7068,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6682,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6024,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e come si usa la Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": "animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6065,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega brevemente cosa sono le sottoclassi \"Transition\" e \"Timeline\" e qual'è la loro funzione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " subclasses"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6063,
          "asker": {
            "courseId": 100,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le diverse funzionalità di Transition e Timeline? Fornire un esempio in cui è meglio utilizzare una e uno in cui utilizzare l'altra.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": " Transition"
            },
            {
              "keyword": "Animazion"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6073,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa intendiamo per KeyFrame e KeyValue? ",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "KeyFrame"
            },
            {
              "keyword": "KeyValue"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6423,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 767,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il keyframe è un tipo di fotogramma che definisce lo stato iniziale, finale o intermedio, di un'animazione.\r\nUna volta stabiliti i keyframe iniziali e finali di un filmato, è possibile crearne i fotogrammi intermedi.\r\n\r\nLe keyvalue(s) sono le proprietà dell'oggetto animato",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6946,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6996,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6694,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6973,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6949,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7092,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6823,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6375,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "KeyFrame è un oggetto che denota la posizione di un Node in un determinato momento in una Timeline.\r\nInfatti una Timeline definisce un'animazione su un node tramite interpolazioni fatte su questi keyFrame, che possono essere interpretati come posizioni chiave ad un determinato momento; infatti un oggetto di classe KeyFrame si inizializza come KeyFrame kf = new KeyFrame(Duration,KeyValue,KeyValue).\r\nUn oggetto KeyValue [costruttore (DoubleProperty,double)] definisce quale proprietà [la DoubleProperty] deve valere un determinato valore [double].\r\nUn esempio:\r\nRectangle r = new Rectangle(0,0,10,10);\r\nTimeline t = new Timeline();\r\nKeyValue k1 = new KeyValue(r.translatePropertyX(),200);\r\nKeyValue k2 = new KeyValue(r.translatePropertyY(),300);\r\nt.getKeyFrames().add(new KeyFrame(Duration.millis(1500),k1,k2);\r\n\r\nDopo che la timeline verrà fatta partire, il rettangolo si sposterà dalla posizione 0,0 in 200,300 in 1 secondo e mezzo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6974,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6695,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6947,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6950,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6824,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6997,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7094,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6461,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Il KeyFrame, insieme al TimeLine mi permette di gestire l'interpolazione dei vari frame nel tempo di un'animazione, definendo attraverso variabile dette KeyValues la posizione in cui si dovrà trovare l'oggetto al tempo prefissato e specificato. Posso principalmente avere due esempi a livello di impementazione del codice con Keyframe:1)Istanziare un nuovo KeyFrame in cui setto la durata e istanzio un nuovo eventHandler che mi gestisce le posizioni con get/set TranslateX/Y 2)Aggiugnere alla TimeLine nuovi KeyFrame che vengono istanziati settando le Durations e i rispettivi KeyValues.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6693,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6822,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6945,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7093,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6948,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6972,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6995,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6103,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Fornire una breve spiegazione delle sottoclassi di Transition.\r\n(https://docs.oracle.com/javafx/2/api/javafx/animation/Transition.html)",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": "sottoclassi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6409,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Transition è una classe astratta che fornisce le funzionalità di base per animazioni basate su tale classe. Le sottoclassi di Transition implementano il metodo interpolate specificando così il comportamento dell'animazione da applicare all'oggetto a cui verrà assegnata.\r\nLe sottoclassi sono:\r\n-FadeTransition => modifica l'opacità dell'oggetto\r\n-FillTransition => modifica il colore di riempimento dell'oggetto\r\n-ParallelTransition => esegue in contemporanea una lista di animazioni\r\n-PathTransition => permette di animare un Node lungo un percorso (Path)\r\n-PauseTransition => esegue il metodo Animation.onFinished alla fine della sua durata\r\n-RotateTransition => modifica l'angolo di rotazione di un oggetto\r\n-ScaleTransition => scala le dimensioni dell'oggetto (x, y, z)\r\n-SequentialTransition => esegue in modo sequenziale una lista di animazioni\r\n-StrokeTransition => modifica il bordo di una Shape\r\n-TranslateTransition => muove l'oggetto cambiando le proprietà translate (x, y, z)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6903,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6699,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6757,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6942,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7044,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6879,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6365,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Transition e' una classe astratta che definisce tutte le funzionalita' base delle sottoclassi che permettono di effettuare animazioni.Ogni sottoclasse deve implementare il metodo interpolate che viene utilizzato ad ogni transizione ed ha come parametro un valore compreso tra 0 e 1 (1 quando l'animazione e' terminata). \r\nFadeTransition crea un effetto dissolvenza sul nodo passato nella funzione setNode(). \r\nFillTransition modifica gradualmente il colore del nodo cui e' passato.\r\nParallelTransition necessita di Animazioni come parametri e permette a piu' sottoclassi di Transition di agire simultaneamente.\r\nPathTransition genera un animazione riferita esclusivamente ad un oggetto di tipo Path.\r\nPauseTransition permettere di aggiungere una pausa tra animazioni con l'utilizzo di paralleleTransition.\r\nRotateTransition ruota un nodo.\r\nScaleTransition modifica gradualmente i valori Scale del nodo. \r\nTranslateTransition trasla il nodo.StrokeTransition modifica il colore del bordo di un nodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7041,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6697,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6755,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6901,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6877,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6944,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6424,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 863,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "FadeTransition, ScaleTransition, FillTransition, StrokeTransition:\r\nModificano le proprietà del nodo, cambiandone l'opacità, la dimensione, il colore di riempimento e degli stroke(bordi) lungo un arco di tempo.\r\n\r\nTranslateTransition, RotateTransition, PathTransition:\r\nPermettono di muovere un nodo. Rispettivamente:\r\n- Effettuando una traslazione (x,y,z)\r\n- Ruotandolo \r\n -Definendo un percorso da seguire. In particolare il percorso è definito dal bordo di una Shape, quindi è per es. possibile effettuare un percorso circolare con PathTransition(4000, new Circle(40)). È possibile settare un flag affinchè il nodo sia sempre perpendicolare al percorso.\r\n\r\nPauseTransition:\r\nAspetta un periodo di tempo e esegue Animation.onFinished al termine. Viene combinata con le Transition scritte sotto. \r\n\r\nSequentialTransition, ParallelTransition:\r\nPermettono di combinare altre Transition e di farle agire in parallelo o in modo sequenziale(per es. ingrandire e muovere un oggetto allo stesso tempo).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6878,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6756,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7042,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6698,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6941,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6902,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6410,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Transition è una classe astratta che fornisce le funzionalità di base per animazioni basate su tale classe. Le sottoclassi di Transition implementano il metodo interpolate specificando così il comportamento dell'animazione da applicare all'oggetto a cui verrà assegnata.\r\nLe sottoclassi sono:\r\n-FadeTransition => modifica l'opacità dell'oggetto\r\n-FillTransition => modifica il colore di riempimento dell'oggetto\r\n-ParallelTransition => esegue in contemporanea una lista di animazioni\r\n-PathTransition => permette di animare un Node lungo un percorso (Path)\r\n-PauseTransition => esegue il metodo Animation.onFinished alla fine della sua durata\r\n-RotateTransition => modifica l'angolo di rotazione di un oggetto\r\n-ScaleTransition => scala le dimensioni dell'oggetto (x, y, z)\r\n-SequentialTransition => esegue in modo sequenziale una lista di animazioni\r\n-StrokeTransition => modifica il bordo di una Shape\r\n-TranslateTransition => muove l'oggetto cambiando le proprietà translate (x, y, z)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6876,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6943,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6696,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7043,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6754,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6900,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6041,
          "asker": {
            "courseId": 100,
            "askerId": 861,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega il funzionamento della sottoclasse Transition, specificando i requisiti necessari per utulizzarla.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": "requisiti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6090,
          "asker": {
            "courseId": 100,
            "askerId": 823,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Di che classi abbiamo bisogno per creare un'animazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " animazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6006,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " javafx"
            },
            {
              "keyword": " keyframe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6027,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi devo inverire la scritta '@Override' all'interno del programma? E per quele motivo? A cosa serve?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Override"
            },
            {
              "keyword": " @Override"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6458,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La scritta '@Override' va inserita all'interno del programma quando si va a riscrivere un metodo ereditato per rispettare le nuove necessità dettate dal codice. In questo modo, inoltre, quando il programmatore ne ritiene necessario l'uso, si avvisa direttamente il compilatore che si sta facendo l'overriding di un metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6736,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7088,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7109,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6918,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6813,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6360,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "La scritta @Override va inserita nel programma prima della definizione di un metodo. Essa è necessaria qualora il metodo che si sta andando a definire è un metodo già esistente in una superclasse. Tramite @Override, infatti, noi specifichiamo come la nostra classe deve andare ad utilizzare il metodo con quella firma, permettendoci di adattarla alle nostre necessità. Senza la scritta @Override ( e la definizione del metodo ) con il richiamo della funzione, verrà utilizzato il metodo della superclasse (Object, se non ce ne fosse una).\r\n@Override non è necessario qual'ora il metodo che stiamo scrivendo non sia un metodo presente in una superclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6814,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6919,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7085,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6737,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7110,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6385,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Si inserisce questa scritta quando si fa un override di un metodo; cioè quando la dichiarazione del metodo (nome) è uguale a quella di un altra classe, ma l'implementazione (istruzioni) sono diverse e più precisamente saranno istruzioni opportune per quella classe. Non dovrebbe dare errore se non la si mette ma se non altro serve al programmatore per capire che si è fatto un override.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6738,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6920,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6815,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7108,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7084,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6411,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 838,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il tag @Override dovrebbe essere inserito ogni volta che si estende una superclasse o si implementa un'interfaccia. Questa indicazione, oltre a contribuire alla leggibilità del codice, è molto utile per evitare di cadere in errori insidiosi (facili da commettere e difficili da scovare), quali il mispelling, o l'uso inappropriato di argomenti. Infatti quando il compilatore incontra questo tag verifica che si stia effettivamente facendo override, e non ad esempio overloading, e segnala errore se il codice non è corretto.\r\nUn esempio: vogliamo implementare il metodo hashCode() dentro una classe che estende Object. Se omettiamo l'indicazione @Override e invece di scrivere\r\npublic int hashCode() {..}\r\n\r\nscriviamo \r\npublic int hashcode(){..}\r\n\r\noppure\r\npublic void hashCode(){..}\r\n\r\nil codice gira comunque, non incontriamo errori a runtime, ma di fatto non stiamo facendo ovverride.\r\nAggiungendo il tag, invece, il compilatore riconosce immediatamente l'errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6735,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7087,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7107,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6917,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6812,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6362,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "La scritta '@Override' è un elemento di notazione che va (o, quantomeno, \"andrebbe\") inserito ogniqualvolta si sovrascrive, (re-)implementandolo arbitrariamente, un metodo già esistente in una superclasse o nell'interfaccia implementata dalla classe attuale. Esso va inserito immediatamente prima della definizione del metodo, e serve appunto a notificare, principalmente a scopo di favorire una migliore interpretazione del codice, che il metodo che segue consiste nella sovrascrizione di un metodo già esistente e precedentemente dichiarato (e eventualmente anche definito).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6811,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6916,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7106,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6734,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7086,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6004,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si utilizzano gli oggetti della classe Keyframe nell'ambito degli argomenti visti a lezione? Fai un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Keyframe"
            },
            {
              "keyword": " lezione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6040,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può costruire un animazione, come per esempio una semplice traslazione, per cui basta definire semplicemente la posizione iniziale e quella finale di un oggetto? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "animazione"
            },
            {
              "keyword": " iniziale"
            },
            {
              "keyword": " finale"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6071,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Se il sistema (inteso come tutto il SO + java) subisce dei forti rallentamenti fino a fermare l'animazione (in corso), questa poi continuerà da dove si era fermata oppure riprenderà l'animazione posticipandola opportunamente per rispettare i timer in millisecondi? Argomentando la risposta, spiegare come si imposta la durata di un'animazione",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "freeze"
            },
            {
              "keyword": " millisecond"
            },
            {
              "keyword": " animation"
            },
            {
              "keyword": " timer"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6082,
          "asker": {
            "courseId": 100,
            "askerId": 792,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può creare un'animazione che esegua una sequenza di azioni che durano un determinato tempo?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": "keyevent"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6383,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Timeline, keyFrame e SequentialTransitions.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6708,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6846,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6938,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6976,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6393,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "con TimeLine e settando il valore dei millisecondi con il metodo .setCycleCount(numerocicli);\r\nes: TimeLine t = new TimeLine();\r\n    t.setCycleCount(numerocicli);\r\n    t.getKeyFrames().add(new KeyFrame()); dove il KeyFrame e keyValue servono a definire i punti chiave dell'animazione\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6978,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6847,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6709,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6940,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6440,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Impiegando i metodi della classe Duration (javafx.util.Duration) è possibile settare la durata di un'istanza a piacere, in millisecondi (Duration.millis(double ms)), in secondi (Duration.seconds(double s)) o anche in minuti o ore (rispettivamente .minutes(double min) e .hours(double h) ).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6939,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6849,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6711,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6977,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6387,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Questo problema lo si può risolvere usando una Transition settando tramite setCycleDuration(javafx.util.Duration) il tempo di durata di ogni frame, mentre tramite il metodo interpolate(double) andremmo a definire le azioni che eseguiremo nel frame.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6710,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6975,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6937,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6848,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6086,
          "asker": {
            "courseId": 100,
            "askerId": 922,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenze ci sono tra un'istanziazione normale, ed una utilizzando \"Wildcard\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "istanziazione"
            },
            {
              "keyword": " wildcard"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6096,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si genera un path in javaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "path"
            },
            {
              "keyword": "  javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6101,
          "asker": {
            "courseId": 100,
            "askerId": 833,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando della costruzioni di percorsi sul quale traslare un oggetto, a lezione si è brevemente parlato delle Curve di Bezier.\r\nCosa sono? Come possono essere utilizzate e perché sono importanti?\r\nParlane brevemente.",
          "totalDifficultyLevel": 27,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 19,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Path"
            },
            {
              "keyword": " Bezier"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6376,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Le curve di Bezier sono delle curve parametizzate che vengono definite a partire da dei punti (solitamente nel piano o nello spazio). La curva parte dal primo punto, diciamo P(0), si muove nelle direzioni dettate dai punti P(1), ..., P(n-1) senza però passarvi, e termina nel punto P(n). I punti P(i) sono detti punti di controllo e il poligono convesso formato dai segmenti aventi tali punti come estremi contiene tutta la curva di Bezier.\r\nGli utilizzi in computer grafica sono molteplici in quanto si ha un'eccellente resa per quanto riguarda le linee curve; se ne possono creare di qualsivoglia forma partendo da una curva di Bezier qualsiasi e applicando composizioni e trasformazioni affini. Vengono quindi usate per creare fonts, per creare linee curve, per esempio in programmi di grafica vettoriale, e nelle Animations vengono principalmente usate per rendere il movimento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6994,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6895,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6911,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6429,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 878,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Le curve di bezier sono un tipo di curve, che si servono di punti fissi per essere costruite.\r\nPossono essere usate attraverso i relativi metodi per la costruzione di figure anche molto complesse, il disegno di tracciati, ecc.. e la loro importanza deriva principalmente dalla loro semplicità implementativa e scarsa richiesta di risorse grafiche.\r\nNe esistono di diversi tipi, generalmente discriminati in base al numero di punti di controllo che vengono impiegati. Grazie alla loro versatilità, sono ampiamente usate in computer grafica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6915,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6899,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6993,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6372,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Le curve di Bezier le abbiamo viste nell'ambito delle PathTransiton, ovvero animazioni nelle quali gli oggetti si muovono seguendo un determinato percorso.\r\nQueste curve sono molto importanti e sono utilizzate in moltissime applicazioni grafiche.\r\nPer utilizzarle necessitiamo in particolare di 2 o più punti che forniranno varie informazioni per la loro costruzione. Da essi infatti estrapoliamo il punto di arrivo e di partenza e l'andamento della curva (per esempio, nel caso di tre punti disposti a triangolo la curva passa per il punto M = 1/4 P0 + 1/2 P1 + 1/4 P2, ovvero il punto medio della mediana del triangolo P0 P1 P2 uscente dal vertice P1).\r\nSono molto importanti perché permettono in maniera relativamente semplice di descrivere percorsi anche strutturati.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6989,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6896,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6912,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6425,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Le Curve di Bezier sono dei particolari percorsi su cui è possibile far muovere un oggetto. Essi sono definiti da delle coordinate d'inizio e di fine, più alcuni punti che fungono da controllo. Questi path possono essere generati dalle classi QuadCurveTo e CubicCurveTo. Queste curve sono importanti poiché sono l'unico metodo per generare dei disegni curvilinei precisi, infatti sono anche utilizzate in numerosi programmi di computer grafica. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6910,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6894,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6991,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6380,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "42",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6990,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6898,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6914,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6391,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una curva di Bezier è una particolare curva parametrica, viene costruita usando i punti a disposizione che vanno inseriti nell'algoritmo di de Casteljau, algoritmo che permette di disegnare una curva di Bezier.\r\nIn java esiste la classe PgBezierCurve che estende PgPolygon che può essere usata.\r\nLe curve di Bezier possono essere usate per descrivere la traiettoria di un oggetto che viene traslato, volendo fargli descrivere una traiettoria curva che segue alcuni punti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6913,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6897,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6992,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5999,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "più animazioni in java possono essere usate contemporaneamente su un oggetto? se si come? se invece si vogliono le animazioni una dopo l'altra come si deve fare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "SequentialTransition"
            },
            {
              "keyword": "ParallelTransition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6015,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le sottoclassi di Animation e qual è la differenza tra di esse? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": " Java FX"
            },
            {
              "keyword": " sottoclassi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6105,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per transition e cosa richiede?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Transition"
            },
            {
              "keyword": "definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6009,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza fra timeline e transition? Si potrebbe fare tutto quello che si fa con le transition usando delle timeline? Se sì, perchè esistono le transition?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": "transition"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6363,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Perché le trasnition può!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7071,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7090,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6750,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7120,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6764,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6384,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In parole povere, transition è una classe che fornisce un framework per creare animazioni, mentre timeline è più complessa da utilizzare ma fornisce un controllo più accurato delle animazioni.\r\nCon le timeline si possono fare le stesse cose che si fanno con le transition, ma le transition sono più semplici da implementare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7072,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7089,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6762,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7122,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6748,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6400,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 756,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Timeline definisce un'animazione che si ripete nell'esecuzione del programma. Un'animazione generata con timeline può essere messa in pausa, essere stoppata e eseguita al contrario.\r\nLe transition, danno la possibilità di incorporare più animazioni in una timeline. Quindi con le transition si possono eseguire più animazioni parallelamente.\r\nLe transition esistono proprio per il fatto che si possono eseguire più animazioni contemporaneamente. Tutto però potrebbe essere comunque implementato con una timeline, con la perdita dell'esecuzione parallela.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6749,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7121,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6763,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7073,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7091,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6016,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo è possibile cambiare le coordinate di un oggetto posizionato da un Pane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "coordinate"
            },
            {
              "keyword": " pane"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6083,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra i metodi \r\nplay(), playFromStart(), pause()  e stop() ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "play"
            },
            {
              "keyword": " animazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6076,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java fx, come posso fare per spostare (traslare) un nodo (per esempio per un'animazione)? Quali metodi mi vengono forniti e quali caratteristiche in particolare del nodo vendono modificate? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "animazioni"
            },
            {
              "keyword": " traslation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6048,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa è una struct ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " list "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6093,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è keyframe, la sua funzione e come si utilizza in un programma.",
          "totalDifficultyLevel": 21,
          "totalInterestingnessLevel": 26,
          "totalRelevanceLevel": 24,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "keyframe"
            },
            {
              "keyword": " javafx"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6371,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per 'keyframe' si intende un insieme di costanti corrispondenti a delle variabili che definiscono una particolare configurazione di un'animazione in un preciso momento di tempo (in pratica un fotogramma). Ad esempio, se dobbiamo fare un'animazione si definisce il 'keyframe iniziale', cioè il fotogramma di partenza dell'animazione, il 'keyframe finale', cioè il fotogramma finale, e si possono definire inoltre dei keyframe intermedi.\r\n\r\nIl programmatore quindi può definire l'animazione tra due keyframe fornendo un 'interpolatore' ad ogni variabile. Le variabili saranno quindi interpolate in maniera tale che raggiunga il valore fissato nel keyframe successivo ad un preciso istante di tempo.\r\n\r\nESEMPIO: Supponiamo di voler traslare un punto dalla posizione P=(0,0) alla posizione Q=(0,1), i valori di P e Q saranno rispettivamente il keyframe iniziale e finale e l'interpolazione assegnerà alla seconda variabile (ovviamente in maniera discreta) i valori compresi tra 0 e 1. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7033,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6965,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7101,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6954,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6434,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Definisce lo stato iniziale, finale o intermedio, di un'animazione computerizzata. Precisamente fornisce un valore target ad ogni punto in un set di variabili inserite in una TimeLine. Il programmatore stabilisce i KeyFrames e fornisce un Interpolator associato ad ogni variabile. Le variabili vengono inserite in modo che possano ricercare il loro valore target in ogni specifico istante. Alla fine della funzione (onFinished function) è invocata ogni KeyFrame fornita.  La KeyFrame viene utilizzata da un programmatore quando necessita di un'animazione per un oggetto. Per animazione si intende una transizione di movimento , transizione di forma, transizione di colore o più in generale per un fotogramma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7102,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6951,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6962,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7034,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6430,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "La classe KeyFrame (fotogramma chiave) permette di creare animazioni attraverso le sue istanze, all?interno delle quali si definiscono alcuni valori assunti in un determinato momento per una serie di variabili, che vengono poi interpolati lungo una Timeline (linea temporale). Si riesce quindi a controllare la transizione di un insieme di variabili durante l'intervallo tra un fotogramma chiave e l?altro, fornendo un valore e un interpolatore associato a ciascuna variabile che sara assunto al tempo specificato. Se e stata definita una funzione onFinished questa verra chiamata in ogni KeyFrame. E possibile definire o meno un nome, che in caso affermativo si tradurrà in un cuePoint che viene automaticamente aggiunto alla Timeline.\r\nEs:\r\nTimeline timeline = new Timeline();\r\ntimeline.getKeyFrames().addAll(\r\nnew KeyFrame(Duration.ZERO, new KeyValue(*, #)),\r\nnew KeyFrame(new Duration(2000), new KeyValue(*, #)),\r\nnew KeyFrame(new Duration(4000), new KeyValue(*, #)));\r\n*=variabile #=valore",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6967,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7035,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7104,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6956,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6420,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 769,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un keyframe è pezzo di codice che viene eseguito in un determinato punto nel tempo di una Timeline.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7031,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6953,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7105,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6964,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6451,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ci sono due modi per costruire un'animazione: definendo il comportamento dell'oggetto che si vuole animare frame per frame oppure definendo una serie di stati.\r\nIn particolare la timeline processa sequenzialmente i vari keyframe, ciascuno dei quali descrive un particolare stato della timeline. \r\nAd esempio se volessimo costruire un'animazione con un rettangolo che si sposta da un punto ad un altro usando una timeline, potremmo procedere in due modi:\r\no istanziare un keyframe in cui specificare nel costruttore la durata dell'azione e l'azione di traslazione tramite un eventHandler oppure istanziare due keyframe, uno con tempo iniziale uguale a zero e keyvalue dato dalla posizione iniziale e l'altro con tempo finale e posizione finale. Nel primo caso specifichiamo l'azione in ogni frame, nel secondo stabiliamo dei valori chiave e lasciamo al calcolatore il ruolo di interpolazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7030,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7103,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6952,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6963,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6455,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 874,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Definisce valori target a un specifico punto nel frame per un set di variabili stabilite lungo la timeline",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6955,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6966,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7100,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7032,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6032,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e che caratteristiche hanno Transition e Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Transition"
            },
            {
              "keyword": " Timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6054,
          "asker": {
            "courseId": 100,
            "askerId": 910,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "1) L'altro giorno a lezione abbiamo visto la simulazione di un esame, pur avendo rivisto la soluzione non ho capito come si riesce a costruire la griglia di partenza. Illustrare un metodo per riuscire a costruirla.\r\n2) Illustrare un metodo per costruire la barra nella quale si preleva l'input da tastiera.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "griglia"
            },
            {
              "keyword": " input"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6072,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A quale scopo viene utilizzata la classe Transition? Quali implementazioni e chiamate richiede per funzionare correttamente? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": "transition"
            },
            {
              "keyword": "javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6062,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Timeline: cos'è? a cosa serve? quali altri oggetti simili possiamo usare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " javafx"
            },
            {
              "keyword": " animations"
            },
            {
              "keyword": "animazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6078,
          "asker": {
            "courseId": 100,
            "askerId": 769,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare le principali differenze tra una Transition ed una Timeline? Inoltre è possibile implementare una Timeline in due modi differenti, in cosa consistono? Qual'è la differenza tra un KeyFrame ed un KeyValue?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " keyframe"
            },
            {
              "keyword": " keyvalue"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6036,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Dai una definizione di \"TRANSITION\", soffermandoti sui vari requisiti. Aiutati con un esempio!!",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " requisiti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6064,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra Transition e Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6107,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si crea un'animazione? Ed attraverso quale oggetto si può gestirne ogni singolo frame?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animazione"
            },
            {
              "keyword": " KeyFrame"
            },
            {
              "keyword": " Timeline"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6087,
          "asker": {
            "courseId": 100,
            "askerId": 494,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Animation e Transation?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": "transation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6017,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la classe KeyFrame? Come viene utilizzata per creare i vari movimenti degli oggetti? e servono altre classi per indicare il percorso degli elementi sulla scena?",
          "totalDifficultyLevel": 23,
          "totalInterestingnessLevel": 25,
          "totalRelevanceLevel": 23,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Lezione19"
            },
            {
              "keyword": " Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6397,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe KeyFrame serve a creare animazioni a piacere del programmatore. Possiede dei metodi (SetTranslateX, SetTranslateY, TranslateXProperty...) che permettono di creare i movimenti degli oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6864,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6885,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6850,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6980,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7025,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7114,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6418,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le animazioni in JavaFx so possono divididere in \"timeline animation\" e \"transition\". L'utilizzo della classe KeyFrame si vede soprattutto nella costruzione di animazioni di tipo \"timeline\". Le classi keyFrame definiscono le animazioni timeline e quest'ultima processa queste classi in modo sequenziale al fine di creare l'animazione stessa, l'ordine in cui esse vengono processate dipende invece dal metodo \"KeyFrame.time\". \r\nDi norma la classe KeyFrame prevede l'utilizzo di altre quattro classi specificate in questo esempio:\r\n\r\nKeyFrame keyFrame = new KeyFrame(duration, onFinished , keyValueX, keyValueY), \r\n\r\novvero delle classi KeyValue che indicano il percorso che l'animazione deve seguire, la classe Duration che indica la durata della animazione e la classe EventHandler che invece definisce l'evento da \"eseguire\" alla fine della animazione, rispettivamente:\r\nKeyFrame keyFrame = new KeyFrame(Duration, EventHandler , keyValue, keyValue)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7119,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6851,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7029,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6984,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6886,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6865,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6449,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La classe KeyFrame è una classe che permette di creare animazioni richiamando un evento ogni tot secondi. Viene utilizzata insieme a Timeline, che è una classe che può raccogliere più KeyFrame e farli partire tramite il metodo play(); .\r\nPer spostare un oggetto all'interno della scena secondo un percorso predefinito, si può utilizzare la classe PathTransition, che è una speciale transizione che fa muovere l'oggetto lungo un percorso definito tramite la classe Path. A sua volta la classe Path utilizza classi come MoveTo, HLineTo, LineTo, QuadCurveTo, ArcTo per definire i punti di arrivo e di fine del percorso e le modalità (la forma delle curve) con cui l'oggetto lo deve compiere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7117,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7027,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6869,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6982,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6890,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6855,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6370,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe KeyFrame serve per gestire i vari fotogrammi per creare un'animazione. Viene utilizzata per creare i movimenti degli oggetti tramite l'utilizzo di variabili che cambiano nel tempo. Altri classi che si possono utilizzare per indicare il percorso degli elementi sulla scena sono per esempio la funzione onFinished.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7024,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6888,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6979,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6867,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6853,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7115,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6442,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Definisce i valori obiettivo in un determinato momento per una serie di variabili che sono interpolati lungo una Timeline.\r\nLo sviluppatore controlla l'interpolazione di un insieme di variabili per l'intervallo tra KeyFrame successivi, fornendo un valore obiettivo e un interpolatore associato a ciascuna variabile. Le variabili sono interpolati in modo tale che essi raggiungeranno il loro valore nominale al tempo specificato. Una funzione onFinished viene richiamata su ogni KeyFrame se uno è fornito. Un KeyFrame può facoltativamente avere un nome, che si tradurrà in un cuePoint che viene automaticamente aggiunta alla Timeline.\r\nDue brevi esempi:\r\n1) public KeyFrame(Duration time, KeyValue... values)\r\nCostruttore del KeyFrame\r\n\r\n2)public KeyFrame(Duration time, java.lang.String name,\r\n                                EventHandler<ActionEvent>onFinished, KeyValue... values)\r\nCostruttore del KeyFrame\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7026,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6852,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6887,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6981,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6866,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7118,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6379,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "42",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7028,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6854,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6983,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6868,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6889,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7116,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6091,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Possono essere cambiate le coordinate di un oggetto posizionato da un Pane?\t\r\nCos'e' la Timeline e a cosa viene principalmente associata?",
          "totalDifficultyLevel": 23,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 23,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": " Pane"
            },
            {
              "keyword": " Timeline"
            },
            {
              "keyword": " coordinate"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6415,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le coordinate di un oggetto possono essere cambiate settando opportunamente le proprietà translateX e translateY, le quali definiscono proprio l'entità della traslazione di quell'oggetto (anche se in realtà la traslazione complessiva dell'oggetto viene calcolata come layoutX+traslateX, dove layoutX è la posizione stabile dell'oggetto che viene determinata dal layout).\r\nUna Timeline è un modo per costruire animazioni di una qualsiasi proprietà di JavaFX. È definita principalmente da uno o più KeyFrame. Una KeyFrame è essenzialmente una \"fotografia\" dell'animazione, infatti essa definisce i valori delle variabili per le quali si vuole creare l'animazione. La Timeline interpola i valori delle varie KeyFrame in un determinato intervallo di tempo, creando così l'animazione.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6742,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6825,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6443,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Le coordinate di un oggetto possono essere modificate attraverso l'utilizzo dei metodi getTranslateX() e getTranslateY(), usati per sapere di quanto un oggetto è stato spostato dalla sua posizione standard; setTranslateX e setTranslateY(), usati per spostare di un determinato numero di pixel l'oggetto; inoltre attraverso i metodi getLayoutX() e getLayoutY() puoi ottenere la posizione in cui è stato posizionato l'oggetto.\r\n\r\nTIMELINE : serve a definire la sequenza di KeyFrame da un punto di inizio a un punto di fine per effettuare lo spostamento di un oggetto.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6829,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6746,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6435,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "Sono quasi certo che chiedendolo gentilmente non si ottenga nulla. È consigliato tra gli sviluppatori utilizzare la forza, e se dopo un paio d'ore a spulciare nella documentazione ancora non si cava un ragno dal buco, è buon uso recitare un rosario mentre ci si demoliscono le nocche della mano destra a pugni contro il muro. La Timeline è una classe associata alle animazioni, che tramite KeyFrames permette di svolgere ciclicamente animazioni, transazioni, fading, scaling eccetera. \r\nTanta bella roba insomma. Se non sei ancora impazzito per la prima parte in cui non riesci a spostare oggetti nei Panes, lascia stare tutto e mettiti a deformare forme. Quello funziona più semplicemente.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6744,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6827,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6444,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le coordinate di un oggetto posizionato da un Pane possono essere cambiate usando i metodi getLayoutX() e setTranslateX() (uguale per Y). Con getLayoutX() acquisisco la coordinata X dell'oggetto e con SetTranslateX() lo posso spostare rispetto alla sua coordinata iniziale (o precedente). \r\nLa Timeline contiene i vari KeyFrame. Con il comando Play, la TimeLine esegue i vari KeyFrame che ad essa sono associati. \r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6828,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6745,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6373,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Le coordinate di un oggetto posizionato da un Pane possono essere cambiate accedendo alle proprietà translateX (con una getTranslate X() ) e translateY (con una getTranslateY() ) che definiscono di quanto l'oggetto è traslato sugli assi orizzontale e verticale rispetto alle coordinate fisse del layout ( layoutX e layoutY). Una Timeline è un oggetto usato per creare delle animazioni grafiche in JavaFX. Una TimeLine è definita da uno o più KeyFrame. Ogni KeyFrame definisce un valore che deve assumere una certa proprietà dopo un determinato lasso di tempo e sarà compito della Timeline processarli in ordine e in modo fluido e continuo generando cioè tutti gli stati intermedi della proprietà in questione tra il tempo t0(quello in cui l'animazione del singolo KeyFrame ha inizio) e il tempo t1 (quello in cui l'animazione del singolo KeyFrame terminerà). La Timeline è un potente strumento per le animazioni grafiche! (Lo stesso concetto viene usato per le animazioni di oggetti tridimensionali).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6830,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6747,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6412,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 922,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dipende dal tipo di Pane che si sta utilizzando, ad esempio in un GridPane che ha forma di \"griglia\", gli oggetti avranno posizioni \"fisse\" da rispettare, mentre in un BorderPane si può benissimo dare delle coordinate di posizionamento all'oggetto in modo che appaia dove si preferisce.\r\nLa Timeline è una classe che gestisce degli eventi che si decide di far accadere in un certo lasso di tempo e per una certa durata.\r\nIl codice di conseguenza contiene tutti gli eventi che si vogliono far iniziare (ad esempio cambi di colore, apparizione o movimento di forme, ecc.) e si deve decidere inoltre la quantità di Frame per cui si protrarranno tali eventi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6826,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6743,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6039,
          "asker": {
            "courseId": 100,
            "askerId": 925,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la sottoclasse Transition e come viene implementata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " animation"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6037,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono Transition e Timeline ? Come si usano ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " animazione"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6047,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una curva di Bézier? Come sono implementate in Java FX (tramite quali classi)?\r\nQual'è l'utilità delle curve di Bézier nelle animazioni (cioè cosa posso realizzare con tali curve)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "BezierCurve"
            },
            {
              "keyword": " Animation"
            },
            {
              "keyword": " PathTransition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6080,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve il metodo interpolate e in quale caso bisogna integrarlo? Fare un esempio se si vuole per chiarire al meglio il senso del metodo sopracitato.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Animations"
            },
            {
              "keyword": " javaFx"
            },
            {
              "keyword": " layout"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6388,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando si vuole fare un animazione, per non dover creare tutti i frame che la compongono, può esser utile usare la matematica. Interpolate (interpolazione) è un metodo (insieme ad una classe astratta Interpolator) che serve per definire lo stato di ogni frame tra due punti. Sapendo il punto iniziale e quello finale di un animazione, possiamo interpolare lo stato dei punti intermedi dicendoci \"ma quando sono al 50% dell'animazione, cosa devo mostrare?\". In questo modo mentre si scorre l'animazione, viene richiamato il metodo che ridisegna la scena sfruttando l'interpolazione al 0,5. Giocando con la classe Interpolator, è possibile effettuare interpolazioni non lineari come lo sono, per esempio, l'ease-in o ease-out oppure una curva a piacere che descriverà il \"come\" avverrà il movimento su cui vogliamo dare un interpolazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7097,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7020,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6706,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7062,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6389,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 824,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "E' un metodo che deve essere integrato nella dichiarazione di una Transition e serve a definire cosa deve essere eseguito ad ogni frame della Transition. Con setCycleDuration si imposta la durata di ogni frame.\r\nEs:\r\nTransition aminazione1 = new Transition(){\r\n        {  setCycleDuration(Duration.millis(100)); }\r\n        protected void interpolate(double frac) {\r\n             //azioni da eseguire ad ogni frame, in double frac è disponibile per l'uso il tempo passato \r\n             //dall'inizio dell'animazione;\r\n        }\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7095,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6705,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7064,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7022,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6407,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 771,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Durante una transizione il metodo interpolate viene chiamato a ogni frame, e va quindi implementato per definire cosa vogliamo che sia fatto ad ogni frame, il parametro frac passa da 0.0 a 1.0 dall'inizio alla fine della trasizione in maniera lineare e non, cosa che dipende dall'interpolator e può essere cambiata, di default l'incremento è lineare.\r\nUn esempio dell'uso di interpolate è nelle slide riguardanti le animazioni, a pagina 4, dove il valore di frac  viene usato per \"controllare\" quanta percentuale della stringa si vuole mostrare. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7096,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6704,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7021,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7063,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6413,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe astratta Transition (e le sue sottoclassi) richiede l'implementazione del metodo interpolate(double) per essere istanziabile. Il parametro passato è una frazione (istante attuale diviso la durata totale dell'animazione) compresa tra 0 e 1 che definisce istante per istante l' aspetto dell' animazione desiderata. Esempio:           final String content = \"Buongiorno.\";     final Text text = new Text(10, 20, \"\");     final Animation animation = new Transition() {     {     setCycleDuration(Duration.millis(1500));  }     protected void interpolate(double frac) {  final int length = content.length();    final int n = Math.round(length * (float) frac);      text.setText(content.substring(0, n));   } /* qui frac è arrotondata a un intero e specifica quanti caratteri della stringa mostrare in un dato fotogramma dell' animazione, la quale ha periodo 1500 millisecondi*/  };    animation.play();  /* interpolate modificherà il fotogramma mostrato in funzione del tempo in millisecondi*/",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7060,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7098,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6707,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7023,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6361,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo interlolate gestisce la transionione di un oggetto nella finestra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7019,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7099,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7061,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6703,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6079,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual e' la differenza tra Transition e Timeline? Quale delle due mi conviene usare[specificare utilizzo nei casi].",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": " Transition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6100,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono la timeline e i key frames?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": " key frame"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6060,
          "asker": {
            "courseId": 100,
            "askerId": 841,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una Timeline e come viene definita?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": "keyframes"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6450,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una Timeline può essere utilizzato per definire una forma di animazione, dove vengono definite le sue proprietà associate, come la dimensione, la posizione e il colore.\r\nTimeline viene definita in una public class.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6782,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7006,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6700,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6789,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6366,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La Timeline è una classe che estende Animation, definita tramite uno o più KeyFrame aggiunti secondo una specifica sequenza ed ognuno riferito a un certo tempo  relativo (ogni KeyFrame ha un attributo time che specifica in che momento della timeline è collocato).\r\nUna timeline viene attivata tramite il metodo play(). Si possono inoltre definire con appositi metodi la durata dell'animazione (che può essere infinita) e il KeyFrame corrispondente all'istante zero. Se quest'ultimo non viene definito dal programmatore, un KeyFrame di default verrà sintetizzato a partire dai valori delle variabili su cui agiranno i successivi KeyFrame, nel momento in cui viene chiamata la funzione Animation.play().\r\nInfine, l'animazione che vedremo a runtime sarà determinata dall'interpolazione dei KeyFrame lungo la timeline, che porteranno alla modifica di un gruppo di variabili o oggetti nei vari istanti della riproduzione.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7004,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6701,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6783,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6790,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6394,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Timeline è una classe che estende Application. E' usata per creare animazioni in Javafx. Per implementarla è anche necessario definire dei KeyFrame (che verranno eseguiti sequenzialmente), oggetti che hanno come valori delle loro key (KeyFrame.value) le specifiche dell'animazione ad un determinato tempo t (specificato dal programmatore). Questi valori sono poi interpolati al tempo specificato rispetto alla posizione iniziale del Timeline. In particolare non è specificato quando il KeyFrame viene processato, è solo noto quando sono processate le varie key. Inoltre di default se non viene definita una key per t=0, ne viene creata una con i valori iniziali (ovvero quelli presenti quando viene chiamato il metodo Application.play()). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6784,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6791,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7005,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6702,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6026,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra Transition e Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": "timeline"
            },
            {
              "keyword": "animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6106,
          "asker": {
            "courseId": 100,
            "askerId": 878,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra template e layout?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " gui"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6034,
          "asker": {
            "courseId": 100,
            "askerId": 830,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "spiegare la getTranslation",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "get"
            },
            {
              "keyword": " translation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6098,
          "asker": {
            "courseId": 100,
            "askerId": 893,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un KeyFrame? Spiega il suo ruolo in JavaFX.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "KeyFrame"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6089,
          "asker": {
            "courseId": 100,
            "askerId": 862,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la chiamata super();? Trovata nello svolgimento del test d'esame fornito dal Prof.(PrintStage)\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": "boh"
            },
            {
              "keyword": "esercizio"
            },
            {
              "keyword": "animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6074,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega a cosa serve e come funziona la Timeline portando anche degli esempi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6018,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi si usa Transition e in quali si usa Timeline ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " transition"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6066,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè nella classe animation non sono stati creati i metodi play() stop() pause()? Spiega come sono usati!",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "a"
            },
            {
              "keyword": "b"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6075,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Questo frammento di codice dovrebbe associare ad un'istanza di Circle un listener che risponda ai click del mouse. Per quale motivo non funziona? Qual è la versione corretta?\r\n\r\nCircle circle = new Circle(radius);\r\ncircle.addEventHandler(ActionEvent.ACTION, new EventHandler<ActionEvent>()\r\n{\r\n        @Override\r\n        public void handle(ActionEvent event)\r\n        {\r\n                // do something useful here\r\n        }\r\n});",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " Events"
            },
            {
              "keyword": " Mouse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6045,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste la Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6067,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come può essere utilizzato il CubicCurve? Che metodi ha e secondo quali parametri può essere modificata? Fare un elenco di tutti i metodi per il controllo e per la creazione di un pathtransition ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "cubiccurve"
            },
            {
              "keyword": " pathtransition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6051,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Su quali classi si basa il funzionamento della Timeline (sottoclasse di Animation)? Spiegare quali sono le due modalità in cui possiamo usare tale classe (quali sono le 2 tipologie di animazioni che ci permette di ottenere). ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": " Animation"
            },
            {
              "keyword": " frame"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6035,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione di \"double frac\" e di interpolate?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "frac"
            },
            {
              "keyword": " interpolate"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6053,
          "asker": {
            "courseId": 100,
            "askerId": 880,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un PathTransition? Come viene implementato?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "animazioni"
            },
            {
              "keyword": " path"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6448,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un PathTransition concretizza l'idea di movimento lungo un percorso fissato. \r\n\r\nLa sua implementazione richiede:\r\n1)la costruzione di uno o più nodi presenti nell'animazione.\r\n2)la costruzione di uno o più oggetti path, lungo il quale avverà il movimento.\r\n3)la definizione di un metodo che descrive i movimenti dei nodi presenti.\r\n\r\nLa realizzazione del punto 3 è semplificato dall'uso dalla classe PathTransition, sottoclasse di Transition, che con il costruttore:\r\n\r\nPathTransition(Duration duration, Shape path, Node node)\r\n \r\npermette di impostare nodo, path e durata della singola animazione. \r\n\r\nReferenze: \r\n-http://docs.oracle.com/javafx/2/animations/basics.htm \r\n-https://docs.oracle.com/javafx/2/api/javafx/animation/PathTransition.html \r\n-slides Animation del corso\r\n\r\n\r\n\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7009,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7017,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6786,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6422,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il PathTransition è un tipo di transition, ovvero un movimento degli oggetti durante l'esecuzione di una applicazione in Java con una durata (duration) definita dal programmatore in fase di compilazione. \r\nNel caso del PathTransition, dopo aver definito l'oggetto che si vuol muovere, si passa a definire la traslazione dichiarando dei percorsi, anche diversi tra loro (ex: moveTo, CubicCurveTo, ecc. ); questi poi tramite la chiamata 'path.getElements().add(nomi_traslazioni)' verrano eseguiti nell'ordine.\r\nE' possibile inoltre definire la durata della traslazione e una sua eventuale ciclicità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6785,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7007,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7015,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6406,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le pathTransition si usano per costruire un'animazione lungo un percorso prestabilito più complicato. Per utilizzarle si deve costruire un oggetto di classe Path, il quale ha come children oggetti di tipo PathElement che servono a comporre il percorso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7016,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6787,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7008,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6456,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Un PathTransition è un'animazione, nello specifico una transizione lungo un percorso prestabilito.\r\nIn buona sostanza per implementarlo è sufficiente creare il percorso (il \"Path\" appunto) appoggiandosi a varie classi quali MoveTo, ArcTo, QuadCurveTo e, successivamente è sufficiente chiamare il metodo  moveObjectOnPath passandogli l'oggetto che si desidera muovere e il percorso creato precedentemente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7018,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6788,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7010,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6010,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la classe key-frame nelle animation di java fx?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "utilizzo"
            },
            {
              "keyword": " key-frame"
            },
            {
              "keyword": " animation"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6020,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "E' più flessibile una Timeline o una (o una qualsiasi subclass di) Transition? Detto questo, qual'è di più semplice utilizzo e permette di creare animazioni complesse con poche righe e \"poca fatica\"?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " Animation"
            },
            {
              "keyword": " Transition"
            },
            {
              "keyword": " Timeline"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6374,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La più flessibile è la Timeline.\r\nInoltre, la più semplice e pratica è anch'essa la Timeline.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6926,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6844,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6673,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6720,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6780,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6794,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6431,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Sicuramente la più flessibile tra le due è la Timeline in quanto la Transition offre solo dei metodi basilari per creare delle animazioni mentre la Timeline è molto più complessa. Allo stesso tempo, essendo molto più complessa, creare un'animazione è più faticoso perchè le animazioni di una Timeline si basano sui KeyFrame e non su semplici movimenti",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6781,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6721,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6845,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6674,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6927,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6795,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6452,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Sicuramente una Timeline è più flessibile di una Transition, la prima infatti permette di definire più effetti al suo interno in quanto è possibile creare più blocchi o KeyFrames ognuno dei quali associato ad un azione i quali verranno composti automaticamente, mentre una Transition è più semplice, infatti è in grado di mettere in atto un singolo effetto.\r\n\r\nDetto questo, una Transistion è spesso la soluzione di più facile attuazione, in quanto permette di definire le singole azioni tramite le sue molte sottoclassi e di comporle tramite ParallelTransition e SequentialTransition, ottenendo effetti complessi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6842,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6778,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6671,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6924,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6792,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6718,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6432,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Le animazioni in JavaFX si dividono tra Transition e Timeline (entrambe sono sottoclassi della classe Animation).\r\nTransition permette di definire animazioni (modificare la trasparenza di un oggetto, spostare un oggetto lungo un cammino) e di combinarle eseguendone due o più contemporaneamente o sequenzialmente. In questo tipo di animazione, viene chiesto all'utente di esplicitare delle specifiche quali la direzione di movimento (il cammino che si desidera l'oggetto segua) o i dx di spostamento (di quanto l'oggetto deve muoversi, nell'unità di tempo). Ciò rende l'animazione flessibile in quanto viene controllata manualmente.\r\nTimeline definisce delle animazioni più \"automatizzate\": per ottenere uno spostamento utilizzando le funzionalità di Timeline, verrà richiesto di inserire la posizione iniziale, la posizione finale e la durata del processo di spostamento. Il sistema poi costruirà le fasi intermedie di spostamento. Ciò rende minimi i comandi richiesti, riducendo le righe di codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6779,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6925,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6719,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6793,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6672,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6843,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6057,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le classi ParallelTransition e SequentialTransition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transitino"
            },
            {
              "keyword": " parallel"
            },
            {
              "keyword": " sequential"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6058,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "E' sempre necessario impostare la durata di una transizione? se non la imposto cosa succede?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transizione"
            },
            {
              "keyword": " javafx"
            },
            {
              "keyword": " timer"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6061,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra transition e timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6085,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si cambiano le coordinate in un pane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "coordinate"
            },
            {
              "keyword": "pane"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6070,
          "asker": {
            "courseId": 100,
            "askerId": 894,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali animazioni fornite da JavaFX? Cosa e' un frame?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "intervallo"
            },
            {
              "keyword": " cinema"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6395,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Le animazioni si dividono in 2 gruppi:\r\n\r\n-Timeline: creano una \"sequenza cinematografica\" e costruiscono l'animazione a partire da una sequenza di KeyFrame (\"singoli fotogrammi\" di una data durata).\r\n\r\n-Transition: meno flessibili in generale, ma permettono animazioni complesse con minor sforzo. Generano una transizione da un valore ad un altro (es: la posizione, l'opacità (trasparente a visibile passando per la semitrasparenza). Esistono svariate Transition per vari obbiettivi: una translazione, una translazione lungo un percorso, l'opacità, la composizione di altre transition in sequenza o in parallelo. E' inutile elencarle tutte visto che concettualmente sono la stessa cosa, cambia solo i valori su cui agiscono (a parte per ParallelTransition e SequentialTransition che servono per la composizione).\r\nRimando a http://docs.oracle.com/javafx/2/animations/basics.htm\r\n\r\nInoltre si possono creare facilmente KeyFrame a partire da KeyValues, i valori intermendi saranno generati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7058,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6863,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6761,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6859,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7082,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6777,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7011,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6402,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Le classi principali per fare animazioni in JavaFx sono le due sottoclassi \r\ndi Animation: \r\n-Transition che obbliga ad implementare il metodo interpolate che ha come parametro un double, cioè il parametro frac, un valore che varia tra 0 e 1 in base all'istante in cui ci troviamo, infatti nel costruttore possiamo definire vari parameteri per l'animazione, ad es. setCycleDuration per impostare la durata di un ciclo del''animazione e setCycleCount per definire per quanti cicli deve proseguire.Nel metodo interpolate possiamo definire un'animazione\r\nche si evolve al variare del paramtetro frac\r\n-Timeline che permette di assegnargli o un KeyFrame in cui definiamo un'animazione in modo analogo alla Transition oppure associargliene diversi per diversi istanti di tempo e lasciargli calcolare l'interpolazione (più semplice) tra 2 o più valori di alcuni paramteri dei nodi specificandoli tramite dei KeyValue.\r\nUn frame è ciò che viene visualizzato in uno specifico istante dell'animation.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7014,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6860,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6774,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6758,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7081,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6856,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7056,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6447,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "In Java esiste la classe Animation che mette a disposizione del programmatore una serie di metodi e funzionalità per gestire le animazioni (per esempio play, stop, pause) e il loro ciclo di durata.\r\nIn particolare poi, esistono due sottoclassi di Animation: Transition e Timeline.\r\nTransition permette di specificare il punto iniziale e quello finale di un'animazione. Con un metodo interpolate è quindi possibile specificare il modo in cui l'animazione si dovrà svolgere.\r\nCon Timeline è invece possibile definire frame per frame come avverrà l'animazione.\r\nUn frame è un fotogramma, cioè l'immagine di un oggetto in uno specifico momento. Tanti frame disposti in sequenza in un certo spazio di tempo creano l'illusione che l'oggetto si muova, creando quindi l'animazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7057,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6760,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6858,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7080,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6776,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6862,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7012,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6445,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le principali animazioni di fornite da javafx sono Transitions ,Timeline Animation e Interpolators. I frame sono le singole immagini che compongono l'animazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7013,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7083,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6861,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7059,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6775,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6857,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6759,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6084,
          "asker": {
            "courseId": 100,
            "askerId": 836,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile applicare delle animazioni ai canvas ? In caso contrario spiegarne la motivazione.",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "canvas"
            },
            {
              "keyword": " javaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6398,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Tecnicamente si può applicare un'animazione al canvas, in quanto è un Nodo come gli altri. Ciò che non si può fare direttamente è applicare un'animazione ad uno dei contenuti del canvas, in quanto essi non sono nodi, ma semplici disegni applicati direttamente sul canvas.\r\n\r\nSi può simulare un'animazione ai contenuti del canvas semplicemente pulendo e ridisegnando in continuazione tutti i contenuti, applicando loro le trasformazioni desiderate (posizione, colore, dimensione, opacità, ...).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6840,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6836,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6969,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6986,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6441,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "La risposta potrebbe sembrare alquanto presuntuosa, ma è : Dipende. La canvas è una regione del display che viene trattata come un'immagine, ossia viene paragonata ad una matrice di pixel sulla quale si può disegnare. Tuttavia essa porta con sè anche una limitatezza; Se per esempio creiamo un cerchio sulla nostra canvas, questo non può più essere rimosso, in quanto è un aggregato di pixel delineati all'interno dell'area.\r\nSe vogliamo realizzare un'animazione di un cerchio che si muove all'interno di un rettangolo, siamo costretti a disegnare continuamente il rettangolo con il rispettivo cerchio spostato di qualche pixel. \r\nRettangolo->Cerchio(iniziale)->Rettangolo(ridisegnato e sovrapposto al precendente rettangolo e cerchio)->Cerchio(nuova posizione). In questo modo si dà l'illusione del movimento. Il cerchio quindi non è un'entità a sè stante che possiede le sue proprietà, così come avviene per Circle (Shape). Ovviamente non è possibile associare una Animation ad un entità di canvas ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6834,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6971,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6988,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6838,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6453,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La canvas rappresenta uno spazio che può essere paragonato ad una tela per pittura, ossia tutto quello che viene disegnato rimane impresso senza possibilità di cancellarlo. Di conseguenza se si disegna una forma geometrica come per esempio un rettangolo, esso verrà rappresentato da un insieme di pixel. Questa forma geometrica però non possiede le proprietà di un Rectangle derivato da una Shape, di conseguenza è privo di proprietà. Sostanzialmente non è più possibile agire sull?oggetto dopo che è stato disegnato (canvas), a differenza del Rectangle, il quale invece può essere manipolato (dimensioni,posizione).\r\nQuesto implica l?impossibilità di assegnare un Animazione ad un oggetto disegnato nella canvas in quanto quello che si è disegnato non può essere identificato come ?oggetto a sé stante?.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6985,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6841,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6968,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6837,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6446,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il problema principale nell'applicare animazioni agli elementi di un canvas è che le figure al suo interno non sono oggetti ma un insieme di pixel. Cioè usando il metodo drawLine non si crea un oggetto linea ma viene seplicemente visualizzato sul canvas una linea, quindi non si più applicare un'animazione su di essa inquanto non esiste. Se si volesse applicare animazioni sui canvas si è costretti a cancellare (o sovrascrivere con il colore di sfondo) parti del canvas e dipingerle la nuova area simulando un'animazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6987,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6970,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6835,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6839,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6069,
          "asker": {
            "courseId": 100,
            "askerId": 762,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il miglior modo per implementare una tabella?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": "tabella"
            },
            {
              "keyword": "Implementazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6052,
          "asker": {
            "courseId": 100,
            "askerId": 912,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un KeyFrame?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "significato"
            },
            {
              "keyword": " Keyframe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6428,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un KeyFrame può essere considerato come un fotogramma (principale) dell'animazione.\r\nLa classe KeyFrame di JavaFx definisce i valori assegnati ad un certo gruppo di variabili in un dato momento, in altre parole la \"fotografa\" la situazione dell'insieme di variabili un un dato istante (ad esempio le coordinate di un cerchio che intendiamo far muovere in una finestra, in un determinato istante dell'animazione). La classe definisce diversi KeyFrame e un interpolatore per ogni variabile considerata, che ricostruisce i passaggi intermedi dando vita all'animazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6884,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6961,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7036,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7055,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6367,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il KeyFrame definisce dei valori che avranno alcune variabili in un preciso istante . Questi valori vengono interpolati lungo la Timeline.\r\n\r\nIl programmatore deve gestire l'interpolazione di un insieme di variabili per l'intervallo tra fotogrammi successivi, fornendo un valore di target e un interpolatore associato a ogni variabile. \r\nLa funzione onFinished viene chiamata su ogni keyframe  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7039,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6958,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6880,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7053,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6378,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Un KeyFrame è una classe di javaFX che si trova in javafx.animation.KeyFrame\r\nIl KeyFrame l'abbiamo usato principalmente nella Timeline e serve per definire le immagini sequenziali che formano il 'video' finale che si ottiene e così come nei video, anche i KeyFrame, più il tempo tra un keyframe e il successivo è basso e più l'animazione è fluida.\r\nIl costruttore più usato è:\r\npublic KeyFrame(Duration time, EventHandler<ActionEvent> onFinished, KeyValue... values)\r\nIn cui i parametri indicano:\r\ntime - il tempo di durata\r\nonFinished - l'evento che viene chiamato ad ogni frame per modificarlo\r\nvalues - un KeyValue\r\n\r\nQuesto costruttore, così come gli altri, può generare le seguenti eccezioni:\r\n1) java.lang.NullPointerException\r\n2) java.lang.IllegalArgumentException\r\n\r\nIn cui la prima viene generata se il 'time' passato è null; mentre la seconda se il 'time' passato è invalido.\r\n\r\nQueste eccezioni, come in tutti i casi, si possono gestire tramite la sintassi:\r\ntry{\r\n  //code\r\n}catch(Exc){}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7051,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7038,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6882,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6957,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6392,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": "Innanzitutto il KeyFrame è maggiormente usato in una Timeline. Una timeline è una linea temporale che modifica all'interno di un programma un certo tipo di animazione, come il movimento di una palla, e per far muovere questo oggetto si serve di un KeyFrame, che permette di decidere ogni frazione di tempo,di nostra scelta, un cambiamento di qualsiasi tipo all'oggetto (velocità, direzione, colore e spostamento).\r\n\r\nTimeline t1 = new Timeline();\r\nKeyframe keyframe = new KeyFrame(Duration.seconds(un paramentro a scelta), new EventHandler(){\r\n   public void handle(Event event){\r\n.........} //Funzione qualsiasi per qualsiasi tipo di cambiamento all'oggetto che si vuole modificare\r\n});\r\nt1.setCycleCount(INDEFINITE);\r\nt1.play();\r\nLa Duration è il parametro che ti consente di decidere ogni quanto l'azione Keyframe deve ripetersi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6959,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7040,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6883,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7052,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6426,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un KeyFrame (letteralmente fotogramma-chiave ) è un tipo di \"fotogramma\" che definisce un determinato stato temporale all'interno di una Timeline, come la posizione di un oggetto al tempo iniziale, intermedio o finale. Generalmente sono gli istanti in cui l'oggetto che si vuole animare raggiunge la posizione \"estrema\" prima di cambiare stato, come nel caso di una pallina che rimbalza, il punto più basso ed il più alto del rimbalzo.\r\nStabilita una successione di KeyFrames è compito del programmatore stabilire il metodo secondo il quale devono essere intepolate, cioè legate, nell'animazione finale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7037,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7054,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6881,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6960,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6029,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e a cosa serve la Timeline ? Fare un'esempio di un suo utilizzo\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Slides"
            },
            {
              "keyword": "Timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6005,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo si può definire un percorso che un oggetto(ad esempio un cerchio) deve seguire a schermo?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javafx"
            },
            {
              "keyword": " percorso"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6014,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Si possono eseguire 2 animazioni contemraneamente?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "animazioni"
            },
            {
              "keyword": " contemporaneamente"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6368,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 925,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì è possibile eseguire 2 o più animazioni contemporaneamente, utilizzando la classe ParallelTransition.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6936,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6753,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6893,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6663,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6923,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6767,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6405,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì, è sufficiente creare due oggetti di tipo Animation e chiamare su entrambi il metodo play(). Esempio di applicazione che esegue due animazioni contemporaneamente: http://porkynator.altervista.org/TwoAnimations.java",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6922,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6664,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6752,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6935,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6892,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6766,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6457,
              "task": {
                "taskId": 176,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì. Le animation in JavaFX possono essere divise in timeline animation e transition.\r\nLe transition provvedono a incorporare animazioni su una timeline interna e possono essere composte per creare animazioni multiple da eseguire in parallelo o in sequenza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6891,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6934,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6765,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6662,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6751,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6921,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 176,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6013,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In java fx  per gestire le action viene adoperato il metodo cutter,si specifichino le modalità di utilizzo,eventuali vantaggi nella gestione degli eventi con il comando cutter.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "fx"
            },
            {
              "keyword": "cutter"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6019,
          "asker": {
            "courseId": 100,
            "askerId": 904,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono gestite le animazioni nella timeline tramite l' utilizzo dei frame? E quali sono i tool che permettono di gestirli?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "frame"
            },
            {
              "keyword": " tool "
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6030,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo combinanando le classi timeline e keyframe si ottiene un animazione? Scrivere un breve esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "keyframe"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6003,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali differenze di implementazione ed utilizzo si presentano tra le sottoclassi Transition e Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": " timeline"
            },
            {
              "keyword": " implementazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6022,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali anaimazioni in java? Elencarle e descriverle. La classe animation conrtiene metodi statici? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": "java"
            },
            {
              "keyword": "animazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6104,
          "asker": {
            "courseId": 100,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali metodi che implementano le animazioni in JavaFX? Elencare inoltre le due principali sottoclassi di Animation con una breve spiegazione di quest'ultime.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " animation"
            },
            {
              "keyword": " subclasses"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6033,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Nelle animation le istanze MoveTo HlineTo LineTo ArcTo, cos'hanno di diverso da un semplice Move HLine line ecc, cosa crea il \"To\"?. Spiega con esempi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": " MoveTo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6077,
          "asker": {
            "courseId": 100,
            "askerId": 809,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono timeline e keyframe? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " keyframe "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6102,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una timeline e come funziona?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " keyframe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6001,
          "asker": {
            "courseId": 100,
            "askerId": 824,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale differenza c'è tra Timeline e Transition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Timeline"
            },
            {
              "keyword": " transition"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6012,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 175,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa é una timeline",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "definizione"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 56,
      "lectureTitle": "Lezione 1-2",
      "questions": [
        {
          "questionId": 5095,
          "asker": {
            "courseId": 100,
            "askerId": 893,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per \"zucchero sintattico\" (syntactic sugar)? Scrivere un esempio.",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "zuccherosintattico"
            },
            {
              "keyword": " syntacticsugar"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5370,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 881,
                "courseId": 100,
                "courseFinalScore": 9
              },
              "answerText": "Con zucchero sintattico si intende l'uso di costrutti sintattici per rendere il codice più leggibile ma che non influiscono sulle funzionalità del programma.\r\nUn esempio potrebbe essere l'uso delle quadre nella notazione delle matrici in C++.\r\n*(*(x+i)+j) diventa x[i][j]\r\nSono entrambi giusti e fanno la stessa cosa, ma il secondo è più intuitivo del primo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2713,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2790,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2466,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2625,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5451,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Uno zucchero sintattico è un altro modo, di solito più semplice e immediato,per definire costrutti sintattici di un linguaggio di programmazione che non hanno effetto sulla funzionalità del linguaggio, ma ne rendono più facile l'uso.\r\nUn esempio se vuoi aumentare una variabile x invece che scrivere x+1 scrivo x++.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2623,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2711,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2464,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2792,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5346,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 885,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Zucchero sintattico è un aggettivo che si dà ad alcuni costrutti della sintassi di un linguaggio di programmazione per indicare il fatto di essere stati creati per semplificare il lavoro del programmatore. Ad esempio nei puntatori gli indici con le parentesi quadre (*p[n]) non sono altro che zucchero sintattico per indicare in realtà i frame successivi al primo indirizzo di memoria. Infatti *p [1] è equivalente a (p +1)*.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2622,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2710,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2467,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2791,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5338,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Per zuccherino sintattico si intende un tipo di sintassi di un linguaggio di programmazione atta a semplificare una certa scrittura. Grazie ai zuccherini sintattici il codice diventa più leggibile, si applicano in scritture che vengono usate abbastanza spesso come in c++ \"int a++\"  (a=a+1) o \"a->b\" (*a.b). Il principio è paragonabile alla mamma che da la propoli su un zuccherino al figlio per rendere la medicina più gustosa. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2624,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2789,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2712,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2465,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5021,
          "asker": {
            "courseId": 100,
            "askerId": 839,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità dei puntatori a puntatori? Un esempio di utilizzo",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5029,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile predire con certezza l'output del seguente segmento di codice? Se sì, qual'è? Motivare la risposta.\r\n\r\n#include <iostream>\r\n\r\nint *foo(void) {\r\n  int bar = 5;\r\n  return &bar;\r\n}\r\n\r\nunsigned add(unsigned a, unsigned b) {\r\n  if(a == 0) return b;\r\n  return add(a-1, b+1);\r\n}\r\n\r\nint main() {\r\n  int *ptr = foo();\r\n  cout << add(2, 3);\r\n  cout << \" == \" << *ptr << endl;\r\n  return 0;\r\n} ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pointer"
            },
            {
              "keyword": " stack mechanism"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5063,
          "asker": {
            "courseId": 100,
            "askerId": 824,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Con 32bit e 64bit si intende il numero di bit che compongono gli indirizzi della memoria, il numero di dati che il processore può elaborare in un sola operazione o entrambi?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Dimensione"
            },
            {
              "keyword": " Indirizzi"
            },
            {
              "keyword": " Dati"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5450,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con 32bit o 64bit si vuole indicare la dimensione di diverse unità di dati.\r\nNel caso del processore, o CPU, servono a dare una dimensione ai registri interni e ai dati che un processore riesce ad elaborare contemporaneamente in un'operazione.\r\nMa con i bit può essere indicata anche la dimensione dei dati che vengono portati nella memoria al momento della lettura o della scrittura.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2478,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2393,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2437,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2454,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2607,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2331,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5468,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le due terminologie usate in senso generale indicano sia il numero di bit che compongono gli indirizzi della memoria, sia anche il numero di dati che il processore elabora tramite lettura o scrittura.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2434,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2609,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2391,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2329,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2479,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2453,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5429,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Solo la prima.\r\nGli indirizzi sono a 64 bit ma i registri del processore rimangono a 32.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2455,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2608,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2332,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2435,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2481,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2394,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5421,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Con 32bit e 64bit si intendono entrambe le cose; infatti in un'architettura a 32bit si ha un bus, cioè un insieme di fili che collegano il processore alla memoria RAM in grado di trasportare 32 bit alla volta, mentre un'architettura a 64 bit è in grado di lavorare con 64 bit per volta. Inoltre con un'architettura a 32bit si possono gestire fino a 4 Gb di RAM, ossia vengono gestiti 2 elevato alla 32 indirizzi di memoria; in un architettura 64bit invece si arrivano a gestire 2 elevato alla 64 indirizzi di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2456,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2606,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2392,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2330,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2480,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2436,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5156,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In base all' introduzione e al richiamo del c++ in ambito pratico dove conviene l'utilizzo del c++ e di java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "confronto"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            },
            {
              "keyword": " lavoro"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5085,
          "asker": {
            "courseId": 100,
            "askerId": 859,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono le variabili globali e quali effetti negativi possono comportare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "visibilità"
            },
            {
              "keyword": " modifiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5071,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "che differenza c'è a livello di compilazione tra il linguaggio di programmazione Java e il c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Compilazione"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5054,
          "asker": {
            "courseId": 100,
            "askerId": 848,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali errori si può incorrere utilizzando variabili globali invece che le variabili automatiche (locali)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " globali"
            },
            {
              "keyword": " automatiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5145,
          "asker": {
            "courseId": 100,
            "askerId": 879,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In C++, per il passaggio di parametri per riferimento si fa uso di puntatori. E' possibile definire una funzione che restituisca più di un valore in output senza l'uso di essi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "parametri"
            },
            {
              "keyword": " riferimento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5042,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Java deve il suo successo ad una sua caratteristica particolare che la differenzia da altri linguaggi come il C++. Spiegare brevemente di cosa si tratta e in che modo viene realizzato.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5061,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali motivazioni che hanno portato alla nascita di Java e cosa lo contraddistingue dai linguaggi di programmazione tradizionali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " caratteristiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5151,
          "asker": {
            "courseId": 100,
            "askerId": 885,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché la maggior parte dei linguaggi di programmazione moderni hanno scope statico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "caratteristiche dei linguaggi"
            },
            {
              "keyword": " scope statico"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5031,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Mettiamoci nella situazione di un linguaggio senza puntatori (tipo Java).\r\nSe volessimo creare una funzione che ha più valori di ritorno (slide 24 lez 2), come possiamo fare non avendo i puntatori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": "funzioni"
            },
            {
              "keyword": "multi-output"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5101,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza fra scope statico e dinamico,qual'è il più diffuso e perchè?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "scope"
            },
            {
              "keyword": "statico"
            },
            {
              "keyword": "dinamico"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5049,
          "asker": {
            "courseId": 100,
            "askerId": 855,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In questo esempio, a pagina 35 della seconda lezione non capisco come fanno i 3 esempi a essere equivalenti.\r\n\r\nconst int N=4;\r\n1)  void printLargest(int v[]) { \r\n2)  //  void printLargest(int *v) {     è equivalente \r\n3)  //  void printLargest(int v[2]) {    è equivalente \r\nint largest=v[0];\r\nfor(int i=1;i<N;i++)\r\nif (largest<v[i]) largest=v[i];\r\ncout<< \"Il massimo e': \"<<largest<<\"\\n\"; \r\n\r\nNel terzo esempio non capisco perchè inserisce un int v[2], così se passi il vettore di lunghezza N non viene ridotto a lunghezza 2? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vettori"
            },
            {
              "keyword": "funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5023,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza/e tra stack e heap?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " heap"
            },
            {
              "keyword": " differenza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5326,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 907,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Lo stack e l'heap sono due differenti sezioni di memoria; nello stack vengono allocate le variabili locali e parametri formali delle funzioni mentre nello heap sono allocate le variabili dinamiche la cui dimensione non è determinabile a momento di compilazione.\r\n\r\nLa disposizione di stack e heap può essere visto come una pila alla cui cima si trova lo stack che \"cresce\" verso il basso mentre alla base si trova l'heap che \"cresce\" verso l'alto. Quando stack e heap \"collidono\" si genere l'overflow, che in sostanza è una sovrapposizione di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2633,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2728,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2664,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2513,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5417,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 887,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "la differenze tra le memorie e che la stack e una memoria variabile che usa più o meno memoria x allocare tutte le variabili utilizzati dal programma in runtime mentre la memoria della heap e decisa dal programmatore. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2514,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2727,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2632,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2663,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5320,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Sono 2 meccanismi per l'allocazione di memoria con scopi diversi. Lo stack è controllato automaticamente e contiene i frame delle funzioni chiamate, che vengono scartati a funzione terminata (normalmente modificando un puntatore alla cima dello stack, senza azzerare la memoria). L'heap soddisfa le richieste di memoria manuali ([m/c]alloc per c, new per C++) allocazione e deallocazione sono a carico del programmatore.\r\nSi pongono l'obiettivo di risolvere due problemi diversi:\r\nLo stack permette l'implementazione di funzioni ricorsive, che non sarebbe possibile ad esempio con allocazione statica, permettendo inoltre di contenere l'uso di memoria alla quantità necessaria in ogni momento;\r\nL'heap permette la gestione di casi in cui non si conoscono a priori le dimensioni senza ricorrere a sovra-allocazione; in questo modo si può usare l'effettiva quantità di memoria che il problema richiede e non si rischia di aver preallocato uno spazio troppo piccolo (es char s[80] -> massimo 79 lettere)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2630,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2661,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2512,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2725,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5415,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 849,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sono entrambe aree di memoria dove sono allocate le costanti e le variabili di un programma durante la sua esecuzione.\r\nNello stack i dati sono allocati staticamente in una pila, secondo la modalità \"Last In First Out\". Il sistema operativo si occupa dell'allocazione dei dati all'avvio della relativa funzione, e alla loro deallocazione al termine di questa. Le dimensioni delle costanti/variabili devono essere note al momento della compilazione: ciò ottimizza al massimo la gestione della memoria.\r\nNella heap invece i dati sono allocati dinamicamente: a run-time è allocato uno spazio delle dimensioni necessarie, ed è creato un puntatore ad esso, che può essere visibile e manipolabile dal programmatore solo se il linguaggio lo permette. È compito del programmatore scegliere la funzione più adatta all'allocazione dei dati, e di deallocarli una volta terminata la loro utilità, pena il calo di prestazioni della macchina dovuto a memory leaks, ovvero spazi allocati inutilizzati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2631,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2511,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2726,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2662,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5109,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Java nasce con l'obbiettivo di risolvere il problema della portabilità del codice. Perchè non deve quindi essere estendibile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " portabilità"
            },
            {
              "keyword": " estendibile"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5116,
          "asker": {
            "courseId": 100,
            "askerId": 878,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè le variabili globali vengono gestite in modo differente da quelle automatiche, addirittura con un area diversa nel modello della memoria?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "C++"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5395,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": "Le variabili globali vengono gestite in modo differente rispetto a quelle automatiche perchè svolgono un ruolo diverso. Le variabili globali non appartengono a nessun blocco, ma appartengono al programma nella sua interezza. Le variabili automatiche invece, sono visibili al programma solo nel blocco in cui sono presenti e quando si esce dal blocco cessano di esistere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2533,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2743,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2413,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5369,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "L'Area Dati Statici è un'area di memoria destinata a contenere le variabili globali o quelle allocate staticamente, mentre l'Area Stack è destinata a contenere le variabili locali ed eventuali parametri formali di una determinata funzione. \r\nLe variabili locali/automatiche sono definite all'interno di una certa funzione o blocco che le usa; di conseguenza \"nascono\" quando la funzione entra in esecuzione e \"muoiono\" al termine della funzione stessa. Questo tipo di variabili non sono quindi visibili all'esterno del blocco in cui sono state definite.\r\nLe variabili globali sono definite solitamente all'inizio del programma e sono visibili fino alla fine del codice. Questo implica anche la possibilità di modificarle in un qualsiasi punto del programma. Tuttavia l'uso di queste variabili può risultare rischioso, vista la difficoltà nell'individuare eventuali modifiche apportate. Difatti anche le difficoltà delle operazioni di debugging saranno proporzionali alla complessità del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2411,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2744,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2532,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5371,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La vita delle variabili globali coincide con l'intera durata del programma. Per questo motivo esse sono staticamente pre-allocate in un'area di memoria dedicata. Al contrario, la vita delle variabili automatiche coincide con quella del blocco in cui sono definite. Per questo motivo sono allocate sullo stack, nel record del blocco che le definisce, nel momento in cui inizia l'esecuzione del suddetto blocco, e sono automaticamente \"eliminate\" dallo stack nel momento in cui, all'uscita del blocco, l'intero record viene \"eliminato\". Questa gestione permette tra l'altro l'esistenza di più copie della stessa variabile (come nel caso di funzioni ricorsive).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2412,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2534,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2742,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5117,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenze ci sono tra il passaggio di parametri per valore e per indirizzo in una funzione? In particolare, quali sono gli svantaggi e i vantaggi? Fare un esempio di funzione a piacere sia per valore che per indirizzo. ",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": " indirizzo"
            },
            {
              "keyword": " valore parametro "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5375,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il passaggio di parametri per valore è un modo molto comune per passare informazioni a una funzione ossia viene copiato il valore, questo consuma più memoria rispetto al passaggio per riferimento ma mi consente di modificare solo la variabile copiata alla funzione.\r\nIl passaggio di parametri per indirizzo passa alla funzione l?indirizzo e non il valore dell?argomento. Questo approccio richiede meno memoria rispetto alla chiamata per valore, e soprattutto consente di modificare il valore delle variabili che sono ad un livello di visibilità esterno alla funzione, questo molto spesso causa errorri in quanto si va a modificare una variabile esterna alla funzione che magari non si voleva modificare.\r\nFaccio due esempi delle dichiarazioni delle funzioni nei due modi sopra descritti:\r\n- passaggio di parametri per valore: int moltiplica (int, int);\r\n- passaggio di parametri per indirizzo: int moltiplica (int *, int *);\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2667,
                  "rater": {
                    "raterId": 799,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2736,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2716,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2771,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5418,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Nel caso di passaggio per valore il valore del param. attuale viene copiato nel param. formale, mentre il passaggio per indirizzo è equivalente al passaggio di un indirizzo per valore. Il principale svantaggio del passaggio per valore é che nel caso in cui il param. attuale sia di grosse dimensioni il passaggio del param. alla funzione diventa computazionalmente oneroso, cosa che invece non avviene nel passaggio per indirizzo in quanto viene passato solamente un riferimento al param. attuale; con il passaggio per valore vi é scambio di informazioni solo dal chiamante al chiamato, mentre il passaggio per indirizzo permette di modificare direttamente le var. di cui viene passato il riferimento e quindi di ottenere side-effects sul chiamante. Questa caratteristica é sia un vantaggio che uno svantaggio in quanto apre la possibilitá di modifiche accidentali (per questo spesso si ricorre al passaggio per indirizzo costante). Es per valore: fact(int n); per indirizzo: stampaArray(float a[]);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2768,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2668,
                  "rater": {
                    "raterId": 799,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2737,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2717,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5316,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "passando per indirizzo si può modificare il valore della cella passata oppure anche modificare celle di cui si conosce la precisa lontananza. passando invece solo il valore non si può modificare la variabile passata ma se ne usa una nuova che si può alterare a piacimento senza dover pensare agli effetti su uno scope più vasto. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2735,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2666,
                  "rater": {
                    "raterId": 799,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2769,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2715,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5448,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 802,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "1Nel passaggio di parametri per valore, alla funzione viene passata solo una copia dell?argomento e il valore della variabile nel programma chiamante non viene modificato. 2Nel passaggio di parametri per indirizzo, i parametri fanno riferimento all'indirizzo della cella di memoria delle variabili del programma principale e si possono ottenere più risultati.\r\nx = &a;    in x indirizzo di a,  &a fornisce l?indirizzo della variabile a \r\nb = *x;    in b valore contenuto nell?indirizzo di x, *x interpreta la variabile x come un puntatore e ritorna il valore contenuto nella cella di memoria puntata\r\n\r\nes1:  void aggiungi1 (int x){ x=x+1;}\r\n        main (){ int a=3; aggiungi1(a); cout<< \"a=\" a;}\r\n\r\nes2: main() { int a,b,x,y; \r\n       int * pa, * pb; \r\n       pa=&a; pb=&b; \r\n       a=1; b=2; \r\n       x=a+b; \r\n       y=*pa + *pb; \r\n cout << a<<\" \"<<b<<\" \"<< x <<endl; \r\n cout << a <<\" \"<< *pb <<\" \"<< y <<endl; \r\n} \r\n\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2665,
                  "rater": {
                    "raterId": 799,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2734,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2770,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2714,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5126,
          "asker": {
            "courseId": 100,
            "askerId": 887,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si genera un ByteCode?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ByteCode"
            },
            {
              "keyword": "JVM"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5381,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Per generare ByteCode e' necessario compilare il codice digitando il seguente comando:\r\n\r\n&javac nomefile.java\r\n\r\nspecificando necessariamente l'estensione del file.\r\n\r\nLa compilazione e' possibile grazie alla JVM.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2328,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2470,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2880,
                  "rater": {
                    "raterId": 887,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2619,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5400,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Il ByteCode è composto da un file con livello intermedio tra il codice macchina ed il sorgente Java. E' generato dal compilatore della macchina e successivamente passerà all'interprete per rendere eseguibile il programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2326,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2469,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2618,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2877,
                  "rater": {
                    "raterId": 887,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5373,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un ByteCode, linguaggio assembly-like, si genera al momento della compilazione di un file con estensione .java tramite il comando $javac, producendo un file .class. Questo contiene il codice binario bytecode da eseguire sulla Virtual Machine(JVM). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2325,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2621,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2471,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2878,
                  "rater": {
                    "raterId": 887,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5402,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 895,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il file ByteCode viene generato dal compilatore",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2327,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2620,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2468,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2879,
                  "rater": {
                    "raterId": 887,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5133,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Di cosa bisogna tenere conto quando si affronta l'aritmetica dei puntatori?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "aritmetica"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5461,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 786,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Bisogna tenere conto del tipo e della dimensione dell'oggetto puntato al fine di evitare errori insidiosi (overflow, segmentation fault ...)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2318,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2549,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2522,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2552,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5339,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando si affronta l'aritmetica dei puntatori è importante ricordare che essa fa riferimento al puntatore base. Per questo motivo, quando un puntatore base punta ad un oggetto derivato, l'incremento del puntatore non fa in modo che questo punti all'oggetto successivo, del tipo derivato. Al contrario, esso punterà a quello che dovrebbe essere l'oggetto successivo del tipo base.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2523,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2320,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2548,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2551,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5396,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 821,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dei rischi dovuti alla gestione di memoria tramite puntatori: memory leaks dovuti a mancate deallocazioni di memoria, puntatori ad aree della memoria non allocate o errate. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2319,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2550,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2547,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2524,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5083,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Puntatori a strutture: Le regole di precedenza per l'accesso ai diversi campi, nello specifico la differenza tra  (*p).a e *p.a.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Puntatori"
            },
            {
              "keyword": " precendeza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5147,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": " - Come mai l'indice di un array inizia dal valore zero?\r\n - È consigliabile usare una variabile globale? in caso affermativo spiegare il perchè.\r\n - Da quali fattori dipende la programmazione in the \"Large\"?\r\n - Cos'è ESSENZIALE in un codice rilasciato?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Varibile"
            },
            {
              "keyword": "Contratto"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5057,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In relazione con la ricerca dei bachi in un codice, perché è opportuno evitare di usare le variabili globali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "bachi"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5096,
          "asker": {
            "courseId": 100,
            "askerId": 862,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono utilizzate le due zone di memoria stack e heap da un linguaggio di programmazione generico?Quali sono le differenze tra queste zone?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": "variabili"
            },
            {
              "keyword": "heap"
            },
            {
              "keyword": "scope"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5092,
          "asker": {
            "courseId": 100,
            "askerId": 844,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quali motivi è altamente sconsigliato l'utilizzo di variabili globali all'interno di un programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": "globali"
            },
            {
              "keyword": "sconsigliate"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5137,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Java è un linguaggio presente in massa nei PC, tablet e smartphone moderni.\r\nMa qual'è la filosofia che adottarono i creatori di Java e che poi ha reso così importante questo linguaggio?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "obiettivi"
            },
            {
              "keyword": " filosofia"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5111,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo il passaggio di un array (di DIM elementi) ad una funzione, avviene sempre per indirizzo/riferimento e mai per valore?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Indirizzo"
            },
            {
              "keyword": " Riferimento"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5349,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Perchè quando si passa un array ad una funzione non si stà facendo altro che passare il puntatore al primo elemento. \r\nCosa molto sensata poichè passare per valore un numero DIM molto grande di elementi comporterebbe uno spreco di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2559,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2563,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2382,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5466,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 901,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il passaggio di un array ad una funzione è sempre fatto per riferimento poiché il vettore in se rappresenta degli indirizzi attigui nell'area di memoria, il vettore v infatti rappresenta l'indirizzo di memoria di v[0].\r\nDiventa dunque semplice accedere ai seguenti elementi del vettore sommando 1 all'indirizzo di memoria. L'uso dell'indice facilità l'utilizzo dei vettori poiché rende più intuibile il meccanismo sopra descritto.\r\nUtilizzare gli operatori di dereference e puntatori è buona prassi per risparmiare eventuali rallentamenti di esecuzione dovuti al troppo utilizzo di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2562,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2566,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2379,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5321,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Passare un array di dimensione DIM per valore implicherebbe fare una copia di tutti gli elementi dell'array,il che comporterebbe sia uno spreco di memoria,sia un calo nelle prestazioni.\r\nPer questo motivo quando devo passare un array ad una funzione lo passo sempre per riferimento/indirizzo,in questo modo evito di dover fare una copia,inoltre in quanto copia dell'array originale ,il valore della variabile chiamante non viene modificato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2380,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2560,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2564,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5354,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 798,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "per evitare di occupare troppa memoria creando un altro array in funzione e per far si che le modifiche avvenute nella funzione vengano eseguite sull'arrey della funzione principale che lo contiene!  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2381,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2565,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2561,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5115,
          "asker": {
            "courseId": 100,
            "askerId": 877,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Provare a spiegare in poche parole il Principio del ''Need to Know''\r\n",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Principio"
            },
            {
              "keyword": " Need to Know"
            },
            {
              "keyword": " Spiegazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5431,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il principio nel \"Need to Know\" consiste nel fatto che ogni funzione o blocco del programma abbia a disposizione tutte e solo le informazioni che necessita per funzionare correttamente non una di più o di meno.\r\nQuesto postulato serve per preservare il principio della località dell'informazione che se non rispettato può portare a confusione nel codice (e quindi bug) che rende oggettivamente impossibile gestire un progetto di grandi dimensioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2405,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2806,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5361,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 756,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Ogni blocco deve poter accedere solo alle informazioni necessarie per eseguire il proprio codice, per far si che tali informazioni non vengano modificate da altre parti del programma non autorizzate.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2808,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2404,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5435,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "In informatica,il principio del \"need to know\" stabilisce che, in un programma, di ogni funzione/procedura si debba conoscere solo i dati di input e output, non l'implementazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2403,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2807,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5038,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega sinteticamente come l'introduzione del linguaggio Java ha modificato il concetto tradizionale di portabilità, contestualizzando la presenza di due nuovi elementi quali Bytecode e macchine astratte JVM nell'interazione tra il codice del programma e l'OS.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Portabilità"
            },
            {
              "keyword": " JVM"
            },
            {
              "keyword": " Bytecode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5150,
          "asker": {
            "courseId": 100,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché la Java Virtual Machine influisce negativamente sulle prestazioni del codice java?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " jvm"
            },
            {
              "keyword": " prestazioni "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5455,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per rendere il codice Java eseguibile su piattaforme e sistemi operativi differenti, esso non viene compilato direttamente in codice macchina, ma trasformato in un codice intermedio detto bytecode. Quando l'utente esegue l'applicazione Java, il bytecode viene caricato nella Java Virtual Machine installata. Le istruzioni vengono singolarmente tradotte in linguaggio macchina prima di poter essere eseguite. Questo processo causa una perdita di prestazioni variabile a seconda della struttura del programma (per esempio durante un operazione iterativa non sarà necessario effettuare nuovamente l'operazione di traduzione del bytecode). Questo impatto si é ridotto decisamente rispetto alla prima versione di Java grazie ai miglioramenti apportati nel corso degli anni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2407,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2334,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2813,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5331,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La JVM interpreta il bytecode e lo trasforma in linguaggio macchina per esser eseguito. Questo \"traduttore\" rallenta la velocità d'esecuzione del codice (dovendo aggiungere un passaggio in più tra il codice compilato e l'esecuzione) nonostante permetta di rendere più portabile il bytecode e più hardware indipendente.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2406,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2815,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2333,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5365,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La JVM è supposta essere operativa su ogni tipo di macchina, da ciò deve produrre un codice aspecifico che non può godere delle potenzialità differenti di differenti macchine.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2410,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2337,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2816,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5427,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 765,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nell'eseguire un codice Java bisogna necessariamente far uso della JVM, che essendo una macchina virtuale richiederà del tempo di calcolo alla CPU. La necessità di utilizzare un ulteriore \"software\", la JVM appunto, andrà ad allungare i tempi di calcolo complessivi del nostro programma, richiedendo alla CPU di svolgere ulteriori task parallelamente a quelli richiesti dal nostro codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2409,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2814,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2336,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5319,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Perché si inserisce tra sistema operativo e linguaggio  e di conseguenza si ha un passaggio in più da fare per l'esecuzione del codice Java",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2408,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2335,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2812,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5037,
          "asker": {
            "courseId": 100,
            "askerId": 823,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quanta memoria viene dedicata ad un puntatore?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 14,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " puntatore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5391,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 879,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La quantità di memoria che viene dedicata ad un puntatore è equivalente alla quantita di memoria necessaria a contenere l'indirizzo della locazione di memoria a cui punta. Questo spesso dipende dalla macchina sulla quale viene sfruttato il puntatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2616,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2463,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2776,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2313,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2639,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2704,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5438,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 838,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dipende dal tipo a cui si riferisce,  e quindi allo spazio che la macchina assegna ad ogni tipo.  Ad esempio,  se siamo su una macchina a 32 bit e il nostro puntatore si riferisce ad un int (che occupa 4 byte)  allora il puntatore occuperà 4 byte. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2312,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2617,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2461,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2705,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2640,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2778,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5353,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 813,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ad un puntatore viene dedicato uno spazio di memoria sufficiente a contenere un indirizzo(equivalente ad un int) quindi per esempio se una macchina lavora a 32 bit sarà 4 byte se una macchina lavora a 64 bit sarà 8 byte.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2615,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2462,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2703,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2777,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2314,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2638,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5067,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai nella suddivisione della memoria abbiamo uno spazio riservato al testo(codice eseguibile)[slide2, lezione2]?Questo file in che linguaggio e' scritto?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Divisione"
            },
            {
              "keyword": " Memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5457,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 791,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Quando si deve eseguire un file eseguibile (scritto in codice macchina, cioè in assembly ), carico dal disco rigido (Tempo= 10^(-3) secondi) il codice macchina del programma nel text, che è una parte della memoria dedicata al programma, la quale è nella temporanea. Così facendo ogni volta che dovrò accedere al codice ci metterò di meno, in quanto il tempo di caricamento da memoria è minore che da quella da disco (10^(-6) secondi), e quindi avrò una diminuzione dei tempi di esecuzione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2817,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2377,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2869,
                  "rater": {
                    "raterId": 813,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2389,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2307,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2761,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2873,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5355,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Il codice eseguibile viene salvato in memoria perché poi l'interprete, cioè il processore, lo eseguirà e dalla memoria riesce a trovare il \"punto di inizio\" del codice. Questo file viene salvato in linguaggio macchina (comprensibile al processore) nella memoria ma prima può essere implementa in qualsiasi linguaggio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2305,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2763,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2387,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2875,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2871,
                  "rater": {
                    "raterId": 813,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2819,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2375,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5359,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Secondo lo standard di Von Neumann, il codice eseguibile deve essere memorizzato in una parte della memoria denominata TEXT. Successivamente alla scrittura, questa parte di memoria diventa READ ONLY, cioè, il codice non viene modificato durante la sua esecuzione. In questo modo è più facile capire la \"logica\" del programma e il suo comportamento. Il codice eseguibile è scritto in BYTECODE, cioè in un linguaggio che la macchina è in grado di capire.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2388,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2376,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2306,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2874,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2762,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2818,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2870,
                  "rater": {
                    "raterId": 813,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5406,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 811,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Tenendo conto che la memoria dedicata all'esecuzione di un programma viene allocata nella RAM, avere una copia del codice al suo interno è conveniente, perché accederci è circa 1000 volte più veloce rispetto ad un file sul disco fisso (alcuni microsecondi contro alcuni millisecondi). Questo codice è scritto in linguaggio macchina (le istruzioni elementari scritte in codice binario, 0 e 1) perché, in caso contrario, sarebbe necessario compilarlo, rendendo l'esecuzione del programma notevolmente più lenta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2390,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2872,
                  "rater": {
                    "raterId": 813,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2378,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2876,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2308,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2760,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2820,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5026,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità e il vantaggio della definizione di nuovi tipi di dati?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "dati"
            },
            {
              "keyword": " tipi di dati"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5420,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 897,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'utilità e il vantaggio che si ha definendo un nuovo tipo di dato sta nel semplificare, sia per chi scrive che per chi legge, il programma, usando parole che aiutino a capire più facilmente di che tipo di variabile si tratta, per cosa verrà usata e cosa conterrà. Associando un nuovo identificatore ad un tipo, permetterà di usare quell'identificatore come se fosse un tipo di dato, rendendo più leggibile e pulito il programma, sopratutto nei programmi più complessi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2346,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2831,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2530,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2544,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5377,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Attraverso l'utilizzo di tipi di dato personalizzati si possono creare delle strutture, anche complesse,\r\nche possono servire a vari scopi e il cui significato è immediatamente comprensibile all'utilizzatore.\r\nPer esempio, una variabile di tipo float ci dice poco, mentre una di tipo personalizzato coordinata \r\nci indica più chiaramente il suo possibile contenuto e utilizzo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2832,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2531,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2546,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2345,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5385,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "La definizione di nuovi tipi di dato serve a migliorare portabilità del codice e a renderne più semplice e immediata la lettura per il programmatore. \r\nCi sono due modi per definire nuovi tipi di dato: il primo consiste in una semplice rinominazione e si realizza con typedef. È utilizzato per semplificare eventuali modifiche necessarie per portare il codice da una macchina ad un'altra.\r\nIl secondo è la creazione di dati composti tramite struct.\r\nIn entrambi i casi è possibile assegnare un nome arbitrario al nuovo tipo di dato; scegliendolo opportunamente si può semplificare notevolmente la lettura del codice rendendo più chiaro il significato di alcune variabili.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2545,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2529,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2344,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2833,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5423,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Il principale vantaggio sta nella maggiore chiarezza del codice prodotto, rendendolo più comprensibile anche a \"utenti\" diversi da chi lo ha scritto. Per esempio definendo un tipo che equivale comunque all'intero rende più intuitivo cosa rappresentano le variabili di questo tipo e le distingue da altre variabili sempre intere ma che rappresentano valori concettualmente diversi.\r\n\r\nPer fare un esempio più concreto in c++:\r\n\r\ntypedef double coordinata;\r\ntypedef double distanza;\r\n\r\n[...]\r\n\r\ncoordinata x;\r\ndistanza d;\r\n\r\nin tal modo si può intuire facilmente lo scopo delle variabili x e d e la probabile differenza nel loro utilizzo.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2528,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2543,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2834,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2347,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5034,
          "asker": {
            "courseId": 100,
            "askerId": 809,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa ha portato Java al successo ? Quali sono i vantaggi rispetto al C?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5065,
          "asker": {
            "courseId": 100,
            "askerId": 815,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale regola/prassi si deve seguire per poter lavorare al meglio in una community?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Prassi"
            },
            {
              "keyword": " community"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5068,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra il linguaggio C e Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "C"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5103,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella gestione della memoria, che differenze ci sono tra lo stack e lo heap, oltre al fatto che il primo contiene variabili allocate dalle funzioni e il secondo dal programmatore? Le due zone di memoria vengono gestite in maniera diversa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " heap"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " allocazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5143,
          "asker": {
            "courseId": 100,
            "askerId": 871,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale ragione le variabili globali e i GO TO risultano pericolosi da utilizzare nella scrittura di un codice?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili globali"
            },
            {
              "keyword": " GO TO"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5039,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Si supponga di avere il seguente blocco di codice in pseudo-C:\r\n{\r\n  int n = 2;\r\n  int foo(int n)\r\n  {\r\n    n++;\r\n    return n;\r\n  }\r\n  void fie()\r\n  {\r\n    n = n-2;\r\n  }\r\n  void few(int *n)\r\n  {\r\n    (*n)++;\r\n  }\r\n  int main()\r\n  {\r\n    int *rn = &n;\r\n    fie();\r\n    foo(n);\r\n    few(rn);\r\n  }\r\n}\r\n\r\nAl termine dell'esecuzione, quanto varrà n?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "previsione"
            },
            {
              "keyword": " c"
            },
            {
              "keyword": " scope"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5074,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Java è ,al giorno d'oggi, efficiente,  quali sono le due caratteristiche che fanno sii che questo accada?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " efficiente"
            },
            {
              "keyword": " caratteristiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5051,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra Java e C++? E quali sono invece le loro somiglianze? Descrivere la gestione della memoria condivisa dai due linguaggi di programmazione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Differenze"
            },
            {
              "keyword": "Java"
            },
            {
              "keyword": "C++"
            },
            {
              "keyword": "Memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5152,
          "asker": {
            "courseId": 100,
            "askerId": 880,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i rischi derivanti dall'uso di variabili globali? Per quale/i motivo/i?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "scope"
            },
            {
              "keyword": " variabili globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5157,
          "asker": {
            "courseId": 100,
            "askerId": 886,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quali scopi pratici è consigliabile inserire i puntatori all'interno del codice?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Puntatori"
            },
            {
              "keyword": " Codice"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5414,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I puntatori permettono una gestione della memoria in maniera dinamica. Non sempre è possibile determinare la quantità di memoria a priori (compile-time) perciò spesso è necessario gestire la quantità di memoria in fase di esecuzione e cioè a run-time tramite i puntatori.\r\nI puntatori sono importanti anche nel passaggio dei parametri alle funzioni, ne evitano la copia passando solo un riferimento (indirizzo) ad essi. A differenza del passaggio per riferimento, con i puntatori è anche possibile poi puntare ad un altro oggetto.\r\nUno dei vantaggi principali dei puntatori è quello di rendere efficiente l?allocazione di memoria evitando sprechi di risorse e di spazio.\r\nI puntatori, inoltre, danno la possibilità ad una funzione di restituire un oggetto allocato dinamicamente in essa.\r\nI puntatori permettono, infine, implementazioni di strutture dati dinamiche che non sono prevedibili a priori o che sono variabili nel tempo come liste, alberi, grafi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2554,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2432,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2852,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5446,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "è consigliabile inserire i puntatori all'interno del codice nel caso si desideri lavorare con oggetti di grosse dimensioni (struct) che solitamente conviene passare alle funzioni tramite puntatore; un'altro utilizzo dei puntatori è l'implementazione di stack e liste concatenate oppure alberi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2431,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2553,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2851,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5432,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per poter creare strutture di dati dinamiche come alberi e liste.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2555,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2433,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2850,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5048,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Assumi di essere stato appena assunto da una grande azienda informatica come programmatore. Ti hanno assegnato un progetto di medie dimensioni, da svolgere insieme ad alcuni programmatori professionisti, per vedere com'è il tuo stile di programmazione. Da questo progetto dipenderà la tua carriera futura.\r\nCome gestiresti la scrittura della tua parte di codice? Quale principio seguiresti? Quali elementi possono generare una maggior quantità di bug in un successivo controllo del codice? (Spiega brevemente)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "InformationHiding"
            },
            {
              "keyword": " NeedToKnow"
            },
            {
              "keyword": " VariabiliGlobali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5041,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo il linguaggio di programmazione Java cerca di venire incontro al problema della portabilità?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Portabilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5128,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Da quanto visto sul modello della memoria che viene dedicata ad un programma, abbiamo visto che in un'area apposita viene caricato anche il codice eseguibile del programma stesso: perchè il programma, oltre ad essere già presente sulla memoria di massa, viene caricato anche nella memoria principale?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "modello di memoria"
            },
            {
              "keyword": " codice eseguibile"
            },
            {
              "keyword": " memoria principale "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5433,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Durante l'esecuzione di un programma, il codice eseguibile, dal disco, viene copiato nella memoria centrale in quanto vi è una differenza enorme (un fattore di un milione circa) tra i tempi di accesso al disco (ordine dei millisecondi) e i tempi di accesso alla RAM (ordine dei nanosecondi). Inoltre questa è necessario per una questione di architettura della macchina stessa, in quanto il processore non è in grado di accedere alle informazioni contenute su disco senza averle prima caricate nei registri.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2829,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2804,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2502,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2644,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2629,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5424,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il programma viene caricato nella memoria principale per 2 motivi: velocità e \"sicurezza\"\r\nAnzitutto la memoria (ram) ha un tempo di accesso prossimo ai microsecondi [ 10^(-6) secondi ] mentre un hard disk ha un tempo di accesso misurato in millisecondi [ 10^(-3) secondi ] : l'accesso alle istruzioni da eseguire risulterebbe quindi sensibilmente più lento e le prestazioni del programma potrebbero non essere accettabili se rimanessero nell'hard disk.\r\nInoltre la partizione di memoria nel quale viene caricato il programma è da considerarsi \"Read Only\" in quanto il programma non può, e non deve, essere modificato durante l'esecuzione. Nei vecchi sistemi questa memoria veniva chiama ROM (read only memory) e solitamente ospitava il sistema operativo (altri esempi possono essere i CD-ROM o, meno conosciute, le EPROM).\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2627,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2642,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2802,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2827,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2501,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5407,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il codice eseguibile, cioè il programma compilato, risiede nella memoria di massa. Tuttavia\r\npoichè i tempi di accesso alla memoria di massa sono abbastanza lunghi (dell'ordine di millisecondi), risulta conveniente caricare in memoria il codice eseguibile in modo tale che, quando il processore deve leggere un'istruzione piuttosto che accedere al disco, trova quest'ultima nell'opportuna zona di memoria.\r\nInoltre nel modello, questa porzione di memoria si chiama \"zona di testo\" e, a differenza delle altre, è \"read only\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2500,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2643,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2828,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2803,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2628,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5318,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il codice eseguibile del programma viene caricato anche sulla memoria principale (RAM) per ridurre il tempo di lettura e, quindi, velocizzare il tempo di esecuzione. Infatti, il tempo che la macchina impiega per leggere dalla memoria di massa è più elevato rispetto al tempo che impiega per leggere dalla memoria principale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2626,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2503,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2805,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2830,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2641,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5106,
          "asker": {
            "courseId": 100,
            "askerId": 819,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quanto visto sul funzionamento degli stack nella scorsa lezione, descrivi le differenze che si presentano tra delle chiamate di funzione lineari e delle chiamate a funzioni ricorsive. ",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " ricorsività"
            },
            {
              "keyword": " modularizzazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5384,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Per ogni funzione si crea nello stack un area di memoria contenente le variabile relative alla funzione (a partire dalla zona più bassa dello stack). Ogni volta che si chiama un'altra funzione, si crea immediatamente sopra una nuova zona dello stack contenente le nuove variabili.\r\n\r\nNel caso di funzioni lineari, nel momento in cui si esce dalla funzione, la parte di stack relativa a quella funzione si libera.\r\n\r\nNel caso di funzioni ricorsive, ad ogni richiamo si crea una nuova area sopra al richiamo precedente, che rimane in memoria. Ciò continua fino a che non termina la ricorsione, che va a liberare tutti i blocchi creati. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2369,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2669,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2745,
                  "rater": {
                    "raterId": 819,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5360,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nelle chiamate lineari il programma viene svolto riga per riga, istruzione per istruzione e dunque linearmente; lo stack crescerà di conseguenza. Nelle funzioni ricorsive invece con poche righe scritte all'interno della funzione, il risultato del programma sarà ottenuto mediante la ripetizione della funzione stessa. Infatti all'interno della funzione ricorsiva si troverà generalmente un istruzione if contente il caso base, che finché non sarà verificato, in un'istruzione else successiva si troverà l'invocazione alla funzione stessa con il parametro in ingresso modificato di un valore costante ad ogni chiamata. Quindi in questo caso lo stack crescerà in base a quante chiamate ricorsive serviranno per render vero il caso base della funzione.    ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2670,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2746,
                  "rater": {
                    "raterId": 819,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2370,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5064,
          "asker": {
            "courseId": 100,
            "askerId": 784,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa vuol dire che Java è portabile? In che modo viene realizzata la portabilità?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "portabilità"
            },
            {
              "keyword": " JVM"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5130,
          "asker": {
            "courseId": 100,
            "askerId": 765,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e come è stato risolto il problema della \"portabilità\" dai programmi Java?cos'è e che ruolo svolge la JVM nella risoluzione di questo problema?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Portabilità"
            },
            {
              "keyword": "JVM"
            },
            {
              "keyword": "Java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5378,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il problema della portabilità di Java è stato risolto con l'introduzione della Java Virtual Machine (JVM) in quanto senza di essa non sarebbe possibile eseguire un programma codificato in Java su altre macchine.\r\nLa JVM è un interprete di un linguaggio assembly-like chiamato Bytecode.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2440,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2598,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2537,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2801,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5403,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La portabilità dei programmi java consiste nel poter compilare i codici java in qualsiasi compilatore (dall'unix al mac) e riuscire a far funzionare i programmi in qualsiasi sistema operativo. Questo problema della portabilità è stato risolto con l'introduzione della Java Virtual Machine. La JVM si tratta di un interprete di linguaggio assembly chiamato bytecode. La JVM è dunque un componente software del sistema operativo, che potrebbe essere incorporato nel hardware. Facendo ciò la JVM può far eseguire programmi java in qualsiasi sistema operativo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2438,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2538,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2597,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2800,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5322,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Java ha cercato di venire incontro al problema della portabilità facendo in modo che, attraverso un software-layer detto JVM (Java Virtual Machine) strutturato appositamente per ogni OS diverso, qualsiasi codice scritto in Java possa funzionare come eseguibile (bytecode) su qualsiasi macchina (è solo importante fare attenzione alla versione utilizzata). La JVM ha appunto il ruolo di macchina virtuale, con lo scopo di eseguire il bytecode sul relativo OS.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2439,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2600,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2799,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2536,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5337,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "La portabilita' e' la caratteristica di ogni programma di essere utilizzato su diverse piattaforme. Maggiore portabilita' determina anche il successo di un linguaggio e la sua popolarita' dato che non e' necessario riscrivere completamente il codice per ogni piattaforma hardware che software. Java ha risolto questo problema implementando la JVM (Java Virtual Machine), una macchina astratta che esegue lo pseudo-programma. Il programmatore scrive il codice ed in seguito compila il codice sorgente generando il bytecode (un linguaggio intermedio piu' astratto tra java e il linguaggio macchina). Solo dopo che e' stato generato il bytecode la JVM esegue il programma. Esistono molte JVM che variano sia in base alla versione di Java da eseguire, sia in base alla diversa architettura della macchina hardware. Il vantaggio e' che esistono diverse piattaforme software per eseguire lo stesso codice su diverse macchine. Ecco perche' lo slogan di Java e': \"Write once, run everywhere!\". ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2599,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2535,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2441,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2798,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5036,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e a che cosa serve la Java Virtual Machine?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JVM"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " Virtual"
            },
            {
              "keyword": " Machine "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5428,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 812,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "E' una macchina virtuale in grado di leggere e compilare programmi scritti in linguaggio Java",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2752,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2681,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2794,
                  "rater": {
                    "raterId": 828,
                    "courseId": 100,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5469,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 839,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Come dice la parola stessa é una macchina virtuale che permette di lanciare il bytecode java. Il preggio sta nella possibilità di poterla installare in diverse piattaforme rendendo il codice java portabile ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2796,
                  "rater": {
                    "raterId": 828,
                    "courseId": 100,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2683,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2754,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5333,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La JVM è una componente della piattaforma Java. Il programmatore scrive il programma in un editor di testo, questo poi viene trasformato in bytecode attraverso un software di compilazione. A questo punto la JVM esegue il programma a partire dal bytecode.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2682,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2795,
                  "rater": {
                    "raterId": 828,
                    "courseId": 100,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2753,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5401,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La java virtual machine è un interprete di un linguaggio ,simile al linguaggio assembly, chiamato byte-code. Questa virtual machine permette a java di garantire un livello neutro che renda l'esecuzione del programma indipendente dal sistema operativo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2797,
                  "rater": {
                    "raterId": 828,
                    "courseId": 100,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2755,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2680,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5459,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 829,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Serve per interpretare i codici pre-compilati in java, i bytecode, ed eseguirli sulla macchina.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2793,
                  "rater": {
                    "raterId": 828,
                    "courseId": 100,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2751,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2684,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5058,
          "asker": {
            "courseId": 100,
            "askerId": 813,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale area di memoria si trovano le variabili allocate da una funzione durante l' esecuzione di un programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " allocazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5025,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra una variabile locale e una variabile globale?\r\nPerché è sconsigliato utilizzare le variabili globali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili locali"
            },
            {
              "keyword": " variabili globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5024,
          "asker": {
            "courseId": 100,
            "askerId": 811,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono i Principi di Parna? Perché sono importanti?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "parna"
            },
            {
              "keyword": " modularità"
            },
            {
              "keyword": " contratto"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5357,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 835,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "1. Il committente di una funzione deve dare all'implementatore tutte le informazioni necessarie a scrivere una funzione e nulla di più;\r\n2. L'implementatore di una funzione deve dare all'utente tutte le informazioni necessarie ad  utilizzare la funzione e nulla di più.\r\nQuesti principi sono importanti perchè in questo modo la funzione creata funziona in modo corretto per qualsiasi input e l'implementatore non ha la possibilità di creare un programma diverso che funziona solo per un numero ristretto di input, ma crea un programma più generale che funziona sempre anche se viene cambiato il punto in cui la funzione viene applicata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2430,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5341,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "sono quei principi per i quali un programmatore deve dare all'implementatore soltanto le informazioni necessarie a realizzare quella data funzione e allo stesso modo l'implementatore deve dare all'utente soltanto le informazioni necessarie per utilizzare quella data funzione. Perciò devono essere evitate informazioni in eccesso e inutili per quella funzione. Questi principi sono importanti perchè permettono all'implementatore e all'utente di aver chiarezza e fruibilità sulle funzioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2427,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5358,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "David Parnas fu un pioniere dell?ingegneria del software che sviluppo il concetto dell?information hiding, importante nella programmazione modulare, in particolare quella orientata ad oggetti, e soprattutto nei progetti di grande volume.  Principio 1: Allo sviluppatore si devono fornire tutte e sole le informazioni necessarie all?implementazione della funzione commissionata. Principio 2: lo sviluppatore deve comunicare tutte e sole le informazioni necessarie all?utilizzo della funzione. Questo si riassume nel ?contratto? tra le due parti: cosa la funzione riceve e cosa restituisce. Il need to know è importante perché garantisce la flessibilità e l?intercambiabilità del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2429,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5356,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 769,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I Principi di Parna stabiliscono la corretta relazione che ci deve essere tra committente e implementatore di una funzione. Il committente di una funzione deve dare all'implementatore soltanto le informazioni necessarie a realizzare la funzione tutto il resto sarà superfluo. L'implementatore della funzione a sua volta deve dare all'utente solamente le informazioni necessarie ad usare la funzione e niente in più.\r\nI principi di Parna sono importanti per due motivi fondamentali: \r\n- eliminano la possibilità che l'implementatore lavori basandosi su informazioni aggiuntive e superflue.\r\n- non consentono all'utente di utilizzare la funzione in modo sbagliato basandosi magari sulla sua     implementazione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2428,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5120,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale modo Java elimina molti degli errori che vengono commessi quando si scrive in C?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "C"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5335,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Java semplifica la scrittura di un programma rispetto al C in più modi . I vantaggi più grandi sono:\r\n- l'assenza di puntatori che possono portare ad errori \r\n- i garbage collector che puliscono autonomamente la memoria occupata che non serve più \r\n- i \"cuscinetti \" posti agli estremi degli array per evitare effetto catastrofici portati dall uscita delle dimensioni prestabilite  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2338,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2515,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5336,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 867,
                "courseId": 100,
                "courseFinalScore": 15
              },
              "answerText": "Java presenta molte semplificazioni rispetto a C, queste permettono una maggiore velocità di scrittura ma anche meno flessibilità. Per esempio la mancanza di variabili globali in Java serve ad evitare ambiguità; un'altra importante differenza è la gestione della memoria che in Java è completamente automatica impedendo così molti errori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2516,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2340,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5327,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il linguaggio Java non ammette l'utilizzo di variabili globali e puntatori, ovvero delle fonti di errori più comuni per i programmatori in C. Sicuramente quindi Java puó definirsi come un \"linguaggio robusto\", ma in compenso proprio per questo puó risultare più lento in fase di compilazione rispetto al C.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2517,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2339,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5113,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Una variabile locale allocata dinamicamente (per quanto possa essere una mossa da EVITARE assolutamente) viene memorizzata nell'heap o nella parte di RAM posta ad ospitare le variabili locali (uninitialized data / initialized read-write data)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "RAM"
            },
            {
              "keyword": " allocazione"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5155,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di Java rispetto ad altri linguaggi come C e C++ che ne hanno comportato una così grande diffusione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Vantaggi"
            },
            {
              "keyword": "Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5078,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Parla delle variabili globali e del perché sono dannose, avvalorando la risposta con un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili globali"
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5122,
          "asker": {
            "courseId": 100,
            "askerId": 843,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali problemi può dare inserire Goto in un codice in  c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Goto"
            },
            {
              "keyword": " chiarezza"
            },
            {
              "keyword": " codice"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5030,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché esiste l'algebra dei puntatori e che cosa sarebbe difficile realizzare se non ci fosse?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " array"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5363,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 766,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'algebra dei puntatori serve per andare a prendere le informazioni che ci servono da una certa cella di memoria e senza di essa sarebbe difficile realizzare tutto quanto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2355,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2359,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2504,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5372,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "L'algebra dei puntatori è stata introdotta nel linguaggio C e permette un facile accesso, utilizzo e modifica di aree contigue di memoria, contenenti variabili dello stesso tipo.\r\nIn particolare essa garantisce una manipolazione più semplice degli array, come negli esempi spiegati di seguito.\r\nSe per primo esempio definiamo un vettore di tipo int 'v[10]' e un puntatore a int 'p' che punta all'elemento 'v[0]' del vettore, grazie all'algebra dei puntatori è definito 'p+n', il quale punta all'indirizzo di p incrementato di 'n*sizeof(int)', ovvero a v[n].\r\nAl contrario sottraendo due puntatori tra loro è possibile definirne la distanza rispetto l'indirizzo di memoria.\r\nCome si nota dal primo esempio il valore dell'incremento/decremento dipende dal tipo a cui punta il nostro puntatore, ma può essere variato tramiti eventuali type cast.\r\nL'algebra dei puntatori è presente, infine, in linguaggi quali C e C++, mentre è assente in Java\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2358,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2505,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2354,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5405,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 848,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'algebra dei puntatori è stata creata per accedere con un maggior livello di flessibilità a dati memorizzati in posizioni contigue della memoria, ad esempio gli array. L'accesso agli elementi di un array risulta così semplificato, riuscendo ad evitare l'uso della tradizionale sintassi indicizzata per accedervi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2506,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2356,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2352,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5340,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'algebra dei puntatori esiste per poter utilizzare l'allocazione dinamica per esempio, senza di essa sarebbe impossibile fare cose come il passaggio per riferimento e sarebbe assai difficile programmare delle liste, delle pile, delle code o alberi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2353,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2507,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2357,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5089,
          "asker": {
            "courseId": 100,
            "askerId": 828,
            "courseFinalScore": 14
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa dicono i principi di Parna?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "principi"
            },
            {
              "keyword": " parna"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5102,
          "asker": {
            "courseId": 100,
            "askerId": 764,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è fortemente sconsigliato, soprattutto per un codice ad uso industriale, l'utilizzo di variabili globali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": "globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5091,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Prendendo in considerazione il seguente codice :\r\n\r\nvoid quadrato(int & a);\r\nfloat meta(int a);\r\nint a=5;\r\nint main()\r\n{    float b=0;\r\n      int a=1;\r\n      float c=0;\r\n      Quadrato(a);\r\n      b=meta(a);\r\n      c=b-a;\r\n}\r\n\r\nvoid Quadrato(int & a)\r\n{ a=a*a;\r\n}\r\nfloat meta(int a)\r\n{ return (a/2); \r\n}  \r\n\r\nQual'è il risultato di c ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "13"
            },
            {
              "keyword": " 0 "
            },
            {
              "keyword": "-1 "
            },
            {
              "keyword": "-0.5"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5110,
          "asker": {
            "courseId": 100,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi è più utile utilizzare una variabile globale rispetto ad una locale?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "scope"
            },
            {
              "keyword": " variabile"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5144,
          "asker": {
            "courseId": 100,
            "askerId": 800,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un puntatore? A cosa servono i simboli * e & associati ad un puntatore? Qual'è la loro utilità maggiore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " simboli"
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5129,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in C++ è da evitate l'utilizzo di variabili globali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": "globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5140,
          "asker": {
            "courseId": 100,
            "askerId": 861,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Elenca le differenze che ci sono tra i linguaggi di programmazione Java e C++.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "differenze"
            },
            {
              "keyword": "linguaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5139,
          "asker": {
            "courseId": 100,
            "askerId": 791,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il bytecode? Quali sono i suoi vantaggi? ",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Bytecode"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5434,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il bytecode è un linguaggio assembly-like che viene eseguito dalla JVM, Java Virtual Machine. Essa è una layer software ( macchina astratta ) che viene eseguita su un'altra macchina astratta, che può essere ad esempio un sistema operativo. Il bytecode viene generato dal compilatore Java. Il vantaggio principale del bytecode è la possibilità di essere eseguito indipendentemente dall'architettura fisica e dal sistema operativo, in quanto è la JVM che si occupa di eseguirlo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2364,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2342,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2473,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2779,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2361,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5367,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 899,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Il Bytecode è un interprete che si frappone tra il programma sorgente e la Java Virtual Machine. Il Bytecode traduce le istanze in modo da renderle leggibili per la \"particolare\" Java Virtual Machine, \"particolare\" perchè ogni macchina con caratteristiche diverse da altre ha una propria JVM. Grazie al Bytecode è quindi possibile scrivere un solo codice eseguibile in tutte le macchine che supportano Java. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2343,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2780,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2365,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2474,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2362,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5343,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 900,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il Bytecode è un linguaggio intermedio più \"astratto\" tra il linguaggio macchina e il linguaggio di programmazione, è molto utile per realizzare linguaggi di programmazione perché riduce la dipendenza dall'hardware e facilita la creazione degli interpreti del linguaggio stesso. Java compila il suo codice in Bytecode in modo da essere interpretato da tutti i calcolatori dotati di JVM (Java virtual machine)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2363,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2360,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2781,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2341,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2472,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5020,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli svantaggi dovuti alla mancanza di un controllo sugli indici dei vettori al momento dell'esecuzione? Per quale motivo, questo controllo, non è presente nel linguaggio C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vettori"
            },
            {
              "keyword": " controllo"
            },
            {
              "keyword": " esecuzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5069,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è la Java Virtual Machine? A cosa serve? Quali le sue caratteristiche principali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Virtual"
            },
            {
              "keyword": " Machine"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5104,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra un puntatore di tipo void e, ad esempio, un puntatore di tipo double? Supponendo di lavorare su un'architettura a 64 bit, quanta memoria occupa il puntatore a void? E quello a double?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatore"
            },
            {
              "keyword": " indirizzo"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5397,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 771,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "In generale i puntatori a void possono puntare a tutto, mentre quelli a double puntano al tipo double.\r\nMa con i giusti cast qualsiasi puntatore può essere fatto puntare a qualsiasi cosa, double* p1=(double*)&a.\r\nUn puntatore a void può puntare a tutto senza la necessità di castare l'indirizzo di ciò che punta, è però necessario eseguire un cast quando si intende usare il valore della cosa puntata dal puntatore, in modo che il programma sappia quanti bit leggere e come sono codificati,*((int*)p1) se p1 è un puntatore a void.\r\nIn generale il peso dei puntatori su un architettura a 64 bit è di 8 byte, ma può dipendere anche dal sistema operativo o se  si compila il programma in modalità 32 bit o 64 bit; determinato il peso di un puntatore sulla macchina su cui sui si sta lavorando è lecito aspettarsi che il resto dei tipi di puntatori abbiano lo stesso peso.\r\nIn ogni caso visto che tutto ciò dipende da svariati fattori è meglio farsi un programmino per controllare le dimensioni dei tipi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2645,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2574,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2689,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2773,
                  "rater": {
                    "raterId": 919,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5425,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 815,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il puntatore di tipo void viene detto anche \"puntatore generico\", ovvero può puntare ad indirizzi che contengono qualsiasi tipo di variabile, mentre il puntatore di tipo double punta ad indirizzi che contengono variabili esclusivamente di tipo double.\r\n\r\nI puntatori contengono al loro interno esclusivamente un indirizzo, ossia l'indirizzo in cui si trova la variabile a cui puntano. Quindi la memoria che occupano è indipendente dal contenuto della variabile. In conclusione sia il puntatore a void che quello a double occuperanno una memoria di 64 bit (8 byte).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2576,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2691,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2775,
                  "rater": {
                    "raterId": 919,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2647,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5399,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Un puntatore di tipo void è una variabile che contiene l'indirizzo di memoria ad un'altra variabile di qualsiasi genere. Esso, non sapendo a quale tipo di variabile punta, per poter essere utilizzato per operazioni, obbliga il programmatore all'utilizzo dell'operazione di casting. Essa restituisce un puntatore ad una variabile di tipo conosciuto. Il puntatore di tipo double, invece, contiene l'indirizzo di una variabile di tipo double. L'architettura a 64bit indica il formato standard delle variabili semplici, tra cui i puntatori. I puntatori a void e a double possono, quindi occupare, fino a 64bit di memoria allocata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2646,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2575,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2774,
                  "rater": {
                    "raterId": 919,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2690,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5364,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il puntatore double userà molta più memoria rispetto a quello di tipo void.\r\nIl secondo andrà da +/-1.79769313486231570E+308 / +/-4.94065645841246544E-324 mentre il primo da -2147483648 / 2147483647",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2648,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2772,
                  "rater": {
                    "raterId": 919,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2692,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2577,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5027,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è importante la presenza dei puntatori in c++, mentre in java essi sono stati rimossi? Spiega portando qualche esempio di utilizzo dei puntatori in c++.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5118,
          "asker": {
            "courseId": 100,
            "askerId": 850,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i side-effects che possono essere causati dalle variabili globali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5098,
          "asker": {
            "courseId": 100,
            "askerId": 584,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "E' vero che nè memoria stack nè memoria heap possono essere allocate dinamicamente? Illustrare la differenza.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5066,
          "asker": {
            "courseId": 100,
            "askerId": 788,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "All'interno dello stesso programma, è possibile che, in punti diversi del codice, un nome si riferisca a due variabili di tipo diverso? Come viene chiamato questo fenomeno che associa ad un nome una variabile (o il relativo indirizzo in memoria) ?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "blocchi"
            },
            {
              "keyword": " scoping"
            },
            {
              "keyword": " visibilità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5379,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Sì, uno stesso nome può riferirsi a variabili di tipo diverso purchè si trovi in blocchi differenti e rispetti quindi le regole di scope, in modo da non portare in confusione il compilatore; al contrario e' possibile anche il fenomeno dell'aliasing ossia una stessa variabile può assumere denominazioni(nomi) differenti. Il fenomeno che associa un nome ad una variabile e' detto binding permettendo così ai fini del ragionamento da parte del programmatore un ulteriore astrazione sui dati. La corrispondenza tra nome e indirizzo di memoria sarà garantita da ciò che chiameremo ambiente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2748,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2685,
                  "rater": {
                    "raterId": 879,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2860,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5441,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, è possibile poichè lo scope di una variabile è delimitato dal blocco in cui essa è contenuta (nel caso in cui le due variabili con lo stesso nome siano dichiarate in blocchi diversi). Se, invece, esse vengono dichiarate all'interno dello stesso blocco possiamo andare in contro ad errori. Tale fenomeno è noto come aliasing.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2687,
                  "rater": {
                    "raterId": 879,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2862,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2749,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5440,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "è sicuramente possibile che un nome si riferisca a due variabili di tipo diverso, questo può succedere in due casi :\r\n\r\n- nel caso in cui una dichiarazione avvenga in due blocchi separati, uno annidato all'altro, secondo le regole di scope la variabile del blocco più esterno viene oscurata nel blocco interno\r\n- mentre nel caso in cui ciò accade nello stesso blocco possiamo avere un errore di ALIASING ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2861,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2688,
                  "rater": {
                    "raterId": 879,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2747,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5465,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 824,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "All'interno di un programma è possibile che un nome si riferisca a due variabili di tipo diverso, o meglio, che due variabili di tipo diverso abbiano lo stesso nome. In questo caso valgono le regole di scope, quindi nel caso esse siano chiamate per far parte di qualche istruzione, il compilatore sceglierà quella contenuta nel blocco più interno e \"vicino\" all'istruzione stessa, perché quella più esterna verrà automaticamente \"schermata\", oscurata. Il fenomeno che associa ad ogni nome la sua vera variabile seguendo queste regole è detto scope. Grazie a questo, durante la compilazione, la differenza e l'uso delle due variabili con lo stesso nome è ben definito e univoco.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2750,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2863,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2686,
                  "rater": {
                    "raterId": 879,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5028,
          "asker": {
            "courseId": 100,
            "askerId": 792,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Passaggio di parametri per puntatore. È possibile che, quando una variabile viene passata per puntatore, all'interno di una funzione si possa cambiare l'indirizzo che viene assegnato al parametro formale? Questa cosa può portare ad errori? Come è possibile evitarlo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Puntatori"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5075,
          "asker": {
            "courseId": 100,
            "askerId": 858,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'output di questo programma?\r\n\r\n...\r\nint s=0; //globale\r\n\r\nint f(int s){\r\n     return s++;\r\n}\r\n\r\nint main(){\r\n\r\n   int s=1;\r\n\r\n   {\r\n       int s=2;\r\n       s=f(s);\r\n    }\r\n\r\n    cout << s << endl;\r\n\r\n   return 0;\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "output"
            },
            {
              "keyword": " scopre"
            },
            {
              "keyword": " porgramma"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5114,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "qual è ed in che modo viene ottenuta la caratteristica principale di java e in che modo si differenzia dal c++",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " jvm "
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5097,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Dato un programma, in quanti e quali modi può una funzione, invocata dalla funzione main, restituire a quest'ultima un valore  ( assumendo che venga usato il linguaggio c++ )?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzioni"
            },
            {
              "keyword": " c++"
            },
            {
              "keyword": " return_valori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5050,
          "asker": {
            "courseId": 100,
            "askerId": 749,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Le variabili globali sono una buona alternativa a quelle locali? Perché?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "c++"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5046,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In c++, qual è il modo per poter modificare più variabili del main in una funzione o in una procedura? Quali rischi può comportare tale metodo risolutivo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": "indirizzi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5146,
          "asker": {
            "courseId": 100,
            "askerId": 833,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile definire una funzione che associa al tempo t il numero f(t) di bug individuati in un programma (dal rilascio della sua ultima versione al tempo t-a)\r\nf:R* --> R\r\nt -> f(t):=#bugs al tempo t\r\nSe un team di sviluppo lavora correttamente ed è in grado di risolvere la maggioranza dei bug individuati, è possibile assumere che la funzione f sia una funzione DECRESCENTE su ampie regioni del dominio di definizione.\r\n(1) È possibile affermare che, per t che tende ad infinito, allora lim f(t) = 0 ? Motivare la risposta.\r\n(2) Come ci si può aspettare che le caratteristiche di Java modifichino il grafico della funzione f?\r\n\r\n(argomento trattato nella lezioni di mar 24 febb 2015)",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Bug"
            },
            {
              "keyword": " Trend"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5374,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "1)Per f tendente ad infinito, il limite è un valore costante maggiore di 0, in quanto se si modifica un programma complesso per eliminare dei bug, si tende inevitabilmente ad introdurne altri.\r\n2)Java è un linguaggio che sacrifica efficienza in cambio di rapidità di sviluppo del codice, quindi le fasi alpha e beta di produzione del programma saranno più brevi rispetto ad altri linguaggi come c++ per esempio, e il grafico sarà più stretto all' inizio e uguale, con un valore costante non nullo, a lungo termine.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2836,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2764,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2372,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5456,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "(1) No, in quanto da un certo tempo t in poi il numero di bugs diventa costante. Ciò accade perché correggendo un bug se ne crea un altro (ad esempio a causa dell'utilizzo di variabili globali)\r\n\r\n(2) L'utilizzo di Java, che punta molto su robustezza e affidabilità, farà tendere la funzione più velocemente al valore limite, il quale sarà più \"vicino\" allo 0",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2373,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2835,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2767,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5386,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "1) Sarebbe scorretto dare una risposta certa a questa domanda in quanto, in un programma, il numero di bug e la facilità con cui si individuano dipendono da innumerevoli fattori: quali il numero di istruzioni da cui è composto, il linguaggio con il quale è stato scritto, quante persone lo utilizzano, come lo utilizzano, etc. Supponendo che il programma sia ben progettato(nel senso che la correzione di errori non ne generi altri in altre parti del codice)allora, in un tempo infinito, il numero di bug e quindi il numero di bug individuati in un'unità di tempo tenderebbe a zero. Tuttavia nella realtà e in programmi di grandi dimensioni esistono quasi sempre bug che rimangono nascosti perchè troppo rari e difficili da individuare.\r\n2)Le caratteristiche di Java, quali i controlli a runtime(a scapito delle prestazioni) e la sua facilità d'uso rispetto a molto altri linguaggi(come il C), farebbe decrescere la funzione f più rapidamente. Per questo motivo Java è infatti ampiamente utilizzato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2374,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2837,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2765,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5362,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "1) No, non è possibile affermare ciò, poiché ad un certo punto il numero di bug rimarrà pressoché uguale. Infatti, per quanto il team possa essere esperto, risolvendo dei bugs è sempre possibile introdurne degli altri, anche inavvertitamente. Per esempio, se nel codice si utilizzano variabili globali non costanti, allora si corre il rischio di causare situazioni impreviste e potenzialmente dannose, perché è possibile modificare le variabili globali in qualunque parte del codice.\r\n\r\n2) Tra le caratteristiche principali di Java troviamo la portabilità del codice e la sua robustezza. Grazie a quest'ultima il grafico della funzione f tenderà ad un valore probabilmente inferiore a quello ottenibile usando altri linguaggi di programmazione. Per esempio, fonti di errori come le variabili globali o i puntatori non sono presenti in Java.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2766,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2371,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2838,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5019,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le  differenze principali tra java e c++ ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5148,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Dal punto di vista della memoria, quale vantaggio danno le variabili locali, denominate anche \"automatiche\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " globali"
            },
            {
              "keyword": " locali"
            },
            {
              "keyword": " stack"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5445,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Le variabili locali occupano la memoria soltanto fino al termine della funzione in cui sono dichiarate a differenza delle variabili globali che, invece, restano in memoria fino al termine del programma. Un caso eccezionale di variabili locali che occupano la memoria anche oltre all'uscita dalla funzione sono quelle dichiarate staticamente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2637,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2757,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2304,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5454,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 853,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Dal punto di vista della memoria, il vantaggio delle variabili locali rispetto le variabili globali è quello di essere memorizzate nello stack (struttura dati che il programma può implementare e utilizzare per il proprio funzionamento).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2758,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2301,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2636,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5464,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Le variabili locali, o \"automatiche\", dal punto di vista della memoria sono molto efficienti, in quanto vengono allocate nello stack e permangono in memoria solo finchè si trovano all'interno del loro scope",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2756,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2635,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2303,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5430,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili automatiche sono allocate dinamicamente: la porzione di memoria usata aumenta e diminuisce a seconda delle necessità del codice in maniera automatica, senza l'intervento del programmatore. Questo permette di far \"respirare\" la stack, anziché riservare una quantità invariata di memoria allocata durante tutta l'esecuzione del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2759,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2634,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2302,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5062,
          "asker": {
            "courseId": 100,
            "askerId": 759,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il linguaggio JAVA viene considerato indipendente dalla piattaforma di esecuzione ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Indipendenza"
            },
            {
              "keyword": " Piattaforma "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5134,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando e in quali casi è (fortemente) consigliato usare c++, java o un altro linguaggio obj oriented? Qualora la risposta fosse affermativa è perché il codice sorgente sarebbe più facile da scrivere (e leggibile), perché a parità di conoscenze con alcuni linguaggi sarebbe pressoché impossibile o per altri motivi?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "differenze"
            },
            {
              "keyword": " linguaggi"
            },
            {
              "keyword": " c++"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5082,
          "asker": {
            "courseId": 100,
            "askerId": 781,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Java può essere utilizzato per creare programmi che richiedono un grande utilizzo di memoria o è consigliabile usare il C++?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": "C++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5351,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "È consigliato usare C++ per la gestione della memoria rispetto a Java, perche C++ permette una libera gestione e utilizzo della memoria. Un esempio tipico è il caso la funzione deallocazione della memoria dopo aver allocato. In C++ la gestione della deallocazione è compito del programmatore effettuarlo, invece in Java c'è una apposita funzione che a secondo dei suoi tempi effettua la deallocazione e questo può comportare delle difficoltà nella gestione di programmi di grande utilizzo di memoria. Soprattutto quando è richiesto l'utilizzo di una parte della memoria che è stato utilizzato in precedenza e che non è più utile e quindi deallocabile, in questo caso siccome il tempo della deallocazione non è a comando dal programmatore può comportare dei ritardi dell'utilizzo della memoria per altri funzioni del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2854,
                  "rater": {
                    "raterId": 892,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2671,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2847,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2384,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5390,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Per creare programmi che richiedono un grande utilizzo di memoria è preferibile usare il c++, in quanto questo linguaggio permette una maggiore accuratezza nella gestione della memoria. In c++ è infatti responsabilità del programmatore occuparsi delle operazioni di allocazione e deallocazione della memoria.\r\nJava è invece un linguaggio più semplice, quindi permette di sviluppare un programma in tempi più brevi rispetto al c++. In Java infatti, per abbassare il numero degli errori in fase di programmazione, mancano per esempio i puntatori, e la gestione della memoria è effettuata in modo automatico.\r\nSi ottiene quindi un codice più semplice e robusto del c++, ma per realizzare programmi che necessitano di molta memoria è preferibile usare il c++, in quanto la memoria è gestita in modo migliore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2846,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2853,
                  "rater": {
                    "raterId": 892,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2383,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2673,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5389,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 876,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Siccome in Java non esistono i puntatori è più conveniente utilizzarlo per programmi che richiedono grande utilizzo di memoria perché in c++ i puntatori sono spesso causa di memory leak e quindi di spreco di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2674,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2848,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2386,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2855,
                  "rater": {
                    "raterId": 892,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5348,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Java può si essere utilizzato per programmi di un certo rilievo, ma è chiare che le prestazioni di C++ sono superiori. Ciò che avantaggia Java è la possibilità di adattarsi a ogni macchina tramite la sua Virtual Machine. Entrambi sono linguaggi per Object Oriented e si tenga conto del fatto che in Java non ci sono puntatori, spesso causa di errori quali Memory Leak!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2856,
                  "rater": {
                    "raterId": 892,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2385,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2672,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2849,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5105,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Il linguaggio di programmazione Java si compone di alcune funzionalità per certi aspetti  diverse dal linguaggio C++: una di queste è la gestione dinamica della memoria. Nel caso del C++ la responsabilità dell'allocazione / deallocazione dinamica della memoria è affidata al programmatore; ma in che modo viene implementato questo aspetto in Java? Descrivere sinteticamente le differenze di implementazione tra i due linguaggi, specificando se possibile vantaggi e svantaggi per ciascuno. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria dinamica"
            },
            {
              "keyword": " garbage collector"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5121,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Visto che in java gli operatori di dereferenziazione non sono supportati, come passo un parametro per reference in un metodo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " reference"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5153,
          "asker": {
            "courseId": 100,
            "askerId": 898,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè i programmi sviluppati utilizzando Java sono detti \"portabili\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": "Portabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5099,
          "asker": {
            "courseId": 100,
            "askerId": 751,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Le variabili globali doverebbero essere evitate a causa di side-effects. Ma se noi avessimo bisogno di utilizzare una variabile in più sitazioni e in diverse funzione che vengono richiamate dalla funzione main() e anche dal main principale, non sono loro che mi permetterebbero di riuscire di evitare di dover ogni volta inizializzare la stessa variabile col stesso valore? In più esse mi permetterebbero di evitare di dover ricontrollare l'intero codice e dover controllare ogni variabile per dover modificarla? Non sarebbe eratto voler inizializzare all'interno del codice una variabile che io ho gia inizializzato globalmente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Vaibili"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5100,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa differenzia il blocco dinamico di memoria STACK dal blocco dinamico di memoria HEAP?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": " Heap"
            },
            {
              "keyword": " Modello di memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5072,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "É possibile implementare funzioni che non rendono portabile del software? Come viene risolto in java questo problema? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Portabilità software"
            },
            {
              "keyword": " portabile"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5084,
          "asker": {
            "courseId": 100,
            "askerId": 894,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Se dovessi implementare un sistema software per un carro-armato mi converrebbe implementarlo con un sistema firmware?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "si"
            },
            {
              "keyword": "no"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5138,
          "asker": {
            "courseId": 100,
            "askerId": 897,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra l'operatore & e l'operatore * e perchè un puntatore viene utilizzato come argomento di una funzione?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatore"
            },
            {
              "keyword": " operatore"
            },
            {
              "keyword": " parametro"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5350,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "1.\r\n-Dato int a=0,int &ra=a è un riferimento alla variabile, ovvero ra dimenta un sinonimo di a.\r\nUn puntatore int *pa= &a è una variabile che punta ad a ovvero contiene l'indirizzo di memoria di a.\r\n-La dereferenziazione,Dato int b=5; e le due variabili sopra si ha che:\r\nra=b; --> a=5\r\n*pa=b;-->a=5 // in questo caso uno può confondere assegnazione di un valore con la variazione del indirizzo.\r\n-Riferimento è costante,mentre puntatore può essere riassegnato\r\n-Puntatore puo puntare al NULL,riferimento no\r\n-I riferimenti sono più sicuri per quanto riguarda la memoria(memory leak)\r\n-I puntatori sono più malleabili(aritmetica)\r\n\r\n2.Un puntatore viene utilizzato come argomento,come un'alternativa alle variabili globali ed agli problemi legati ad esse. Un puntatore contiene un indirizzo di memoria, dunque si può andare ad modificare le variabili che non sono presenti all'interno del proprio scope di visibilità,inoltre non si agire sulla copia dei dati può risparmiare memoria(array,struct).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2811,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2845,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2659,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5408,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore &  (\"address of\") permette di accedere all'indirizzo (l-value) di un oggetto, l'operatore * (\"dereference\") all'oggetto contenuto in un indirizzo, un puntatore può essere utilizzato come argomento di una funzione perchè utilizzandolo non si passa direttamente l'elemento che è puntato e di conseguenza esso può venire modificato e quelle modifiche si applicano anche al passaggio",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2660,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2843,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2809,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5368,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "L?operatore & (?address-of?) ritorna l?indirizzo dell?espressione a cui è applicato. Invece occorre applicare l?operatore di dereference * per accedere all?oggetto puntato da una variabile puntatore.\r\nUn puntatore viene utilizzato come l'argomento di una funzione per modificare la variabile. Invece se viene utilizzato un'argomento normale l?informazione viene (temporaneamente) duplicata, quindi la variabile originale rimane invariato quando viene modificato all'interno della funzione. Un'altro vantaggio è che l?informazione non viene duplicata, quindi, evita possibile spreco di tempo CPU e memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2658,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2844,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2810,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5060,
          "asker": {
            "courseId": 100,
            "askerId": 830,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "int a=5;\r\nvoid f() {\r\n int a=2, b=4;\r\n printf(\"(a,b) in f: (%d,%d) -\",a,b);\r\n return;\r\n}\r\nmain() {\r\n int b=6;\r\n printf(\"(a,b) in main: (%d,%d) -\",a,b);\r\n f();\r\n printf(\"(a,b) in main: (%d,%d)\\n\",a,b);\r\n} \r\n\r\n\r\nCosa stampa?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Variabili "
            },
            {
              "keyword": " globali "
            },
            {
              "keyword": " automatiche "
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5076,
          "asker": {
            "courseId": 100,
            "askerId": 836,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai le variabili globali possono arrecare danni alla correttezza del programma ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": "globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5090,
          "asker": {
            "courseId": 100,
            "askerId": 895,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "significa che se io ho a=2 e b=2\r\nif (a==b) cout << ?OK\\n?; qua è come fare 2=2\r\nif (a=b) cout << ?OK\\n?; e qui è come fare 2!=0?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttori idiomatici"
            },
            {
              "keyword": " assegnazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5119,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in certe situazioni è più conveniente lavorare con i tipi di dati personalizzati, utilizzando typedef, rispetto all'utilizzo dei tipi di dati predefiniti? ",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "tipi"
            },
            {
              "keyword": "dati"
            },
            {
              "keyword": "typedef"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5330,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Per rendere il codice più leggibile: ovvero più vicino al linguaggio umano. Per esempio definire un float come coordinata può aiutare nell'interpretazione di un programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2583,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2699,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2611,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2694,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2868,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2486,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5323,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 831,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In certe situazioni, è più conveniente utilizzare tipi di dati personalizzati per agevolare la lettura/comprensione del codice e quindi comprendere la funzione di una o più variabili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2614,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2702,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2586,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2484,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2697,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2865,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5329,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Per rendere il codice più leggibile: ovvero più vicino al linguaggio umano. Per esempio definire un float come coordinata può aiutare nell'interpretazione di un programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2584,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2695,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2612,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2482,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2864,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2700,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5411,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perché migliora la leggibilità del codice  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2866,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2483,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2585,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2701,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2613,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2696,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5332,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 873,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perchè typedef può essere utilizzato per la creazione di sinonimi, e aiuta a rendere il linguaggio meno pesante e piu leggibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2698,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2582,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2485,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2610,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2693,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2867,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5056,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è la Java Virtual Machine, qual'è la sua utilità, come funziona e in che maniera essa è collegata con il bytecode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JVM"
            },
            {
              "keyword": " bytecode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5136,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Come Java rivoluziona la cosiddetta \"traditional portability\" e quali sono i suoi vantaggi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": "portability"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5131,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa differiscono l'operatore indirizzo (&) e l'operatore di dereferenziazione (*) nel linguaggio C++? Scrivere inoltre un piccolo programma (in C++) utile a chiarire questa/e differenza/e.",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Differenza"
            },
            {
              "keyword": " Operatori"
            },
            {
              "keyword": " C++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5383,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "using namespace std;\r\n#include <iostream>\r\n\r\nint main(){\r\n\tint a=2;\r\n\tcout << \"indirizzo di a: \"<< &a << endl;\r\n\t//L'operatore indirizzo \"&\" fornisce l'indirizzo \r\n\t//di un ipotetica variabile intera \"a\".\r\n\t\r\n\t// dichiarazione di un puntatore\r\n\tint *b;\r\n\t// assegno al puntatore b l'indirizzo di \"a\"\r\n\tb = &a;\r\n\tcout << \"*b= \" << *b << endl;\r\n\t// il puntatore defernziato punta cosi al valore contenuto nella variabile \"a\"\r\n\tcout << \"b= \" << b << endl;\r\n\t// a differenza di b che contiene l'indirizzo della variabile \"a\"\r\n\t\r\n\t// il puntatore quindi altro non è che un operatore che punta all'indirizzo\r\n\t// di una variabile, deferenziandolo (*b) poi otteniamo il valore contenuto in quella       //variabile\r\n\t \r\nreturn 0;\r\n\t\r\n\t// i puntatori e e gli indirizzi risolvono un importante problema ovvero quello di\r\n\t// passare dei parametri tra una funzione e l'altra all'interno del codice di un //programma\r\n\t\r\n\t}\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2651,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2708,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5447,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 859,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore & restituisce l'indirizzo dell'operando, per esempio &a restituisce l'indirizzo della variabile a, l'operatore di dereferenziazione (*) invece, scritto nel formato *var, interpreta var come un indirizzo e fornisce il valore contenuto nella cella di memoria puntata da quest'ultimo.\r\n\r\nESEMPIO :\r\n\r\nmain() {\r\n     // Dichiaro una variabile di tipo intero\r\n     int a;    \r\n     // Dichiaro una variabile di tipo puntatore ad intero\r\n     int *pa;\r\n     // Inizializzo a\r\n     a = 1;\r\n     // Faccio puntare pa ad a assegnandogli lo stesso indirizzo di memoria\r\n     // utilizzando l'operatore &\r\n     pa = &a;\r\n     // Stampo il contenuto di pa con l'operatore di dereferenziazione *\r\n     // che mi restituisce il valore contenuto nella cella di memoria puntata da pa\r\n     cout << \"*pa = \" << *pa << endl;\r\n     // L'output del programma è 1 poichè pa punta ad a che vale 1\r\n}\r\n\r\n ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2652,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2709,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5392,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore indirizzo & fornisce l'indirizzo di una variabile. L'operatore di dereferenziazione * invece fornisce il valore contenuto nella cella di memoria puntata.\r\nPer esempio:\r\nSe scrivo \"int &b=a;\", alla variabile b verrà assegnato l'indirizzo della variabile a. Se modifico b si modifica anche a ma non viceversa. \r\nSe scrivo \"int *b; b=&a;\", alla variabile b viene assegnato il valore contenuto nella cella di memoria di a. Se modifico *b si modifica a, e viceversa.\r\n\r\nEsempio:\r\n\r\nint x=1;\r\nint y=1;\r\nint &a=x;\r\nint *b;\r\n\r\nb=&y;\r\n\r\ncout << \"x= \" << x << \" &a= \" << &a << endl;         (x=1, &a=1)\r\ncout << \"y= \" << y << \" *b= \" << *b << endl;           (y=1, *b=1)\r\na=2;\r\n*b=3;\r\ncout << \"x= \" << x << \" &a= \" << &a << endl;         (x=2, &a=2)\r\ncout << \"y= \" << y << \" *b= \" << *b << endl;           (y=3, *b=3)\r\nx=4;\r\ny=7;\r\ncout << \"x= \" << x << \" &a= \" << &a << endl;         (x=4, &a=2)     \r\ncout << \"y= \" << y << \" *b= \" << *b << endl;           (y=7, *b=7)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2707,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2650,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5439,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore indirizzo, o address-of, (&) serve a mostrare l'indirizzo di un oggetto a patto che questo sia dotato di l-value.\r\nL'operatore di deferenziazione (*) si usa nell'ambito dei puntatori e serve ad accedere all'oggetto puntato da questi. Questo perché se ad esempio \"px\" è un puntatore che punta ad \"x\", \"*px\" diventa sinonimo temporaneo di \"x\" (e quindi se modifico uno modifico anche l'altro).\r\n\r\nEsempio\r\nint x = 2;                     //x variabile di tipo int\r\nint *px;                       //px variabile puntatore\r\n\r\ncout << &x << endl;    //stampa l'indirizzo in memoria di x\r\npx = &x;                      //assegna px a x, quindi *px divenda sinonimo di x\r\ncout << px << endl;    //stampa px, che equivale a stampare &x\r\ncout << *px << endl;   //stampa *px, che equivale a stampare x\r\n\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2649,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2706,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5047,
          "asker": {
            "courseId": 100,
            "askerId": 772,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'output del seguente codice ?\r\n\r\nint s = 5;\r\n\r\nint incrementa(){ \r\n     s++;\r\n     return s;\r\n}\r\n\r\nint main(){\r\n     int s = 1;\r\n     int a = incrementa();\r\n     std::cout << a;\r\n     return(0);\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "visibilità"
            },
            {
              "keyword": " scope"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5154,
          "asker": {
            "courseId": 100,
            "askerId": 834,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Gli Array sono puntatori veri e propri o vengono gestiti in maniera diversa per quanto riguarda l'allocazione in memoria dei dati? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " allocazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5033,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Le costanti globali sono \"cattive\"?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "globale"
            },
            {
              "keyword": "costane"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5366,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 773,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili globali sono definite variabili \"cattive\"; ma se queste vengono usate come costanti, diventano variabili read-only e, quindi, non modificabili durante il programma.\r\nPer cui le costanti globali non sono delle variabili \"cattive\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2786,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2444,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2449,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5324,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "sì, in quanto sono visibili in ogni punto del programma, quindi danno luogo a possibili problemi, come la maggior difficoltà nel capire quando e dove la variabile viene modificata, essendo visibile e lavorabile da diverse parti del programma. Tutto ciò rende imprevedibile il comportamento della variabile globale e difficoltosa la lettura del programma. Inoltre, essendo presumibilmente usata in diversi punti del codice e in diverse situazioni, una modifica alla variabile globale potrebbe rendere inefficaci i calcoli effettuati all'interno dei blocchi o calcoli diversi tra loro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2785,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2442,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2450,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5412,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Le variabili globali sono visibili ad ogni blocco/subroutine del programma. Nel caso non siano dichiarate come read only variables (o costanti) tramite l'operatore 'const', ogni blocco può accedervi e modificarne il valore, creando confusione sullo stato  o valore della variabile a run time. Questo può creare comportamenti anomali ed errori.\r\nNel caso siano usate come costanti, sono utili perchè definiscono un parametro globale uguali a tutti i blocchi senza dover passare parametri aggiuntivi. Per convenzione il loro identificatore ha tutte le lettere maiuscole.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2787,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2445,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2452,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5467,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 819,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sono considerate cattive perchè possono dare problemi con lo scope e intralciano la leggibilità del codice stesso. In caso di errori o debug può far sorgere ulteriori problemi nella ricerca della sorgente dell' errore causato dal codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2451,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2443,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2788,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5107,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa restituisce l'operatore di dereference (*) se applicato ad una variabile?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": "dereference"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5342,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Restituisce il valore della cella di memoria a cui punta quella variabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2510,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2718,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2309,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5437,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dopo aver dichiarato un puntatore (*) e dichiarato a che variabile punta (puntatore e variabile devono essere dello stesso tipo), il puntatore (*) diventa sinonimo della variabile stessa e modificandone una delle due si modifica quindi anche l'altra.\r\nPertanto stampando un *x dove x = &y, è esattamente la stessa cosa che stampare y.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2509,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2310,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2720,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5317,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 836,
                "courseId": 100,
                "courseFinalScore": 19
              },
              "answerText": "L' operatore restituisce, nel caso di puntatori in C/C++ , il valore della variabile puntata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2508,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2719,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2311,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5125,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenza fra C# e Java, vista l'origine storica simile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Differenze"
            },
            {
              "keyword": " C#"
            },
            {
              "keyword": " e"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5108,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in C/C++ si inizia a contare da zero anzichè da uno?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "zero"
            },
            {
              "keyword": "uno"
            },
            {
              "keyword": "contare"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5398,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 749,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "In C/C++ si inizia a contare da zero anziché da uno perché quando l'utente scrive a[i], con a che rappresenta un array e i un indice, il compilatore lo traduce come a+i, con a che rappresenta l'indirizzo di memoria del primo elemento dell'array e i un numero intero che cambia l'indirizzo di memoria di 4 bit alla volta.\r\nSe quindi l'array viene dichiarato di 10 elementi e si prova ad accedere ad a[10] si troverà un elemento con indirizzo di memoria superiore di 4bit*10 rispetto al primo elemento dell'array, che però non sarà contenuto all'interno dell'array.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2569,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2740,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2580,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2499,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2458,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5344,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì parte a contare da zero poiche così facendo gli indici degli elementi di un array hanno range 0 <=i <N , dove N è la dimensione dell'array, senza dover sommare o togliere una quantità pari a uno. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2570,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2457,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2581,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2497,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2741,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5436,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 751,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In c/c++ si inizia a contare da 0 anzichè da uno perché il c++ lavora in base decimale. Se si ciclasse in un array di 10 elementi e iniziassi a contare da uno, essendo che stiamamo lavorando in base decimale, lui mi ciclerebbe su solo nove elementi e mi lascerebbe fuori un elemento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2496,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2579,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2568,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2739,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2460,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5334,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per avere una corrispondenza tra l'aritmetica classica e l'aritmetica dei puntatori. Gli array sono indicizzati a partire da zero perché in realtà un array non è altro che un insieme di celle contigue di memoria, quindi se l'array inizia all'indirizzo 0x2222, allora il primo elemento sarà all'indirizzo (0x2222+0) = 0x2222",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2498,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2578,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2459,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2567,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2738,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5032,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega la differenza fra variabili globali e locali, e inoltre spiega perchè le variabili globali sono definite \"cattive\".",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Parna "
            },
            {
              "keyword": " Need to know"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5035,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cos'è il bytecode.\r\nUna volta compilato il bytecode su di una macchina, questo puo' essere eseguito su altre di diverso tipo? Eseguendo un programma, il bytecode dovrà essere tradotto più volte?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "bytecode"
            },
            {
              "keyword": " assembler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5449,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 827,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una volta creato, il file bytecode è eseguibile su qualsiasi macchina, infatti java è nato proprio per risolvere il problema della portabilità del software.\r\nNo perchè la \"java virtual machine\", ovvero la macchina virtuale java, è un interprete del bytecode inteligente, che ricorda le parti di codice gia tradotto e evita ritraduzioni inutili (si veda il caso dei cicli ad esempio) permettendo una maggiore efficienza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2396,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2520,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2322,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5422,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il bytecode é il prodotto ottenuto dalla compilazione del codice sorgente in un linguaggio di alto livello come Java. Una volte compilato, il bytecode puo essere eseguito su tipi diversi di macchine tramitte Java virtual machine(JVM)(macchina virtuale/interprete che esegue il bytecode) che deve essere compatibile con il sistema operativo della macchina stessa. Questa proprieta da' a Java la caratteristica di una piattaforma indipendente. Quindi il bytecode non dovra essere tradotto piu volte (codice sorgente in bytecode).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2519,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2324,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2398,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5393,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 783,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il bytecode è un linguaggio intermedio tra il linguaggio macchina e il linguaggio di programmazione(\"assembly-like\"); esso risulta essere molto utile in quanto diminuisce la dipendenza dall'hardware e facilita la creazione di interpreti del linguaggio stesso.\r\nUn programma in bytecode è eseguito mediante un secondo programma, la macchina virtuale, che ne interpreta le istruzioni traducendolo in linguaggio macchina, prima di eseguirlo. \r\nCiò consente di scrivere programmi portabili, ovvero architettati in modo tale da poter essere eseguiti su diversi tipi di sistemi operativi e di architetture hardware, \" write once run everywhere \". ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2323,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2397,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2521,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5394,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il bytecode è un insieme di istruzioni che possono essere eseguite da una macchina o interpretate da un interprete. Nel caso del Java bytecode, questo viene eseguito dalla JVM - Java Virtual Machine. Il bytecode è il risultato dell'operazione di compilazione (nel caso di java attraverso il compilatore javac) del codice sorgente.\r\nSe per bytecode si intende java bytecode il cui codice sorgente non contiene riferimenti a versioni modificate di JDK, allora il bytecode può essere eseguito su qualsiasi JVM, che per sua natura è OS-independent. Altrimenti nulla si può dire.\r\nEseguendo un programma, il bytecode viene prima analizzato da un interprete che fornisce le istruzioni al Java processor chip e viceversa, questa è l'unica \"traduzione\" che viene effettuata.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2395,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2518,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2321,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5081,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Il comando \"new\" in questo pezzo di codice Java tra virgolette è un costrutto formale o ha una particolare funzione:\r\n\"\r\nclass Applicazione{\r\n/* Hello World, my first Java application - second version*/\r\npublic static void main (String args[]) {\r\n Applicazione p= new Applicazione();\r\n}\r\nApplicazione() {\r\nSystem.out.println(\"Hello World!\");\r\n// qui va il resto del programma principale\r\n}\r\n} \r\n\"\r\n\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "comando "
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5059,
          "asker": {
            "courseId": 100,
            "askerId": 756,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché le variabili globali vanno sempre evitate? Cos'è il principio del need to know?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " scope"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5053,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si lavora con gli indirizzi (con l'operatore indirizzo &) bisogna tenere conto del tipo di dato usato? Perché?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Lezione2"
            },
            {
              "keyword": " Puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5404,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Si, utilizzando l'operatore indirizzo & è necessario tenere conto del tipo di dato usato. Innanzitutto l'operatore è utilizzato solo con operandi l-value, ed oltre a ciò è possibile assegnare un indirizzo di un specifico tipo di dato solamente ad un puntatore dello stesso tipo (es:  int*p=&a , dove a è una variabile int). \r\nQuesta limitazione è stata inserita come feature di sicurezza per evitare accessi alla memoria potenzialmente scorretti; infatti:\r\n- Se volessimo incrementare il puntatore : p++;\r\n- p punterà ora ad un valore in memoria che è 1 moltiplicato per la dimensione del tipo di       dato (in questo caso sarebbe aumentato di 1*sizeof(int)).\r\nE' possibile arginare questa limitazione e dunque assegnare puntatori ad indirizzi di dati di tipo diverso utilizzando gli operatori di casting. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2448,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2526,
                  "rater": {
                    "raterId": 798,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2416,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2824,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5376,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si.\r\nPerchè non si può lavorare con puntatori di tipo diverso, devono sempre corrispondere, per esempio:\r\n\r\nint *pointer;\r\nfloat x;\r\npointer=&x;\r\n\r\ngenera un errore, poichè pointer è un puntatore a intero e c un float.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2414,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2825,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2447,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2527,
                  "rater": {
                    "raterId": 798,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5345,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, perché quando usi l'operatore & fornisci l'indirizzo in memoria di un dato specifico (int,char ..) quindi non puoi assegnare a una variabile int l'indirizzo di memoria di una variabile char.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2826,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2446,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2525,
                  "rater": {
                    "raterId": 798,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2415,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5149,
          "asker": {
            "courseId": 100,
            "askerId": 904,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Ritrovandoti nei panni di uno sviluppatore intenzionato a sviluppare un applicativo molto complesso dedicato alla gestione della memoria e indirizzato ad una utenza desktop windows e mac, sulla base di quanto studiato nelle ultime  due lezioni la tua scelta per lo sviluppo ricadrebbe su c++ o java ? Quali sono gli aspetti (positivi o negativi) di entrambi i linguaggi di programmazione che ti hanno portato a fare una scelta ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Applicativo "
            },
            {
              "keyword": "memoria "
            },
            {
              "keyword": " scelta "
            },
            {
              "keyword": " caratteristiche "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5123,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Chi è l'autore dei \"proncipi di Parna\"? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Principi"
            },
            {
              "keyword": " Parna"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5112,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando viene compilato un codice Java che cosa viene generato? \r\nIl codice generato è eseguibile su qualsiasi macchina senza nessuna aggiunta? \r\nSe no, specificare con cosa si può rendere eseguibile ovunque.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "jvm"
            },
            {
              "keyword": " bytecode"
            },
            {
              "keyword": " eseguibile"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5093,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo l'introduzione di variabili globali all'interno di software può essere fonte di bug? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": "bug"
            },
            {
              "keyword": "bachi"
            },
            {
              "keyword": "variabili globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5044,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "In un dispositivo avente un ridotto quantitativo di memoria fisica, dovendo scegliere tra due versioni di uno stesso algoritmo, una ricorsiva, l'altra iterativa, per quale è opportuno optare? Motivare dettagliatamente la risposta.",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " ricorsione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5388,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "E' opportuno optare per un algoritmo iterativo, in quanto esso occupa molta meno memoria rispetto a quello ricorsivo. Infatti ogni volta che una funzione viene chiamata, verrà allocato nello stack della memoria un blocco, necessario per salvare i parametri e le variabili locali della funzione; un algoritmo iterativo richiede quindi un solo blocco, mentre uno ricorsivo richiede sicuramente più blocchi (perchè la funzione chiama se stessa varie volte) ed occuperà quindi più spazio in memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2368,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2858,
                  "rater": {
                    "raterId": 839,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2494,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2556,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5380,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 823,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nel caso in questione occore scegliere la versione iterativa dell'algoritmo, in quanto in quella ricorsiva ad ogni ciclo (tranne l'ultimo) della funzione si richiama la stessa, con evidenti ripercussioni sull'occupazione della ridotta memoria fisica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2557,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2495,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2367,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2859,
                  "rater": {
                    "raterId": 839,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5410,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 745,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Ci sono alcuni algoritmi che sono più naturalmente implementati ricorsivamente (come gli alberi), altri meglio implementati come cicli. Se il problema è la memoria, a prima vista opterei per la soluzione iterativa (visto che, ogni volta che la funzione chiama se stessa, viene occupata altra memoria), a patto che questa non diventi di difficile mantenibilità (ci sono algoritmi ricorsivi che non sono così intuitivi da rendere in iterativi)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2857,
                  "rater": {
                    "raterId": 839,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2558,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2366,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2493,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5022,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai il linguaggio Fortran non permette l'uso di funzioni ricorsive?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ricorsivo"
            },
            {
              "keyword": "linguaggio"
            },
            {
              "keyword": "lezione2"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5141,
          "asker": {
            "courseId": 100,
            "askerId": 901,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo gli array possono essere definiti degli \"zuccherini sintattici\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": "puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5052,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè al linguaggio di programmazione Java viene attribuita la caratteristica \"robustezza\" rispetto ad altri linguaggi come il C e C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " caratterisstiche"
            },
            {
              "keyword": " robustezza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5079,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Immaginiamo di avere un main e una funzione esterna che lavori con la variabile x del main.\r\nPer modificare il valore x nel main è sufficente passare un parametro per copia? è possibile modificare il valore x nel main passando il paramentro per copia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "parametro"
            },
            {
              "keyword": " copia"
            },
            {
              "keyword": " riferimento"
            },
            {
              "keyword": " funzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5132,
          "asker": {
            "courseId": 100,
            "askerId": 852,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Nei vettori, provando ad accedere ad un elemento con un indice errato si manifestano due casi di errore, quali?\r\nQuando è più difficile accorgersi dell'errore?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "blocchi"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5463,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nel caso l'indice di un vettore sia errato, si rischia di accedere a dati \"sbagliati\" della memoria, cioè fuori dal range del vettore (per esempio, se il vettore va da 0 a n, accedo alla cella di memoria successiva a quella identificata da n). E' difficile accorgersi dell'errore quando il dato \"sbagliato\" viene acquisito e riconosciuto come giusto dal compilatore, perchè magari compatibile col tipo di dato con cui stiamo lavorando. Il programma, dopo essere stato eseguito, darà dei risultati che molto probabilmente saranno errati, poichè tengono conto di dati esterni al vettore. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2351,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2839,
                  "rater": {
                    "raterId": 821,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2541,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2721,
                  "rater": {
                    "raterId": 869,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5413,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ci sono due tipi di errore:\r\n-nel primo caso, si accede a un elemento al di fuori dello spazio allocato per il programma, e in questo caso tale errore può essere individuato nel momento in cui viene lanciato il programma;\r\n-nel secondo caso, si accede un elemento al di fuori del vettore, ma all'interno dello spazio allocato per il programma; questo è il caso in cui è più difficile accorgersi del problema, in quanto nel momento del lancio del programma non viene indicato nessun errore, ma naturalmente non si accede all'elemento desiderato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2841,
                  "rater": {
                    "raterId": 821,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2350,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2722,
                  "rater": {
                    "raterId": 869,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2540,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5325,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 748,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Un errore è quando si esce dall'area di memoria riservata alla nostra esecuzione ed è l'errore meno grave perché il compilatore se ne accorge e ci blocca. L'errore più grave e più difficile da scovare è quando si resta dentro lo spazio a noi riservato in memoria ma si modifica qualcosa che non si sa di aver modificato e quindi ci si accorge solo quando si incorre in un nuovo problema dato da quella modifica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2723,
                  "rater": {
                    "raterId": 869,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2348,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2539,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2842,
                  "rater": {
                    "raterId": 821,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5458,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nei vettori, nel momento in cui si chiama un elemento con indice errato si accede ad una cella di memoria esterna a quelle che sono state allocate per il vettore. La cella a cui si accede può non essere stata allocata dal programma, in questo caso il risultato sarà quindi la lettura di un valore casuale già presente oppure la scrittura su una locazione che non verrà però mai usata dal programma; se invece la cella a cui si accede è allocata dal programma, per una variabile o per un altro array ad esempio, il risultato sarà la sovrascrittura del programma stesso. Risulta più difficile accorgersi del primo caso di errore, dal momento che nel secondo la sovrascrittura di dati può provocare malfunzionamenti del codice molto più gravi della presenza di un valore random.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2724,
                  "rater": {
                    "raterId": 869,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2840,
                  "rater": {
                    "raterId": 821,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2349,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2542,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5088,
          "asker": {
            "courseId": 100,
            "askerId": 829,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Il codice eseguibile può essere modificato mentre il computer è acceso?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Sì"
            },
            {
              "keyword": " No"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5124,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare brevemente le problematiche che possono verificarsi con l'utilizzo di variabili globali all'interno di un programma medio/grande.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Scope"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5142,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo in informatica, per esempio nella determinazione degli elementi di un array, si parte sempre a contare da 0 ?\r\nMi ricordo che era stato detto a lezione ma non ricordo quale fosse il motivo e non l'ho segnato esplicitamente negli appunti, quindi non sono sicuro della risposta",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "conteggio"
            },
            {
              "keyword": " zero"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5409,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 863,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Possiamo pensare a un array come a una zona di memoria contigua contenente n elementi di un determinato tipo. I puntatori possono essere utilizzati per riferersi a questa area di memoria utilizzando l'aritmetica dei puntatori. Esempio:\r\n\r\nint dispari[10]={1,3,5,7,9,11,13,15,17,19};\r\nint *px = &myArr[0];  // creo un puntatore al primo elemento dell'array\r\ncout << *(px+2) << endl;\r\n\r\nSommare un intero i ad un puntatore a un determinato tipo T significa sommare all'indirizzo puntato i*sizeof(T): l'output dell'esempio è 5.\r\nSi comincia a contare da 0 poichè *(px+0)=*px ossia il primo elemento dell'array.\r\n\r\nIn realtà gli array non sono altro che puntatori \"mascherati\", infatti passare un array a una funzione equivale a passare l'indirizzo del suo primo elemento(ed è per questo che gli array non sono passati per valore). Nell'esempio avrei potuto anche scrivere\r\nint *px=myArr; \r\ne il risultato sarebbe invariato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2487,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2475,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2571,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2782,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5443,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 903,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "l'elemento 0 di un array è diventato uno standard nella programmazione e porta gli elementi massimi all'interno di un array a N-1",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2783,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2488,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2476,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2573,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5387,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Supponiamo di avere un array di dim elementi di tipo int, dove dim vale 10.\r\nAbbiamo quindi:\r\nint array[dim];\r\nNella notazione \"zucchero sintattico\" degli array, scorriamo l'array in questo modo:\r\nfor (int i = 0; i < dim; i++)\r\narray[i];\r\nNotiamo che l'indice parte da 0 e arriva a 9, quindi i 10 elementi dell'array sono numerati da 0 a 9.\r\nOra, se volessimo accedere all'elemento i-esimo dell'array dovremmo togliere 1 da i:\r\narray[3] indica, ad esempio, il QUARTO elemento dell'array e non il terzo come ci si aspetterebbe.\r\nA causa di questa scomodità sintattica, in informatica si è adottata la convenzione di cominciare a contare da 0.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2784,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2572,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2477,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2489,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5055,
          "asker": {
            "courseId": 100,
            "askerId": 814,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Sia nello stack che nello heap la memoria è allocata dinamicamente ma non con le stesse modalità; qual'è la differenza tra le due allocazioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Allocazione"
            },
            {
              "keyword": "Memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5086,
          "asker": {
            "courseId": 100,
            "askerId": 881,
            "courseFinalScore": 9
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando parliamo di variabili globali, cosa si intende per side effects?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "side effects"
            },
            {
              "keyword": " scope di variabili"
            },
            {
              "keyword": " globali"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5080,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè vanno evitate variabili globali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5070,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che relazione c'è tra stack e funzioni?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": " Funzioni"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5382,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando viene chiamata una funzione, viene allocata memoria nello stack per le variabili che le vengono passate come parametri e quelle dichiarate all'interno della funzione stessa (le variabili automatiche, quelle non allocate manualmente con gli operatori \"malloc\" o \"new\").\r\nTale memoria rimane occupata finché non termina l'esecuzione della funzione (\"return\" nelle funzioni non void).\r\nNel caso particolare di funzioni ricorsive c'è il rischio che lo stack si riempia (stack overflow), in quanto la stessa funzione richiama se stessa più volte prima di terminare l'esecuzione, e quindi nuova memoria viene allocata prima che quella occupata da chiamate precedenti sia stata liberata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2821,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2315,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2492,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5347,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "In C++, la memoria stack è l'area di memoria in cui vengono salvate temporaneamente le variabili di una funzione in fase di esecuzione ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2822,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2316,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2491,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5419,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 799,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La stack è una parte di memoria che viene utilizzata per l'allocazione delle funzioni (variabili automatiche), questa è la relazione tra stack e funzioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2490,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2823,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2317,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5127,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che tipo di passaggio di parametri sto eseguendo in questa funzione e quale sara' il risultato?\r\n\r\nvoid swap (int *& a, int *& b){\r\n\t\r\n\tint *tmp;\r\n\ttmp = a;\r\n\ta=b;\r\n\tb=tmp;\r\n\t\r\n}\r\n\r\nint main (){\r\n\t\r\n\tint x = 5, y = 6;\r\n\tint *a, *b;\r\n\t\r\n\ta= &x;\r\n\tb= &y;\r\n\t\r\n\tcout<<\"a= \"<<a<<\" *a= \"<<*a<<\"  x= \"<<x<<endl;\r\n\tcout<<\"b= \"<<b<<\" *b= \"<<*b<<\"  y= \"<<y<<endl;\r\n\t\r\n\tswap (a,b);\r\n\t\r\n\tcout<<\"a= \"<<a<<\" *a= \"<<*a<<\"  x= \"<<x<<endl;\r\n\tcout<<\"b= \"<<b<<\" *b= \"<<*b<<\"  y= \"<<y<<endl;\r\n\t\r\n\treturn 0;\r\n\r\n}\r\n\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " riferimenti"
            },
            {
              "keyword": " passaggio puntatore per riferimento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5040,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè Java è considerato più lento del C ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " c"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5135,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché i programmi scritti nel linguaggio Java sono considerati Platform Indipendent? \r\nPossiamo dire lo stesso di JVM?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "platform"
            },
            {
              "keyword": "indipendent"
            },
            {
              "keyword": "jvm"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5043,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Elencare le possibili modifiche e/o operazioni da poter effettuare su un pezzo di codice per migliorarne sensibilmente la leggibilità.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "leggibilità"
            },
            {
              "keyword": " codice"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5444,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Nella programmazione industriale, anche detta Programming \"in the large\", un programma deve avere delle particolari caratteristiche per renderne migliore l'interpretazione e la creazione, quali:\r\n- suddivisione del lavoro tra persone/gruppi\r\n- mantenibilità del codice\r\n- robustezza.\r\nPer migliorare sensibilmente la leggibilità di un pezzo di codice è richiesta:\r\n- la documentazione aggiornata (commenti che descrivano ciò che quel codice fa)\r\n- evitare ambiguità di nomi delle funzioni/variabili (dare nomi sensati ad ogni oggetto creato)\r\n- indentazione del codice (allineare il codice secondo una determinata logica che ci permette di rendere velocemente leggibile ed interpretabile il codice)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2422,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2653,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2601,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5426,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per migliorare sensibilmente la leggibilità di un pezzo codice vi sono principalmente due operazioni che si possono compiere: innanzitutto implementarlo in modo corretto e ordinato di modo da rendere esplicite le relazioni di annidamento dei diversi blocchi e istruzioni, inoltre può essere molto utile l'inserimento di commenti, così da rendere chiari il significato e/o la funzione del codice stesso.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2602,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2423,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2654,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5328,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 767,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Commentare il codice e una buona indentazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2655,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2426,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2603,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5352,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Un fattore fondamentale per migliorane sensibilmente la leggibilità è l'indentazione. Essa risulta di primaria importanza in qualunque software. \r\nUlteriormente si consiglia di utilizzare le \"best practices\", ovvero delle \"regole\" che permettono immediatamente guardando un codice di capire a che cosa ci si riferisce.\r\nAltra buona abitudine è quella di usare nomi significativi e scrivere brevi commenti per esplicare cosa quella porzione di codice faccia.\r\nInfine, ma non per importanza, seguire le direttive che ci vengono date all'interno dei team di lavoro (infatti i software grandi non saranno mai sviluppati da un'unica persona).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2657,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2605,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2425,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5442,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per migliorare la leggibilità del codice occorre: una buona documentazione (commenti aggiornati ad ogni modifica del codice); l'uso dell'indentazione per facilitare la lettura del codice; una dichiarazione delle funzioni esplicite ed non ambigue (variabili con nomi significativi, esempio char carattere;); parametri della funzione devono essere precisi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2424,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2656,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2604,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5077,
          "asker": {
            "courseId": 100,
            "askerId": 867,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e come funziona la JVM? Che correlazione c'è con il Bytecode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JVM"
            },
            {
              "keyword": " Bytecode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5094,
          "asker": {
            "courseId": 100,
            "askerId": 827,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il problema della portabilità del software e come java ha provato a risolverlo?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": "portabilità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5453,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Un programma è portabile quando non bisogna modificare il codice sorgente per farlo funzionare su sistemi differenti. Si deduce quindi che la portabilità del software dipende dal linguaggio di programmazione.\r\n\r\n-Per essere più chiari prendiamo ad esempio il linguaggio C++\r\nDal punto di vista algoritmico e della compilazione del codice, se il programma è scritto usando lo standard C++ (attualmente alla versione C++14 di Agosto 2014) questo compila con qualsiasi compilatore conforme agli standard. Ma lo standard non include l'utilizzo di input/output e un programma che non si interfacci con mouse-tastiera o display-stampanti è pressoché inutile; quindi bisognerà fare delle modifiche al codice sorgente per far si che non si presentino problemi in compilazione o esecuzione.\r\n\r\nJava invece è interamente portabile infatti il software Java può essere eseguito in qualsiasi ambiente a patto che ci sia installata la JVM (Java Virtual Machine) o più precisamente le JRE (Java Runtime Environment)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2589,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2731,
                  "rater": {
                    "raterId": 827,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2594,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2419,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2677,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5416,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "Il problema consiste nella difficoltà di rendere compatibili programmi eseguibili su macchine diverse. Java provò a risolvere questo problema prima interpretando il codice sorgente in un file contenente linguaggio a basso livello (bytecode), che è eseguibile in ogni sistema operativo grazie ad una nuova macchina astratta, la Java Virtual Machine.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2590,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2595,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2678,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2417,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2732,
                  "rater": {
                    "raterId": 827,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5462,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Il problema della portabilità del software nasce nel momento in cui si prova a trasportare un software appuntini un ambiente diverso da quello d' origine .Non sono in molti i linguaggi in grado di garantire questo processo senza problemi e java rientra fra questi.\r\nCiò è possibile innanzitutto grazie al fatto che java utilizza una sintassi unificata al posto di accedere a librerie di terze parti , inoltre tramite la java virtual machine viene utilizzato un unico bytecode da tutti i complitatori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2588,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2593,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2676,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2730,
                  "rater": {
                    "raterId": 827,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2418,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5452,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Un programma è portabile quando non bisogna modificare il codice sorgente per farlo funzionare su sistemi differenti. Si deduce quindi che la portabilità del software dipende dal linguaggio di programmazione.\r\n\r\n-Per essere più chiari prendiamo ad esempio il linguaggio C++\r\nDal punto di vista algoritmico e della compilazione del codice, se il programma è scritto usando lo standard C++ (attualmente alla versione C++14 di Agosto 2014) questo compila con qualsiasi compilatore conforme agli standard. Ma lo standard non include l'utilizzo di input/output e un programma che non si interfacci con mouse-tastiera o display-stampanti è pressoché inutile; quindi bisognerà fare delle modifiche al codice sorgente per far si che non si presentino problemi in compilazione o esecuzione.\r\n\r\nJava invece è interamente portabile infatti il software Java può essere eseguito in qualsiasi ambiente a patto che ci sia installata la JVM (Java Virtual Machine) o più precisamente le JRE (Java Runtime Environment)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2587,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2729,
                  "rater": {
                    "raterId": 827,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2675,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2421,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2592,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5460,
              "task": {
                "taskId": 152,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 883,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il problema della portabilità si ha per via del compilatore associato ad ogni sistema operativo, il quale crea un file eseguibile diverso per ogni piattaforma. Con il linguaggio java si evita questo problema poiché i programmi java vengono compilati e trasformati in bytecode, il quale verrà poi letto da una macchina virtuale univoca per tutti gli SO, nel caso specifico la JVM (java visrtual machine",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2679,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2733,
                  "rater": {
                    "raterId": 827,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2591,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2596,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2420,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 152,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5073,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 151,
            "taskName": "Ask A Question"
          },
          "questionText": "Esistono altri modi per passare i parametri di una funzione? (oltre a per valore e per puntatore/indirizzo)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": "indirizzo"
            },
            {
              "keyword": "passaggio"
            },
            {
              "keyword": "parametri"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 60,
      "lectureTitle": "Lecture 9-10",
      "questions": [
        {
          "questionId": 5615,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nell'implementazione della Pila usando le collections abbiamo dovuto creare anche una classe Number? C'è un modo per evitarlo? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": "  pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5635,
          "asker": {
            "courseId": 100,
            "askerId": 894,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra il comportamento di un set e quello di una pila? Implementare una funzione bool isMember() che controlli se l'elemento inserito appartiene già al set.Se volessi un Set ordinato cosa dovrei implementare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "sort"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5581,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è utile il modificatore final?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Modificatore"
            },
            {
              "keyword": " final"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6000,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 900,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Questo semplice modificatore ha un?importanza fondamentale. È applicabile sia a variabili, sia a metodi, sia a classi. Potremmo tradurre il termine final proprio con \"finale\", nel senso di \"non modificabile\". Infatti: \r\n\r\nuna variabile dichiarata final diviene una costante. \r\n\r\nun metodo dichiarato final non può essere riscritto in una sottoclasse (non è possibile applicare l?override). \r\n\r\nuna classe dichiarata final non può essere estesa. \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5027,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4838,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4731,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4796,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5151,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4841,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5119,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5900,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "Final è utile perché permette di dichiarare variabili che non possono essere modificate (costanti), metodi che non possono essere sovrascritti tramite @Override e classi che non possono essere subclassate. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4798,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5154,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4734,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4839,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4844,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5028,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5118,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6017,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "La parola final viene utilizzata in java per implementare un metodo, una variabile o una classe che saranno \"bloccati\", ovvero nel primo caso questo non potrà essere polimorfico e quindi assumere più forme, mentre nel secondo non potrà essere modificata successivamente. Per quanto riguarda le classi queste non potranno essere estese da nessuna sottoclasse. Se si tenta di farlo, infatti, comparirà un messaggio del tipo \"Fatal error:...\". Utilizzare le classi final potrebbe sembrare privo di significato per il concetto fondamentale di estensione delle classi tuttavia spesso può risultare utile per la sicurezza e la stabilità delle applicazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5030,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4794,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5116,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5153,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4840,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4732,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4843,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5931,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La variabile Final è costante per l'istanza di una classe.\r\nFinal può essere applicato anche ai metodi di una determinata classe e un metodo definito come final implica che se eredito la classe che contiene il metodo, su questo non potrà essere eseguito l'override.\r\n\r\nSostanzialmente un oggetto (variabile, funzione o classe) final è intesa come non modificabile (overridabile) e garantisce al programmatore che nessuna modifica verrà fatta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4733,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4845,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5152,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4797,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4837,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5117,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5026,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5977,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il modificatore \"final\" è utile per tre ragioni: \r\nle variabili dichiarate in tal modo sono costanti;\r\ni metodi dichiarati final non possono essere svrascritte da altre classi (non si verifica Overriding);\r\nle classi final non possono essere subclassate (non si verifica Subclassing).\r\n\r\nAd esempio per far sì di non creare ambiguià tra classi che utilizzano una stessa funzione che è stata sovrascritta, utilizzare il modificatore final fa sì che la macchina utilizzi alla fine quel metodo e non le versioni sovrascritte successive a questo.\r\nPer quanto riguarda l'utilizzo del final sulle classi, esso permette che tali classi non siano ereditabili, poiché si suppone non necessitino di ulteriori estensioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5115,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4735,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5155,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5029,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4795,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4842,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4836,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5607,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, in che punti del codice è possibile usare il modificatore final? Qual è il suo significato in ciascuno di questi punti? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " final"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5609,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'esercizio della tombola che è stato proposto a lezione venerdì come si faceva a implementare una funzione che eviti di far uscire un numero già estratto ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tombola"
            },
            {
              "keyword": "estratto"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5597,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le Collections e quali sono le differenze tra le interfacce Set e List?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Interfacce"
            },
            {
              "keyword": " Set"
            },
            {
              "keyword": "List"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5652,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "In java cosa si intende per \"Collection\"? \r\nQuali sono i principali tipi di Interfacce delle Collection?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5630,
          "asker": {
            "courseId": 100,
            "askerId": 584,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Elencare tutte le differenze tra Set e List e le loro funzionalità",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "set"
            },
            {
              "keyword": " list"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5599,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il CAST e in quali casi può risultare utile? Quale la differenza tra UPCAST e DOWNCAST? ",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "cast"
            },
            {
              "keyword": " upcast"
            },
            {
              "keyword": " downcast"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5948,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il cast e' un operatore che \"forza\" un determinato tipo ad assumere un tipo diverso. Infatti non e' possibile assegnare il valore di un char ad un int , ma con il casting se i tipi sono compatibili si puo' farlo.\r\n\r\nchar c='a';\r\nint n = (int) c;\r\n\r\nIn Java il cast e' fondamentale per utilizzare appieno l'ereditarieta'.Se noi istanziamo un oggetto che e' la corrispettiva superclasse di una classe figlia ma con l'operatore new gli assegniamo una classe figlia otteniamo un UPCAST, in questo modo la classe figlia e' trattata come se fosse la classe madre. Invece se noi volessimo \"specializzare\" l'oggetto creato(superclasse) e trattarlo come se fosse  una qualsiasi classe figlia dovremmo utilizzare il cast e forzare il cambiamento di tipo.Questa tecnica e' chiamata DOWNCAST molto utile per utilizzare i metodi della classe figlia anche se l'oggetto istanziato in origine e' una parent class.\r\n\r\nPoint n=new NamedPoint();    // UPCAST\r\n((NamedPoint)n).getNome();  // DOWNCAST",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4717,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4907,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4680,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6005,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il cast è un modo per convertire a livello di compilazione (quindi non vengono realmente modificati i dati, ma ne viene data una rappresentazione diversa al compilatore) un oggetto di tipo A ad un tipo compatibile B. Se il tipo A è sottotipo di B, allora si parla di downcast, altrimenti se B è sottotipo di A si parla di upcast.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4716,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4906,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4681,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5923,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 748,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Abbiamo un cast quando per esempio ci viene passato un double e a noi interessa solo la parte intera: int x = (int) 4.5; \r\npuò risultare utile nell'uso delle collections.  \r\nUpcasting è l' assegnare un oggetto ad una variabile di una classe superiore.\r\nDowncasting è il contrario, ovvero assegnare un oggetto ad una variabile di una sottoclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4682,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4909,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4713,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5903,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il cast si può fare solo all?interno di una gerarchia di ereditarietà.\r\nNel caso di una sottoclasse, essendo figlia di una superclasse, può essere vista come una specializzazione della superclasse. Dunque se si ha una superclasse Persona, e una sottoclasse Uomo si può dire che un Uomo è una Persona ma non viceversa.\r\n \r\nIl downCast è molto pericoloso rispetto all' upcast: bisogna essere sicuri che avendo in mano una Persona questa sia un Uomo (in tal caso è consigliabile usare instanceOf). Il downCast è molto sconsigliato, tranne nel caso di override della equals di Object.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4908,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4679,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4714,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5947,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Upcasting e downcasting sono una parte del linguaggio Java, che ci permettono di costruire programmi complessi utilizzando una sintassi semplice, dandoci grandi vantaggi, come il polimorfismo o il raggruppamento di oggetti diversi. \r\nJava inoltre permette ad un oggetto di tipo sottoclasse di essere trattato come un oggetto di qualsiasi tipo di superclasse, questo è l'upcasting. Esso avviene automaticamente, mentre il downcasting dev'essere effettuato manualmente dal programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4715,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4683,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4910,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5656,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare le librerie nella programmazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "programmazione"
            },
            {
              "keyword": " api"
            },
            {
              "keyword": " librerie"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5622,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa hanno in comune e in che cosa differiscono un Set ed una List?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "set"
            },
            {
              "keyword": " list"
            },
            {
              "keyword": " confronto"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5558,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile invocare un metodo private di una superclasse da un istanza di una sottoclasse? Se fosse protected? Definire le differenze. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Private"
            },
            {
              "keyword": "  protected"
            },
            {
              "keyword": "  modificatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5621,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare con un esempio il concetto di \"interfaccia\" in Java",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " interfaccia"
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5575,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'utilità delle interface? Che problema risolve il loro uso?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interface"
            },
            {
              "keyword": "ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5583,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un'interfaccia e cosa una collection? In particolare come risolve un'interfaccia il problema dell'ereditarietà multipla?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interface"
            },
            {
              "keyword": " collections"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5579,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il modificatore \"final\" e come agisce?\r\n\r\nIn che senso posso sfruttare l'ereditarietà multipla con le interfacce?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " ereditarietà multipla"
            },
            {
              "keyword": " final"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5629,
          "asker": {
            "courseId": 100,
            "askerId": 802,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa comporta il modificatore 'final'?  Quali sono le convenzioni di definizione per classi e oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "final"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " oggetti"
            },
            {
              "keyword": " def"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5634,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un UML e come si costruisce? Quali sono le differenze fra l'eredità IS-A, HAS-A e PART-OF?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " eredità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5907,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un UML (Unified Modeling Language) è in sostanza una rappresentazione grafica delle relazioni che hanno fra loro le classi rispetto all'ereditarietà. Per indicare l'ereditarietà vera e propria (\"is-a\") si rappresenta la sottoclasse proprio sotto la superclasse, collegata con una linea terminante in un triangolino. Per indicare invece un'aggregazione (\"has-a\") si posizionano le classi parallele e si collegano con una linea terminante in un rombo (indica che una può esistere senza l'altra). Se il contenitore non può esistere a prescindere dal contenuto il rombo è riempito e in questo caso di parla di composizione (\"part-of\").",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4984,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5175,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4967,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5134,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5936,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Un UML consiste nella rappresentazione delle classi tramite una notazione grafica. Ogni classe è rappresentata da un rettangolo (contenente anche gli attributi e le operazioni che la compongono) e si utilizzano le frecce per indicare che la classe \"eredita da\" un altra classe, ossia tutte le varie associazioni fra le classi.\r\nIS-A, HAS-A e PART-OF sono 3 possibili relazioni fra le classi.\r\nCon la IS-A si intende la più comune relazioni fra 2 classi: B extends A. Con questo tipo di relazione, B eredita tutti i metodi di A.\r\nCon la HAS-A e PART-OF la classe B contiene A come oggetto. Esse però si differenziano in quanto B può anche non contenere A, in quanto 2 oggetti di tipologia diversa, mentre con PART-OF, B non può essere concepito senza utilizzare A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5138,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4969,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5174,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4986,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5974,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "UML (Unified Modeling Language), come si intuisce dal nome, è un linguaggio di modellazione unificato basato sul paradigma object-oriented, cioè attraverso diagrammi si esprimono le relazioni esistenti fra le classi.\r\nIn UML è strutturato in: nome della classe, variabili di istanza, lista dei metodi.\r\nLe principali differenze tra le eredità sono:\r\nIS-A è una classe che eredita da un'altra cioè una classe che estende un'altra (comunque di classi simili);\r\nesempio: lo studente è una persona  ma la persona può non essere uno studente.\r\nHAS-A quando una classe può avere un valore nullo e la relazione continua ad esistere (fra diversi tipi di classi);\r\nesempio: la persona è \"dentro\" (fa parte) della stanza ma se la persona non c'è la stanza esiste comunque.\r\nPART-OF quando una classe è parte essenziale di essa e quindi non può avere valore nullo perchè la relazione non continua ad esistere;\r\nesempio: le gambe fanno parte del tavolo ma senza di esse il tavolo non può esistere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4968,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5137,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4985,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5172,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6011,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 824,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Un UML è una notazione grafica per mostrare le relazioni di ereditarietà tra diverse classi di un programma Java. Ogni classe viene identificata con un blocco quadrato solitamente diviso in 3 parti (nome classe, metodi, variabili). Apposite frecce indicano i diversi legami tra le classi.\r\nLa relazione IS-A (indicata con una freccia avente come vertice un triangolino dalla parte opposta alla sottoclasse), indica una relazione in cui una classe, oltre a tutti i suoi metodi ed alle sue variabili di istanza, eredita (e quindi può utilizzare) da una classe superiore tutto ciò che essa contiene.\r\nLa relazione HAS-A (aggregazione, indicata con una freccia con un rombo in punta) è una relazione in cui una classe contiene ed utilizza, anche più volte, oggetti del tipo di un'altra classe. PART-OF funziona nello stesso modo di HAS-OF con la differenza che la classe container A (contenente più oggetti di tipo B) non può essere concepita senza gli oggetti di tipo B al suo interno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5135,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5171,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4970,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4987,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5915,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "UML, la cui sigla stà per Unified Modeling Language, è un metodo per descrivere l'architettura di un sistema nel dettaglio, usato per capire e descrivere le caratteristiche di un nuovo sistema o di uno esistente. Si può costruire un modello seguendo le regole semantiche e sintattiche del linguaggio servendosi di appositi programmi.\r\nSono 3 differenti tipi di operazioni tra classi: l'associazione è un'associazione uno a uno o uno a più; l'aggregazione viene definita come una relazione nella quale le classi parte hanno un significato anche senza che sia presente la classe tutto; la composizione è definita come una relazione forte, una relazione nella quale le classi parte hanno un reale significato solo se sono legate alla classe tutto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5173,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4983,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5136,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4966,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5572,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche e i principali vantaggi dell'introduzione delle interfacce in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interface"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5613,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Come posso inserire un dato di tipo float in una Collection? Perché non è possibile aggiungerlo \"direttamente\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " Object"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5574,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le Collection e cosa possono o non possono contenere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": "definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5616,
          "asker": {
            "courseId": 100,
            "askerId": 881,
            "courseFinalScore": 9
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono gli iteratori nelle interfaccie? Dai un esempio in codice di almeno 2 iteratori.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iteratore"
            },
            {
              "keyword": " interfaccie"
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5626,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono  le collections? Come si gestiscono? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " arraylist "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5555,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione dell'Iterator e come è implementata la sua interfaccia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " Interface"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5589,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali metodi dell'interfaccia Iterator e in quali casi, lavorando con le Collection, può essere utile fare uso di iteratori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " interfaccia"
            },
            {
              "keyword": " Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5567,
          "asker": {
            "courseId": 100,
            "askerId": 900,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le parole chiave: private, public, protected. Dammi un chiaro esempio",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Private"
            },
            {
              "keyword": " public"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5899,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 921,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "queste tre parole sono in java dei modificatori di accesso cioè sono delle parole che conferiscono, a seconda di quale viene usata, una diversa visibilità dell'oggetto a cui sono assegnate all'interno del programma. Public: rende visibile l'oggetto in qualsiasi parte del programma. Private: l'oggetto può essere visto e utilizzato solo all'interno della classe in cui è stato creato. Protected: visibile da tutte le classi e sottoclassi che condividono lo stesso package",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5043,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5128,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4930,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5203,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4822,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5918,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Gli attributi sopracitati servono per determinare a quali classi è visibile una determinata cosa (variabile, classe...). Nello specifico public rende visibile la cosa a tutte le classi, protected solo alla classe e le sottoclassi, private solo a quella classe li.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4928,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5202,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5042,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5127,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4825,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5969,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Queste parole chiave sono dei modificatori di visibilità applicabili ad attributi e metodi delle classi in Java; in particolare il modificatore \"public\" rende un elemento visibile a qualsiasi classe anche esterna al progetto, \"protected\" permette la visibilità a tutte le sottoclassi oltre che al package corrente, mentre private restringe l'accesso alla sola classe stessa.\r\nVi è inoltre un modificatore di default che viene adottato se non se ne specificano altri.\r\nEsso permette la visibilità ad ogni classe del package corrente.\r\n\r\npublic class Esempio { \r\n   private int n;    \r\n   public float f;\r\n   protected double d;     \r\n// si applicano i modificatori di visibilità come descritti sopra\r\n\r\n   public int getN() {     \r\n      return n; \r\n   }\r\n// getN() permette l'accesso in sola lettura all'attributo n da ogni classe anche esterna al package\r\n\r\n   public void setD(float d){\r\n      this.d=d;\r\n   }\r\n// setD() permette l'accesso in sola scrittura all'attributo d\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5044,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4931,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4823,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5126,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5205,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5998,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Metodi/attributi dichiarati private, non sono visibili o usabili all'esterno della classe che li contiene. Due oggetti della stessa classe però, possono vedere i rispettivi metodi/attributi privati. I valori private vengono incapsulati, rendendo impossibile il loro richiamo o modifica da parte di altro codice per disattenzione o casualità perché per leggerli o modificarli bisogna implementare e chiamare appositamente get e set.\r\npublic può essere attribuito a tutti gli elementi di una classe e li definisce come \"pubblico\" e quindi visibili e modificabili dall'esterno della classe, da qualsiasi package.\r\nprotected può essere attribuito solo ai metodi e alle variabili interne alla classe e non alla classe stessa, esse sono visibili da classi dichiarate nello stesso package e da sottoclassi e classi derivate dichiarate ovunque.\r\nIn assenza di questi tre, l'elemento assume visibilità di default ed è di accesso pubblico ma solo ed esclusivamente al package della classe dove è inserito.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4824,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5041,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5129,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5204,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4929,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5633,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella programmazione ad oggetti, nello specifico in Java, che cosa sono le interfacce? In che cosa si distinguono e che vantaggi hanno rispetto alle classsi astratte?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " interface"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6012,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 783,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Nella programmazione orientata agli oggetti con interfaccia si intende un tipo analogo alla classe ma vincolato a non definire l'implementazione dei propri metodi. \r\nLe interfacce presentano diversi vantaggi, esse possono definire tipi di dati astratto, di cui forniscono la specifica delle operazioni, il modo in cui le operazioni sono effettivamente definite verrà determinato dalla classe che realizza l'interfaccia.\r\nLe interfacce possono essere utilizzate come \"contratto\" tra chi implementa una classe e chi la usa. Questo permette di procedere in parallelo alla scrittura delle due parti, e di integrarle alla fine.\r\nInoltre la classe che implementa l'interfaccia può essere sostituita con un'altra più efficiente o più conveniente, senza modificare il programma che la utilizza.\r\nInfine, una classe può implementare più di una interfaccia.Quest'ultima caratteristica fornisce la massima flessibilità nella definizione del comportamento che si desidera attribuire ad una classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5200,
                  "rater": {
                    "raterId": 798,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5245,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5133,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5070,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4747,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5984,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le interfacce sono delle classi particolari in Java che consento solo la dichiarazione di metodi senza la loro implementazione. L'implementazione dei metodi dovrá essere effettuata dalla classe che li implements. Queste classi particolari permettono l'ereditarietá multipla cosa non concessa con classi normali.\r\nLa classe astratta é una classe che al suo interno deve avere almeno un metodo astratto, quindi la classe astratta non ha tutti i metodi astratti ma solo alcuni mentre le interfacce hanno tutti metodi \"astratti\" ossia che vanno implementati dalle classi. Un'altra differenza sostanziale é che la classe astratta deve avere una sottoclasse che implementi i suoi metodi astratti mentre i metodi delle interfacce posso essere implementati da classi differenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4745,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5071,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5198,
                  "rater": {
                    "raterId": 798,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5130,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5247,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6021,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Le interfacce sono collezioni di firme di metodi prive di implementazione, paragonabili agli header del c++.\r\nLe interfacce si differenziano dalle classi astratte in quanto nelle interfacce non è possibile inserire codice, ma solo firme e costanti; inoltre ogni classe può implementare diverse interfacce ma estendere una sola classe astratta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5201,
                  "rater": {
                    "raterId": 798,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4744,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5068,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5131,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5244,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5922,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 848,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un'interfaccia Java rappresenta un prototipo che consente al programmatore di definire lo scheletro di una classe, con i propri nomi dei metodi, i propri tipi ritornati e la lista dei parametri. A differenza delle classi astratte, che richiedono, ad esempio, la definizione dei metodi al suo interno nel caso vengano implementate nuove classi derivate da essa, l'interfaccia stabilisce il protocollo di una classe senza preoccuparsi dei dettagli di implementazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4746,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5069,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5132,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5199,
                  "rater": {
                    "raterId": 798,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5246,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5582,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche di una classe abstract? Può contenere metodi non abstract? Una classe non abstract può, invece contenere metodi abstract?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi abstract"
            },
            {
              "keyword": " metodi abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6016,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe abstract è un particolare tipo di classe che non può essere istanziata e, per tale motivo, deve essere obbligatoriamente subclassata. Una classe abstract può contenere sia metodi non abstract sia metodi abstract. Di questi ultimi non è presente l'implementazione nella classe abstract e perciò essi devono essere necessariamente sovrascritti nelle sottoclassi. Viceversa non è possibile definire metodi abstract in classi non abstract. \r\nLe classi abstract sono utilizzate essenzialmente per \"raccogliere\" metodi che sono comuni a diverse sottoclassi ma che vengono implementati in maniera differente da ciascuna di esse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4913,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4977,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4783,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4942,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4899,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5954,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 798,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In una classe abstract possono essere presenti metodi sia astratti che implementati,  mentre una classe normale contiene solo metodi implementati e dà errore inserendo un metodo abstract. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4943,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4914,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4782,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4900,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4978,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5940,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Una delle caratteristiche principali di una classe dichiarata 'abstract' è il fatto che non può essere istanziata ma può essere subclassata. Se una classe ha almeno un metodo ' abstract' (metodo che contiene solo la dichiarazione e non la sua implementazione) deve essere dichiarata 'abstract' e l'implementazione del metodo deve essere realizzata nelle sue sottoclassi (per questo si puo anche dire che una classe abstract 'deve' essere subclassata). Se no,anche loro si dichiarano abstract. Ma una classe abstract puo contenere anche metodi non abstract. Invece una classe non abstract,quindi concreta ,non puo contenere metodi abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4941,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4976,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4912,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4780,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4898,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5910,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "La caratteristica principale delle classi che vengono dichiarate con abstract è che non possono essere ne instanziate ne subclassate , le classi astratte posso essere considerate super-classi che contengono metodi astratti perché sono progettate in modo che le sotto classi che ereditano da esse implementino i metodi estendendone le funzionalità.Le classi abstract possono contenere metodi non abstract ma una classe che contiene almeno un  metodo abstract deve essere obbligatoriamente definita come abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4911,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4940,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4781,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4975,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4897,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5610,
          "asker": {
            "courseId": 100,
            "askerId": 859,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono le collections e perchè vengono utilizzate?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gruppo"
            },
            {
              "keyword": " elementi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5614,
          "asker": {
            "courseId": 100,
            "askerId": 494,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Una collection può contenere valori di tipo int o double? Se sì, come?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " oggetti"
            },
            {
              "keyword": " int"
            },
            {
              "keyword": " double"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5605,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Map e per Sorted Map quando si parla di Core Collections Interfaces?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Map "
            },
            {
              "keyword": " Sorted Map"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5618,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il problema che sorge con l'introduzione dell'ereditarietà multipla?\r\nIn quale modo le interfacce lo risolvono?",
          "totalDifficultyLevel": 22,
          "totalInterestingnessLevel": 25,
          "totalRelevanceLevel": 27,
          "numEvaluators": 7,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "multipla"
            },
            {
              "keyword": "interfacce"
            },
            {
              "keyword": "abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6008,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 100,
                "courseFinalScore": 16
              },
              "answerText": "L'ederitarietà multipla crea ambiguità: entrambi i genitori hanno un campo o una funzione x, di diverso tipo. Quale ereditare? E quale costruttore della superclasse chiamare? L'ereditarietà da una singola classe crea decisamente meno problematiche. I creatori di Java hanno preferito la semplicità, ma non per questo a discapito della flessibilità, grazie all'uso delle interfacce.\r\n\r\nEssendo le interfacce contenitore di firme di funzioni pubbliche, permettono definire solamente delle funzionalità \"viste dall'esterno\" e comuni tra le implementazioni. Non definiscono altro. Non introducono ambiguità di quelle citate sopra (a meno che uno non se le vada proprio a cercare).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5087,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5207,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4855,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5104,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4748,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5111,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5230,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5930,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 823,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con l'ereditarietà multipla può insorgente un errore nel caso in cui una sottoclasse erediti da due superclassi due metodi diversi aventi la stessa firma. Tale situazione non si presenta nel caso si utilizzi l'ereditarietà multipla per interfacce, in quanto in esse sono definite le firme dei metodi ma non la loro implementazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4749,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5208,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5088,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5105,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5109,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4854,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5232,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6001,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Le complicazioni che sorgono con l'introduzione dell'ereditarietà multipla sono essenzialmente le ambiguità che si formano quando si cerca di estendere una classe con due o più superclassi che hanno attributi con lo stesso nome o metodi con la stessa firma.  Le interfacce risolvono questa ambiguità perché anche nel caso si ereditassero due metodi con lo stesso nome da interfacce diverse è sempre necessario riscrivere il metodo. In Java si parla di ereditarietà multipla semplificata perché in realtà le classi possono ereditare dalle interfacce solo la loro parte funzionale (i metodi) e non i dati. In Java 8 con l'introduzione di metodi statici e di default per le interfacce tutto si complica perché le ambiguità che abbiamo parlato prima risologono per quest'ultime, la situazione si risolve tramite l'override nella classe che estende. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4751,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5110,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5211,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5229,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5107,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5090,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4852,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5960,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il problema che sorge con l'ereditarietà multipla tra oggetti è saper come risolvere la definizione dei metodi. Ad esempio se A IS-A B e A IS-A C, e tutti e tre gli oggetti definiscono il metodo f, non si sa quale venga eseguito a runtime.\r\nLe interfacce sono raccolte di costanti e firme di metodi senza corpo. Quindi se una classe implementa due interfacce, aventi entrambi la firma di un metodo f, una volta che la classe scrive il metodo f, è unico e definito per entrambe le intefacce, risolvendo le ambiguità dovute all'ereditarietà multipla",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4750,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5106,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4858,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5112,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5212,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5089,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5231,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6014,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'ereditarietà multipla si ha quando una sottoclasse eredita da più superclassi: essa deriva il suo codice (e quindi il suo comportamento e le sue proprietà) non solo da una, ma da più classi. Nonostante l'idea sia buona, possono insorgere alcuni problemi:\r\n- la struttura gerarchica delle classi si complica e da albero diventa grafo, dunque sarà più complesso seguire il codice e capire cosa farà il compilatore;\r\n- ci sono ambiguità sintattiche per la gestione di variabili strutturali e/o comportamentali, che risultano eredità comune di più superclassi.\r\n\r\nTramite il concetto di interfaccia, Java offre supporto ad un meccanismo di simulazione dell?ereditarietà multipla. Un? interfaccia dichiara metodi e costanti, ma non definisce né variabili né metodi; non avendo implementazioni, si elimina il rischio di collisione fra metodi o dati omonimi. Questo fa sì che le interfacce possano sopportare l'eredità multipla senza troppi rischi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5101,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4754,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5209,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4856,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5084,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5233,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5114,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5916,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 925,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In alcuni contesti l'ereditarietà multipla può essere causa di qualche confusione.\r\nUna possibile causa di ambiguità è la seguente: se due classi B e C ereditano dalla classe A e la classe D eredita sia da B che da C, se un metodo in D chiama un metodo definito in A, da quale classe viene ereditato? B o C?\r\nQuesto dilemma prende il nome di \"diamond problem\" (problema del diamante), a causa della forma del diagramma di ereditarietà delle classi, simile ad un diamante.\r\n\r\nPer ovviare a questo problema, in Java si è adottato questo compromesso: una classe può ereditare le interfacce da più di una classe base, ma può ereditare i dati ed i metodi effettivi da una sola classe base. Le interfacce, infatti, permettono di definire metodi comuni a classi senza darne un?implementazione (è possibile definire solo parametri di metodi e costanti).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4753,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5086,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5108,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5103,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5234,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4853,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5206,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5945,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sorge il seguente problema: quando hai due classi B e C che ereditano entrambi dalla classe A, e a sua volta una classe D che eredita sia da B che da C allora chiamando in D un metodo definito in A si crea ambiguità non sapendo da che classe (B o C) i metodo sia stato chiamato.\r\nLe interfacce permettono di creare una specie di scheletro costituito da metodi astratti (non ancora eseguibili)che serve come punto di inizio ad una classe che lo voglia ereditare.Fino a java8 , il linguaggio non aveva questo problema perché non permetteva ereditarità multipla.Da java 8,ogni classe può sì ereditare da più interfacce, ma può ereditare le variabili e gli specifici metodi da una classe soltanto altrimenti genera un errore a runtime.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5102,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5228,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5210,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4752,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5113,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4857,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5085,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5594,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra un hashset ed un arraylist?\r\nE a cosa serve un iteratore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": "iteratori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5588,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una Collection? A cosa serve? In che campo si usa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " utilizzo"
            },
            {
              "keyword": " scopo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5638,
          "asker": {
            "courseId": 100,
            "askerId": 434,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra Set e List, definite nella libreria java.util.Collections?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 21,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5991,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "List e set sono due tipologie di collection che possiamo trovare in java. \r\nSet è un insieme di elementi senza ripetizione e non ha il concetto di posizione, per cui non è possibile accedere ai vari elementi indicando la loro posizione tramite un indice.\r\nList è invece basato sul concetto di sequenza. Quindi gli elementi di una List possono ripetersi ed è possibile accedervi tramite un indice poiché ha il concetto di posizione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4849,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4758,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5121,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5165,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4890,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5994,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 771,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Una list è una sequenza di elementi ordinati nella stessa maniera in cui sono stati inseriti, e può contenere duplicati, è generalmente implementata come un ArrayList o una LinkedList.\r\nUn set è invece un insieme di elementi il cui ordine non è garantito che rimanga quello di inserimento e che non può contenere elementi che sono uguali tra loro, l'uguaglianza è stabilità dal metodo equals della classe Object; un set è di solito implementato come HashSet o TreeSet.\r\n\r\nDato che esistono delle implementazioni di set che mantengono l'ordine, come un LinkedHashSet, la differenza più sostanziale è costituita dal fatto che in un set non esitono duplicati, e inserire un elemento già presente non altera di fatto il set.\r\nQuesta risposta è data pensando che chi ha fatto la domanda intendesse java.util.Collection, e non Collections, in ogni caso la risposta non cambia, ma è giusto ricordare che Collections riguarda Set/List/Map vuote e costanti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4891,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4760,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5168,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4850,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5124,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5956,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 885,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "List contiene dati oridinati e permette duplicati al contrario di set.\r\n \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4846,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4887,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5125,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5167,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4757,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5963,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Set e List sono due esempi di Collection(interfacce), ossia insiemi di oggetti che non possono contenere tipi di dato primitivi. List è una collection ordinata che può contenere duplicati:essi sono accessibili tramite indice e mantengono l'ordine di inserimento(nella rimozione di un elemento contenuto in duplice copia, ne viene eliminato uno soltanto, nell' ordine). Set è una collection che, al contrario, non contiene elementi ordinati(a meno che non sia la sottoclasse SortedSet) e che non è accessibile tramite indice: essa non può contere duplicati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4848,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4759,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5120,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4888,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5166,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5904,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Sostanzialmente nella list possono essere contenuti elementi multipli mentre nella set non possono essere contenuti elementi multipli. Considerando a una Collection:\r\na.add(1)\r\na.add(2)\r\na.add(2)\r\na.add(1)\r\na.add(3) \r\navrà come risultato:\r\n1,2,3 se a è un Set\r\navrà come risultato:\r\n1,2,2,1,3 se a è un List",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5170,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4756,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4886,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4847,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5123,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6022,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 901,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Set è una collection che non può contenere elementi duplicati, questi elementi non mantengono l'ordine in cui son inseriti e non son accessibili tramite indice.\r\nList altresì è una collection ordinata che può contenere elementi duplicati a cui si può accedere mediante un indice e che son memorizzati in ordine di inserimento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4889,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5169,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4851,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5122,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4755,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5608,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le collection e quali sono i vantaggi / svantaggi nell'utilizzarle?",
          "totalDifficultyLevel": 27,
          "totalInterestingnessLevel": 29,
          "totalRelevanceLevel": 33,
          "numEvaluators": 8,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": "utilizzo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5949,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le collections sono un insieme di oggetti che contengono interfacce, implementazioni(classi) e algoritmi che, semplificano parte dell'implementazioni degli diversi oggetti.\r\nEssi hanno il vantaggio di agevolare l'utilizzatore avendo già delle classi implementate di default, risparmiando tempo di lavoro a chiunque ne faccia uso.Inoltre le diverse interfacce che contengono le firme dei metodi danno diverse possibilità al programmatore di implementarle a seconda delle proprie necessità.\r\nUno svantaggio delle collections è l'omogeneità dei tipi (Object) che, obbliga constantemente l'utilizzatore ad eseguire un cast sull'oggetto di tipo non primitivo in caso le volesse utilizzare per eseguire delle operazioni tra tipi primitivi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4761,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4817,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5005,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4932,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4920,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5053,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4871,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6024,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Le Collection sono delle interfacce che forniscono appunto delle operazioni su una generica collezione di oggetti.\r\n\r\nDi fatto, una Collection è un oggetto che raggruppa elementi multipli in una singola entità. Gli elementi multipli possono essere raggruppati con criterio differente (insieme ordinato, contenente elementi multiplo, etc.) e in base a ciò esistono differenti tipo di Collection (Tree Set, Linked Lista, etc.)\r\n\r\nIl vantaggio principale che si ha nell'usare è che, grazie ad esse, abbiamo già a disposizione uno strumento per offettuare operazioni su gruppi \"naturali\" di oggetti.\r\n\r\nLo svantaggio più evidente è che richiedono le stesse precauzioni delle Interfacce, quindi ad esempio i loro metodi possono riceve solo dei dati di tipo Object. A volta questo approccio può essere controintuitivo, perché se ad esempio volessi aggiungere un intero ad un Set, non possono aggiungerlo come int ma devo prima convertirlo (in un qualche modo a piacere) in un Oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4818,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5055,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4766,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5011,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4938,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4877,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4926,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5959,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Le collection di Java sono una gerarchia di classi contenute nel package java.util che implementano vari tipi di \"collezioni\" di oggetti: set, liste, mappe. La gerarchia comprende sia interfacce, che definiscono i metodi che ogni tipo di collection deve implementare, sia classi concrete che ne forniscono diverse implementazioni. I vantaggi nell'usare le collection sono la possibilità di definire metodi che operano sulle interfacce, astraendo dunque gli algoritmi dalla particolare implementazione di collection scelta, permettendo di cambiarla senza dover riscrivere tutto il codice, la possibilità di estendere le classi o implementare le interfacce per implementare nuove collections specializzate in base alle particolari necessità dell'applicazione. Uno svantaggio (se non si usano i \"generics\" introdotti in Java 5) è il fatto che una collection contiene Objects, e ciò obbliga il programmatore ad effettuare cast espliciti in fase di estrazione, oltre ad impedirne l'uso coi tipi primitivi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4927,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4878,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5052,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4767,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4939,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5010,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4815,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5989,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una collection è un'interfaccia, cioè un insieme di firme di metodi (senza implementazione).\r\nEssa raggruppa elementi multipli (anche eterogenei) chiamati elementi ed è usata per immagazzinare, recuperare e trattare dati, e per trasferire gruppi di dati da un metodo ad un altro.\r\nHa delle basic operations, che permettono di lavorare su un generico insieme, come per esempio il metodo boolean add(object element) che permette di aggiungere elementi, o iterator iterator () che serve a visitare la collezione.\r\nUna collection può essere un Set (una collection che non può contenere elementi duplicati) o una List (cioè una collection ordinata che può avere elementi duplicati); a loro volta i set si dividono in HashSet e TreeSet, mentre la liste in ArrayList e LinkedList.\r\nVantaggi: \r\n-aumenta la velocità di scrittura e la qualità del codice e di nuove API\r\n-Permette la interoperabilità tra API non correlate\r\n-Supporta il riuso di codice\r\nSvantaggio: impossibilità di inserire tipi primitivi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5050,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4821,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5007,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4765,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4874,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4923,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4935,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5987,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 756,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Una collection è una struttura che raggruppa molti oggetti della stessa classe. Esistono dei metodi per accedere e manipolare questi dati:\r\n\r\n - add(elem): aggiunge un elemento.\r\n - remove(elem): rimuove un elemento.\r\n - next(): restituisce il prossimo elemento.\r\n - hasNext(): da vero se esiste l'elemento successivo a quello puntato, falso altrimenti.\r\n - sort(): ordina gli elementi della collection.\r\n - shuffle(): mescola gli elementi della collection.\r\n - isElement(elem): dice se una certa istanza di un oggetto è contenuta nella collection.\r\n\r\nIl vantaggio di utilizzare una collection è che si può trattare come un'unica entità, contenente più dati, quindi posso usarla ad esempio per passare un solo parametro ad una funzione, invece che passarne molti. \r\nLe collection si dividono in Set e List. Un Set non può contenere elementi doppi e gli elementi non sono ordinati. Una List invece può contenere elementi duplicati e mantiene l'ordine di inserimento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4876,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4763,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5056,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5009,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4937,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4816,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4925,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5937,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Le collections sono degli oggetti atti a contenere degli elementi (anche eterogenei) di qualsiasi tipo, secondo le strutture dati standard (come, ad esempio, gli alberi e le linked list). Inoltre hanno un'interfaccia comune tramite la quale è possibile manipolarle senza conoscere la loro implementazione. I vantaggi nell'utilizzarle sono una migliore qualità del codice, la maggiore velocità di scrittura del programma, un'ampia possibilità di riuso del codice e la possibilità di cooperare tra API diverse tramite queste interfacce. Purtroppo si ha uno svantaggio nell'estrazione di elementi da esse, poiché è necessario controllare successivamente di che tipo è l'elemento estratto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4936,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5004,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4819,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4875,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4924,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4764,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5054,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5968,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le collection sono degli oggetti che contengono al loro interno elementi multipli (per esempio una mano di poker è una collezione di carte).\r\nVantaggi:\r\nLe collection funzionano con tutti gli oggetti.\r\nForniscono una grande interoperabilità fra API non correlate.\r\nFavoriscono un riuso del codice.\r\nSvantaggi:\r\nRispetto agli array sono meno performanti e occupano più memoria.\r\nNon esistono limitazioni sul tipo di oggetto che posso inserire in una collection (posso inserire dei cani in una collection di gatti).\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5049,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5008,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4820,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4921,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4762,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4933,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4872,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5996,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Una collezione, o contenitore, è semplicemente un oggetto che raggruppa più elementi in una singola unità.\r\nLe collezioni sono utilizzate per memorizzare, recuperare, manipolare e comunicare dei dati aggregati.\r\nEsse sono composte da: interfacce (tipi di dati astratti come List, Queue, Set etc), implementazioni astratte (parziali implementazioni di interfacce), implementazioni concrete (classi che implementano le interfacce), algoritmi (funzioni come ordinamento e ricerca) e utilità.\r\nIl principale vantaggio è la possibilità di disporre di questi \"contenitori\" già sviluppati, predisposti e ottimizzati per la rappresentazione della realtà.\r\nTuttavia esistono anche svantaggi, infatti, non essendovi limiti  sul tipo di oggetti inseribili all'interno di una collection all'estrazione di essi li ritroveremo come un Object e quindi sarà necessario un cast a run time.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4873,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5051,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4922,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4934,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5006,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4814,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4768,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5602,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra le classi astratte e le interfacce?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " astratta"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5938,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe astratta è una classe che viene de&#64257;nita solo per stabilire una interfaccia comune per tutte le sue sottoclassi. Essa dovrà definire tutti i metodi astratti, altrimenti dovrà essere etichettata anch'essa come stratta. Oltre a metodi astratti una classe astratta può contenere dati e metodi non astratti. Essa con uno o più metodi astratti deve essere a sua volta dichiarata astratta. Inoltre può avere un costruttore che non sarà mai usato direttamente, ma sarà chiamato dai costruttori delle classi derivate. Infine essa può essere estesa con l'operatore extends.\r\nUn?interfaccia è una struttura che definisce un protocollo di comportamento, che può essere implementato da una qualunque classe. Essa definisce un insieme di metodi ma non li implementa. Inoltre non si possono definire variabili ma solo costanti. La classe che implementa un'interfaccia deve definire tutti i metodi. Per dichiarare che una classe implementa un'interfaccia si deve usare la parola chiave implements.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4639,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4672,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4684,
                  "rater": {
                    "raterId": 790,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5944,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una interfaccia è una collezione di firme di metodi non implementati. Ovvero viene definito l'eventuale tipo di dato ritornato, il nome del metodo e i parametri, senza però alcun \"corpo\", quindi è solo un pattern che lo sviluppatore dovrà rispettare\r\nUn'interfaccia può anche dichiarare costanti.\r\n\r\ninterface MotorVehicle\r\n{\r\n    void run();\r\n    int getFuel();\r\n}\r\n\r\nUna classe abstract oltre ad essere più dispendiosa in termini di CPU, permette di descrivere anche il comportamento dei metodi, come definire che tipo di variabile si vuole ritornare.\r\nabstract class MotorVehicle\r\n{\r\n    int fuel;\r\n    int getFuel()\r\n    {\r\n         return this.fuel;\r\n    }\r\n    abstract void run();\r\n}\r\n\r\nMetodi e variabili di una abstract class possono essere definiti con qualsiasi visibilità, mentre nelle interfacce i metodi devono essere public.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4685,
                  "rater": {
                    "raterId": 790,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4673,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4638,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5649,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega l'utilizzo dei modificatori: private, public e protected.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": " visibilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5620,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'iterator?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6004,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 762,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un iterator è un oggetto che consente di vedere tutti gli elementi contenuti in un altro oggetto.\r\nUn iterator può essere considerato un tipo puntatore specializzato che fornisce un punto di accesso sequenziale agli elementi di un oggetto che contiene un numero finito di oggetti più semplici detto aggregato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5046,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4689,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5226,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5932,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'iterator si usa nelle collection per estrarre un elemento e passare il puntatore all'elemento successivo. Esso può essere migliorato facendolo ritornare true se l'azione è riuscita e false se fallisce.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5045,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4686,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5225,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6003,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'iteratore è legato ad una collection. Fa parte della classe java.util. La sua funzione è quella di sostituire l'enumerazione nel Java Collection Frameworks. L'iteratore differisce da l'enumerazione in due aspetti:\r\n1)  l'iteratore consente al chiamante di rimuovere elementi dalla collection predefinita durante l'iterazione.\r\n2) il metodo nome è supportato.\r\nL'iterator è inoltre legato alle interface che è un membro della Java Collections Framework.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5224,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5047,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4687,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5950,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 773,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'iterator è una classe che, attraverso i suoi tre metodi, visita tutti gli elementi di una qualsiasi collezione.\r\nQuesto lavora mettendosi nella prima posizione della collezione e ogni volta che gli viene richiesto di leggere o rimuovere un elemento, lui esegue l'istruzione e poi si sposta in avanti, al prossimo elemento, aspettando l'istruzione successiva.\r\n\r\nI metodi di questa classe sono:\r\n-hasNext: che ritorna true se ci sono ancora elementi da scorrere\r\n-next: che ritorna l'elemento successivo\r\n-remove: che rimuove dalla collection l?ultimo elemento ritornato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4688,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5227,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5048,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5557,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono i modificatori? Spiegare anche le loro funzionalità. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5563,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè abbiamo dovuto introdurre le interfacce?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzionalità"
            },
            {
              "keyword": " metodi di quella classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5631,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Il concetto di polimorfismo e la keyword abstract come sono legati? fare un esempio non complicato semplice e commentato, puo essere anche la sola risposta",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Abstract"
            },
            {
              "keyword": "ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6006,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un metodo abstract è la definizione della firma di un metodo, non implementato; una classe abstract non è istanziabile, deve essere estesa da una sottoclasse priva di metodi astratti. Un esempio di applicazione:\r\npublic abstract class Stack /*per gestire un insieme di interi tramite array*/\r\n{\r\nprotected int marker; \r\nprotected int[] contenuto; /*l'array che contiene l'insieme*/\r\n(...altri campi, costruttore...)\r\npublic void inserisci(int){...} /*le sottoclassi useranno lo stesso metodo di inserimento*/\r\npublic void cresci(){...} /*il metodo che allarga l'array se pieno*/\r\npublic abstract int estrai(); /*metodo da implementare in sottoclassi*/\r\n}\r\npublic class Pila extends Stack /*implementiamo un estrai che restituisce l'elemento inserito più recentemente (last in first out)*/\r\n{\r\npublic int estrai(){...}\r\n} \r\nLa classe Stack fornisce uno scheletro per costruirne altre, tipo pile, code ecc. \r\nOra il principio di sostituzione mi permette di istanziare:\r\nStack p1 = new Pila();\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4701,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4664,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4982,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4870,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4999,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5999,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sono legati perchè lekayword abstract sono classi che dichiarano metodi senza implementarli, quindi bisogna creare sottoclassi che implementano questi metodi(polimorfismo).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4667,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4997,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4869,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4981,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4702,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5992,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La keyword abstract permette di definire delle classi e metodi astratti, cioè tali che non \r\npossano essere istanziati e che debbano essere obbligatoriamente subclassati. Nel polimorfismo,\r\nquesta possibilità è molto utile poichè è possibile definire dei metodi, la cui implementazione\r\nè diversa in base alla classe in cui essi sono sovrascritti. Per esempio, data una classe abstract \r\nForma(), definisco un metodo abstract disegna() che deve produrre in output il disegno di una \r\nfigura. Ovviamente, classi che definiscono forme come cerchi, triangoli, quadrati avranno\r\nmetodi disegna() con un'implementazione diversa, essendo le figure tutte diverse\r\nfra di loro. Quindi, io posso scrivere \"Forma F = new Triangolo()\" ed eseguire \"F.disegna()\".  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4700,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4666,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4867,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4979,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4998,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5914,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Polimorfismo e  keyword abstract, sono due concetti fondamentali della programmazione orientata agli oggetti. Sia le classi astratte che le interfacce non possono essere instanziate poichè al loro interno definiscono soltanto i metodi e le proprietà che dovranno essere implementate dalle classi che deriveranno da esse, rappresentano pertanto un modello, un \"template\" per le classi che una volta derivate ed instanziate ne implementeranno il comportamento.\r\n\r\nClassi astratte ed interfacce, sono simili tra loro, ma sebbene le similitudini sono molte vi sono delle sottili ma fondamentali differenze concettuali.\r\n\r\nUna classe astratta è una classe che non può essere instanziata e che serve solo per essere derivata, definendo al suo interno metodi e proprietà tutti o in parte anch'essi astratti.\r\n\r\nLe interfacce sono molto simili alle classi astratte, in quanto anch'essa definisce metodi e proprietà astratte, pero non troveremo l'implemetazione di alcun metodo o proprietà",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5000,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4868,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4703,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4980,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4665,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5604,
          "asker": {
            "courseId": 100,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le operazioni base di una collection?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " operations"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5623,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi nell'utilizzo di una libreria in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vantaggi"
            },
            {
              "keyword": " libreria"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5576,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Riguardo alla lezione sulle collection, che cos'è un'interfaccia? Come si riconosce in un diagramma UML? Dare un esempio di interfaccia (non deve essere presente sulle slide).\r\n\r\nParlando dell'interfaccia Iterator, qual'è la sua particolarità?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interface"
            },
            {
              "keyword": " Iterator"
            },
            {
              "keyword": " Polymorphism"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5566,
          "asker": {
            "courseId": 100,
            "askerId": 925,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le Collections? Quando vengono utilizzate?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " dati"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5627,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono le collections? Quali sono le operazioni di base di una collection?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " operazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5570,
          "asker": {
            "courseId": 100,
            "askerId": 907,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "I modificatori di visibilità, come si applicano e cosa determinano nella programmazione ad oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " modificatori"
            },
            {
              "keyword": " visibilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5598,
          "asker": {
            "courseId": 100,
            "askerId": 772,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile creare Collection di oggetti di tipo primitivo? Nel caso non fosse possibile come si può risolvere il problema e quindi essere in grado di creare, per esempio, Collection di interi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " tipi primitivi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5617,
          "asker": {
            "courseId": 100,
            "askerId": 848,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quanto è utile per un programmatore l'utilizzo di una libreria? Quanta mole di lavoro può far risparmiare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Librerie"
            },
            {
              "keyword": " Utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5643,
          "asker": {
            "courseId": 100,
            "askerId": 751,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è un interfaccia? Nelle interfacce si possono dichiarare delle costanti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfaccia"
            },
            {
              "keyword": " costanti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5571,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le interfacce e che utilità hanno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " interfaccia"
            },
            {
              "keyword": " interface"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5653,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un iteratore? Che funzione svolge e come si può utilizzare in Java? Un iteratore supporta ogni tipo di collezione? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iteratore"
            },
            {
              "keyword": "java"
            },
            {
              "keyword": "pop"
            },
            {
              "keyword": "collezioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5593,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Se ho due classi interfacce A e B e una classe C che eredita da ambedue, è possibile applicare il principio di Liskov su: \r\n- C(sottoclasse) rispetto ad A e B(superclassi,interfacce)?\r\n- A(superclasse,interfaccia) rispetto a B(superclasse,interfaccia)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5619,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'e un'interfaccia?\r\nUna classe puó implementare più interfaccie? Se sì, cosa succede se in 2 o più interfaccie implementate da una classe è presente un metodo con la stessa firma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaccie"
            },
            {
              "keyword": " implements"
            },
            {
              "keyword": " astrazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5554,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa sono le struct ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5560,
          "asker": {
            "courseId": 100,
            "askerId": 749,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra List e Set?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " list"
            },
            {
              "keyword": " set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5584,
          "asker": {
            "courseId": 100,
            "askerId": 756,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è la javadoc? Perchè è utile implementarla in una propria classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " javadoc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5556,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega che cosa sono Static e Dynamic binding in Java e che differenze hanno, portando anche degli esempi.",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Dynamic"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5993,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Se si dispone di più di un metodo con lo stesso nome o due variabili con lo stesso nome in gerarchie della stessa classe diventa difficile scoprire quale viene utilizzato durante il funzionamento a causa del riferimento nel codice. Questo problema viene risolto utilizzando binding dinamico e static in  Java.\r\ndifferenze: \r\nin Java Static si verifica durante la compilazione mentre binding dinamico si verifica durante il runtime\r\n2) private &#8203;&#8203;, final e static e le variabili utilizzano binding statico e legato al compilatore mentre i metodi virtuali sono legati in runtime.\r\n\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5242,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4993,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4729,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4945,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5924,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Lo Static Binding effettua il binding a tempo di compilazione che garantisce minor tempo di esecuzione ma non concede all'utente la flessibilità del dinamic binding. Esso infatti effettua il binding a runtime, permette all'utente di designare \"le proprietà\" della variabile, seppur perdendo velocità in tempo di esecuzione. In C++ non esiste il binding dinamico (a differenza di Java) e sta allo sviluppatore virtualizzare quello statico. Un esempio noto è quello dello stack e della coda in cui: \r\nPila s; int type;\r\ndo {\r\nsystem.out.println (\"Pila (1) o Coda (2)?\"); \r\n} while (type<1 || type>2); \r\nswitch (type) { \r\ncase 2: s=new Coda(); break; \r\ncase 1: s=new Pila(); break;\r\n\r\nlascerà all'utente la decisione se \"s\" dovrà essere pila o coda. Questo è un classico esempio di binding dinamico: se si fosse presentato invece un caso di binding statico, non si sarebbe presentata la \"scelta\" tra pila e coda. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4994,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5240,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4944,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4730,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5939,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 766,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Binding statico è il binding stabilito a tempo di compilazione. Nel binding statico i tipi delle variabili sono determinati univocamente, e quindi vengono determinate univocamente le operazioni che possono essere effettuate;questa associazione non può essere più modificata durante l'esecuzione.\r\nEsempio:\r\nCerchio c = new Cerchio();\r\nSystem.out.println( c.getRaggio() );\r\n\r\nIl metodo getRaggio() verrà agganciato staticamente, perchè si hanno tutte le informazioni utili a sapere quale classe utilizzare.\r\n\r\nBinding dinamico è il binding stabilito a tempo di esecuzione.In questo caso il compilatore non genera una volta per tutte il codice per l'assegnazione dei valori ma invece genera un codice che verrà utilizzato per calcolare quale metodo richiamare di volta in volta.\r\n\r\nEsempio:\r\npublic double differenzaAree(Figura f1, Figura f2) {\r\nreturn f1.calcolaArea() - f2.calcolaArea();\r\n}\r\nNon è possibile sapere a priori quale tipo di oggetto venga passato a ciascuno dei due parametri.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5243,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4995,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4728,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4947,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6018,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 811,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Lo Static Binding si ha quando la determinazione della classe di appartenenza di un oggetto avviene a compile-time, mentre il Dynamic Binding viene determinato a run-time.\r\nLo S.B. è più efficiente dal punto di vista delle prestazioni, mentre il D.B. rende più flessibile il codice, in particolare rendendo più efficace la tecnica del Polimorfismo.\r\nAd esempio, sia A una classe e B la sua classe figlia. Il codice seguente è permesso sia dal D.B. che dallo S.B.\r\n\r\nA a;\r\nif (x > 0) a = new B();\r\nelse a = new A();\r\n\r\nOra, se viene utilizzato lo Static Binding l'oggetto \"a\" sarà sempre di tipo \"A\"; invece, se viene utilizzato il Dynamic Binding nelle righe di codice successive il tipo di \"a\" non può essere deciso a priori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4946,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4727,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4996,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5241,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5637,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Indicare le principali differenze tra list e set (argomento Collections) e per ciascuna indicarne le caratteristiche.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " set"
            },
            {
              "keyword": " collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5644,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo le interfacce in Java permettono l'ereditarietà multipla?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "multipla"
            },
            {
              "keyword": "interfacce"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5921,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "le interfacce permettono l'ereditarietà multipla, visto che java permette ad una classe  l'implementazione di una o più interfacce, mentre non consente l'ereditarietà multipla nel caso delle classi che vogliono estendere delle classi abstract. Infatti una classe può estendere una sola classe abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4708,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5078,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4660,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5099,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5982,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": "Java non supporta l'ereditarietà multipla fra classi. Una classe può però implementare più interfacce e in  questo modo possiamo per essa definire diversi comportamenti, il cosidetto polimorfismo.\r\nEs:\r\npublic interface PriceItem { \r\n     public void setPrice(int price); \r\n     public double getPrice(); \r\n    } \r\nPossiamo a questo punto implementare l'interfaccia in una classe  Libro nel seguente modo:\r\n\r\n  public class Book implements PriceItem { \r\n        private String title; \r\n         ... \r\n        public void setPrice(int price) { \r\n            this.price = price; \r\n        } \r\n        public double getPrice() { \r\n            return price; \r\n        } \r\n    } \r\nIn questo modo la classe Book, o tutte le classi di cui hai bisogno ereditano da PriceItem i vari metodi.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4710,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4661,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5097,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5079,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5953,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un interfaccia in Java è un insieme di firme di metodi senza implementazione. Ogni interfaccia rappresenta un tipo. Una classe può implementare non solo una ma più interfacce. Per fare questo deve contenere la definizione di tutti i metodi delle interfacce. Con un oggetto istanza di questa classe può essere utilizzato l'upcasting a una qualsiasi delle interfacce implementate. \r\n\r\nÈ  cioè possibile scrivere, ad esempio:\r\nInterfaccia oggetto1;\r\noggetto1 = new Classe ();",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5076,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5096,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4663,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4709,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5909,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 899,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Le interfacce permettono di definire una lista di metodi e firme senza un'effettiva implementazione. Le classi che implementano una data interfaccia devono quindi fornire l'implementazione di ogni metodo dichiarato. Ciò permette di non avere conflitti se vengono definiti metodi con la stessa firma, infatti l'implementazione sarà unica, fornita dalla classe. Le interfacce possono inoltre essere utilizzate come pseudo-tipi permettendo l'utilizzo del polimorfismo senza una classe base comune.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5100,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4712,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5077,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4662,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5920,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "In Java non esiste l'ereditarietà multipla con le classi. Per questo sono state create le interfacce che sono una \"collezione\" di metodi NON implementati e costanti. Sono quindi l'elemento astratto per eccellenza, e per questo sono un buon compromesso per avere una ereditarietà multipla che sia più controllata, robusta e stabile rispetto a quella del c++. Un esempio pratico\r\n\r\npublic interface I1 {  // dichiarazione interfaccia\r\n        // contenuto\r\n}\r\n\r\npublic interface I2 {  // dichiarazione interfaccia\r\n        // contenuto\r\n}\r\n\r\npublic class C implements I1 implementa I2 {\r\n        // contenuto\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4711,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5098,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4659,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5080,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5611,
          "asker": {
            "courseId": 100,
            "askerId": 790,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Prendendo come riferimento l'esercizio /esempio della tombola perché la progettazione è così tanto importante tanto che possiamo dire che il lavoro del programmatore è per il 90% progettazione e per il restante scrittura? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "progettazione"
            },
            {
              "keyword": " software"
            },
            {
              "keyword": " tombola"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5641,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le collection? Sono indispensabili per un programmatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "lezione9"
            },
            {
              "keyword": " collection "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5600,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste un limite di interface che una classe può implementare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interface"
            },
            {
              "keyword": " limite"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5642,
          "asker": {
            "courseId": 100,
            "askerId": 824,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "All'interno del codice di una classe è possibile inserire istruzioni che non siano dichiarazioni ed inizializzazioni di variabili e metodi? Es:\r\npublic void class Prova(){\r\n    int a;\r\n    int b;\r\n    int c, d;\r\n    \r\n    c = b*a +14;                                                                   // queste due operazioni\r\n    d = JOptionPane.showInputDialog(\"Inserisci un numero\");  // sono lecite?\r\n   \r\n    Prova(){\r\n        a = 4;\r\n        b = 5;\r\n    }\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " dichiarazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5646,
          "asker": {
            "courseId": 100,
            "askerId": 896,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le collezioni in Java? Quali vantaggi presentano? Che differenze ci sono tra un set e una list?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collezioni"
            },
            {
              "keyword": " set"
            },
            {
              "keyword": " list"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5603,
          "asker": {
            "courseId": 100,
            "askerId": 922,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che correlazione intercorre tra le interfacce Set e List? Quali sono le differenze sostanziali tra le due? Esistono altre interfacce che svolgono un compito simile? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Set"
            },
            {
              "keyword": " List"
            },
            {
              "keyword": " Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5591,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire cos'è una Collection e che tipi ne esistono.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " list"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5587,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il ruolo principale delle Interfacce in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " ruolo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5657,
          "asker": {
            "courseId": 100,
            "askerId": 880,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze sostanziali tra \"set\" e \"list\"? In quali casi conviene utlizzare la prima e in quali la seconda?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "set"
            },
            {
              "keyword": " list"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5606,
          "asker": {
            "courseId": 100,
            "askerId": 853,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Unit Testing e quali sono i suoi benefici?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Unit testing"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5919,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Con Unit Testing si intende la verifica indipendente delle diverse parti di codice. Nella programmazione OOP la divisione in parti è banale: si verifica il behavior delle varie classi che compongono il programma. Ciò viene fatto tramite la scrittura di un programma banale che utilizzi le funzioni offerte dalla classe verificando che l'output sia corretto per ogni input.\r\nIl vantaggio principale è la maggior velocità di individuazione dei bug. Sia perché una volta implementato il test è immediato verificare la correttezza di un elemento ogni volta che si apporta una modifica, sia perché al fallire di un test è immediato verificare il punto del codice che espone il problema.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5018,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5147,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5235,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6025,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Lo Unit Testing è un?attività di collaudo delle singole unità software, cioè delle parti di software che hanno un funzionamento autonomo. In base al linguaggio e al paradigma di programmazione possono essere per esempio: una funzione oppure una classe o un singolo metodo.\r\n\r\nLo scopo è quello di isolare un modulo e verificarne la correttezza. E? svolto solitamente dagli sviluppatori manualmente o tramite appositi software di controllo.\r\nPer analizzare una singola classe che interagisce con altre classi è possibile creare un mock object, si simulano, cioè, le interazioni della classe conducendo un test più approfondito.\r\n\r\nLo Unit Testing favorisce, inoltre, la scrittura del software in moduli indipendenti, che assieme a un design pattern cioè ad uno schema procedurale-logico portano alla realizzazione del migliore codice possibile e ad un?ottima manutenibilità del software",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5017,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5150,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5238,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5928,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 907,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per Unit Testing si intende l'attività di testing per ogni singola unità, il componenente minimo di un'architettura, in altre parole il collaudo di ogni singola unità. Lo Unit testing semplifica innanzitutto la modifica successiva del modulo, se per ogni funzione e unità creiamo degli Unit Testing, se apportiamo qualche modifica ci sarà facile capire dove è sorto l'errore confrontando i risultati delle Unit Testing. Semplifica inoltre l'integrazione tra diverse unità, in quanto limita i malfunzionamenti. Infine fornisce una documentazione \"live\" del codice, in ogni test ci sono le caratteristiche critiche necessarie per il corretto funzionamento della singola unità e il test le \"documenta\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5146,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5019,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5236,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5988,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 749,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Con Unit Testing si intende una fase di testing sulle singole unità in modo da controllare che ogni singola unità assolva le sue funzioni. I benifici sono l'individuamento precoce di eventuali bug e per avere la certezza che un pezzo di codice funzioni correttamente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5020,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5239,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5149,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5964,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per unit testing si intende l'attività di collaudo di singole unità software. Per unità si intende normalmente il minimo componente di un programma dotato di funzionamento autonomo; a seconda del linguaggio di programmazione, questo può corrispondere per esempio a una singola funzione nella programmazione procedurale, o una singola classe o un singolo metodo nella programmazione a oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5021,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5148,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5237,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5595,
          "asker": {
            "courseId": 100,
            "askerId": 910,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "L'ereditarietà multipla in Java non si può fare, se si potesse fare che ambiguità sorgerebbero?, grazie alle Interface l'ereditarietà multipla è possibile, perché?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " multipla"
            },
            {
              "keyword": " interface"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6013,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "In Java si è deciso di impedire l'uso dell'ereditarietà multipla, poichè in molti casi risulta essere piuttosto confusionaria. Per capire meglio questa frase, è utile discutere tramite un esempio quello che viene chiamato <problema del diamante> (diamond problem). Dichiariamo due classi, NamedPoint e Point3D. Queste classi ereditano le caratteristiche di una superclasse chiamata Point. Quindi avremo rispettivamente |NamedPoint extends Point| e |Point3D extends Point|. A questo punto dichiaro una classe NamedPoint3D che eredita sia NamedPoint che Point3D. Se per esempio NamedPoint3D chiama un metodo di Point, da quale classe viene ereditato? da NamedPoint o da Point3D? In Java non si può avere una risposta a questa ambiguità, ed è per questo che si è deciso di evitare l'ereditarietà multipla.Tramite le Interface è possibile \"arginare\" questo problema, tuttavia non si tratta di un ereditarietà vera e propria, dato che le classi devono obbligatoriamente implementare i metodi \"ereditatati\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5214,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5186,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4720,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4828,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5001,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5163,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5995,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Se l'ereditarietà multipla fosse possibile in java questo porterebbe al fatto che una classe possa ereditare da più di una superclasse ponendo due problemi fondamentali: Il primo problema è quello relativo all'ambiguità dei nomi e può verificarsi se un metodo ereditato è definito con lo stesso nome in tutte le classi padre di una data classe.\r\nIl secondo problema invece consiste nella scarsa efficienza della ricerca dei metodi definiti nelle classi infatti con l'ereditarietà multipla le classi acquisiscono un architettura a grafo che rende impossibile una ricerca lineare.\r\nIn java però è possibile aggirare questo problema tramite l'uso delle Interface all'interno delle quali sono presenti le definizioni dei metodi che si vuole vengano implementati dalla classe stessa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5213,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5185,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5002,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4826,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5162,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4718,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5967,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "L'ereditarietà multipla in Java non si può fare, perchè c'è il rischio relativo alla possibile ambiguità dei nomi. Due classi possono fornire implementazioni diverse dello stesso metodo. Qual'è implementazione che va ereditata dalla loro sottoclasse ? \r\nES: \r\nVoglio ereditare due classi Macchina e Bomba, entrambi implementano la funzione On().Nel miglior caso accendo la macchina nel peggior caso salto in aria. Questo è il pensiero che ha spinto i sviluppatori di Java a puntare sulla ereditarietà singola.\r\nE' vero che una classe può ereditare da una sola superclasse,ma può implementare più interfacce così facendo Java sta in qualche modo rendendo possibile una forma di eredità multipla.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5003,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5187,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4719,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4827,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5215,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5164,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5577,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per \"Collection\", come può essere utilizzata (operazioni più comuni) e in quali casi può rivelarsi utile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " Operations"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5578,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa il test di una singola classe in un progetto che ha più classi?\r\nQuale è la giusta struttura di package e folders da utilizzare per un eventuale main di test, se si usa?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " test"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5943,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Per eseguire un test su di una classe specifica e' sufficiente costruire il metodo main per quella classe stessa testandone il suo corretto funzionamento. Nell'eventualita' in cui si volesse verificare il corretto funzionamento dell'intero progetto con una classe di prova (che conterra' il main), e' necessario che essa sia presente nello stesso package delle classi da testare.\r\n\r\nLa soluzione ideale invece sarebbe definire in un altro package di \"test\" in cui definire la classe contenente il main di prova specificando all'inizio gli opportuni import delle classi da testare.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5183,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4949,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4643,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5908,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "L'operazione di test delle singole classi viene detta Unit Test, per fare ciò si può creare un main apposito il quale creerà un'istanza della classe da testare e chiamerà una procedura appositamente creata che eseguirà tutta una serie di operazioni per testare in diverse situazioni il comportamento degli oggetti della classe da testare. Non è necessario specificare una struttura particolare di package e folder, basterà infatti indicare in fase di compilazione la classe che contiene il main che effettua il test della classe (che può chiaramente essere diversa dalla classe che contiene il \"vero\" main da utilizzare in fasi successive a quelle di test).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4951,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4646,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5182,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5962,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 852,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Sì utilizza la tecnica dell'unit testing, permette di testare ogni singola classe.\r\nPurtroppo testando singole classi non si individuano problemi di integrazioni, prestazioni e altri problemi legati al sistema in generale.\r\nSi utilizza lo stesso package sia per la classe di testing che il main di test e la classe da testare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4645,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4950,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5181,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5902,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Per verificare il corretto funzionamento di una singola classe è necessario attuare un procedimento detto \"Unit Testing\". E' solitamente effettuato dagli sviluppatori della classe stessa, i quali lo modificheranno in base alle necessità. Per esempio si può testare una singola classe utilizzando un main di test che non farà assolutamente parte del programma finale, ma verrà utilizzato solo in fase di sviluppo per essere sicuri di non aver commesso errori nell'unità di software presa in considerazione. Questo particolare main dovrà includere sicuramente la classe da testare e tutte le risorse che potranno essere utili per la realizzazione  di un test più efficace e più veloce da scrivere. Il testing delle singole classi è solitamente considerato parte integrante dell'attavità di sviluppo del software, in quanto facilità notevolmente l'individuazione di errori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5184,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4948,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4644,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5580,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "E' dato il seguente codice:\r\n\r\nabstract class Padre{\r\n     protected int a;\r\n     public A(int i){\r\n            a = i;\r\n     }\r\n\r\n     public abstract int dueVolteA();\r\n\r\n     public String toString(){\r\n            return String.valueOf(a);\r\n     }\r\n}\r\n\r\nScrivere la classe \"class Figlia extends Padre\" con il minimo affinché il codice compili.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Visibilità"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5568,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Perche' le interfacce sono fondamentali nella programmazione ad oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " fondamentale"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5659,
          "asker": {
            "courseId": 100,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra le collection di tipo set, ordered set e list? E' possibile usare una in luogo dell'altra per esprimere le stesse relazioni tra gli oggetti che le compongono? Se sì, in che modo?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " set"
            },
            {
              "keyword": " list"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5925,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una collection è un oggetto che ragguppa elementi multipli (anche eterogenei) in una\r\nsingola entità. Collections sono usate per immagazzinare, recuperare e trattare dati, e per trasferire gruppi di dati da un metodo ad un altro. La collection set e' una collection che non può contenere elementi duplicati. List è una collection ordinata che puo c&#768; ontenere elementi duplicati. Normalmente fornisce all? utente controllo nell? inserimento. L?utente accede agli elementi attraverso un indice. Sì, è possibile usare una in luogo dell'altra per esprimere le stesse relazioni tra gli oggetti che le compongono. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4963,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5093,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4786,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5976,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Set e List sono specializzazioni di Collection.\r\n- Set è caratterizzato dal fatto di non avere elementi ripetuti e che, per accedere ad un elemento, devo usare l'iterator;\r\n- List è caratterizzato dal fatto di permettere gli elementi ripetuti, di avere il concetto di \"posizione\" di ogni suo elemento, dunque per accedere ad un elemento è sufficiente sapere la sua posizione ( get(int index) ).\r\n\r\nOrdered Set (o Sorted Set) è una specializzazione di Set e aggiunge la nozione di ordinamento sugli elementi.\r\n\r\nDefinita una relazione d'ordine in un Ordered Set, posso definire la stessa relazione d'ordine in una list tramite uno \"stable order\" che non è altro che un ordine che non riordina elementi uguali appunto presenti in una lista. \r\n\r\n\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4965,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4788,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5091,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6007,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Error 404 comment not found",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4964,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5095,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4787,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5926,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Innanzitutto credo che si intendesse dire sortedset invece di ordered set come si riscontra nella diapositiva numero 12 delle collections.\r\n\r\nComunque la differenza tra i tre tipi è molto semplice.\r\n\r\n* SET è una collection che non può contenere elementi duplicati\r\n* LIST invece è una collection ordinata che può contenere elementi duplicati e &#318;utente può accedervi attraverso un indice\r\n* SORTEDSET è invece una estensione della collection set. Quindi avrà accesso a tutti i metodi di set con &#318; aggiunta di nuovi metodi. Gli elementi saranno inseriti usando il loro ordinamento naturale.\r\n\r\nNon è possibile usare set per esprimere relazioni list in quanto sono due collection differenti.\r\nÈ possibile invece tra set e sortedset in quanto quest'ultima è sottoclasse di set.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4784,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4962,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5094,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6015,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Un Set è una Collection che contiene elementi non duplicati e non in ordine, quindi non identificabili da indici, mentre in un Sorted Set gli elementi sono in ordine, ma comunque senza duplicati. Una List, invece, contiene elementi in ordine e quindi accessibili attraverso indici, e può contenere elementi duplicati.\r\nÈ possibile usare una in luogo dell'altra attraverso i metodi toArray, i quali portano gli elementi di una Collection in un Array appositamente allocato, la cui lunghezza è uguale al numero degli elementi della Collection.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4961,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5092,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4785,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5624,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'utilità di usare la parola \"abstract\" nella dichiarazione dei metodi?\r\nPerchè anche la classe che contiene metodi abstract dev'essere abstract?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5625,
          "asker": {
            "courseId": 100,
            "askerId": 811,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare brevemente cosa sono e a cosa servono le interfacce.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5586,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono gli iteratori in Java? Dire a cosa servono il hasNext(); next(); e remove(); in un iteratore e fare un esempio per ciascuno.",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 15,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "iteratori"
            },
            {
              "keyword": " hasnext"
            },
            {
              "keyword": " remove"
            },
            {
              "keyword": " next"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5972,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Gli iteratori servono per gestire delle collezioni. Sono delle interfacce e di conseguenza le funzioni hasNext(); next(); e remove(); non sono direttamente implementate ma si trovano nelle classi (collections) che implementano (tramite la parola chiave \"implements\") queste funzioni. Esempi con iteratore standard di Java data collezione c:\r\nc.next()  : ritorna il prossimo elemento della collezione\r\nc.hasNext()  : controlla presenza elemento consecutivo ad ultimo restituito da next()\r\nc.remove()  : elimina ultimo elemento restituito da next()",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5160,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4725,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4650,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4773,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5188,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4656,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5971,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Un iteratore è un oggetto che, applicato a una collezione, permette di scorrerla in modo lineare senza bisogno di sapere il tipo degli elementi della collezione. \r\nSupporta i comandi:\r\n  -hasnext(), che verifica se ci sono altri elementi ella struttura dati e restituisce un true o false a seconda che ci sia o meno l'elemento successivo della sequenza\r\n  -next(), che fa avanzare l'iteratore e restituisce l'elemento successivo della sequenza\r\n  -remove(), che rimuove dalla struttura dati l'ultimo elemento visitato. Deve essere preceduto da next() e può essere chiamato una volta sola dopo ogni next (altrimenti genera l'eccezione IllegalStateException)\r\nEsempio:\r\nL'iteratore scorre una lista di interi e rimuove gli elementi negativi.\r\nwhile(iterator.hasNext()){\r\n    if(iterator.next() < 0){\r\n                iterator.remove();\r\n    }\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4772,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4654,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5156,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5193,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4648,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4724,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6002,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 836,
                "courseId": 100,
                "courseFinalScore": 19
              },
              "answerText": "Gli iteratori servono quando non siamo in grado di interagire con gli elementi di una collezione (che sia albero binario, lista concatenata ecc. ). Servono principalmente per la scansione lineare di un vettore. HasNext() è una funzione booleana che restituisce true nel caso l elemento ha un successivo e false nel caso contrario; next() restituisce l elemento successivo a quello attuale, e nel caso non sia presente lancia un eccezione; remove() cancella dalla collection l ultimo elemento ottenuto dal next(). Fare un esempio di queste funzioni è particolarmente complicato perché cambiano da collection in collection.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5161,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5191,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4721,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4649,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4770,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4655,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5981,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 829,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Gli iteratori sono delle interface e servono per gestire delle collezioni. Le funzioni hasNext(); next(); e remove(); si trovano nelle classi (collections), sono implementate tramite la parola chiave \"implements\" all'interno delle collezioni.\r\nEsempi: data una collezione x:\r\nx.next()  : ritorna il prossimo elemento della collezione\r\nx.hasNext() : restituisce true o false se ci sono altri elementi oltre a quello ritornato da next ();.\r\nx.remove()  : elimina ultimo elemento restituito da next().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4769,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4657,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4726,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4651,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5192,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5157,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6020,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L?interfaccia iteratore consente di ?ciclare? sugli elementi di una collection; si comporta cioè come un ciclo for. Viene generalmente usato in connessione ad un ciclo while. I metodi dichiarati da un iteratore sono: ?hasNext()? che restituisce un booleano: in particolare restituisce true se ci sono altri elementi nella collection; ?next()? che restituisce l?oggetto successivo ed infine ?remove()? che rimuove l?oggetto restituito da next(); quest?ultimo può essere chiamato solo una volta dopo ogni next. \r\nAd esempio nel codice:\r\nvoid filter(Collection x){\r\nIterator i =x. iterator();\r\nwhile (i.hasNext()){\r\nif (!cond(i.next()))\r\ni.remove();\r\n}\r\n}\r\nintroduciamo inizialmente un metodo ?filter? che lavora sulla collection ?x?ed un iteratore ?i? associato alla x. Fin quando ci sono elementi nella collection (hasNext) chiamiamo il metodo \"cond\" sull?oggetto restituito da next sull?iteratore i e, se tale oggetto non verifica la condizione implementata da cond, lo rimuoviamo con il remove.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4658,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5190,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4652,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4771,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4723,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5159,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5935,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Gli iteratori sono puntatori che hanno la funzione di gestire gli elementi di una collezione. Prevedono diverse funzioni di default, tra cui:\r\n\r\n-hasNext(); che restituisce \"true\" se esiste un elemento successivo a quello attuale\r\n-next(); che restituisce l'elemento successivo a quello attuale\r\n-remove(); che rimuove dalla collezione l'ultimo elemento restituito da next();\r\n\r\nper raccoglierli in un esempio:\r\n\r\niterator i = x.iterator;\r\nwhile(i.hasNext()){\r\n i.next()++;\r\n }\r\nwhile(i.hasNext()){\r\n i.remove;\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5158,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4647,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4774,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4722,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5189,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4653,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5612,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono e a che cosa sono utli le Collection? Che differenza c'è tra Set e List?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " Set"
            },
            {
              "keyword": " List"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5645,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'esempio fatto a lezione sulla tombola che classi utilizza il codice implementato in java per funzionare? Queste classi possono essere non utilizzate o sono tutte indispensabili? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tombola"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5648,
          "asker": {
            "courseId": 100,
            "askerId": 815,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si può mettere in una Collections?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " contenuto"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5970,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Java collections è un framework.Tutte le classi e le interfacce che permettono di gestire gruppi di oggetti, costituiscono il Java Collection Framework. In una collections si può mettere degli oggetti e creare i gruppi. Viene usato per gestire efficientemente questi gruppi di oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5180,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4676,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4915,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4775,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4990,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5951,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Una collection è un oggetto che ragguppa elementi multipli, anche di diversi tipi, in una singola entità. Queste strutture sono particolarmente utili per trasferire gruppi di dati da un metodo ad un altro. \r\nNelle collection però non posso essere inseriti dati appartenenti ai tipi primitivi (int, float, char, ecc.). Per fare ciò devo costruire una struttura (collection) nella quale inserire il dato nel tipo primitivo. Per potervi poi accedere uso nome_struttura.nome_variabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4776,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4677,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4991,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4919,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5176,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5905,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 790,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Qualsiasi oggetto presente nelle librerie che hai dichiarato",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4779,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4675,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4988,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5178,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4918,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6009,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 863,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Gli elementi di una Collection devono essere oggetti dello stesso tipo. I tipi primitivi(es.: int) non possono essere elementi di una Collection ma è possibile creare una classe wrapper(es.: Integer). Esempio:\r\n\r\nimport java.util.*\r\n\r\nclass Integer {\r\n    int n;\r\n    Integer(int n){\r\n      this.n=n;\r\n    }\r\n    int getInt(){\r\n      return n;\r\n    }\r\n}\r\n...\r\n   public static void main(){\r\n      Collection mylist = new ArrayList<Integer>;\r\n      for(int i=0;i<10;i++){\r\n         mylist.add(new Integer(i));\r\n      }\r\n      ...\r\n   }\r\n...\r\n\r\nIn realtà queste classi wrapperso sono già definite in Java.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5179,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4777,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4678,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4992,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4917,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6019,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una Collection non è altro che oggetto che raggruppa assieme molteplici elementi, permettendo di immagazzinarli, manipolarli e trasferirli a seconda delle necessità. Potenzialmente può contenere una qualsiasi categoria di oggetti, ma viene principalmente impiegata per raggruppare oggetti che formano un gruppo \"naturale\", come nomi e numeri di un elenco telefonico o il catalogo di una libreria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5177,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4989,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4674,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4916,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4778,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5650,
          "asker": {
            "courseId": 100,
            "askerId": 745,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'ereditarietà multipla? Quali sono i vantaggi e le problematiche che essa presenta? In Java è possibile avere ereditarietà multipla? Se sì, come?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " multipla"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5660,
          "asker": {
            "courseId": 100,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Come agiscono i modificatori relativi alla visibilità delle classi e in che modo essi vengono implementati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Modificatori"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5564,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le interfacce? Che scopo hanno e a cosa servono?\r\nPossono essere anche private o solo pubblic? Perchè?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " private o pubblic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5990,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 853,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Le interfacce sono una collezione di firme di metodi (senza implementazione) con possibilità di dichiarare costanti, risultano quindi come punto di incontro tra componenti simili che hanno una struttura interna diversa. \r\nI metodi dichiarati in una interfaccia sono sempre public, quindi i corrispondenti metodi di una classe che implementa l'interfaccia devono essere public.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4736,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4901,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5013,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5216,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5946,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Le interfacce sono delle collezioni di metodi che è possibile implementare come soluzione al problema dell'ereditarietà multipla. Un'interfaccia in Java ha una struttura simile ad una classe ma può contenere solo metodi astratti (abstract) e costanti. In Java una classe può implementare più di una interfaccia (al contrario dell'ereditarietà tra classi) permettendo così un'efficace soluzione al \"problema del diamante\". Un'interfaccia può inoltre essere utilizzata per evidenziare funzionalità comuni a più classi o per definire tipi di dato astratti. I metodi dichiarati nell'interfaccia non sono implementati (un'interfaccia non contiene codice) e quando una classe implementa un'interfaccia (utilizzando la parola chiave implements) deve necessariamente codificare tutti i metodi ereditati da quell'interfaccia.\r\nI metodi dichiarati in un'interfaccia devono essere necessariamente public, ma l'interfaccia stessa può essere private o comunque accessibile solo al package che la contiene. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4738,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5014,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4904,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5220,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5912,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Le interfacce private non servono a nulla e non si possono nemmeno fare..anche perché dichiarare in interfaccia privata e non poterla implementare...Le interfacce non possono essere istanziate e contengono le firme dei metodi.Hanno lo scopo di implementare l'ereditarieta multipla.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4739,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4902,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5012,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5218,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5901,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una interfaccia in Java ha una struttura simile a una classe, ma può contenere SOLO metodi d'istanza astratti e costanti (quindi non può contenere costruttori, variabili statiche, variabili di istanza e metodi statici).\r\n\r\nLe interfacce possono essere utilizzate:\r\n-Per definire Tipi di Dati Astratti; si pensi al TDA degli insiemi, definiti come entità matematiche caratterizzate dalle usuali operazioni (unione, appartenenza, ...), e a diverse possibili implementazioni del TDA (liste con/senza ripetizioni, array, tabelle hash, alberi binari di ricerca, ...);\r\n-come contratto tra chi implementa una classe e chi la usa: le due parti possono essere sviluppate e compilate separatamente;\r\n-per evidenziare funzionalità comuni a più classi, sopperendo alle limitazioni dell'ereditarietà singola;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4903,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5219,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4737,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5015,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5955,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 835,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un'interfaccia è una collezione di firme di metodi. In un'interfaccia sono rese note solo le definizioni di alcuni metodi che poi saranno implementati nelle classi figli. Sono utili per dare un'idea di cosa riservano le sottoclassi. In un'interfaccia possono essere dichiarate costanti, ma non variabili o metodi statici. Un'interfaccia può essere solo public se vogliamo che voglia essere vista anche fuori dalle classe in cui è annidata (se invece l'interfaccia è annidata in un'altra classe è possibile dichiararla private/protected)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5016,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5217,
                  "rater": {
                    "raterId": 926,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4905,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4740,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5651,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo posso creare una lista di int",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "list"
            },
            {
              "keyword": " collections "
            },
            {
              "keyword": "Integer"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5585,
          "asker": {
            "courseId": 100,
            "askerId": 912,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando un codice viene detto polimorfo? Un esempio trattato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5628,
          "asker": {
            "courseId": 100,
            "askerId": 858,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può dichiarare una classe o un metodo abstact e final? Perché? \r\nEs: abstact final class Classe {\r\n            abstact final pubblic metodo();\r\n     } ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " class"
            },
            {
              "keyword": " abstrac"
            },
            {
              "keyword": " final"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5636,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con il termine \"collection\"? A cosa serve la basic operation \"iterator()\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " iterator"
            },
            {
              "keyword": " basic operations"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5559,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le Collections ? Quali vantaggi danno  il loro utilizzo al programmatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": "Vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5592,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'operatore \"instanceof\" in java? (fare esempi anche in casi di ereditarietà) ",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "operatore"
            },
            {
              "keyword": " instanceof"
            },
            {
              "keyword": " operator"
            },
            {
              "keyword": " laboratorio"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5965,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 926,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "instanceof È un operatore che consente di determinare a run-time il tipo di un oggetto. Restituisce true o false a seconda che l'oggetto sia o no un'istanza della classe di confronto o di una delle sue superclasse. \r\nQuindi nel caso in cui sia abbia una superclasse il comando istanceof darà return true per ogni istanza di di sé stessa o di classi figlio, false in caso contrario. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4808,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4879,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5036,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5065,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5144,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5958,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"instanceof\" in Java serve a verificare se un oggetto è istanza di una data classe.\r\nPuò essere posto nella condizione della struttura \"if\", ad esempio in questo modo:\r\nBicycle myBike = new Bicycle (...);\r\nif (myBike instanceof Bicycle)\r\n{...}\r\nIn questa porzione di codice, il blocco del costrutto if viene eseguita solo se myBike risulta essere un'istanza della classe Bicycle.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4805,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5145,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5061,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5031,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4885,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5966,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 926,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "instanceof È un operatore che consente di determinare a run-time il tipo di un oggetto. Restituisce true o false a seconda che l'oggetto sia o no un'istanza della classe di confronto o di una delle sue superclasse. \r\nQuindi nel caso in cui sia abbia una superclasse il comando istanceof darà return true per ogni istanza di di sé stessa o di classi figlio, false in caso contrario. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5066,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5032,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5143,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4806,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4880,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5941,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore instanceof è usato per testare se un oggetto è un'istanza di uno specifico tipo, classe, sottoclasse o interfaccia.Per esempio se ho un oggetto a di tipo cane che estende la classe animale qual'ora io andassi ad utilizzare il comparatore instanceof nel seguente modo \r\na instanceof animale il risultato sarà true.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4803,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5062,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5037,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4883,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5141,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5986,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 881,
                "courseId": 100,
                "courseFinalScore": 9
              },
              "answerText": "instanceof È un operatore che consente di determinare a run-time il tipo di un oggetto. Restituisce true o false a seconda che l'oggetto sia o no un'istanza della classe di confronto o di una delle sue superclassi. \r\nEsempio: \r\nif (\"foo\" instanceof String) ... // restituisce true \r\nEsempio2: \r\nint pt = 2;\r\nif (pt instanceof String) ... // restituisce false \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4884,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5067,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4804,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5139,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5034,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5997,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "L'operatore instanceof controlla se un oggetto è un istanza di una specifica classe. Usato spesso all'interno di un costrutto if, in quanto instanceof ritorna un booleano (true,false). La sua maggiore utilità si ha quando è presente l'ereditarietà tra classi, in quanto è molto importante verificare se è possibile fare un determinato downcast. Ad esempio prendiamo le classi \"Automobile\" e \"Berlina\", chiaramente \"Berlina\" eredita da \"Automobile\", in questo caso è utile utilizzare questo operatore, come segue:\r\n\r\nif (auto instanceof Berlina) { Berlina b = (Berlina)auto;  ... }",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4882,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4809,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5140,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5033,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5063,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6010,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"instanceof\" compara un oggetto con un tipo di istanza e ritorna un valore booleano; è utilizzato per verificare se un oggetto è un istanza di una classe, di una sottoclasse o di una classe che implementa una particolare interfaccia. Inoltre se applichiamo \"instanceof\" ad una variabile inizializzata al valore null, l'operatore restituisce sempre false. \r\nAd esempio, abbiamo la classe Animale e la sottoclasse Cavallo che la estende; istanziamo l'oggetto w, all'interneo della sottoclasse Cavallo,in questo modo:\r\nCavallo w=new Cavallo;\r\nallora se applichiamo l'operatore \"instanceof\" all'oggetto w comparandolo con Animale (cioè chiediamo se w è istanza della classe Animale) verrà restituito true, perché w è istanza della sottoclasse Cavallo, che estende però la classe Animale ed è quinidi anche istanza di quest'ultima.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5064,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5035,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4881,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5142,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4807,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5573,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi della programmazione ad oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "programmare"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5590,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa comporta dichiarare un metodo \"final\"? E una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "final"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5601,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo in una Collection non è possibile mettere un tipo di dato primitivo? In che modo si può arginare questo inconveniente?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " tipi"
            },
            {
              "keyword": " primitivi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5913,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Non posso utilizzare un tipo primitivo nelle collection in quanto non sfruttano l'ereditarieta',per arginare questo problema posso creare una classe,oppure utilizzare le classi predefinite da Java(es Integer)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4974,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5057,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4960,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5072,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5942,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Il motivo per il quale non è possibile mettere un tipo di dato primitivo è perchè il programmatore di quella classe contenitore non sapeva quale specifico tipo potreste inserire nel contenitore e facendo in modo che il contenitore contenesse soltanto un determinato tipo, avrebbe impedito di renderlo uno strumento di utilizzo generale. Una Collection contiene quindi un riferimenti a Object, che è la radice di tutte le classi e contiene qualsiasi tipo. Una soluzione è quella di eseguire un cast al tipo corretto prima di utilizzarlo; un'altra è quella di creare una nuova classe usando ArrayList, in modo che accetti e generi soltanto il tipo desiderato. ArrayList è un array che si espande automaticamente al quale vengono aggiunti elementi con add() e letti con get() utilizzando un indice ma omettendo le parentesi quadre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5059,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4972,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4958,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5073,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5957,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In una Collection non è possibile mettere un tipo di dato primitivo perchè il linguaggio Java non li considera come Object. Questo inconveniente si può arginare tramite l'uso di un'Object wrapper che rappresenta ogni tipo di dato primitivo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5060,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5074,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4959,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4973,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5929,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Una collection è in grado di contenere una \"collezione\" di oggetti di tipo Object. Dato che ogni classe in Java estende quest'ultima, grazie al polimorfismo una collection può contenere istanze di qualsiasi classe.\r\nI tipi di dato primitivi, però, non sono classi e, quindi, \"non sono Object\". Per questo motivo una Collection non può contenere direttamente un tipo primitivo.\r\nPer aggirare questa limitazione sono state introdotte in Java alcune classi particolari che rappresentano i rispettivi tipi primitivi, per esempio: Integer per gli int, Float per i float, Boolean per i boolean, ecc...\r\nQueste classi contengono una variabile di istanza del tipo primitivo corrispondente e alcuni metodi utili.\r\nInfine, essendo queste delle classi, esse estendono la classe Object e possono essere contenute di conseguenza in una Collection.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4971,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5075,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4957,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5058,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5569,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quali motivi, in un programma Java, ci potrebbe essere il bisogno di creare una classe Common? E come viene utilizzata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Common"
            },
            {
              "keyword": "Java"
            },
            {
              "keyword": "utility"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5647,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa e quali sono i modificatori? In che ambito vengono utilizzati? Fai degli esempi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5640,
          "asker": {
            "courseId": 100,
            "askerId": 897,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'iteratore in Java?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "iteratore"
            },
            {
              "keyword": " iterator"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5978,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'iteratore in Java serve per visitare una collezione, cioè per accedere ai suoi elementi. \r\nAlcuni metodi dell'iteratore sono già presenti, come hasNext() che restituisce true se ci sono altri elementi nella collezione, next() ritorna l'elemento successivo mentre remove() rimuove l'elemento ritornato da next();",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5023,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4864,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4830,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4860,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5985,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe iterator in Java consente di lavorare sugli oggetti forniti dal namespace java.util.Collections in modo \"general purpose\", funzionante quindi per tutti gli oggetti di tipo Collection.  L'iterator è fornito dall'oggetto stesso tramite il metodo iterator().\r\nUna volta ottenuto ques'ultimo, la .next() permette di ottenere il prossimo oggetto, la remove() consente di rimuovere l'ultimo elemento ritornato, e la hasNext() consente di controllare se ci sono altri oggetti.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4866,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4832,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5022,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4862,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5911,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'iteratore dichiarato nell'interfaccia Collection viene restituito dal metodo iterator, consentendoci di visitare ed eventualmente rimuovere i dati di una lista. È anche possibile avere contemporaneamente più iteratori sulla stessa lista.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4831,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4865,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4861,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5025,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5933,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "L'iteratore è un oggetto che troviamo quando parliamo di collezioni (collections), ovvero particolari classi di java. Esso \"naviga\" tra i vari elementi della collezione in questione e, con l'utilizzo di apposite funzioni, consente di effettuare delle operazioni su di essi, come per esempio la lettura o la scrittura dei valori che contengono.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4859,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4863,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5024,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4829,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5639,
          "asker": {
            "courseId": 100,
            "askerId": 833,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Il nostro cliente ha deciso che aspettare fino all'uscita della Tombola è veramente molto noioso, e così ha chiesto di aggiungere al suo gioco la possibilità di una (e una sola, la prima) Cinquina.\r\n\r\nIn virtù della nuova richiesta, che classi possiamo aggiungere e quali metodi dovranno avere? Come modificheremo il Diagramma UML?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5952,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Al fine di soddisfare l'esigenza del cliente è possibile introdurre nell'implementazione della Tombola una nuova classe Riga come Set di N interi compresi tra 1 e 90. Il diagramma UML verrà di conseguenza modificato attraverso l'inserimento di una nuova classe, legata secondo la relazione Cartella HAS-A Riga.\r\nI principali cambiamenti interni al codice che questa scelta comporta possono essere riassunti come segue:\r\n-Modifica della Classe Cartella come collection di oggetti di tipo Riga;\r\n-Implementazione di un metodo di controllo interno alla classe Cartella sugli elementi inseriti nelle righe, in modo tale da impedire che possano ripetersi all'interno di una singola cartella;\r\n-Introduzione di un metodo checkCinquina della classe Riga, richiamato dal metodo checkNumber della classe Giocatore, che dichiara, qualora una delle righe sia vuota, il verificarsi di una cinquina;\r\n-Introduzione di un controllo nel metodo Giocatore.checkNumber sulla prima cinquina.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4799,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4670,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4810,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5195,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4707,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5980,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nel caso si abbia una sola cartella si dichiara un metodo \"cinquina\" che verifichi se sono stati pescati 5 elementi presenti nella cartella, si crea un sottoclasse alla classe \"cartella\" chiamata \"riga\", composta da 3 set riempiti e da un metodo che controlli che ognuno dei 5 elementi pescati appartenga a un intervallo decimale diverso (10-19, 40-49...). Quindi si applica il sistema isFinished() (precedentemente usato per la tombola) a ogni riga, se questo si verifica è cinquina (oppure se sei burlone lo urli a caso al terzo numero estratto). Il diagramma UML varia per la presenza di una sottoclasse riga alla classe cartella. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4704,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4802,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5196,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4669,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4811,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5961,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il diagramma UML non dovrà essere modificato poichè non è richiesta alcuna classe aggiuntiva o altra relazione. Visto che nell'esempio il check number lo svolge la classe giocatore ed essendo un metodo simile, conviene anche per coerenza del codice far svolgere questa operazione alla classe giocatore senza andarea a modificare alcuna relazioni fra classi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4706,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4801,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4812,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5194,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4671,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5983,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 922,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il numero classi a mio parere può rimanere invariato, è necessario tuttavia aggiungere alcuni metodi a quelle già esistenti:\r\nNella classe \"Giocatore\" aggiungerei un metodo \"ControlloVincita\" che con un ciclo vada a vedere quanti valori per ogni riga della scheda del giocatore sono stati segnati come estratti, in modo da riportare poi l'eventuale presenza di 5 numeri segnati nella stessa riga in una variabile \"res\".\r\nSuccessivamente, nella classe \"Tombola\", aggiungerei un metodo che vada a controllare il valore di \"res\" precedentemente aggiornato e comunichi l'eventuale vincita di una cinquina.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4705,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4800,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4813,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5197,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4668,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5562,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le interfacce? Perche sono fondamentali in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": "fondamentali"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5654,
          "asker": {
            "courseId": 100,
            "askerId": 862,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si presentano le interfacce relativamente alla modularità del programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " modularità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5565,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando di polimorfismo si è detto che l'utilizzo di una classe astratta permette di descrivere un'interfaccia comune e costringere le classi derivate a fornire un'implementazione. Che scopo hanno in questo quadro le interfacce? Offrono un valore aggiunto o si poteva ottenere lo stesso risultato sfruttando solamente le classi astratte?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "abstract classes"
            },
            {
              "keyword": " interfaces"
            },
            {
              "keyword": " polymorphism"
            },
            {
              "keyword": " inheritance "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5906,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Teoricamente :\r\nUna classe astratta ha proprio il senso di oggetto \"fisico\" che ha dei metodi che solo delle sottoclassi più raffinate implementano effettivamente.\r\nL'interfaccia è unicamente una lista di funzionalità che una classe che la implementa dovrà avere. Un interfaccia *non* è oggetto nel senso della programmazione ad oggetti mentre analizziamo con un diagramma UML. Essa è semplicemente una lista di funzionalità che dovranno esser presenti nelle classi che la implementano.\r\n\r\nPratica:\r\nÈ possibile utilizzare unicamente le classi astratte. Il problema nasce quando il nostro sistema richiede che due classi siano padre e figlio e (non avendo l'ereditarietà multipla in Java) non ci sarà così possibile estendere anche la classe-astratta-interfaccia.\r\nUtilizzando le interfacce, imponiamo che siano presenti i metodi senza considerare il diagramma dei collegamenti tra gli oggetti veri e propri.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4640,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4743,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4834,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5040,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5081,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5221,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5973,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I concetti di classe astratta e di interfaccia sono simili, ma ci sono alcune differenze. Innanzitutto, una classe astratta può contenere metodi non abstract e fornirne l'implementazione (il viceversa non è vero: classi non abstract non possono avere metodi abstract), mentre un'interfaccia contiene solo le firme dei metodi (oltre ad eventuali variabili final). Da questo punto di vista le interfacce possono essere considerate un'estremizzazione delle classi astratte.\r\nPiù nel concreto le interfacce, essendo a tutti gli effetti classi, sopperiscono alla mancanza dell'ereditarietà multipla (fino a Java 7): una classe può ereditare da una sola superclasse, ma può implementare più di un'interfaccia. Problemi relativi all'ereditarietà multipla come \"da quale superclasse (interfaccia) eredito l'implementazione del metodo X?\" non si presentano, in quanto le interfacce non forniscono le implementazioni dei metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4835,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4742,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5082,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5222,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4642,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5038,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5979,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un'interfaccia può essere vista come un'ulteriore astrazione di una classe astratta. Infatti la classe può avere sia metodi astratti che metodi definiti, sia variabili che costanti, mentre un'interfaccia contiene solo firme di metodi e costanti. Entrambe inoltre non possono essere istanziate e devono essere \"ereditate\" da classi a cui forniscono un'ambiente comune. L'ulteriore astrattezza dell'interfaccia però non permette di impostarla come tipo di una variabile e successivamente fare downcast. Come vantaggio si ha la possibilità di implementare l'interfaccia anche in classi che già ereditano da un'altra classe o implementarne più in una stessa classe. Infatti il compilatore sa che in un'interfaccia non esistono metodi non astratti che possano creare conflitto con altri metodi. Quindi una classe, anche se astratta, è un elemento dell'albero formato dalle classi con la relazione is-a, mentre l'interfaccia crea una relazione più debole ma che può accomunare classi anche molto lontane.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4833,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5039,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5083,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5223,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4741,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4641,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5661,
          "asker": {
            "courseId": 100,
            "askerId": 830,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Definisci overloading. Definisci overriding",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5655,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che derivano dall'utilizzo delle interfacce?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " libreria"
            },
            {
              "keyword": " metodi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5632,
          "asker": {
            "courseId": 100,
            "askerId": 784,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di utilizzare una libreria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "libreria"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5658,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una collection? E quali sono i suoi utilizzi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": "utilizzi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5596,
          "asker": {
            "courseId": 100,
            "askerId": 759,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "List <int> myList= new ArrayList <int>();\r\n\"myList\" contiene dei numeri interi. Implementa una funzione che ritorna come output la somma dei elementi della lista dopo aver ricevuto in input una lista.\r\n\r\npublic static int ricerca (List lista)\r\n{\r\n       ......\r\n       .........\r\n}\r\n\r\nCompleta questa funzione, usando il ciclo \"while\" e \"Iterator\" (obbligatorio).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iterator"
            },
            {
              "keyword": "iteratore"
            },
            {
              "keyword": "codice"
            },
            {
              "keyword": "algoritmo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5561,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 163,
            "taskName": "Ask A Question"
          },
          "questionText": "Che utilità hanno le collection?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": " import"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5934,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Una collection è un oggetto che raggruppa elementi multipli ed eterogenei in una singola entità. \r\nLe collections sono delle strutture che sono state create per migliorare la comprensibilità e semplificare la complessità del codice; in particolare sono utili per immagazzinare, recuperare e trattare dati, e per trasferire dati da un metodo all'altro.\r\nPer utilizzare le collection abbiamo la possibilità di sfruttare alcune operazioni di base come :\r\n- int size() = riporta la grandezza della struttura;\r\n- boolean isEmpty() = ci informa se la struttura è vuota o meno (True/False);\r\n- boolean contains(Object element) = restituisce True se l'oggetto passato come parametro è presente nella struttura dati;\r\n- boolean add(Object element) = aggiunge un oggetto alla struttura e restituisce True se l'operazione è andata a buon fine;\r\n- boolean remove(Object element) = rimuove l'oggetto dalla collection;\r\n- Iterator iterator() = serve per visitare la collezione, ha funzione di indice;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4692,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4956,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4896,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4698,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4790,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5927,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una collection serve essenzialmente per raggruppare all'interno di un metodo più dati, anche di tipi diversi, così da poterli gestire con una singola entità. L'utilità è paragonabile alle struct in C++.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4693,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4789,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4696,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4894,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4954,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5975,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Le collection sono utili perché permettono di utilizzare del codice di base per la gestione dei dati già scritto e testato, in modo da velocizzare la scrittura del codice e potersi concentrare sugli algoritmi specifici che dobbiamo implementare. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4699,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4691,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4793,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4953,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4893,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6023,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per Collection si intende una classe che contiene una collezione di oggetti che può essere strutturata in vario modo, e che viene caratterizzata dalla propria interfaccia, che si chiama anch'essa Collection, arrivando a costituire (insieme alle implementazioni e agli algoritmi) Java Collection Framework.\r\nNell'interfaccia Collection ci sono dei metodi di utilità generale che vengono utilizzati per tutti i tipi di collection concrete, come ad esempio set o liste. Tali metodi di utilità sono:\r\nint size();\r\nboolean isEmpty();\r\nboolean contains(Object element);\r\nboolean add(Object element);\r\nboolean remove(Object element);\r\nIterator iterator().\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4695,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4690,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4892,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4791,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4952,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5917,
              "task": {
                "taskId": 164,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 751,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le collection permettono di ragruppare dati omogenei in un singolo elemento",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4955,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4792,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4895,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4697,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4694,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 164,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "lectureId": 63,
      "lectureTitle": "Lecture 17-18",
      "questions": [
        {
          "questionId": 5915,
          "asker": {
            "courseId": 100,
            "askerId": 850,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi non si possono usare i tipi generici? Per quale ragione? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Casi"
            },
            {
              "keyword": " generici"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5904,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa ad associare al bottone un evento che funzioni solo tramite il click del mouse oppure uno specifico tasto della tastiera?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " Event.Action"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5917,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Dare una definizione precisa del concetto di \"fuoco\", e fornire un esempio concreto della sua rilevanza ai fini della gestione degli eventi in java FX",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "fuoco"
            },
            {
              "keyword": " javaFX"
            },
            {
              "keyword": " concetto"
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6352,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando utilizziamo il mouse per interagire con un programma, portiamo il cursore sull'oggetto che ci interessa e premiamo un pulsante, generando un evento per quell'oggetto. \r\nQuando invece utilizziamo la tastiera dobbiamo trovare un modo per definire con quale elemento dell'interfaccia vogliamo interagire. Il focus serve a identificare l'oggetto a cui verrà associato un evento (ad esempio la pressione di un tasto della tastiera). Si tratta di una proprietà che può avere solamente un nodo della scena per volta e può essere modificato, ad esempio, premendo TAB. Viene solitamente indicato visivamente con un contorno colorato (ad esempio azzurro).\r\n\r\nConcretamente, l'evento KeyEvent.KEY_TYPED si verifica quando un oggetto ha il focus e viene premuto un tasto della tastiera.\r\n\r\nNel caso in cui si volesse interagire con l'intera finestra invece che con un singolo node, è necessario aggiungere un EventHandler a stage, così da catturare tutti gli eventi, indipendentemente dal focus. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6329,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6263,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6393,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6223,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6481,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6287,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "La componente dell'interfaccia grafica (tra quelle che la compongono) che ha il \"fuoco\" è quella designata a ricevere gli eventi. Se ad esempio definiamo un EventHandler per intercettare gli eventi da tastiera e lo associamo ad un Button, per esempio per fare in modo che gli venga associata una shortcut da tastiera, se il pulsante al momento dell'esecuzione non ha il fuoco, comunque non sarà in grado di intercettare l'evento generato dalla pressione dei tasti sulla tastiera. Una soluzione da adottare può essere quella di gestire l'evanto a livello più alto, cioè associando un EventHandler alla Scene e simulare da codice la pressione del Button tramite il metodo fireEvent della classe Event che vuole come parametro la componente target(destinata a ricevere l'evento) e il tipo di evento da scatenare da chiamare durante l'overriding del metodo handle nella definizione dell'EventHandler.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6224,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6262,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6392,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6480,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6328,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5905,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi nell'uso dei Generic ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " vantaggi"
            },
            {
              "keyword": " svantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5923,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le conseguenze dell'inserimento del layout (pane) nella scene o in un group?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Scene"
            },
            {
              "keyword": " group"
            },
            {
              "keyword": " layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5953,
          "asker": {
            "courseId": 100,
            "askerId": 896,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java in che modo sono implementati i template e che limitazioni hanno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " template"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5938,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i generics e in che modo vengono utilizzati? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " tipi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5995,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per generic type?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "genric"
            },
            {
              "keyword": " type"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5914,
          "asker": {
            "courseId": 100,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Se il programma necessita di un layout \"responsive\" rispetto allo schermo in cui esso viene visualizzato, a quali classi container si può ricorrere? Si possono, inoltre, annidare più contenitori fra loro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "container"
            },
            {
              "keyword": " layout"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5980,
          "asker": {
            "courseId": 100,
            "askerId": 772,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può stabilire che all'interno di una Collection debbano essere presenti soltanto oggetti di una determinata classe ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5903,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, quali sono i possibili modi di implementare un Listener per gestire gli eventi generati dall'interazione del mondo esterno con l'applicazione?\r\n\r\nNel caso in cui un certo EventHandler sia usato una sola volta, c'è un modo per semplificarne la sua definizione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tipiDiListener"
            },
            {
              "keyword": " classeAnonima"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5934,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è conveniente utilizzare le generics e in quali cosi non è possibile utilizzarle?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " utilizzo "
            },
            {
              "keyword": "problemi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5967,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le classi HBox e VBox? Qual'è la differenza tra loro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Layout"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5998,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i Generics? In quali situazioni non possono essere usati?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " inutilizzabilità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6336,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 100,
                "courseFinalScore": 16
              },
              "answerText": "Generics è un metodo per scrivere codice funzionante per un certo tipo di dato che viene definito a tempo di compilazione. Nell'implementazione si utilizza un tipo generico T, che in base all'utilizzo viene \"sostituito\" da quello richiesto. Permette di astrarre tipi di dato, che vengono indicate tra parentesi angolari.\r\nDifferisce dall'uso di oggetti generici perchè quest'ultima deve controllare l'appartenza ad una specifica classe al run-time, cosa che può generare errori. Generics non genera errori a run-time, piuttosto li genera a compile-time per il type-checking.\r\n\r\nCome per gli Object, non possono gestire tipi primitivi come int, double o anche array. Il fatto è che \"sotto il cofano\", le Generics funzionano mediante l'utlizzo di Object, quindi devono essere utilizzate classi wrapper (Integer, Double ma anche Collections). Inoltre, non può essere utilizzata istanceof. E la sintassi è più prolissa, se vogliamo parlarne male",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6437,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6350,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6607,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6644,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6252,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 773,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Prima dell'introduzione dei Generics il metodo, per esempio, di prelevamento di un elemento dell'array doveva accettare un parametro Object e avere tipo di ritorno Object. \r\nOra,con i Generics, si può definire un type variable ed usarlo sia come component type dell'array, sia come tipo di ritorno del metodo.\r\n\r\nNella loro implementazione,il compilatore elimina i Generics dal codice sorgente e li sostituisce con i cast necessari per simulare questa funzionalità.\r\nCosi' facendo, il codice eseguito dalla macchina virtuale non usa le informazioni sui Generics, in quanto solo il bytecode contiene le informazioni che identificano i tipi ed i metodi, mentre l'eseguibile no.\r\nIl loro utilizzo ha quindi uno svantaggio importante: i Generics non possono essere impiegati dove è necessario conoscere quale e' il tipo effettivo a run-time, ed è questo il motivo principale per cui il linguaggio impone delle restrizioni sull'uso di questi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6436,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6606,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6643,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6349,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6275,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Generics è un tipo di riferimento che ha uno o più parametri di tipo.\r\nNella definizione di Generics, la sezione dei parametri tipo segue il nome .\r\n\r\nSi tratta di un elenco separato da virgole di identificatori ed è delimitato da\r\nparentesi angolari .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6605,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6348,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6435,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6642,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5933,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Creo una classe generica \"GenericCollector\" di parametro T in grado di contenere oggetti di tipo T, dotata di un costruttore senza parametri.\r\nSi consideri ora il seguente codice:\r\n\r\nGenericCollector<Integer> intCollector = new GenericCollector<Integer>();\r\nGenericCollector<?> collector = new GenericCollector<String>();\r\n\r\ncosa succede se faccio \"collector = intCollector\"?\r\nse invece scrivo \"intCollector = collector\"?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " WildCard Parameter"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5989,
          "asker": {
            "courseId": 100,
            "askerId": 809,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le java generics ? per cosa non possono essere utilizzate?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": "generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5931,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende con Target e Source di un evento? Quale dei due e in che modo varia al variare dell'oggetto a cui aggiungiamo l'EventHandler (o EventFilter)?",
          "totalDifficultyLevel": 21,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Target"
            },
            {
              "keyword": " Source"
            },
            {
              "keyword": " EventHandler"
            },
            {
              "keyword": " EventFilter"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6348,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il target di un evento specifica ciò che ha scatenato lo stesso, ad esempio se abbiamo premuto un bottone l'evento è dovuto proprio a questa azione, mentre la sorgente ne specifica la provenienza.\r\nAl variare dell'oggetto a cui aggiungiamo l'EventHandler o l'EventFilter, ciò che varia è la sorgente mentre il target è sempre lo stesso. In generale l'evento viene infatti passato dal contenitore al contenuto ed aggiungendo un filtro riusciamo ad intercettare questa prima fase. In questo caso la sorgente è prima lo stage poi la scene poi il pane ed infine il button.\r\nSuccessivamente l'evento viene passato dal contenuto al contenitore e con una handle riusciamo ad intercettare questa seconda fase. Dunque la sorgente è prima il button ed in successione il pane la scene ed infine lo stage.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6280,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6447,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6319,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6637,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6306,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6518,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6344,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 802,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La source è l'origine dell'evento. La source cambia appena l'evento ha superato la catena degli eventi. Il target è il nodo dove l'azione si attiva sulla catena degli eventi. Non cambia durante la catena degli eventi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6448,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6320,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6515,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6639,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6281,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6307,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6358,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il Target di un evento è l'oggetto per cui è scatenato l'evento, che viene passato tramite referenza; mentre Source è l'oggetto su cui l'evento si verifica inizialmente.\r\nAttraverso EventHandler o EventFilter si può modificare il Target di un evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6641,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6446,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6279,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6318,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6517,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6305,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6310,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Source è da dove l'evento viene generato, mentre eventTarget, nella catena di eventi che viene creata, è il percorso che l'evento segue nella catena degli eventi (ad esempio dopo aver cliccato con il mouse).\r\nSolitamente, se cambio oggetto (bottone a schermo) cambio eventSource ma non è detto che cambi l'eventTarget.\r\n\r\nGli eventi sono usati per notificare all'applicazione azioni prese dall'utente e permettere all'applicazione di rispondere all'evento. JavaFX offre strutture per catturare un evento e indirizzarlo al Target, così da gestire l'evento come serve.\r\n\r\nUn evento rappresenta un'occorrenza di 'qualcosa' che interessa l'applicazione, come un movimento del mouse o un tasto premuto. In JavaFX un evento è un'istanza della classe javafx.event.Event o subclassi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6317,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6278,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6445,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6304,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6516,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6640,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6285,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Source e Taget sono due proprietà di un evento: Source ne è l'origine, mentre Target è l'ultimo Node nella catena di distribuzione degli eventi.\r\nDurante la fase di cattura di un evento, l'evento passa dal root Node al target Node attraverso la catena di distribuzione. Se i Node sulla catena hanno degli EventFilters, questi vengono processati al passaggio dell'evento; può quindi accadere che un evevento venga \"consumato\" dai filtri e non raggiunga il Target.\r\nUn evento può essere consumato anche da un EventHandler, ma ciò accadrebbe durante la \"risalita\" dal Target al root Node, quindi il Target non ne risentirebbe. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6277,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6638,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6514,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6316,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6444,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6303,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5965,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono i listener e che differenza c'è fra listener interno ed listener esterno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Interno"
            },
            {
              "keyword": " Esterno"
            },
            {
              "keyword": " differenza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5991,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è definita la classe Pair? E quali caratteristiche ha?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": " Pair"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5997,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi si hanno con l'uso dei Generics?Fare anche un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Tipi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5935,
          "asker": {
            "courseId": 100,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Attraverso quale strumento Java permette la tipizzazione di una classe? Dove viene utilizzato <?,?> (preceduto dal nome della classe)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tipizzazione"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5957,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un generic type? Fare un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic type"
            },
            {
              "keyword": "esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5906,
          "asker": {
            "courseId": 100,
            "askerId": 788,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Java Generics: cosa sono, cosa permettono di fare, quali casi non risolvono.\r\nFare un esempio di un utilizzo",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " definizione"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5926,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa é un tipo generic ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tipo"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5970,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi è utile usare la coppia di generics Pair <?,?> ..?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 23,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " pair"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6288,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "La coppia di generics Pair <?,?> fa uso della cosiddetta \"Wildcard Instantiation\" per utilizzare come coppia due dati di qualsiasi tipo. E' utile perchè con lo stesso codice posso implementare una classe o un metodo che funzioni con diversi tipi di dato.\r\nUn esempio:\r\nPair<?,?> coll = new ArrayList<String,int>(); \r\nPair<?,?> coll2 = new ArrayList<float,String>(); \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6387,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6381,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6634,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6528,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6250,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "È utile usare la notazione <?,?> quando non sappiamo di che tipo siano i dati che vengono passati al costruttore al momento della creazione di un oggetto di quel tipo. In questo modo se passiamo per esempio 2 interi negli utilizzi successivi li utilizziamo come interi; se passiamo una String e un Float in metodi successivi li tratteremo come tali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6526,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6384,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6390,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6631,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6271,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando non si sa in quel momento che tipo di variabile sarà quella coppia, ma lo si saprà dopo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6380,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6527,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6636,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6386,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6295,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Nel caso si voglia passare parametri di tipo specifico a una classe. I parametri passati verranno accettati solo se corrispondenti  a quelli della Pair definita. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6524,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6383,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6389,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6632,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6345,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I Generics sono utilizzati per astrarre un tipo o tipi di oggetto che una classe può accettare.\r\nÈ utile utilizzare una coppia di generics quando una classe può funzionare con due tipi generici e diversi di dato, per esempio una classe molto banale che date in ingresso due variabili le stampa a video.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6385,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6525,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6391,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6633,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6318,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "L'utilizzo della wildcard '?' nel dichiarare il tipo di una variabile è utile quando si vuole che tale variabile possa contenere una qualsiasi specializzazione del tipo generico.\r\n\r\nPer esempio, può risultare utile quando ci si trova all'esterno della classe generica e dunque non si ha accesso agli identificatori che rappresentano i tipi specifici usati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6523,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6635,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6388,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6382,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5920,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Dai una definizione di \"Generic type\", aiutandoti con un esmpio (generic pila)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " type"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5943,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i generics in Java? E in cosa consiste l'Autoboxing? Portare un esempio dell'utilizzo dei generics.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " autoboxing"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5900,
          "asker": {
            "courseId": 100,
            "askerId": 844,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile inserire dei layout all'interno di altri layout (ad esempio inserire un VBox all'interno di un BorderPane) ?\r\nSe si, in che modo?\r\nE quale beneficio si trae da ciò?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "layout"
            },
            {
              "keyword": "pane"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5946,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l utilità del meccanismo di cattura degli eventi attraverso handlers e filters?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " handler"
            },
            {
              "keyword": " filter"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5960,
          "asker": {
            "courseId": 100,
            "askerId": 878,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza (vantaggi e svantaggi) tra l'uso del casting e quello dei generics (tipi generici)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " generics"
            },
            {
              "keyword": " casting"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5979,
          "asker": {
            "courseId": 100,
            "askerId": 886,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il meccanismo di template?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Template"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5928,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "C'è un comando o un modo per fare si che un bottone o un qualsiasi altro oggetto in java fx possa adattarsi al gruppo nel quale è inserito? Per esempio un bottone in un Hbox o in un qualsiasi gruppo?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "adatta "
            },
            {
              "keyword": " oggetto "
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6321,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Dato un oggetto Group g (il gruppo di oggetto grafico javafx) e uno o più oggetti Node (un oggetto grafico javafx: Button, Text, Circle ecc), i Node si possono raggruppare nello stesso gruppo g con il comando:    g.getChildren().add(Node n);      oppure per aggiungerne piu di uno    g.getChildren().addAll(Node n1,...,Node nn)\r\nNel caso di un Hbox e un bottone:\r\nHBox hb = new HBox();\r\nButton b = new Button(\"Bottone\");\r\nhb.getChildren().add(b);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6411,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6625,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6486,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6342,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6356,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6255,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 766,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per adattare un bottone o un qualsiasi oggetto ad una finestra o ad un gruppo è molto semplice. Basta associare alla dimensione del bottone le stesse dimensioni del gruppo. Per cui bisogna fare il procedimento a mano e non esiste un comando che lo faccia in automatico.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6489,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6624,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6345,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6359,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6414,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6313,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 878,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Sicuramente c'è un modo e sicuramente la documentazione ufficiale ne parla da qualche parte.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6488,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6344,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6413,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6626,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6358,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6346,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Si esiste, basta chiamare il metodo \"BoundsInParentProperty\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6343,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6412,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6627,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6357,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6487,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5901,
          "asker": {
            "courseId": 100,
            "askerId": 884,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la diffirenza tra un filter, un handler e un cutter per quanto riguarda l'intercettazione degli eventi in JavaFX? Perchè potremmo avere la necessità di utilizzarli in diverse combinazioni?(Fai un esempio)",
          "totalDifficultyLevel": 25,
          "totalInterestingnessLevel": 22,
          "totalRelevanceLevel": 25,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6256,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La differenza tra filter, haundler e cutter e` la priorita` con cui vengono chiamati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6503,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6291,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6578,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6342,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "La differenza principale tra filter e handler  è quando uno o l?altro viene eseguito, handler viene chiamato quando la scena riceve un evento del tipo specificato durante la fase di bubbling di consegna evento (l'evento viene prima catturato e gestito dall'elemento più interno e poi propagato agli elementi esterni), mentre filter nella fase di capturing (l'evento viene prima catturato dall'elemento più esterno e propagato agli elementi interni). Cutter non è presente nativamente in java ma si può ottenere consumando l?evento all?interno di un handler/filter con consume(). Consumando l'evento in un filter si impedisce a qualsiasi nodo figlio sul event chain di agire sulla manifestazione. Consumando l'evento in un handler si interrompe qualsiasi ulteriore elaborazione della manifestazione da parte degli operatori genitore sul event chain ma se il nodo che consuma l'evento ha più di un filter/handler registrato per l'evento, i filter/handler allo stesso livello vengono comunque eseguiti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6502,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6575,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6290,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6267,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando in un'applicazione viene scatenato un evento( ad esempio viene schiacciato un bottone)  questo passa attraverso tutti i livelli dell'applicazione (dal più esterno al più interno: stage, scene, ecc..) fino a raggiungere l'oggetto interessato (ossia il bottone), dopodiché l'evento torna indietro ( dal bottone fino allo stage). Durante il suo percorso l'evento può essere intercettato all'andata, e in tal caso useremo un filter, oppure al ritorno, utilizzando un handler. Se invece si utilizza un cutter (che può essere sia un filter che un handler) l'evento viene \"consumato\", ossia non può più essere intercettato in seguito.\r\nSe ad esempio ho una scena con all'interno un bottone e voglio che cliccando sulla scena (al di fuori del bottone) viene cambiato il colore di riempimento e invece cliccando sul bottone viene cambiato il nome del bottone stesso(senza che cambi il colore di riempimento), allora dovrò usare un filter sulla scena e un cutter sul bottone.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6294,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6500,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6573,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6260,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il filter è uno strumento che consente di registrare il passaggio di un certo tipo di eventi in un certo livello gerarchico (stage, scene, etc.) dell'applicazione, mentre un handler ha la funzione di gestire la risposta dell'applicazione all'evento registrato. Un cutter, invece, può prevenire il fatto che un dato evento da esso registrato possa pervenire a listeners successivi o gerarchicamente inferiori, \"consumandolo\" (event.consume). La funzione è proprio quella di tracciare, ed eventualmente gestire il percorso di un evento attraverso i vari componenti dell'applicazione, a seconda delle esigenze. \r\n\r\nEsempio: //traccia il passaggio per la scena e per lo stage\r\nscene.addEventFilter(ActionEvent.ACTION,filter);         scene.addEventHandler(ActionEvent.ACTION,handler);         stage.addEventFilter(ActionEvent.ACTION,filter);         stage.addEventHandler(ActionEvent.ACTION,handler);     \r\n\r\n//consuma l'evento\r\n stage.addEventFilter(ActionEvent.ACTION,cutter);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6293,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6499,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6574,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6279,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "In JavaFX gli eventi che vengono invocati hanno un ordine ben preciso. Infatti ogni evento parte dallo stage (che contiene tutto), fino a raggiungere il nodo piu' esterno (bottone, disegno ecc..), per poi seguire l'ordine inverso; dal nodo piu' esterno al nodo piu' interno. Per gestire in modo efficiente questa catena degli eventi (Event Chain), JavaFX ci mette a disposizione diversi metodi. Il metodo Filter permette di aggiungere un gestore di eventi ad un oggetto il cui evento passa per la prima volta sull'oggetto (quindi dal passaggio dall'oggetto piu'interno ad esterno). Il metodo Handler e' simile al metodo Filter solo che segue l'ordine inverso di Filter. Un cutter, invece, e' il nome che di solito si da a una classe che implementa l'interfaccia EventHandler e che utilizza, nel metodo handle, il metodo event.consume() che impedisce agli eventi di continuare a percorrere la EventChain. L'utilizzo di questi strumenti ci permette di avere il completo controllo sugli eventi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6504,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6577,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6292,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6328,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": " Ogni evento include le seguenti informazioni, EventType: il tipo di evento su cui si sta lavorando; Source: L'origine dell'evento per quanto riguarda la posizione in cui si trova nella gerarchia degli eventi; Target: Obbiettivo e il nodo finale nella catena di eventi. La gestione degli eventi è fornita dal filter e handler,implementati dall'interfaccia EventHandler. Entrano in gioco in caso tu voglia essere avvisato durante la manifestazione di un certo tipo di evento, la differenza tra i due è quando vengono gestiti.\r\nIl filter viene eseguito durante la fase di cattura di un evento, passa per tutti i nodi figli di un evento generale e consuma il target. Es: Il MouseEvent.MOUSE_PRESSED viene chiamato partendo dall'Input.Event.Any e cosi via. \r\nL'handler invece prende come evento, l'evento generale anche se non viene chiamato il target preciso, Es: Prenderà Input.Event.Any al posto del MouseEvent.\r\nIl Cutter fa consumare l'evento in un determinato nodo, con il comando consume().\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6295,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6576,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6501,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5940,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il generic type? Come si usa? Quali vantaggi/svantaggi comporta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": "type"
            },
            {
              "keyword": "utilizzo"
            },
            {
              "keyword": "definizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5941,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'utilità dei Generics? Che problemi comportano e quali risolvono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " api"
            },
            {
              "keyword": " collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5898,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "E` possibile inserire un layout all'interno di un layout?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Layout"
            },
            {
              "keyword": " nidificato"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5911,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Riguardo il focus degli oggetti, come viene gestito lo spostamento del focus nel passare da una finestra all'altra?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "focus"
            },
            {
              "keyword": " KeyEvent"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5894,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo nella gestione degli eventi troviamo i filter oltre agli handler?? Cosa cambia tra i due? Ed i cutter semplificano qualcosa o aggiungono delle opzioni nella Gestione dell'evento?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "cutter"
            },
            {
              "keyword": "filter"
            },
            {
              "keyword": "handler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6315,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 767,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un handler gestisce da sè l'evento che si è scatenato mentre il filter è creato per gestire dinamicamente le richieste che gli vengono fatte e comportarsi di conseguenza, il cutter è usato per semplificare la gestione degli eventi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6434,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6210,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6261,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6628,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6292,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Event Filters consentono di gestire un evento durante la fase di cattura di un evento. Un nodo può avere uno o più filtri per gestire un evento. Un unico filtro può essere utilizzato per più di un nodo e più di un tipo di evento. Event Filters consentono al Parents nodo dell'elaborazione comune per i suoi nodi Children oppure per intercettare un evento e prevenire ai nodi Children di agire sull'event. Un nodo può registrare più di un filtro.\r\nInvece, un Event Handler viene eseguito durante la fase di bubbling degli eventi. Se un Event Handler per un nodo Children non consuma l'evento, un Event Handler per un nodo Parent può agire per l'evento, dopo un nodo Children lo elabora e propone l'elaborazione di eventi comuni per più nodi Children. \r\nI cutter semplificano la gestione dell'evento. Dice di consumare l'evento in modo che non sarà ellaborato in maniera predefinita dalla sorgente che ha originato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6432,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6259,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6212,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6629,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6312,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "I filter sono una sorta di EvenHandler, ma svolgono una funzione diversa: vengono eseguiti prima dei normali EventHandler e possono essere usati per intercettare alcune classi di eventi e bloccarli attraverso l'uso di un cutter (event.consume()).\r\n\r\nIl motivo principale per avere due set di EventHandler, filter e convenzionali, è l'avere una *chiara suddivisione dei task*. E' buona prassi utilizzare i filter quando si intende far uso di un filter e gli handler quando si intende far uso di un handler per rendere chiare le intenzioni.\r\n\r\nI cutter permettono di bloccare definitivamente un evento e non permettergli di continuare lungo la catena (dal widget esterno all'interno e poi di nuovo verso l'esterno).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6211,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6433,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6260,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6630,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5930,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Nelle api di java viene definito il tipo di dato generics,quali sono i vantaggi nell'usare questo tipo di dato? in particolar modo qual'è il vantaggio nell'istanziare una wildcard?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "fx"
            },
            {
              "keyword": "autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5902,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzione del cutter e quella di consume? Come può variare il loro utilizzo a seconda che noi utilizziamo il Filter o l'Handler? ",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "cutter"
            },
            {
              "keyword": " filter"
            },
            {
              "keyword": " handler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6299,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il \"consume\" è utilizzato per eliminare un evento catturato dal \"filter\" o dal \"handler\" in modo tale che l'evento non si propaghi ulteriormente ed è un metodo che di solito viene richiamato all'interno di un cutter, che si occupa appunto di interromper la catena degli eventi. \r\nUn evento è catturato prima nel filter e poi nel handler, quindi a seconda di dove è posizionato il cutter è possibile fare in modo che l'evento generato si propaghi o no in un determinato punto della catena degli eventi.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6623,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6287,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6553,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6270,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6357,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ma vara dipende delle esigenze il cutter taglia e il consume comsuma fai un po ti in base a quel che ti par giusto, secondo me è la pasta ai fagioli.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6285,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6555,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6268,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6619,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6351,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il cutter è un ActionHandler che creiamo usando il super su EventHandler. È usato per incorporare il metodo consume() che associato ad un evento 'e' lo \"consuma\" impendendo la sua normale elaborazione e eveitando il suo utilizzo ad altri event listener.\r\nQuando è utilizzato su Filter implica che si vuole che l'effetto di consume avvenga prima e quando invece si vuole che l'effetto di consume avvenga dopo lo si utilizza su Handler.  \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6288,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6557,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6621,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6271,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6283,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La funzione del cutter è quella di fermare un evento ad un determinato punto del suo flusso, il quale inizia con i filter a partire dall'elemento stage(più esterno), arriva al target e finisce con gli handler sempre dello stage, passando per tutti gli elementi che contengono il target.\r\nTramite filter ed handler possiamo decidere di fermare un evento prima che termini il suo ciclo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6272,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6554,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6289,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6620,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6280,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java l'Event Chain viene percorsa due volte per ogni evento: all'andata passando dal componente \"più esterno\" a quello \"più interno\", al ritorno vicerversa. All'andata gli eventi vengono intercettati dai Filter, al ritorno dagli Handler (che NON sono tipi diversi di oggetto: uno stesso oggetto può essere usato sia come Filter che come Handler).\r\nL'oggetto cutter che abbiamo creato (slide 30), invocando il metodo consume() sull'evento intercettato, interrompe la catena; se lo si aggiunge come Filter interromperà la catena all'andata, se lo si aggiunnge come Handler al ritorno.\r\n\r\nUn paio di esempi:\r\nscene.addEventFilter(ActionEvent.ACTION,cutter) //Interrompe la catena all'inizio; gli eventi di tipo ACTION non raggiungeranno nessun altro componente oltre a scene.\r\nbutton.addEventFilter(ActionEvent.ACTION,cutter) //Interrompe la catena a metà: tutti i componenti verranno raggiunti all'andata (intercettabili dai Filter), ma nessuno al ritorno (non intercettabili dagli Handler).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6556,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6269,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6622,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6286,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5951,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Associato ad un evento 'e' (es: KeyEvent e), a cosa serve il metodo e.consume()? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " consume"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5912,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Le wildcard si possono istanziare anche come oggetti?\r\nEsempio: Pair<?,?> limit =  new Pair<T,S> dove T e S sono due oggetti generici",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Wildcard"
            },
            {
              "keyword": " Istanziare"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5959,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale caso mi è utile utilizzare nella definizione/istanziazione il Pair con i generics <?,?>? \r\nCosa sono Autoboxing e Autounboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " ?"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5895,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché dovrei usare i Generics quando posso fare tutto con il caro vecchio Object?\r\nMi da solo vantaggi o anche svantaggi?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Static Checking"
            },
            {
              "keyword": " Inheritance"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6262,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un generics è uno strumento che permette la definizione di un tipo parametrizzato, che viene esplicitato successivamente in fase di compilazione secondo le necessità; i generics permettono di definire delle astrazioni sui tipi di dati definiti nel linguaggio.\r\n\r\nVi sono svariati vantaggi nell'uso dei generics:\r\nfornisce una migliore gestione del type checking durante la compilazione;\r\nevita il casting da Object. I.e..\r\n\r\nLo svantaggio é che non é possibile creare esplicitamente array di oggetti di tipo generico.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6347,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6367,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6416,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6365,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6333,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "I Generics sono degli strumenti che permettono la definizione di un tipo parametrizzato che viene esplicitato in fase di compilazione a seconda delle esigenze e che quindi ci consente di creare delle astrazioni sui tipi di dato già forniti.\r\nQuesto porta a due principali vantaggi: una gestione migliore del type checking durante la compilazione e il fatto di poter evitare il casting da Object.\r\nI Generics però portano anche degli svantaggi come una più complicata sintassi e il maggior rischio di errori causato dalla riduzione del controllo sui tipi che dovrà essere implementato in altri modi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6364,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6346,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6366,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6415,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5908,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un tipo generico? E' possibile passare più di un tipo e diversi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tipo"
            },
            {
              "keyword": " generico"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5952,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una Wildcard Instantiation? Quando può essere utilizzata? ",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "wildcard"
            },
            {
              "keyword": "instantiation"
            },
            {
              "keyword": "generics"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6281,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Una Wildcard Instantiation significa fornire un valore di un tipo anonimo. Si usa quando si utilizza un tipo esattamente una volta ma non si conosce il nome, ma solo la sua unicità.\r\nCi sono tre tipi di Wildcards:\r\n- Bounded (covariante): C<? extends T>. Essa accetta un qualunque C<S> con S <: T . Si usa quando si vogliono ottenere dei valori da un produttore di valori.\r\n- Bounded (controvariante): C<? super T>. Essa accetta un qualunque C<S> con S >: T . Utilizzata quando si vogliono inserire valori.\r\n- Unbounded: C<?>. Essa accetta un C<S>. Non si utilizza quando si ottengono e si producono valori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6207,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6541,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6297,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Una wildcard instantiation è una forma di \"generic type\" che, come esso, è costituita da uno o più tipi passati come parametro, divisi da virgola e delimitati dalle parentesi angolari (es. class Pair <X,Y> {..} ). La Wildcard instatiation (es: Pair<?,?>) si differenzia dalla forma generica in quanto non viene specificato subito il contenuto dentro alle parentesi angolari, ma successivamente tramite una chiamata fuori dalla classe. Può essere utilizzata quando non ci serve immediatamente specificare il contenuto dentro alla classe, ma ne necessitiamo più avanti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6542,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6209,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6340,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I Wildcard si utilizzano nel caso si voglia dire che una variabile definita tramite generics può ammettere, come tipo del parametro, un qualsiasi tipo (es Pair<?,?>) o una qualsiasi sottoclasse di una classe scelta (es Pila<? extends A>).\r\nSono utili nel caso si voglia fornire come parametro di una funzione una istanza con variabili di tipo generico in quanto non esiste compatibilità tra un tipo con parametro una classe e lo stesso con parametro però una sua sottoclasse (es anche se A e sottoclasse di B, Pila<A> non è compatibile con Pila<B>).\r\nAd esempio la funzione\r\npublic void drawAllShapes(Collection<? extends Shape> c) {\r\n   for (Shape s : c) {\r\n      s.draw();\r\n   }\r\n}\r\nammette una Collection di Shape ma non una di Circle.\r\nSi possono anche usare i Wildcards durante la dichiarazione di una variabile ma non per l'istanziazione. Ad esempio si può scrivere Pila<?> p= new Pila<Integer>() ma non p=new Pila<?>().\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6206,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6539,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6289,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 863,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Le wildcard instantiation vengono utilizzate al posto dei generics per es. quando il contenuto di una collection non è noto inizialmente, oppure nella definizione di metodi. Esempio:\r\n\r\nvoid printCollection (Collection<?> c){...}\r\n\r\nAll'interno del metodo non potremmo fare assunzioni sul tipo degli oggetti contenuti da c, se non che sono sicuramente Object. \r\n\r\nÈ possibile anche usare le \"bounded wildcards\":\r\n\r\npublic class StrumentoPerScrivere {...}\r\npublic class Matita extends StrumentoPerScrivere {...}\r\npublic class Penna extends StrumentoPerScrivere {...}\r\n\r\nvoid printCollection(Collection<? extends StrumentoPerScrivere> c){...}\r\n\r\nIn questo caso il metodo può solamente stampare il contenuto di Collection che contengono oggetti di tipo StrumentoDaScrivere o sue sottoclassi, quindi anche Matita o Penna. \r\nAll'interno del metodo possiamo assumere che gli oggetti sono StrumentoDaScrivere ma non sappiamo se sono esattamente Matita o Penna.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6208,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6543,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6254,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "La wildcard instantation serve quando si vuole creare una classe che può contenere variabili di tipo diverso in base all'utilizzo di cui si ha bisogno. Ad esempio la classe arraylist può essere utilizzata nativamente con i contenuti di tipo object, ma può essere utilizzata anche con questo metodo arraylist<t> per indicare che il contenuto dell'arraylist sarà di tipo t, permettendo quindi di gestire errori direttamente in scrittura facendo si che vengano inseriti solamente oggetti di tipo t. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6540,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6205,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5913,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona la gestione della catena di eventi di una finestra? Qual è la differenza tra filter e handler? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Lezione18"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6286,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 748,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "quando viene generato un evento, questo evento prima di arrivare al gestore degli eventi di uno specifico componente passa attraverso la gerarchia che contiene quest'ultimo. Se per esempio viene premuto un bottone, l'evento verrà prima trattato dallo stage, poi dalla scena, dal gestore del layout (es: BorderPane) e infine arriverà al gestore del componente.\r\nIl filter gestisce appunto la catena dallo stage al layout mentre l'handler è posizionato sul componente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6529,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6618,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6650,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6534,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6322,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6430,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6249,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6347,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il principio chiave per il funzionamento di una catena è:\r\n? Quando un evento viene catturato, l'evento viene inizialmente osservato dal punto più alto della catena, che può essere ad esempio Stage o Scene, e poi viene inviato ai nodi successivi della catena, discendendola in profondità, fino a raggiungere il suo Target (che, nell'esempio di KEY_PRESSED, è l'oggetto sul quale è posto il focus). In questa fase, se su un nodo è posto un filter, il filtro viene chiamato, completato, e l'evento passa al nodo successivo.\r\n? Dopo che l'evento ha raggiunto il Target (e tutti i filtri sono stati processati), l'evento risale la catena dal Target al root. In questa fase, se incontra un handler, questo viene chiamato, completato, e dunque la catena continua a risalire.\r\n? Qualunque hanlder o filter può, se necessario, \"consumare\" la catena, troncandola, quando viene chiamato.\r\n\r\nLa differenza principale tra filter e handler è dunque il momento in cui vengono eseguiti, come sopra mostrato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6429,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6248,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6616,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6532,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6530,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6321,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6648,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6353,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La gestione degli eventi è affidata a filters e handlers, implementazioni dell'interfaccia EventHandler. Essi hanno lo stesso scopo: sono il cuore del listener e capiscono che l'evento è stato scatenato. Ma diverso è il loro comportamento.\r\nPer capire le differenze facciamo un esempio: supponiamo di avere una finestra, una scena, un pannello e un bottone, tutti provvisti di listener che ascoltano l'evento clic del mouse. Immaginiamoli inscatolati uno dentro l'altro: la scatola più grande è la finestra, quella più piccola il bottone.\r\nSe la gestione degli eventi è affidata a filters, quando clicco il bottone si attiverà prima il listener della finestra, poi quello della scena, poi quello del pannello e infine quello del bottone (apro le scatole dalla più grande alla più piccola).\r\nSe invece è affidata a handlers, si attiverà prima il listener del bottone, poi quello del pannello, poi quello della scena e infine quello della finestra (apro le scatole dalla più piccola alla più grande).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6617,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6323,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6431,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6250,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6533,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6531,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6649,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5921,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In java, definisco una classe generica A <float>. B ,che eredita da A, definito <integer>. Posso farlo? se ho errore, di che tipo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5978,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo il principio dell' Autoboxing/Autounboxing rende più leggero e più leggibile il codice?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": " autounboxing"
            },
            {
              "keyword": " leggibilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5942,
          "asker": {
            "courseId": 100,
            "askerId": 841,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e che cosa fanno addEventFilter e addEventHandler e perchè vengono utilizzati e in che ambito?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "addEventFilter"
            },
            {
              "keyword": "addEventHandler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5891,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere il funzionamento dell'event chain. Fare qulache esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": "Chain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5945,
          "asker": {
            "courseId": 100,
            "askerId": 836,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo certe volte risulta più comprensibile rendere classi Generics ? Elencarne i vari vantaggi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": "generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5964,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere la differenza tra un layout implementato con posizionamento fisso ed automatico e quali vantaggi e/o svantaggi si ottengono scegliendo uno e/o l'altra soluzione? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "layout"
            },
            {
              "keyword": " automatico"
            },
            {
              "keyword": " fisso"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5910,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando uso le Generics e a cosa servono? E le WildCard?\r\nQuando li uso?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics "
            },
            {
              "keyword": " WildCard"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5916,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per \"Wildcard Instantiation\" e qual è l'utilità di tale tipo di instanziazione?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Instanziazione"
            },
            {
              "keyword": " Wildcard"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6317,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe generica è definita come NomeClasse<T1,T2,...Tn>, dove il parametro i-esimo Ti è un tipo template da indicare quando si istanzia tale classe. In una wildcard instantiation uno o più parametri è una famiglia di tipi Object, indicato con ? (detto unbounded, cioè qualunque), ? extends T (famiglia delle sottoclassi di T), o ? super T(famiglia delle superclassi di T) Esempio: void stampaCoppia(Coppia<String,?> x){...};/*metodo che accetta coppie fatte da una stringa e un altro parametro a piacere*/ Coppia<String,?> a = new Coppia<String,Boolean>(); stampaCoppia(a) //Istanzio un oggetto Coppia con parametri accettabili se voglio usare il metodo stampaCoppia. La funzione accetterebbe anche una Coppia<String,Integer>, ma non una Coppia<Integer,Boolean> ecc.; posso porre limiti precisi sui parametri che un metodo può accettare, così il compilatore rifiuta vari casi di codice che in esecuzione potrebbero portare a errori ed eccezioni per uso improprio dei tipi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6376,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6369,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6439,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6568,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6226,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6284,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "L' instanziazione di tipo Wildcard è un tipo di instanziazione dove almeno un tipo degli argomenti è un \"wildcard\" ovvero un jolly .I parametri di tipo wildcard indicano una famiglia di tipi comprendenti istanze concrete di un tipo generico.\r\n\r\nEs: Collection<?>,List<? extends Number>,Comparator<? super String>.\r\n\r\nIl tipo di carattere wildcard utilizzato determina i tipi parametrici concreti appartenenti alla famiglia.Per esempio , il carattere wildcard tipo parametrico Collection < ? > indica la famiglia di tutte le istanziazioni dell'interfaccia Collection indipendentemente dal tipo dell' argomento .\r\nUn tipo parametrico wildcard non è un tipo concreto che potrebbe apparire in una nuova espressione , inoltre è simile a un tipo di interfaccia , nel senso che le variabili di riferimento  possono essere dichiarate, ma nessun oggetto del tipo parametrizzato jolly può essere creato .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6368,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6567,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6438,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6225,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6375,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5924,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il GridPane? Quando si usa? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gridpane"
            },
            {
              "keyword": " layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5944,
          "asker": {
            "courseId": 100,
            "askerId": 830,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "spiegare autoboxing, autounboxing",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": " autounboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5977,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono e a cosa servono le generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5996,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che relazione c'è tra ArrayList e ArrayList<subObj> e che amplificazioni porta il secondo? \r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "jav"
            },
            {
              "keyword": " objcts"
            },
            {
              "keyword": "old"
            },
            {
              "keyword": " casts"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5986,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono i generics in java? ",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6264,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 823,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un generic (tipo generico) permette la definizione di un tipo parametrizzato; questo permette una miglior gestione dei tipi, ad esempio automatizzando l'eventuale casting degli oggetti.\r\nEx:\r\nSet<String> citazioni = new LinkedSet<>();\r\nforza ogni oggetto di \"citazioni\" ad essere una stringa, quindi si può evitare il check al momento dell'aggiunta e il casting all'estrazione.\r\nSi possono anche utilizzare placeholder per un generic nella definizione di una nuova classe parametrizzata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6658,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6234,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6519,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6479,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6302,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I generics in java vengono utilizzati per specificare il tipo di una classe. Vengono infatti spesso riscritte classi specificandone il tipo. I generics vengono indicati con: < > dopo il nome della classe o metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6478,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6520,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6655,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6233,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6253,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I generics sono un costrutto che permette di \"parametrizzare\" la classe creando un segnaposto tipato che verrà specificato solo in altre parti del codice. \r\nUtilizzando le Generics possiamo evitare di fare casting massivo (poiché dobbiamo prevedere in anticipo tutti i tipi degli oggetti che ci capitano) e ricicliamo un sacco di codice poiché avendo un tipo che funziona come parametro, questo verrà cambiato solo all'ultimo momento in base alle nostre esigenze.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6476,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6657,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6521,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6231,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6273,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 769,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I generics rappresentano uno strumento di java che permette di definire un tipo di dato parametrizzato che verrà esplicitato in seguito, in fase di compilazione. (Una cosa molto simile avviene in c++ e prende il nome di template. Ci permette quindi di creare una classe con un parametro T ed in fase di dichiarazione dell'oggetto sceglieremo il tipo di dato con cui istanziare quello oggetto. \r\nPer dichiarare delle generics su una classe si usa il costrutto <T>, dove T indica il nostro tipo di dato all'interno della classe. Mentre quando dovremo dichiarare l'oggetto dovremmo esplicitare il tipo di dato in questo modo object <string> oppure object<int> e così via.  I vantaggi di tutto ciò sono l'abolizione del casting di Object e quindi una scrittura del codice più comprensibile. Inoltre le classe parametrizzate vengono molto usate quando si parla di collections in modo da inserire all'interno della collezione oggetti dello stesso tipo ed operare su di essi senza averi problemi di casting.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6656,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6232,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6477,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6522,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5896,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare i Generics durante la definizione di una classe? E quando invece non è possibile utilizzarli?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5961,
          "asker": {
            "courseId": 100,
            "askerId": 925,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5975,
          "asker": {
            "courseId": 100,
            "askerId": 814,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cosa sono i generics e parla degli eventuali vantaggi/svantaggi portati dall'uso di questi strumenti. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Tipi parametrici"
            },
            {
              "keyword": " Template"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5955,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Se uso il metodo .fire() su un button, l'evento parte \"dall'alto\" passando prima per gli eventFilters o parte dal pulsante e risale attraversando gli eventHandler?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "fire"
            },
            {
              "keyword": "filter"
            },
            {
              "keyword": "handler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5907,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è e in cosa consiste la Event chain? In che modo può essere sfruttata a nostro vantaggio? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vent chain"
            },
            {
              "keyword": " chain event"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5897,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è strutturata la gerarchia di controllo quando avviene un azione dalla tastiera o dal mouse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Filter"
            },
            {
              "keyword": "Handler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5971,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo non è possibile creare un array sfruttanto le Generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5947,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste la procedura di Autoboxing/Autounboxing? Perché viene utilizzata?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autounboxing  "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6269,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "La procedura di Autoboxing consiste nella conversione automatica a tempo di compilazione dei valori di tipo primitivo nei corrispondenti wrapper. L'autounboxing è il contrario (da wrapper a tipo primitivo). Per esempio:\r\n\r\nInteger x = 5;\r\n\r\nIn questo caso il compilatore, quando converte il codice in bytecode, scriverà qualcosa che è equivalente a:\r\n\r\nInteger x = Integer.valueOf(5);\r\n\r\nL'utilità di questa caratteristica di Java è evidente in particolare nelle collections.\r\nInfatti, una collection può contenere solo oggetti ma non valori di tipi primitivi. Vengono, perciò, usate le classi wrapper per contenerli.\r\nRimane, però, scomodo dover ogni volta \"impacchettare\" i valori nei rispettivi wrapper prima di poterli usare (o viceversa). Per esempio, senza autoboxing/autounboxing, dovremmo scrivere:\r\n\r\nArrayList<Integer> a = new ArrayList<Integer>();\r\nfor(int i=0; i<n; i++) a.add(new Integer(i));\r\noppure \r\nint x = a.get(i).intValue();\r\n\r\ninvece che \"a.add(i)\" o \"a.get(i)\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6314,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6547,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6254,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6409,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6562,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6325,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Autoboxing è una tecnica incorporata nel compilatore di Java che fa in modo che le variabili di tipo primitivo vengano automaticamente convertite in tipi equivalenti che sono però delle classi di java e non più dei tipi primitivi. (double a diventa quindi Double a per esempio). La tecnica di unboxing fa il contrario: passa dalla classe al tipo primitivo. Queste tecniche sono utili per esempio per inserire dei dati all'interno di una collection dove i dati di tipo primitivo non possono essere inseriti: nel caso double a la variabile a non può essere inserita nella collection mentre Double a può essere inserita",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6315,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6255,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6410,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6545,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6565,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6258,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Le procedure di autoboxing e autounboxing sono delle procedure attuate in automatico da java e servono rispettivamente per \"trasformare\" un tipo di dato elementare in un oggetto e viceversa. Ad esempio con l'autoboxing java può \"trasformare\" una variabile int in un oggetto di tipo Integer con all'interno un campo che conterrà il valore della variabile int. Viene utilizzata questa procedura per ovviare al \"problema\" che java non è puramente ad oggetti, ma consente anche l'utilizzo di tipi di dato elementare, i quali non possono essere trattati dalle Collections, in quanto queste ultime sono in grado di operare solamente su oggetti. Si può dire che è uno \"zucchero sintattico\" che permette al programmatore di non dover convertire il tipo base in oggetto e viceversa, ogni qualvolta ne ha la necessità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6406,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6311,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6546,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6251,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6566,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6259,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 925,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Introdotta a partire dalla versione 1.5 di Java, la procedura di Autoboxing permette di fare una conversione di tipo automatica tra un tipo primitivo e la sua classe wrapper equivalente. La conversione inversa, invece, prende il nome di Unboxing. Tutto ciò va nella direzione di una maggiore leggibilità del codice, in quanto elimina la necessità di effettuare una esplicita conversione di tipo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6407,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6544,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6252,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6564,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6312,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6320,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Attraverso autoboxing gli oggetti scritti nello spezzone di codice vengono automaticamente creati con i valori di riferimento dettati, senza generare errori. Questo permette di scrivere codice più leggibile e maneggevole.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6563,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6548,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6253,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6408,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6313,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5948,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Con riferimento alla slide 4 della lezione 18, perché è stato necessario un cast sul valore di ritorno del metodo estrai?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " cast"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5918,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponiamo di avere una funzione f che accetti come parametro una generica collezione c di oggetti, e che esegua solo operazioni su stringhe. Ovviamente f non esegue nessun tipo di controllo sul tipo degli oggetti, dato che da per scontato il fatto che siano di tipo String, e quindi si limita ad utilizzare un semplice cast.\r\nCome si può evitare di passare come parametro una collezione popolata da oggetti di tipo diverso da String, e quindi non causare nessun tipo di errore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "collection"
            },
            {
              "keyword": "class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5958,
          "asker": {
            "courseId": 100,
            "askerId": 784,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "cos'è l'autoboxing? se possibile fare un esempio.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": " autounboxing"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6329,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'autoboxing è uno strumento con cui java compatta una variabile do un tipo predefinito in un oggetto del tipo corrispondente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6218,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6374,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6293,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Viene definita autoboxing la conversione automatica che il compilatore java fa tra i tipi primitivi e le loro corrispondenti classi \"wrapper\" (char => Character, int => Integer, float => Float etc.). Per esempio, con l'assegnamento Integer i = 6; viene effettuata una conversione automatica che \"trasforma\" il tipo primitivo int nel suo oggetto corrispondente Integer. La procedura inversa viene invece chiamata unboxing. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6373,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6222,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6251,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "L'autoboxing è una feature che Java ha inserito a causa dell'esistenza di tipi primitivi, seppur in un linguaggio OOP.\r\nIl problema nasce dal fatto che, ad esempio, \"int a = 6;\" inizializza una variabile a di tipo intero con valore pari a 6, ma esiste anche la classe Integer, che gestisce il tipo primitivo intero. Per applicare metodi che accettano interi ad una variabile di tipo int sarebbe stata necessaria una sintassi del tipo:\r\n\"oggetto.metodo(new Integer(a));\"\r\nche è tedioso da scrivere ogni volta. Dal punto di vista logico, è facile capire che a è un intero, e la creazione di una nuova instanza di Integer sarebbe superfluo. Java  quindi fa UNA SORTA DI casting, cosicchè se noi scriviamo \"oggetto.metodo(a);\", nonostante a sia un int e non un'istanza di Integer, esso non genera errori e viene compilato ed eseguito correttamente.\r\nEsiste anche il suo opposto, l'autounboxing, che \"traduce\" automaticamente un'istanza di integer in una variabile di tipo int.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6219,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6371,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6298,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'autoboxing è una pratica che consente ad una oggetto a cui è stata applicata una generic di riconoscere tipi simili alla classe della generic e lavorarci all'interno dei metodi della classe. Si spiega più facilmente con un esempio\r\n\r\nPila s<Integer> = new Pila();\r\nint k = 9;\r\ns.inserisci(s);\r\n\r\nanche se la generic indica che l'oggetto s di Pila può lavorare solo con Integer può comunque assumere tipi int essendo \"simili\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6220,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6370,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6359,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'autoboxing è un meccanismo in cui il compilatore converte a r\r\nrun-time tipi di dati primitive nelle loro specifiche classi in modo da poter essere integrati all'interno di strutture dati più articolate, con il vantaggio di avere un codice più breve e più facile da leggere\r\nESEMPIO (prendo spunto da una pagina web): int x=3\r\n           Integer y= x",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6372,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6221,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5932,
          "asker": {
            "courseId": 100,
            "askerId": 862,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la relazione tra Generics e Polimorfismo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5936,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale differenza vi è tra EventHandler and EventFilter? Qual'è l'utilità di poter agire sugli eventi in due momenti distinti?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": " EventHandler"
            },
            {
              "keyword": " EventFilter"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6306,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le differenze tra EventHandler e EventFilter sono che:\r\n-EventHandler è un gestore di eventi che è in grado di percepire se, per esempio, durante l'esecuzione di un programma, l'utente preme un pulsante da tastiera;\r\n-EventFilter è un'implementazione del metodo EventHandler che permette di filtrare i vari eventi durante l'esecuzione di un programma.\r\nL'utilità di poter agire sugli eventi in momenti distinti è che in questa maniera si può interagire col programma anche se esso sta eseguendo delle operazioni o sembrerebbe momentaneamente inagibile. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6646,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6301,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6336,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6257,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6378,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6319,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La differenza tra EventHandler e EventFilter è: EventFilter consente di gestire un evento durante la fase di cattura di elaborazione degli eventi e un unico filtro può essere utilizzato per più di un nodo e per più di un tipo di evento.\r\nMentre EventHandler è un'implementazione dell'interfaccia EventFilter . Il metodo handle () di questa interfaccia fornisce il codice che viene eseguito quando l'evento associato con il filtro viene ricevuto dal nodo che lo ha registrato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6256,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6300,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6377,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6647,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6335,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6349,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 853,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Utilizzando la EventHandler, attraverso il metodo handle() l'interfaccia fornisce il codice che viene eseguito quando l'evento, associato ad handle(), viene registrato. La registrazione avviene tramite il metodo addEventHandler(), che prende l'evento e l'handle() come argomenti.\r\nLa EventFilter, attraverso il metodo handle(), l'interfaccia fornisce il codice che viene eseguito quando l'evento, associato con il filter, viene registrato. La registrazione, utilizza il metodo addEventFilter(), che prende il tipo di evento e il filter come argomenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6302,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6337,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6258,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6379,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6645,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5974,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella seguente linea di comando: b1.fireEvent(new ActionEvent());\r\nil new ActionEvent cosa richiama?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ActionEvent"
            },
            {
              "keyword": " Firevent"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6272,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Innanzi tutto bisogna dire che la riga di codice serve a far partire un evento (con il metodo fireEvent che appartiene alla classe Event). Il \"new ActionEvent()\" è ciò che viene lanciato; esso richiama il metodo costruttore di ActionEvent (che deriva da EventObject). Ad esso però bisogna passare anche l'oggetto che ha generato l'evento (ovvero il source), altrimenti solleverà un'eccezione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6273,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6338,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6472,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6331,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Presunta l'esistenza della seguente riga di comando:\r\n>> Button b1 = new Button();\r\nil comando:\r\n>> b1.fireEvent(new ActionEvent());\r\nmette il \"fuoco\" sul tasto 'b1' e a seguito di un'azione legata a 'b1' genera un nuovo ActionEvent (o evento in azione) che a noi è ignoto in questo particolare momento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6276,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6475,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6341,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6327,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nella linea di comando sopracitata new ActionEvent richiama il costruttore di ActionEvent e avvia un nuovo evento associato all'elemento JavaFX \"b1\", in questo caso identificabile in un bottone.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6340,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6474,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6275,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6307,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Non sono sicuro di cosa tu intenda con \"cosa richiama\", ma la riga credo che crei un nuovo oggetto dotato di fire event",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6339,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6473,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6274,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5984,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella slide numero 8 della lezione 18, quali sono le \"unchecked or unsafe operations\" usate da Pila.java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " Pila.java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5922,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Mel layout BorderPane come si può fare per centrare qualcosa nella zona destra della finestra? Se usiamo setRight() mettiamo l'oggetto del tutto a destra.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Layout"
            },
            {
              "keyword": " BorderPane"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6277,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Illustro un semplice esempio su come posizionare un oggetto centrato nella parte destra di un BorderPane.\r\n\r\nBorderPane layout = new BorderPane();\r\nButton right = new Button(\"Right\");\r\nBorderPane.setAlignment(right, Pos.CENTER);\r\nlayout.setRight(right);\r\n\r\nCon queste brevi righe di codice l'oggetto sarà posizionato nella parte destra del BorderPane e sarà anche entrato rispetto alla parte destra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6611,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6298,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6354,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una possibile soluzione all?allineamento centrale (orizzontale o verticale) del contenuto nella sezione Right della BorderPane, potrebbe consistere nell?utilizzo di una Vertical Box (VBox), all?interno della quale è possibile inserire il contenuto che si vuole gestire.\r\nESEMPIO:\r\nBorderPane layout = new BorderPane();\t// creo una BorderPane\r\nText right = new Text(?right?);\t\t\t// stringa da centrare\r\nVBox rightBox = new VBox();\t\t\t// creo una Vertical Box\r\nrightBox.getChildren().add(right);\t\t// metto la stringa all?interno della VBox;\r\nrightBox.setAlignment(Pos.CENTER);\t        // posiziono al centro il contenuto della VBox\r\nrightBox.setPrefWidth(150);\t\t\t// specifico la larghezza della VBox\r\nlayout.setRight(rightBox);\t\t\t\t// metto la VBox nella sezione Right della BorderPane\r\nBorderPane.setAlignment(rightBox, Pos.CENTER); // allineo centralmente il contenuto della sezione Right\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6608,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6299,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6332,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il BorderPane è un layout che permette di suddividere lo spazio disponibile in 5 zone (top, bottom, right, left, center) che possono contenere oggetti diversi e comportarsi in modi differenti. Per centrare qualcosa nella zona destra (per esempio un bottone \"right\"), si può usare i comandi:\r\n\r\nBorderPane layout=new BorderPane();\r\nButton right=new Button(\"Right\");\r\nBorderPane.setAlignment(right, Pos.CENTER);\r\nlayout.setRight(right);\r\n\r\ndove il parametro pos.CENTER centra l'oggetto sia orizzontalmente che verticalmente. Se si preferisse centrarlo solo in un senso si dovrebbero usare i comandi pos.CENTER_LEFT/pos.CENTER_RIGHT oppure pos.TOP_CENTER/BOTTOM_CENTER.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6296,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6609,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6326,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In primis implementare la classe Border Pane --> BorderPane border = new BorderPane();\r\nImplemento un buttone --> Button btn = new Button();\r\ne poi con il metodo border.setAlignement(btn, pos.CENTER_RIGHT);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6610,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6297,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5987,
          "asker": {
            "courseId": 100,
            "askerId": 861,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste il tipo Generic e a che tipo di problemi esso mi pone una soluzione? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "typeproblem"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5899,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Le generics in java per cosa vengono utilizzate? Perchè sono importanti? E in java fx?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " utilizzo"
            },
            {
              "keyword": " java fx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5919,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è utile utilizzare un wildcard? Fornisci un esempio",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " wildcard"
            },
            {
              "keyword": " parametrized"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5990,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa permette di fare la funzione Accordion?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "accordion "
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5954,
          "asker": {
            "courseId": 100,
            "askerId": 855,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "è possibile mette all'interno dello stesso Scene più StackPane contemporaneamente? se si come?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "StackPane"
            },
            {
              "keyword": " Scene"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5982,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra una concrete istantiation e una wildcard istantiation? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": "  wildcard"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5983,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire cosa sono le Generics e spiegare a cosa servono.\r\nPerche' a volte e' necessario l'utilizza dell'autoboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " generics"
            },
            {
              "keyword": " API"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5893,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale vantaggio abbiamo nell'utilizzare le Generics nella creazione delle nostre classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " utilità"
            },
            {
              "keyword": " vantaggio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5963,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere la procedura da utilizzare per far si che dei node posizionati in una gridpane appaiano tabulati secondo una formattazione che decide il programmatore.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gridpane"
            },
            {
              "keyword": " node"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5981,
          "asker": {
            "courseId": 100,
            "askerId": 756,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è possibile in javaFX, stabilire la posizione degli elementi in una finestra dell'applicazione?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "javaFX"
            },
            {
              "keyword": " layouts"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6257,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Per stabilire la posizione degli elementi basta usare i metodi prestabiliti per il layout.\r\nCon getX() ritornerò la coordinata x mentre con getY() la coordinata y usabili nel modo seguente :\r\n\r\n<nome_elemento>.getX();\r\n<nome_elemento>.getY();\r\n\r\nMessi insieme saranno le coordinate dell'elemento nella finestra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6227,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6235,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6458,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6595,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6538,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6360,
                  "rater": {
                    "raterId": 932,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6421,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6330,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con le proprietà .getX() e .getY() posso ottenere le ascisse e le ordinate rispetto al parent mentre se voglio ottenere le coordinate di un node rispetto al punto di origine del layout in cui si trova dovrò usare getLayoutX() e getLayoutY()",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6238,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6424,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6461,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6230,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6598,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6363,
                  "rater": {
                    "raterId": 932,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6535,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6296,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Considerando le lezioni 17-18 , non ho individuato accenni riguardo a stabilire la posizione degli elementi in una finestra dell'applicazione,mentre nella lezione 19 è stato spiegato, quindi risponderò con informazioni provenienti da una lezione successiva alla domanda, sperando di poter fornire una risposta soddisfacente. \r\nIn JavaFX per stabilire la posizione degli elementi in una finestra dell'applicazione si usano le funzioni getLayoutX() e getLayoutY() per ottenere rispettivamente le coordinate dell'asse dell'ascissa e dell'ordinata  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6536,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6422,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6361,
                  "rater": {
                    "raterId": 932,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6459,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6236,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6228,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6596,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6355,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Considerando che nella definizione di posizione bisogna essere quanto più generici possibili, nella classe Node è stato introdotto il concetto di Bounding Rectangles: Per Bouding Rectangle di un Node si definisce il rettangolo che contiene geometricamente il nodo, i cui vertici sono i punti minX, maxX, minY, maxY occupati dal nodo.\r\nOgni nodo possiede le seguenti 2 proprietà: \r\nboundsInLocal, che definisce il rettangolo che contiene il nodo nel sistema di coordinate locali, prima di ogni trasformazione.\r\nboundInParent, che definisce il rettangolo dopo ogni trasformazione.\r\nPer ottenere, dunque, la posizione di un nodo dopo una certa serie di trasformazioni occorse:\r\n\r\n=node.localToScene(node.layoutBounds.minX, node.layoutBounds.minY);\r\n\r\nDunque prima calcoliamo le coordinate nel sistema di riferimento trasformato e poi le convertiamo nel sistema di riferimento della scene.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6460,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6537,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6237,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6362,
                  "rater": {
                    "raterId": 932,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6597,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6229,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6423,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5968,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che utilità hanno i GENERIC EVENTS e come si utilizzano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GENERICS"
            },
            {
              "keyword": " EVENT"
            },
            {
              "keyword": " JAVAFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5929,
          "asker": {
            "courseId": 100,
            "askerId": 858,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può fare in Java un metodo che riceve come parametri n numeri (Integer, Float, Long, Double) e ne restituisce la somma?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " generics"
            },
            {
              "keyword": " vargs"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6338,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "E' possibile passando al metodo un array di elementi di tipo object e \"castando\" ogni suo elemento al tipo di dato T (generic).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6247,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6453,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6323,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "impostare come lettura solo i numeri ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6245,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6451,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6270,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "La cosa si puo fare usando il mecchanismo dei tipi generici.\r\npublic <T extends Number> double add (T one, T two)\r\n{\r\n    return one.doubleValue() + two.doubleValue(); \r\n}\r\nLa funzione restringe il campo T fino alle sottoclassi di Number che comprendono i tipi richiesti il ritorno e` un double perche consente la massima precisione.\r\nNon ho capito bene la parte di n numeri come parametri, ma si potrebbe implementare lo stesso meccanismo usando una List generica, il codice pero` diventerebbe piu` complicato, dunque secondo me e` meglio tenere la funzione semplice e giocarci con quella.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6452,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6246,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6350,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 831,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Usando i generics",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6244,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6450,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6290,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Grazie al meccanismo di Autoboxing - Autounboxing, i tipi primitivi come ad esempio int, double, float... sono automaticamente inseriti nella loro classe wrapper e automaticamente estrapolati da tale classe a seconda delle richieste del programma. Un esempio \r\n\r\npublic class Test {\r\n   \r\ndouble somma (Integer a, Float b , Long c , Double d) {\r\n        return a+b+c+d;\r\n    } \r\n    \r\n    public static void main(String[ ] args) {\r\n        int a = 1;\r\n        float b = 3.0f;\r\n        long c = 3;\r\n        double d = 5;\r\n        Test test = new Test ();\r\n        System. out.println( test.somma(a,b,c,d)); \r\n    }\r\n}\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6243,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6449,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5966,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare qual è il ciclo di vita di un evento (qual è il suo percorso di andata/ritorno nella catena di contenimento). Come è possibile consumare un evento prima che questo arrivi al destinatario?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " EventChain"
            },
            {
              "keyword": " cutter"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5988,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e a cosa serve FlowPane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javafx"
            },
            {
              "keyword": " FlowPane"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5956,
          "asker": {
            "courseId": 100,
            "askerId": 880,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche che differenziano le varie tipologie di Pane? (FlowPane, AnchorPane...)",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Pane"
            },
            {
              "keyword": " caratteristiche"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6308,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Innanzitutto i Pane sono delle sottoclassi del Parent (o gruppo) e quindi ereditano da questo e svolgono il suo stesso compito, ovvero quello di contenere un qualsiasi numero di oggetti come bottoni, forme geometriche, testo e molto altro per poi inserirli nella Scena o anche in uno stesso altro gruppo. Si differiscono per il modo attraverso il quale dispongono appunto gli oggetti e quindi ognuno possiede alcuni metodi diversi dall'altro.\r\nPossono essere divisi in gruppi con layout di base come il FlowPane(dispone gli oggetti uno in seguito all'altro orizzontalmente e li manda a capo se viene ristretta la finestra),l'HBox, il Vbox, lo StackPane, il TilePane o layout evoluti come AnchorPane(fissa la posizione per alcuni oggetti anche se viene mossa la finestra), BorderPane, GridPane, TitlePane. I primi, infatti, offrono un tipo di layout semplice che  non permette grandi modifiche mentre gli altri permettono di essere modellati secondo alcuni costrutti predefiniti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6495,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6352,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6331,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6282,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "La caratteristica che distingue i vari Layout (tra cui anche i Pane) è il modo in cui i nodi vengono distribuiti all'interno del layout stesso: StackPane  dispone i vadi nodi come se fossero in uno stack, ossia uno sopra l'altro (l'ultimo inserito sarà quello in evidenza, in primo piano). TilePane dispone i nodi in celle eterogenee (adattate al nodo di dimensione maggiore inserito). FlowPane li dispone in maniera consecutiva (orizzontalmente o verticalmente) con la possibilità di impostare una distanza che deve esserci fra i nodi. BorderPane (e quelli successivi) sono dei Pane che possiedono dei metodi di odinamento dei nodi automatici. Con BorderPane è possibile aggiungere dei nodi specificando in quale settore (Top, Bottom, Left, Right e Center) lo si vuole disporre. ArchorPane permette di \"ancorare\" un nodo ad una parte specifica del Pane, rimanendo costante se si modifica la dimensione del Pane. GridPane li dispone in una griglia adattando le celle ai \"lati\" del maggiore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6354,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6333,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6497,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6294,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In java fx i pane sono dei layout atti a contenere dei nodi,quindi la differenza sostanziale riscontrabile nei pane è la distribuzione dei nodi in output.Per esempio FlowPane permette di specificare la distanza da un vertice della mia finestra,l'AnchorPane permette invece al programmatore di fissare dei nodi all'interno della mia finestra",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6498,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6334,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6355,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6268,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 838,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In generale, pane diversi offrono proprietà diverse per disporre gli oggetti. Vediamole in dettaglio:\r\nAnchorPane: permette di disporre gli oggetti indicandone i vincoli (ad esempio vicinanza ai bordi);\r\nBorderPane: divide la finestra in cinque zone dove possono essere disposti gli oggetti: top, bottom, right, left, center;\r\nFlowPane: gli oggetti sono disposti in sequenza orizzontale o verticale, inoltre se cambiano le dimensioni della finestra gli oggetti rimangono visibili, nel senso che vengono spostati (nel caso orizzontale, mandati \"a capo\") mantenendo la sequenza;\r\nGridPane: costruisce una griglia flessibile in cui mettere gli oggetti;\r\nHBox e VBox: dispongono gli oggetti in orizzontale o verticale;\r\nStackPane: non ha particolari vincoli sulla disposizione, ma permette la sovrapposizione di oggetti;\r\nTilePane: dispone gli oggetti in una griglia le cui celle hanno tutte uguale dimensione, e si adatta alla dimensione della finestra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6494,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6330,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6351,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6263,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "-StackPane: posiziona gli elementi uno sopra all'altro;\r\n-TilePane: posiziona gli elementi in celle di eguale dimensione. Di default posiziona gli elementi orizzontalmente uno dopo l'altro e, quando non c'è più spazio, va a capo e comincia una nuova riga. Il numero delle righe e delle colonne che delineano le celle del TilePane variano al variare delle dimensioni della finestra;\r\n-FlowPane: posiziona gli elementi uno dopo l'altro. Possiamo decidere se posizionarli orizzontalmente oppure verticalmente;\r\n-BorderPane: delinea delle zone all'interno della finestra e posiziona gli elementi all'interno di esse. Le zone sono \"Top\",\"Bottom\",\"Left\",\"Right\" e \"Center\";\r\n-AnchorPane: posiziona gli elementi in base ai suoi bordi e ad un offset, quindi al variare delle dimensioni del Pane gli oggetti si sposteranno seguendo i suoi bordi;\r\n-GridPane: crea una griglia con righe e colonne dove posizionare gli elementi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6353,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6332,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6496,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5976,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona la  EventChain in JavaFX? a cosa serve il metodo consume?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "EventChain"
            },
            {
              "keyword": " consume"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6309,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'EventChain in JavaFX è un meccanismo che permette di \"intercettare\" gli eventi a più livelli attraverso la gerarchia di contenimento: in andata (capturing phase), attraverso un Filter (dal contenitore al contenuto: Scene->Pane->Button) o in ritorno (bubbling phase) attraverso un Handler (dal contenuto al contenitore: Button->Pane->Scene); in questo modo la gestione degli eventi passa dal livello microscopico del bottone, nel caso dell'esempio precedente, al caso macroscopico dell'interfaccia grafica stessa. Attraverso questo meccanismo diventa quindi possibile decidere l'ordine con il quale agire sugli eventi a favore della flessibilità. Ogni evento può essere \"consumato\" in fase di filtering o di handling in qualsiasi punto della catena attraverso la chiamata del metodo consume(): in questa situazione la catena si interrompe, l'evento non verrà propagato ulteriormente e tutto ciò che segue non riceverà notifiche dell'evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6325,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6483,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6399,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6395,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6343,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 932,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La EventChain rappresenta una catena di oggetti che possono inviare un oggetto, il quale viene inviato passando da un evento al successivo della catena fino a raggiungere la fine della catena. \r\nla catena è  solitamente formata seguendo la gerarchia genitore-bimbo Dalla radice al target dell'evento è aggiungendo tutti gli oggetti incontrati dalla catena.\r\nil metodo consume() serve a 'consumare' un evento tramite un filtro evento o un gestore di eventi in qualsiasi punto della catena di invio evento.\r\nquesto metodo segnala che l'elaborazione dell'evento è completa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6396,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6400,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6484,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6326,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6303,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'EventChain, cioè la gestione degli eventi, in JavaFX avviene nel seguente modo:\r\nposso andare a definire uno stage, una scena, un layout e un nodo in esso contenuto; se ad ognuno di essi aggiungo un filter e un handler (che implementano EventHandler, e sono aggiunti il primo col comando addEventFilter e il secondo con addEventHandler), nel momento in cui avviene un evento, questo viene colto per prima cosa nel filter dello stage, poi nel filter della scena, poi in quello del layout e infine in quello del nodo; dopo ciò, compie il percorso inverso, andando ad attraversare l'handler del nodo, l'handler del layout, quello della scene ed infine quello dello stage. \r\nOltre a filter e handler, è possibile anche definire cutter (anch'esso estende Event Handler) al cui interno però è richiamato il metodo cunsume dell'ActionEvent, il quale consuma l'evento, cioè nel caso cutter sia passato attraverso addEventHandler o addEventFilter, il metodo consume tronca l'evento  a quel livello.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6397,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6401,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6327,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6485,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6356,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "La EventChain in JavaFX mi traccia il flusso dell'azione attraverso i vari step;questa catena può essere idealmente divisa in due sottopercorsi: quello di andata[il Filter] verso il/i target/s e quello di ritorno[HandlerEvent]. La EventChain, o per meglio dire i due percorsi, vengono sfruttati rispettivamente per accomunare gli eventi comuni a più target[se eseguiti prima delle altre istruzioni nel Filter, altrimenti nello handlerEvent]. Un evento può essere \"consumato\" tramite il metodo consume() da un event filter o handler in qualsiasi momento nella catena degli eventi; questo metodo segnala che il processo dell' evento è completo e fa terminare l'EventChain.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6482,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6324,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6398,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6394,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5992,
          "asker": {
            "courseId": 100,
            "askerId": 833,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando di GENERICS abbiamo parlato del simbolo sottostante\r\n <?>\r\nQuale significato ha e come può essere utilizzato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " templare"
            },
            {
              "keyword": " wildcard"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5925,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza pratica tra EventFilter e EventHandler?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "differenza"
            },
            {
              "keyword": "Filter"
            },
            {
              "keyword": "Handler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5972,
          "asker": {
            "courseId": 100,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'evento di tastiera 'fuoco'?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "fuoco"
            },
            {
              "keyword": " tastiera"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5985,
          "asker": {
            "courseId": 100,
            "askerId": 912,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un fuoco? Quando lo incontriamo?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "fuoco"
            },
            {
              "keyword": " definizione"
            },
            {
              "keyword": " momento"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6335,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il fuoco (o focus) è una condizione di un componente di una finestra in cui esso viene messo in evidenza e sarà per primo oggetto di interazione. Ad esempio, se in una finestra avessimo 2 caselle di testo e cominciassimo a scrivere, scriveremo nella casella dotata di focus, o ancora se, sempre in una finestra, avessimo due pulsanti e premessimo invio, verrà premuto quello su cui c'è il focus.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6468,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6490,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6239,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6561,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6552,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6572,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6341,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In generale, il fuoco (focus) è un indicatore che ci dice quale sia, tra le tante, la finestra in uso in quel determinato momento e che riceve gli imput (per esempio da tastiera).\r\nLa finestra che ha la proprietà di possedere il fuoco è evidenziata in maniera diversa rispetto alle altre. \r\n\r\nIncontriamo il fuoco in ogni momento in cui usiamo il computer; per esempio se passiamo da un browser ad un documento office cliccando con il mouse, stiamo passando il focus dal browser alla finestra relativa al documento office.\r\n\r\nIn Java ci sono diversi strumenti che ci permettono di gestire il focus come per esempio la classe FocusEvent e i rispettivi metodi e lal classe FocusListener. E' molto importante saper gestire l'assegnazione del fuoco perché se si ha a che fare con un'interfaccia con più finestre, è molto importante assegnare il fuoco a quella giusta affinché riceva i giusti input.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6550,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6471,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6493,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6560,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6242,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6571,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6314,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 899,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Il fuoco ce l'ha l'oggetto che riceve l'input. Si vede attraverso il contorno sul controllo. Lo incontriamo in javafx e nelle interfacce grafiche in generale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6492,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6549,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6559,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6470,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6570,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6241,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6266,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Il fuoco (focus) indica se un oggetto al'interno della nostra applicazione grafica è sottoponibile a input da tastiera come, per esempio, la pressione di un Button tramite il tasto ENTER o la digitazione di caratteri all'interno di un TextField. Di solito si può osservare se un oggetto ha il fuoco dal fatto che esso sia leggermente evidenziato.\r\nUn oggeto può ricevere o perdere il fuoco sia tramite tasto TAB sia al click del mouse su tale oggetto (riceve il fuoco) o meno (perde il fuoco). Inoltre è possibile gestire il fuoco tramite alcune proprietà della classe Node, come \"focused\" e focusTraversable e tramite alcuni metodi che impostano tali proprietà.\r\n\r\nCome spiegato sopra, il fuoco si incontra nella gestione degli eventi da tastiera.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6558,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6240,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6569,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6551,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6491,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6469,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5892,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste l'autoboxing/autounboxing e perché è necessario (o meglio, utile) in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": " oop"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5962,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa è una list ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " list "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5950,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le generics e che vantaggi possono apportare al codice di un programma ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": "ottimizzazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5994,
          "asker": {
            "courseId": 100,
            "askerId": 802,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si cattura un'azione per es, dalla tastiera o da mouse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "action"
            },
            {
              "keyword": " handler"
            },
            {
              "keyword": " cattura"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5927,
          "asker": {
            "courseId": 100,
            "askerId": 494,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'ultilizzare i generic rispetto ad utilizzare un object?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " template"
            },
            {
              "keyword": " object"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6265,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "I Generics sono stati creati perchè vi è la necessità di scrivere funzioni che prescindono dai tipi, cioè che sono \"generiche\", funzionanti con tutti i tipi perchè in sostanza sono funzioni che non richiedono caratteristche specifiche di un tipo. Un esempio potrebbe essere l'implementazione di una funzione swap che scambia i valori di due variabili dello stesso tipo. Senza i generics bisognerebbe implementare una funzione che scambia il valore di due variabili intere (void swap (int a, int b)) una che scambia il valore di due variabili di tipo char (void swap(char a, char b)) e continuando così per ogni tipo per cui vogliamo sia implementata la funzione. In questo modo abbiamo creato del codice ridondante, perchè le funzioni sono identiche, tranne per il tipo delle variabili da scambiare. Invece con i generic possiamo implementarne una che vale per qualsiasi tipo(che estende Object in questo esempio):\r\nvoid swap(<T> a, <T> b){\r\n    <T> tmp = a;\r\n    a = b;\r\n    b = tmp;\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6426,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6418,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6588,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6612,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6455,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6274,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il vantaggio principale nell'utilizzo di un generic type è quello di poter creare una classe con dei metodi compatibili con più tipi di oggetti come nell'uso di object, ma ad istanziazione si dovrà definire il tipo (non primitivo), classe o interfaccia a sostituzione del generic type.\r\nCiò risolve il problema che si avrebbe con una classe di object: a compile time non si può sapere come verrà istanziata la stessa e quali tipi di oggetti saran contenuti nei suoi eventuali attributi; si potranno quindi avere errori di type mismatch a runtime.\r\n\r\nLa creazione di una classe generic prevederà quindi l'utilizzo delle parentesi angolari per denominare i \"type parameter\":\r\n  public class Box<T> {...}\r\n\r\nQuesti parametri verranno poi specificati come \"type argument\" alla creazione dell'istanza:\r\n  Box<Integer> integerBox = new Box<Integer>();\r\n\r\nSi noti che l'utilizzo di generic permette anche la distinzione di più tipi diversi come parametro, ad esempio:\r\n  class Tripletta<X,Y,Z>{...}\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6420,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6457,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6590,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6428,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6614,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6334,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 917,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "i vantaggi sono:\r\n\r\n-Forniscono una migliore gestione del type checking durante la compilazione;\r\n-Evita il casting da Object. I.e\r\n-si alleggerisce la scrittura di un istruzione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6419,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6589,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6456,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6613,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6427,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6339,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "I generics in java sono strumenti che servono per introdurre nel codice un tipo parametrizzato. E' quindi possibile in fase di compilazione specificare il tipo desiderato in base alle necessità.\r\nL'uso dei generics permette di evitare il cast da Object e facilita il controllo della correttezza del codice. \r\nPer esempio se dichiaro una Collection di String mediante l'uso dei generics è impossibile inserirvi un elemento diverso da String. Questo faccilita notevomente il controllo sui tipi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6454,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6615,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6417,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6425,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6591,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5939,
          "asker": {
            "courseId": 100,
            "askerId": 769,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra una TilePane ed una GridPane e quando conviene usare una piuttosto che l'altra? Inoltra è possibile simulare una GridPane attraverso l'uso di HBox e VBox? Se si spiegare come...",
          "totalDifficultyLevel": 23,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 23,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "layout"
            },
            {
              "keyword": " tilepane"
            },
            {
              "keyword": "gridpane"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6300,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il GridPane suddivide lo spazio disponibile nella finestra con una griglia, dove quindi ci si può riferire alle varie celle che si formano attraverso le loro coordinate.\r\nIl TilePane invece piastrella lo spazio disponibile con celle della forma necessaria a contenere il bottone più grande, di default sistema gli oggetti in Righe orizzontali e risistema i bottoni se modifichiamo lo spazio disponibile (ex. li sposta nella riga sottostante se la finestra si restringe).\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6508,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6584,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6466,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6604,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6278,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il TilePanel è un layout grafico che ti permette di gestire tutte componenti della stessa dimensione, mentre il GridPanel è più flessibile. Quindi ti conviene usare il primo quando devi gestire una matrice con oggetti della stessa classe o con oggetti di classe diversa ma con stesse dimensioni grafiche; mentre il secondo quando devi fare cose più elaborate e gestire oggetti con dimensioni diverse. \r\nSi, il GridPanel si può simulare tramite l'uso di un array di HBox o VBox ma si perderebbero i benefici del GridPanel. Quindi conviene usare sempre il GridPanel o il TilePanel quando si ha a che fare con matrici di oggetti per usufruire delle relative API.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6600,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6506,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6580,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6464,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6337,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una GridPane offre un layout a griglia sulla quale è possibile posizionare elementi di dimensioni e proporzioni diverse, mentre in un TilePane tutti gli elementi all?interno della griglia devono avere la stessa dimensione. Per simulare una GridPane con HBox e VBox è possibile utilizzare uno dei due come container ed inserire una riga/colonna dell?altro elemento. Applicando questa tecnica però sarà più complesso gestire il resize della finestra e il riposizionamento degli elementi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6465,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6507,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6582,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6602,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6276,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "TilePane si può dire che \"piastrelli\" lo spazio, infatti divide lo spazio in celle di dimensione uniforme mentre la GridPane costruisce una tabella più flessibile.\r\n\r\nè possibile simulare un GridPane attraverso l'uso di VBox e HBox in quanto basta creare prima una e poi all'interno di ogni spazio di essa creare l'altra",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6579,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6505,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6599,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6462,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6304,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 922,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Mentre nella GridPane le righe e le colonne si adattano in base al contenuto, quindi le misure di ogni \"Cella\" cambiano, nella TilePane tutte le \"Mattonelle\" hanno la stessa misura che si basa sulle misure del contenuto più grande tra tutte.\r\nE' possibile cercare di ricreare una GridPane utilizzanto HBox e VBox tuttavia risulta molto più semplice e comodo l'uso della sopracitata in quanto si risparmia sia in termini di codice che in termini di \"progettazione\" della disposizione dei contenuti nella finestra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6463,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6509,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6601,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6581,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6324,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "La differenza tra TilePane e GridPane consiste principalmente nel loro comportamento quando modifico la dimensione della finestra; la GridPane mantiene l'ordine e la posizione degli oggetti, mentre la TilePane sposta gli oggetti organizzandoli in base allo spazio libero sulla finestra. L'utilizzo di una piuttosto che l'altra dipende da ciò di cui hai bisogno, se ti serve un form che mantenga fisse le posizioni allora sfrutti le proprietà della GridPane viceversa puoi utilizzare una TilePane. Hai anche a disposizione la possibilità di poterle unire inserendo una TilePane all'interno di una posizione della GridPane e viceversa.\r\nInoltre è sicuramente possibile simulare una GridPane attraverso l'uso di HBox e VBox in due modi differenti :\r\n - Creando una VBox ed inserendo in ogni sua riga una HBox;\r\n - Creando una HBox ed inserendo in ogni sua colonna una VBox;\r\nIndifferentemente da quale soluzione si sceglie si creerà una tabella di spazi in cui poter inserire gli oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6583,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6510,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6603,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6467,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5949,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Si elenchino i vari modi di creare una classe \"Listener\" che implementi EventHandler. Quali sono i vantaggi e gli svantaggi che caratterizzano queste diverse opzioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " EventHandler"
            },
            {
              "keyword": " Eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5993,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo è possibile combinare dei layout? Fornire un breve esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "layout"
            },
            {
              "keyword": "esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5937,
          "asker": {
            "courseId": 100,
            "askerId": 904,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono e come funzionano i tool principali per gestire il posizionamento degli oggetti con javafx?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": "tool"
            },
            {
              "keyword": "posizionamento"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6301,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Il posizionamento degli elementi all'interno di una Scene può essere affidato ai cosiddetti Layout, i quali sono in grado di gestire anche lo spazio occupato dalle componenti.\r\nTra i Layout più comuni vi sono:\r\n- HBox: elementi posizionati orizzontalmente su un'unica riga;\r\n- VBox: elementi posizionati verticalmente su un'unica colonna;\r\n- BorderPane: distinzione tra zone diverse, quali Top, Bottom, Left, Right e Center;\r\n- GridPane: elementi disposti in una griglia con un numero variabile di righe e colonne;\r\n- AnchorPane: possibilità di stabilire una posizione fissa di un determinato elemento;\r\n- FlowPane: in caso di ridimensionamento della finestra, cerca di rappresentare tutto il contenuto spostanto i componenti;\r\n- TilePane: simile alla GridPane, ma usufruisce di tutto lo spazio disponibile in caso di ridimensionamento;\r\nQuesti Layout non devono essere considerati isolati uno dall'altro, anzi una buona combinazione tra di essi può portare ad un ottimo risultato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6512,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6283,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6593,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6309,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6586,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6305,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "In un'applicazione JavaFX si può gestire manualmente l'interfaccia utente impostando la posizione e le dimensioni di ogni elemento.\r\nQuesta gestione risulta tuttavia molto sfavorevole e l'opzione più semplice è quella di utilizzare layout panel. Questi sono \"contenitori\" i quali al loro interno possono includere altri nodi.\r\nTale approccio offre molti vantaggi infatti, ridimensionando o spostando una finestra, i nodi all'interno del panel in base alle varie proprietà verranno gestiti (spostati e ridimensionati) correttamente. Ne abbiamo visti di diversi e le classi dispongono i nodi contenuti nel seguente modo:\r\nHBox in orizzontale in un unica riga, VBox in verticale unica colonna, StackPane in una pila back-to-front, TilePane in celle uniformi, FlowPane in verticale o in orizzontale, BorderPane in cinque zone dello schermo prestabilite, AnchorPane ancorati a varie zone della finestra e \tGridPane in una griglia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6587,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6594,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6308,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6513,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6282,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6311,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "VBox,HBox,GridPane,BorderPane,StackPane,TilePane,FlowPane,AnchorPane, e servono per gestire il layout della finestra. Vbox = verticale , HBox = box orrizontale, BorderPane = divide la finestra in Top, Bottom , Left , Right, center e si possono aggiungere i componenti in quelle parti, StackPane = uno sopra l'altro , TilePane = tutte celle di grandezza uguale a quella più grande , FlowPane = nodo vicino ad un altro e va a capo quando non c'è più spazio in finestra, AnchorPane =  ancora alla finestra in modo tale che se la finestra viene ridimensionata, le componenti restano al loro posto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6585,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6511,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6284,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6592,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6310,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5909,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "La gestione degli eventi è meglio farla in un altra classe Listener esterna alla classe con il main oppure è meglio gestire tutto in un unica classe?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": " listener"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6322,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La gestione degli eventi generalmente dipende da ciò che si vuole implementare. \r\nPer programmi piuttosto brevi si può anche fare nella stessa classe del main, mentre negli altri casi è preferibile gestire gli eventi in modo più ordinato attraverso la creazione di una classe esterna al main.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6442,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6653,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6404,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6266,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6261,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "è meglio gestire il tutto in un unica classe",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6403,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6265,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6441,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6652,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6316,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "La gestione della View e del Controller in un'unica classe viene realizzata tramite Listener interno( listener sta in un altra classe che è interna a quella della applicazione grafica,quindi ha accesso diretto a tutte le variabili e metodi della classe che la contiene) e self Listener (la classe della applicazione gestisce tutto da sola senza neanche separare il controller in una classe distinta).Gestire tutto in una classe viene indicato quando siamo sicuri che tutto ciò che verrà gestito si trova in questa classe( questo Listener non serve a gestire un tipo di evento altrove fuori dalla classe). In pratica,ancora più usata è Listener interno anonimo, che viene definita+implementata direttamente dove serve. Molto usata quando il controller serve solo quella volta. Il caso poi più generale è usare Listener in una classe esterna che si indica quando l'ascoltatore deve gestire allo stesso modo gli stessi tipi di eventi che vengono scatenati da sorgenti che si trovano in classi diverse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6651,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6264,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6440,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6402,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6291,
              "task": {
                "taskId": 173,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "L'implementazione interna e/o esterna del Listener e' arbitraria.\r\nLa prima soluzione e' ottimale ad esempio per listener anonimi (\"usa e getta\") mentre la seconda per fattorizzare ed aumentare leggibilita' del codice raggruppando gli ascoltatori in una classe unica. \r\nQuesta scelta potrebbe risultare importante pero', nel momento in cui il Listener debba effettuare modifiche sull'ambiente dell'applicazione (es. l'aggiornamento di una variabile counter per tenere traccia del numero di volte in cui un bottone viene cliccato).Difatti, implementare una classe Listener esterna impone al programmatore l'accortezza di mantenere un riferimento alla classe-applicazione istanziandone una variabile dello stesso tipo. A quel punto sara' possibile operare direttamente sulla classe-applicazione. Implementare, invece, l'intero Listener all'interno della stessa classe-applicazione comporta una semplificazione per quanto riguarda eventuali riferimenti all'ambiente principale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6267,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6405,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6443,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6654,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 173,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5969,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è utile definire quali oggetti possono essere inseriti in una Collection? Quali vantaggi porta in fase di run-time nel caso siano presenti nella Collection oggetti diversi dal tipo sul quale si vuole operare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collection"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5973,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 172,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi e svantaggi comporta l'utilizzo delle Generics nello sviluppo del codice (Java)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 58,
      "lectureTitle": "Lecture 5-6",
      "questions": [
        {
          "questionId": 5370,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "È consigliabile, nella costruzione di una coda in Java, riscrivere tutto il codice avendo programmato già una pila? Se no, indicare come procedere.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "coda"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5312,
          "asker": {
            "courseId": 100,
            "askerId": 823,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il ruolo del metodo \"super()\" nella gestione dell'ereditarietà tra classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " sottoclasse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5301,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegando cosa si intende per \"firma\" di una funzione, chiarisci i concetti di overriding e oveloading e le relative differenze",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 22,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overloading "
            },
            {
              "keyword": " overriding "
            },
            {
              "keyword": " firma"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5751,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dato un oggetto, per firma di un suo metodo si intende il nome e i parametri in input. La firma è unica. Se all'interno di un oggetto si hanno due metodi che hanno in comune il nome, ma diversi parametri in numero e/o tipo , allora si parla di OVERLOADING, o sovraccarico. Da notare che il tipo restituito non fa parte delle firma:\r\nint gamma(int a, int b);\r\nfloat beta(int a, int b);\r\nhanno la stessa firma e non sono permessi.\r\nPer overriding si intende la dichiarazione di un metodo, all'interno di una sottoclasse, che è stato ereditato da una classe principale. Quindi \"overwrite\", cioè, sovrascrittura.\r\nLe differenza più evidente è che l'overloading avviene nella stessa classe, mentre l'overwrite \"richiede\" una classe base e una classe figlia. Un'altra notevole differenza è che il primo avviene at Run-time, il secondo at Compile-time. Per questo motivo l'overloading da' migliori performance. Inoltre, le private class possono essere overloaded ma non possono essere overwritten.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3900,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3608,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3796,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5658,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per firma di una funzione si intende il nome e la lista dei parametri di quest'ultima. Le azioni di overriding e di overloading vengono effettuate sui metodi delle classi, in particolare la prima consiste nel ridefinire nella classe figlia un metodo esistente nella classe padre mantenendone la stessa firma ma cambiandone il comportamento. La seconda consiste nel creare un alias di un metodo, in particolare viene mantenuto il nome ma la lista dei parametri risulta differente. A differenza dell'overriding, l'overloading avviene tra due metodi contenuti nella stessa classe. É opportuno puntualizzare che nella firma della funzione non é compreso il tipo di dato ritornato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3902,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3798,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3610,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5659,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per firma di una funzione si intende il nome e la lista dei parametri di quest'ultima. Le azioni di overriding e di overloading vengono effettuate sui metodi delle classi, in particolare la prima consiste nel ridefinire nella classe figlia un metodo esistente nella classe padre mantenendone la stessa firma ma cambiandone il comportamento. La seconda consiste nel creare un alias di un metodo, in particolare viene mantenuto il nome ma la lista dei parametri risulta differente. A differenza dell'overriding, l'overloading avviene tra due metodi contenuti nella stessa classe. É opportuno puntualizzare che nella firma della funzione non é compreso il tipo di dato ritornato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3612,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3904,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3800,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5652,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In programmazione si dice overloading una famiglia di funzioni/subroutine aventi lo stesso nome, ma con la possibilità di accettare un diverso set di argomenti ,tale famiglia di funzioni è detta in rapporto di Overloading.\r\n\r\nA seconda dei casi, si può parlare di overloading di funzioni, di costruttori e di operatori. Sovraccaricare il costruttore di una classe è una pratica comune per gli sviluppatori di librerie, in quanto permette loro di fornire allo sviluppatore finale diverse modalità per istanziare inizializzando l'oggetto della classe con determinati valori iniziali.\r\n\r\n\r\nNella programmazione orientata agli oggetti, l'overriding è la ridefinizione, in una sottoclasse, di un metodo ereditato da una superclasse.\r\n\r\nNella maggior parte dei linguaggi di programmazione a oggetti, si richiede che i due metodi abbiano la stessa firma e che il metodo della superclasse non sia privato o final.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3899,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3607,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3795,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5717,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per \"firma\" di una funzione si intende la sequenza dei tipi e dei nomi degli eventuali parametri formali passati in input.\r\nL'overloading consente di definire in una stessa classe più metodi aventi lo stesso nome, ma che differiscano nella firma. È il compilatore che determina quale dei metodi verrà invocato, in base al numero e al tipo dei parametri attuali. L'overriding, invece, consente di ridefinire un metodo in una sottoclasse: il metodo originale e quello che lo ridefinisce hanno necessariamente la stessa firma, e solo a tempo di esecuzione si determina quale dei due deve essere eseguito. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3613,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3801,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3905,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5663,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La firma di una funzione è una collezione di informazioni che identifica univocamente la funzione comprende tipo di ritorno numero e tipo di argomenti.\r\nCon il termine overloading si intende la possibilità di creare più funzioni con lo stesso nome ma firma diversa, a seconda del tipo e numero di argomenti nella chiamata il programma sceglie la funzione adatta.\r\nL'overriding consiste nella reimplementazione di un metodo della superclasse nella classe figlio, il metodo implementato deve avere la stessa firma del metodo ereditato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3903,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3799,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3611,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5753,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La firma di una funzione è costituita dal nome della funzione, e dalla lista dei suoi parametri e del tipo di questi ultimi . Si parla di overriding quando una funzione viene ridefinita in una sottoclasse, anche se non ne viene modificata la firma; mentre se due funzioni hanno lo stesso nome ma firma differente (perché cambia il numero o il tipo dei parametri) si tratta di overloading.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3901,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3609,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3797,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5311,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'ereditarietà degli oggetti, abbiamo visto che le variabili (e i metodi) del padre vengono passate ai figli.\r\nNella classe padre è presente una variabile dell'oggetto (ad esempio 'int prova = 1\") che poi viene \"ripetuta\" nella classe figlio (con un 'int prova=2').\r\n\r\nSe stanziamo il figlio, quale valore avrà 'figlio.prova'?\r\nCi ritornerà il valore del figlio o del padre?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "override"
            },
            {
              "keyword": " ereditarietà"
            },
            {
              "keyword": " ProvarePerCredere"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5755,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 878,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "L'istanza del figlio conterrà la variabile prova con valore 2, perché nonostante per i principi di ereditarietà OOP essa erediti la variabile dal padre, la sua ridichiarazione ne maschera il valore originale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3680,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3712,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3604,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5720,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il valore di figlio.prova sarà 2.\r\nIn una classe, una variabile che ha lo stesso nome di una variabile contenuta nella sua superclasse nasconde il campo della superclasse anche se sono di tipo differente. Nella sottoclasse la variable della superclasse non può essere referenziata utilizzando semplicemente il suo nome ma può essere utilizzata attraverso il comando \"super\". Nascondere i campi solitamente non è consigliato in quanto rende l codice poco leggibile. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3679,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3711,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3603,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5721,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ci troviamo infatti in una situazione di overriding di proprietà e in questo caso ci ritornerà il valore del figlio (prova = 2). \r\n\r\nQuesto avviene per il seguente motivo: in fase di compilazione (compile-time), la verifica è fatta sul tipo di referenza. Tuttavia, in fase di esecuzione (run-time), la JVM \"capisce\" il tipo di oggetto e (se richiesto) esegue il metodo (o la variabile semplice) che appartiene a quel particolare oggetto.\r\n\r\nDunque, nel nostro caso, viene data la precedenza a \"int prova = 2\" in quanto è proprio dell'oggetto figlio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3606,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3682,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3714,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5701,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Come già succede in altri linguaggi di programmazione, stanziando una variabile \"prova\" di tipo intero dentro la classe \"figlio\" (interna a quella \"padre\"), automaticamente l'eventuale dichiarazione più esterna di un'altra variabile con lo stesso nome, viene \"coperta\" e sovrascritta da (in questo caso) \"prova.figlio\". Il valore di tale espressione sarà dunque 2.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3713,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3681,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3605,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5306,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può affermare che in Java non esistono i puntatori? Se sì, perché? Altrimenti si spieghi come vengono utilizzati.",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Puntatori"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5678,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 745,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "In Java non esiste l'aritmetica dei puntatori. Ogni qual volta viene creato un oggetto, esso viene allocato dinamicamente. Oltretutto, quando si lavora sugli oggetti, lo si fa per riferimento. Quando un oggetto non è più utilizzato (per esempio quando perde di visibilità), il garbage collector interviene autonomamente e rende disponibile la memoria utilizzata dall'oggetto non più necessario",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3665,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3767,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3819,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4068,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3956,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5750,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 838,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Questa affermazione non è del tutto corretta,  infatti in Java  ci sono gli identificatori che svolgono il ruolo dei puntatori,  ma non ne ereditano l'aritmetica.  \r\nIn \r\nPila s= new Pila() ;\r\n\"s\" è l'identificatore,  ed è l'unico modo per raggiungere l'oggetto: per invocare un elemento o in metodo si scrive ad esempio s.size, s.inserisci().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3666,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3954,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3820,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4066,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3768,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5625,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 836,
                "courseId": 100,
                "courseFinalScore": 19
              },
              "answerText": "La domanda è abbastanza ambigua, per il fatto che la questione puntatori in Java è abbastanza accesa. In Java esistono le references che effettivamente svolgono il compito dei puntatori ma non vengono chiamati così.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3817,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3957,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3765,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4069,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3663,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5739,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "In java i puntatori esistono, ciò che manca rispetto ad altri linguaggi è l'aritmetica legata ad essi.\r\nIn java essi sono usati come identificatori degli oggetti, in quanto è possibile accedere agli oggetti solo per referenza",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3766,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3818,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4065,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3664,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3953,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5732,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": "Nel linguaggio Java esistono i puntatori, quello che Java non ha è l'aritmetica dei puntatori. Inoltre Java ha un linguaggio più semplificato nella sintassi dei puntatori rispetto al c++.\r\nIn C++ la sintassi è la seguente:Point * punto = new Point(10,10); x->punto;\r\nIn Java : Point punto=new Point(10,10); x.punto;\r\nJava ha una sinstassi più semplificata ma i due codici sono equivalenti.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3667,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3769,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3821,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3955,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4067,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5302,
          "asker": {
            "courseId": 100,
            "askerId": 921,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è uno dei vantaggi principali nei metodi di una classe dovuto all'ereditarietà tra classi in un programma object oriented? (Es: tra una classe coda e una pila)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " metodi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5323,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzione del meccanismo dell'ereditarietà?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5394,
          "asker": {
            "courseId": 100,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi nell'uso del comando Extends in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": "Extends"
            },
            {
              "keyword": "question"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5388,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in Java non esiste il tipo di dato puntatore? A differenza del C++, in che modo viene allocata (dinamicamente) la memoria senza l?utilizzo ?esplicito? dei puntatori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " C++"
            },
            {
              "keyword": " Puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5345,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "La Garbage Collection (distruttore di oggetti) interviene quando vi è bisogno di memoria e si occupa di eliminare gli oggetti che non possiedono più riferimenti attivi. Come fa la GC a determinare che non esistono più riferimenti attivi a quell'oggetto? Inoltre la GC può essere attivata esplicitamente dal programmatore, tramite quali istruzioni?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage Collection"
            },
            {
              "keyword": " GC"
            },
            {
              "keyword": " distruttore"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5726,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 899,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Esiste un sistema di tracciamento che determina quali variabili sono attive o meno.\r\nLa GC può essere attivata manualmente con il comando 'System.gc()'.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3825,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3981,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3743,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5687,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per determinare quali oggetti non hanno più un riferimento si definiscono le root (radici) che sono gli oggetti persistenti dell'applicazione ovvero quelli sempre presenti durante l'esecuzione del programma. Quali altri oggetti siano considerati root dipende dalla implementazione del garbage collector: generalmente si considerano root anche quegli oggetti il cui scope coincide con il corpo della main.\r\nAd ogni altro oggetto si assegna la proprietà di reachability (raggiungibilità) dalla root. Un oggetto si dice raggiungibile se esiste un percorso di riferimenti che permette di indirizzare l'oggetto stesso. È evidente a questo punto che gli oggetti raggiungibili sono quelli referenziabili mentre gli altri sono quelli da eliminare.La GC può essere attivata tramite i comandi System.runFinalization() richiamato dopo la System.gc()",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3742,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3983,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3824,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5645,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 748,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Quando viene istanziato un riferimento ad un oggetto viene aumentato un contatore di riferimenti a quell'oggetto. Quando per esempio si esce dallo scope di una funzione il contatore viene decrementato e quando arriva a zero la GC interviene.\r\nPuò essere attivata dal programmatore con la chiamata a System.gc() e subito dopo System.runFinalization()",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3823,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3982,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3741,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5672,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La GC annoterà le aree di memoria non più referenziate, cioè allocate da un processo attivo, e le libererà automaticamente nel momento in cui lo riterrà più opportuno per migliorare le prestazioni complessive.\r\nIN JAVA:\r\nLa GC può anche essere chiamata direttamente dal programmatore con il comando System.gc(); con questo comando java prende in considerazione (come suggerimento) la proposta di eseguire la GC, ma se ci sono altri processi attivi la metterà in coda.\r\nIl modo per far si che Java esegua la GC quando evocata è questo:\r\nSystem.runFinalization();\r\nSystem.gc();\r\nCon questo metodo Java esegue immediatamente la GC mettendo gli altri processi in coda.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3822,
                  "rater": {
                    "raterId": 908,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3984,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3740,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5384,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In java non esistono struct e union, con cosa si possono sostituire? Ed in che modo?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 20,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " union"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5627,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 849,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sono sostituite dalle classi. Esse differiscono dalle struct in quanto la visibilità degli elementi è privata di default, le funzioni sono dette metodi e le variabili/costanti sono dette variabili d'istanza.\r\nLa sintassi di una classe è molto simile a quella di uno struct, ma di norma include i propri metodi costruttore e distruttore, e consente l'ereditarietà, quindi la programmazione per differenza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3839,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3530,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3989,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3521,
                  "rater": {
                    "raterId": 913,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4012,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5727,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java le strutture sono essenzialmente sostituite dalle classi. Mentre per sopperire all'assenza delle union si utilizzano le sottoclassi, ossia classi che estendono altre classi dalle quali ereditano tutte le funzionalità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3842,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3535,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3520,
                  "rater": {
                    "raterId": 913,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4015,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3992,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5680,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe è essenzialmente la stessa cosa di una struttura , ma con più funzioni, si possono simulare le caratteristiche importanti delle unioni attraverso le sottoclassi .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3532,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3841,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4013,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3524,
                  "rater": {
                    "raterId": 913,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3990,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5736,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 783,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il linguaggio java non possiede le struct e le union tipiche del linguaggio C, però le classi, i mattoni di ogni programma java, le quali possono essere considerate delle strutture. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4017,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3525,
                  "rater": {
                    "raterId": 913,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3994,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3844,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3531,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5686,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "In java, e nella OOP in generale, si utilizzano le classi. Esse sono apparentemente come delle struct, ma possono possedere funzioni dette metodi. \r\nLe classi funzionano in modo molto simile alle struct, il programmatore deve però ricordarsi che in java non esiste l'aritmetica dei puntatori, e tutto deve venire passato per referenza. Inoltre mentre nelle struct lo scope di metodi e variabili è pubblico di default, e privato solo se specificato diversamente, qui questo ragionamento è alla rovescia. Tutto è privato a meno che non sia specificato direttamente dalla keyword \"public\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3991,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3522,
                  "rater": {
                    "raterId": 913,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4014,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3840,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3534,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5632,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il linguaggio Java non permette di utilizzare i costrutti \"struct\" e \"union\" presenti in C++, permette però attraverso le classi di svolgere simili funzioni. Per sostituire le struct, Java fa uso delle istanze e dei metodi, utili per la programmazione Object Oriented. Un nuovo tipo di struct viene definito in Java come un oggetto e non come un tipo di dato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3843,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3523,
                  "rater": {
                    "raterId": 913,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3993,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3533,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4016,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5320,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il meccanismo del garbage collection ed in che modo posso essere sicuro che venga avviato nel punto da me desiderato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gc"
            },
            {
              "keyword": " finalization"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5317,
          "asker": {
            "courseId": 100,
            "askerId": 815,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Java fa uso del Garbage Collector. Quando interviene e cosa elimina?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage Collector"
            },
            {
              "keyword": " deallocazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5363,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché non è consigliabile compattare la heap come si può deframmentare un file system?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": " deframmentazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5389,
          "asker": {
            "courseId": 100,
            "askerId": 884,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa s'intende per coda in informatica?Quali sono i metodi principali per la sua gestione? Esponi un esempio nel quale potrebbe essere implementata e, partendo dal codice per la creazione di una Pila di interi vista a lezione, crea la nuova definizione della funzione \"void inserisci(int k);\" in modo da trasformarla in una Coda di interi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Coda"
            },
            {
              "keyword": " Pila"
            },
            {
              "keyword": " codice"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5315,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è il Garbage Collector in java? Quando interviene ? E quale è la sequenza di comandi per essere avviato su esplicita richiesta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage"
            },
            {
              "keyword": "collector"
            },
            {
              "keyword": "java"
            },
            {
              "keyword": "comandi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5310,
          "asker": {
            "courseId": 100,
            "askerId": 830,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare l'overloading e la sua utilità.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5359,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'implementazione del costruttore di una classe ereditata, quando è utile utilizzare il reference super() ? ",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 22,
          "totalRelevanceLevel": 23,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": "super"
            },
            {
              "keyword": "ereditarieta"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5654,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Quando si devono utilizzare metodi presenti nella super classe",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4079,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3507,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3649,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3719,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3926,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5623,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il metodo super permette di riferirsi alla superclasse. (La classe estesa dalla classe in cui scriviamo, cioè la classe immediatamente precedente.)\r\nsuper ha due utilizzi:\r\n\r\n-chiamare un costruttore della superclasse\r\n-permettere di accedere a membri della superclasse \"nascosti\".\r\n\r\nsuper() inoltre deve essere la prima istruzione all'interno del costruttore di una sottoclasse.\r\n\r\nSe una classe contiene una variabile di istanza con lo stesso nome di una variabile di istanza della sua superclasse, la variabile della sottoclasse nasconde la variabile della superclasse; per accedere alla variabile della superclasse bisogna usare super; stesso discorso per i metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3923,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3646,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4078,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3511,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3716,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5682,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il reference super() serve per chiamare il costruttore della classe padre dalla classe figlio, ossia tramite super() si eseguirà il codice della classe padre, per poi continuare con la lettura del codice dopo il reference. Tutto ciò avviene all'interno della classe figlio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4081,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3925,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3718,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3510,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3648,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5647,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il costrutto super() viene richiamato nel costruttore di una classe figlio e serve per inizializzare il padre come oggetto a cui successivamente viene \"allargato\" all'oggetto figlio (ad esempio con l'overriding dei metodi del figlio) per effettivamente inizializzarlo come oggetto figlio. In questo si possono passare dei parametri che richiamano il costruttore del padre per inizializzarlo (la vera utilità del super e dell'ereditarietà degli oggetti).\r\nSe non viene dichiarato esplicitamente, nel costruttore ESISTE sempre il comando super() (notare senza parametri) e viene SEMPRE chiamato in maniera automatica anche se non specificato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3645,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3715,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4080,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3922,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3508,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5640,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il reference super(ListaParametri) è un puntatore implicito alla classe madre. Questo ci permette di accedere al costruttore o alle funzioni della superclasse che abbiamo ereditato. I costruttori indicano dei metodi associati alle classi con lo scopo di inizializzare le variabili; questi tuttavia non vengono ereditati ed è qui che il reference super() torna utile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3717,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3647,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3509,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4077,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3924,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5364,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo può essere attivato \"manualmente\" il Garbage Collector? E come ci si può assicurare che ciò avvenga effettivamente?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage"
            },
            {
              "keyword": "collector"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5708,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Utilizzando la chiamata System.gc();\r\n\r\nPer assicurarsi che il GC esegua la finalize degli oggetti che dealloca, prima della chiamata System.gc(); bisogna effettuare la chiamata System.runFinalization();\r\n\r\nè un passaggio importante perchè se nel metodo finalize di alcuni oggetti vengono salvati dei dati, senza la runFinalization() il GC potrebbe deallocare gli oggetti senza \"distruggerli\" tramite il metodo, perdendo quindi i dati",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3787,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3895,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3887,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3632,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3830,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5694,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In java il memory management viene fatto in maniera automatica dal Garbage Collector, intervenendo in caso di necessità di memoria, oppure nel caso in cui  non vi sono più riferimenti attivi ad un dato oggetto in memoria; Tuttavia è possibile richiamare il Garbage Collector manualmente, all'interno del programma, attraverso la chiamata esplicita \"System.gc\". Questa chiamata è da intendersi come un SUGGERIMENTO: la JVM potrà decidere a runtime se eseguirla oppure no e non è quindi garantito che venga eseguita. Per esempio, quando un programma termina, il Garbage Collector non arriva mai a rilasciare la memoria, in quanto viene rilasciata direttamente al sistema operativo; oppure, nel caso in cui la JVM non è prossima all'esaurimento di memoria, potrebbe decidere di non perdere tempo attivando il Garbage Collector. Per essere certi che venga eseguita è possibile richiamare la funzione System.runfinalization() subito dopo la System.gc, FORZANDO la JVM ad invocare il metodo finalize.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3635,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3890,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3833,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3898,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3790,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5669,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Il Garbage Collector di Java (GC) può essere attivato \"manualmente\" utilizzando il metodo System.gc(). E' utile ricordare però che comunque la chiamata di quel metodo non assicura l'attivazione del GC, ma rappresenta solo un \"consiglio\" di attivazione. Essendo infatti implementata in modo automatico e in maniera non deterministica, è in realtà la Java VM a decidere quando attivare la GC (questa decisione è influenzata da diversi fattori, come l'implementazione stessa della VM o dall'utilizzo di memoria in quel determinato momento).\r\nE' in realtà possibile consigliare alla GC di invocare i metodi finalize() (metodo distruttore per gli oggetti che lo posseggono) invocando il metodo System.runFinalization() subito dopo la chiamata a System.gc().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3888,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3788,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3831,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3896,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3633,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5637,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per chiamare il garbage collector si usa il comando \"system.gc ()\", questo peró non ci assicura che il programma esegua il comando, potrebbe farlo in uno momento che al calcolatore sembra piu adatto o non farlo proprio, se si vuole la sicurezza dell'esecuzione bisogna anticipare il comando con il codice \"system.runfinalization ()\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3832,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3789,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3634,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3897,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3889,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5347,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in Java tutti gli oggetti sono allocati nello heap?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "oggetti"
            },
            {
              "keyword": "memoria"
            },
            {
              "keyword": "dinamica"
            },
            {
              "keyword": "heap"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5650,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Non tutti gli oggetti in java sono allocati nello heap, poiché quelli che dichiari a tempo di compilazione vanno nella memoria statica quelli che vengono creati a rin time vanno invece nello heap. Oppure l'allocazione di oggetti in java prevede l'allocazione nello heap per gli oggetti e invece eventuali riferimenti all'oggetto vengono memorizzati nello stack. Il perché di ciò nasce dalla filosofia alla base di Java, che vuole fornire un prodotto sicuro ed efficiente non tanto in termini di velocità ma in termini di gestione efficiente della memoria, gestendo quest'ultima in modo definitivo ovvero dando la memoria esatta quando richiesta e sopratutto deallocata(garbage collector) quando inutilizatta evitando memory leak.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3786,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3838,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3849,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3654,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3879,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5668,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 829,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perché durante il run time lo stack non può essere toccato, quindi viene allocato tutto nel heap. Inoltre java gestisce automaticamente le allocazioni dinamiche degli oggetti heap.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3836,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3784,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3652,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3847,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3877,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5661,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java gli identificatori degli oggetti sono associati a indirizzi di memoria che puntano alle variabili d'istanza e ai metodi dell'oggetto. Essi sono quindi analoghi a dei puntatori nel comportamento, ad esempio nel passaggio come parametri a una funzione o nell'inizializzazione, e come tali vengono anch'essi allocati nella Heap. Inoltre ciò permette una semplificazione che va a vantaggio della robustezza del codice. Mentre infatti in C++ è l'utente a decidere se gestire manualmente la memoria o affidarsi a una gestione automatica, Java assegna di default la gestione automatica alle variabili di tipo primitivo mentre gli oggetti vengono gestiti manualmente, seppur con delle limitazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3876,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3835,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3846,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3651,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3783,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5619,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "In Java non si possono definire variabili di tipo oggetto, ma solo di tipo riferimento a\r\noggetto. Quindi gli oggetti vengono allocati dinamicamente tramite i riferimenti (puntatori) e le memorie allocati dinamicamente vengono allocati sempre nello Heap. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3875,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3834,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3845,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3650,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3782,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5690,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Per renderlo più flessibile non ha puntatori.Lo stack ha un supporto diretto dal processore attraverso il puntatore dello stack.Quest'ultimo viene spostato verso il basso per creare nuova memoria e verso l'alto per liberarla.Per poter eseguire ciò,il compilatore Java deve conoscere,mentre sta creando il programma,l'esatta dimensione e la durata in vita di tutti i dati che sono immagazzinati sullo stack,perchè deve generare il codice che deve spostare il puntatore in su e in giù.Questa procedura pone grossi limiti alla flessibilità del programma.In Java, infatti,gli oggetti si trovano nello heap e soltanto un loro riferimento viene posto nello stack.Essi vengono creati tramite la parola di codice 'new' e gli viene assegnato uno spazio adeguato sullo heap quando il codice viene eseguito;al compilatore non serve sapere quanto spazio di immagazzinamento gli serve assegnare dallo heap o per quanto tempo deve essere occupato.Ciò rende i programmi più flessibili anche se più costosi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3848,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3878,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3785,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3837,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3653,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5362,
          "asker": {
            "courseId": 100,
            "askerId": 925,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per garbage collection? Quando interviene e come può essere attivata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage collection"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5321,
          "asker": {
            "courseId": 100,
            "askerId": 792,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In programmazione ad oggetti, come si possono riutilizzare le classi per crearne di simili con funzionalita' o strutture aggiuntive o che ne modificano il comportamento? Spiegare come implementare questo concetto in Java portandone esempi.\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " Object Oriented"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5409,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è e a cosa serve il Garbage Collector in Java.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage"
            },
            {
              "keyword": " collector"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5327,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "che differenza c`è tra una pila ed una coda ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " coda"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5351,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il meccanismo in Java che permette al Garbage Collection di scegliere quali blocchi di memoria deallocare perché non più utilizzati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage Colletion"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5367,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può dire, in senso assoluto, che Java NON utilizzi i puntatori? Confrontare l'uso dell'operatore \"new\" in Java e il suo uso in C++ ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Puntatori"
            },
            {
              "keyword": " New"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5425,
          "asker": {
            "courseId": 100,
            "askerId": 814,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra Classe e Struct ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": "Struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5429,
          "asker": {
            "courseId": 100,
            "askerId": 898,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono i costruttori e i distruttori di una classe? Elencarne caratteristiche e peculiarità.",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Costruttore"
            },
            {
              "keyword": "distruttore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5618,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 921,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe al suo interno può contenere variabili, vettori, liste e strutture di memorizzazione di ogni tipo. Allocare tutta questa memoria all'avvio di un programma sarebbe sconveniente quindi ogni classe è dotata di un \"costruttore\" ovvero un metodo nel quale avviene l'inizializzazione di queste strutture. Allo stesso modo esistono metodi denominati come \"distruttori\" che vanno ad agire in modo opposto, ovvero bel momento in cui il programma non necessita più delle strutture di memoria di quella classe, questi metodi provvedono alla de-allocazione di quelle aree di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3638,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3959,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4063,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5729,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "In Java i costruttori e i distruttori sono dei metodi particolari utilizzati rispettivamente per creare e distruggere un oggetto.\r\nIn particolare un costruttore contiene tutte le istruzioni per l'inizializzazione dell'oggetto in questione e ha lo stesso nome della classe inoltre questo può avere dei parametri in input utili per l'inizializzazione, nel caso in cui nessun costruttore venga definito verrà utilizzato quello di default assegnato dalla JVM.\r\nIl distruttore invece è stato pensato per liberare le risorse utilizzate dall'oggetto, in java si implementa tramite il metodo finalize() che verrà poi eseguito dal garbage collector.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3960,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3636,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4064,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5622,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "I costruttori ed i distruttori sono funzioni di una classe che vengono utilizzate per la creazione-distruzione di un oggetto di quella classe. Una classe puo avere piu costruttori che differiscono tra loro per il tipo ed il numero di variabili in input, mentre il distruttore e unico e serve a liberare la memoria dalle variabili create precedentemente. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3637,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4062,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3958,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5372,
          "asker": {
            "courseId": 100,
            "askerId": 584,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire la differenza tra overriding e overloading esplicitandone le caratteristiche.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5714,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 823,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'overloading consiste nel definire più funzioni aventi lo stesso nome (ma ovviamente diversa firma); questa pratica viene utilizzata per istanziare lo stesso oggetto (a livello semantico) in vari modi a seconda della necessità.\r\nL'overriding, invece, consiste nel ri-definire un metodo ereditato dalla superclasse in una sottoclasse: ciò permette di evitar di riscrivere codice (aumentando quindi la leggerezza e la mantenibilità del codice); una condizione da soddisfare è che il metodo \"nuovo\" abbia la stessa firma del \"vecchio\" e che quest'ultimo non sia final o private.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3987,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3685,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 4056,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3726,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5706,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "- Si definisce \"Overriding\" una sottoclasse nel quelle viene sovrascritto una funzione già esistente nella classe ereditata, mantenedo la stessa firma della funzione della super classe(classe ereditata).\r\nUn esempio illustrativo del concetto di \"Overriding\" è la funzione estrai() della Coda la cui super classe è la Pila.\r\n- Si definisce \"Overloading\" l'implemantazione di una funzione con lo stesso nome della funzione ereditata della sua super classe, cambiando la firma di quest'ultimo.\r\nEsempio illustrativo è:\r\n Consideriamo una classe di nome A nella quale è implementato una funzione con la firma { int loc(int t); } e consideriamo una sottoclasse B che eredita da A. Ora la funzione B possiede la funzione della sua super classe definito in precedenza. Se definamo una nuova funzione { int loc(float t);} abbiamo applicato il concetto di \"Overloarding\", cioè nella classe B sottoclasse di A è stato implementato una funzione con lo stesso nome (int loc), ma con una firma diversa(float t).  \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3683,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3988,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4057,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3724,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5738,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "L'overriding è il principio per il quale un metodo di una classe può essere ridefinito da una sua sottoclasse. A tal proposito, si ricorda che un metodo final non può essere sovrascritto.\r\n\r\nL'Overloading è, invece, il principio per il quale due funzioni con lo stesso nome ma firma differente possono coesistere, ovvero sono riconosciute come due funzioni differenti dal compilatore. A tal proposito si ricorda che il valore di ritorno di una funzione non fa parte della sua firma, di conseguenza due funzioni del tipo\r\nvoid function1 (int a)\r\nfloat function1 (int a)\r\nhanno la stessa firma e non possono coesistere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3684,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3725,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3985,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4054,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5638,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "La firma di una funzione (o di un metodo) è definita dal nome della funzione e dal tipo dei parametri passati alla funzione stessa (per esempio f(int) e f(float) sono due funzioni diverse).\r\nIn questo modo, funzioni con lo stesso nome ma parametri diversi possono convivere in un programma java. Questo fenomeno prende il nome di overloading.\r\n\r\nSe invece due funzioni hanno lo stesso nome e la stessa firma ma vivono in contesti diversi (in due classi diverse) abbiamo il fenomeno dell'overriding.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4055,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3986,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3686,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3727,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5427,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'ereditarietà le estensioni come possono essere? quali sono le caratteristiche e come incidono in un programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " estensioni"
            },
            {
              "keyword": " caratteristiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5358,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Definisci brevemente cos'è una classe.",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classe"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5722,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe è un costrutto di linguaggio, usato nella programmazione orientata agli oggetti, utilizzato per definire il modello su cui costruire l'oggetto. Una classe per istanziare oggetti è il progetto per una tipologia di oggetti istanza che sono caratterizzati da uno stato, ovvero da un insieme di proprietà, dette variabili d?istanza;da un comportamento, ovvero sanno eseguire delle operazioni, i cosiddetti metodi d?istanza; un metodo per la loro creazione ovvero per una opportuna inizializzazione del loro stato, cioè dei costruttori. Nel caso della classe Punto (ad esempio, intesa in senso cartesiano p(x,y)) gli oggetti istanziati non sono altro che i punti con le loro coordinate.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3803,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3969,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3519,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3583,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5728,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Una classe è un insieme di oggetti che possiedono tutti caratteristiche (=proprietà) e comportamenti (=metodi) simili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3516,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3970,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3805,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3581,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5695,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In java, una classe e' un costrutto usato come modello per creare oggetti con attributi e metodi:\r\n-Gli attributi sono dati che descrivono la classe\r\n- I metodi sono funzioni che modificano i valori degli attributi o producono effetti collaterali.\r\n\r\nMediante le classi è possibile definire qualsiasi tipo di oggetto, individuando quelli che ne condividono comportamenti e caratteristiche simili e permettendo di raggiungere un alto livello di astrazione. Una volta definita una classe, e' possibile istanziare tanti oggetti che hanno lo stesso modello della classe di riferimento, indipendenti tra di loro: ovvero è possibile modificare un attributo di una variabile (riferita ad un oggetto il quale ha il modello di una determinata classe) senza modifica gli attributi di una variabile riferita ad un oggeto che ha il modello della classe stessa in quanto la locazione in memoria è differente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3802,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3967,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3580,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3518,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5667,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 811,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe è un costrutto di un linguaggio di programmazione che incorpora una serie di attributi e metodi. Una classe può essere instanziata in diversi oggetti, che mantengono la struttura di base della loro classe, pur essendo distinti tra loro, come per il valore dei loro attributi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3582,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3804,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3517,
                  "rater": {
                    "raterId": 800,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3968,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5322,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Si vuole implementare una Pila in un programma c++ dove la dichiarazione delle funzioni che operano su tale Pila sono inserite all'interno della sua struct. Avendo dichiarato nel main \"Pila * s=new Pila(5);\" si vuole poi copiare tale pila in un'altra con con questo comando \"Pila * w = s->copia();\". Come si scriverà la funzione copia che viene però descritta fuori dalla struttura pila per questioni di leggibilità come per esempio per questa \"void Pila::stampaStato() {.....}\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzione "
            },
            {
              "keyword": " copia "
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5352,
          "asker": {
            "courseId": 100,
            "askerId": 848,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai il linguaggio Java non utilizza i puntatori (e la relativa aritmetica)? Quali sono i vantaggi e gli svantaggi rispetto a un linguaggio che fa uso di tali strumenti (ad esempio il C)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5377,
          "asker": {
            "courseId": 100,
            "askerId": 824,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in Java non è possibile lavorare con i puntatori? Sono nascosti o non sono più implementati? Lavorare senza puntatori quale vantaggio porta? Nel caso di allocazione e deallocazione dinamica come viene liberata la memoria utilizzata se i puntatori non possono più essere manipolati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Puntatori"
            },
            {
              "keyword": " Allocazione"
            },
            {
              "keyword": " Deallocazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5412,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "java usa solo lo heap e mai lo stack?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": " stack "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5628,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "no.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3550,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4046,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3776,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3868,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3572,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5624,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Java usa entrambi. Infatti per tutti gli elementi per i quali è possibile una allocazione statica è usato lo stack (referenze, corpi locali dei metodi, costanti..). Tutto il resto viene allocato dinamicamente a runtime e viene utilizzato lo heap (nuovi oggetti, metodi, ecc..).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3547,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3569,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4049,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3777,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3869,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5653,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Assolutamente no per esempio per le variabili Integer o Floating o Double è la memoria di stack ad essere utilizzata",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3570,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4048,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3548,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3775,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3867,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5703,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 867,
                "courseId": 100,
                "courseFinalScore": 15
              },
              "answerText": "Java usa sia un'area di heap che uno stack",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3778,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3571,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3870,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4047,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3549,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5300,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il comando System.runFinalization();? ed il comando System.gc();?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "lezione6"
            },
            {
              "keyword": "garbageCollector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5399,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è la firma di un metodo?\r\nÈ possibile, ad esempio, definire all'interno della stessa classe entrambi i metodi seguenti?\r\n\r\nint maggiore(int a, int b) {\r\n...\r\n}\r\n\r\nint maggiore(int a, int b, int c) { \r\n...\r\n} ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "firma"
            },
            {
              "keyword": " metodi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5644,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "La firma di un metodo è l'insieme di keyword e identificatori utilizzato per definire un metodo. Nella firma va considerato il tipo di ritorno, il nome associato al metodo e l'insieme dei parametri con i relativi tipi.\r\n\r\nEs: <tipoRitorno> <nomeMetodo>(<tipo1> <param1>, ... ,<tipoN> <paramN>)\r\n\r\nInoltre, esiste un meccanismo chiamato \"Overloading\" che permette di definire più metodi con lo stesso nome, ma con parametri differenti in tipo e/o quantità (ATTENZIONE, il tipo di ritorno deve rimanere uguale, altrimenti il compilatore non sarebbe in grado di decidere il tipo di ritorno, qualora il risultato del metodo non venisse assegnato esplicitamente ad una variabile). Quindi, grazie a questo meccanismo, è possibile implementare l'esempio sopraccitato nella domanda.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4019,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4074,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3529,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3656,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5718,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La firma è la lista dei tipi dei parametri che riceve in input un metodo.\r\nAll'interno di una classe puoi definire tutti i metodi che vuoi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4021,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3657,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4076,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3526,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5630,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 765,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La firma di un metodo è caratterizzata da due parti : la prima parte è definita dall'identificatore del metodo, nel nostro caso l'identificatore è \"maggiore\", la seconda definisce invece i parametri necessari ad invocare il metodo : int a,b per il primo mentre int a,b,c per il secondo. Fintato che due o più metodi, con uguale identificatore uguale hanno firma distinguibile in maniera univoca è sempre possibile definirli ed invocarli all'interno di una stessa classe. La risposta è pertanto si : nel nostro metodo sarà possibile definire i metodi maggiore (int a, b) e maggiore (int a, int b, int c) in quanto hanno firma uguale. Si noti che il tipo di ritorno del metodo, nell'esempio \"int\", NON è significativo nella definizione della firma di un metodo. Per tanto due metodi int maggiore (int a) e double maggiore (int a) NON sono definibili all'interno di uno stesso metodo in quanto non è chiaro al compilatore a quale fare riferimento in una possibile invocazione del metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3527,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3655,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4073,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4018,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5740,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La firma di un metodo è costituita da un insieme di informazioni che identificano univocamente il metodo stesso all'interno della classe a cui appartiene.\r\nIn particolare è formata dal nome del metodo e dall'insieme dei parametri di input dello stesso.\r\nNella stessa classe possono esserci due metodi con lo stesso nome, purchè essi abbiano una diversa firma, come nell'esempio proposto. In questo caso si parla di \"overloading\".\r\nE' importante sottolineare che la firma non dipende dal tipo di ritorno, infatti se ad esempio considerassimo un metodo con due firme di questo tipo: int maggiore(int a, int b) e float maggiore(int a, int b), in questo caso avremmo due firme uguali il che non è ammissibile.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3528,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4075,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4020,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3658,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5430,
          "asker": {
            "courseId": 100,
            "askerId": 791,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "\"Java non ha puntatori\". Questa affermazione è vera? Spiegare il perché della propria risposta",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5417,
          "asker": {
            "courseId": 100,
            "askerId": 901,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali funzioni del GC? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memory management"
            },
            {
              "keyword": " distruzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5392,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra una class e una struct, in c++ e in java? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5420,
          "asker": {
            "courseId": 100,
            "askerId": 852,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega brevemente l'ereditarietà. Quali sono i vantaggi di questa tecnica? Una sottoclasse cosa eredita dalla superclasse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Oggetti"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5354,
          "asker": {
            "courseId": 100,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona la gestione dinamica della memoria in Java? Quali aspetti sono automatici e quali invece sono gestiti \"manualmente\" dal programmatore?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " dinamica"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5655,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La memoria dinamica, denominata Heap,  è gestita non come un ?banale? array sequenziale ma attraverso una lista libera. Le allocazioni sono fatte prendendo il puntatore dalla lista libera. Quando si crea un nuovo oggetto, con l?operatore new, non si specifica la quantità di memoria richiesta, solo il nome dell?oggetto richiesto. Il reference alla porzione di memoria allocata è già del tipo richiesto.\r\n\r\nIn Java esiste un thread a bassa priorità che si occupa di liberare la memoria (garbage collector). \r\n\r\nGarbage collection:\r\nIl garbage collector esamina l?area di memoria dinamica di Java, marcando gli oggetti referenziati. Dopo aver esaminato tutti i possibili reference agli oggetti, gli oggetti non marcati sono considerati spazzatura ( garbage ) e quindi eliminati. Il garbage collector gira in modo sincrono quando il sistema non ha più memoria o in risposta ad una chiamata esplicita dell'applicazione (vedi Classe Runtime della libreria). \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4005,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3574,
                  "rater": {
                    "raterId": 873,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3815,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3643,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5702,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java la memoria viene gestita principalmente dal programma, venendo allocata quando quando richiesto e deallocata dal cosiddetto \"garbage collector\", una funzione di sistema che dealloca automaticamente la memoria non più utilizzata. Questa funzione può essere invocata manualmente dal programmatore, implementando i metodi static System.gc() e Runtime.gc() ove egli ritiene siano necessari e convenienti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3573,
                  "rater": {
                    "raterId": 873,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3642,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3814,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4007,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5692,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 815,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La gestione della memoria in Java risulta essere AUTOMATICA. Nella HEAP, infatti, la deallocazione non è necessaria: quando una funzione e le sue variabili terminano il loro scope, vengono eliminati i riferimenti per gli oggetti ed entra in gioco il Garbage Collector che si occupa della deallocazione (definitiva) delle entità appena dereferenziate.\r\nIl programmatore può intervenire invocando in maniera esplicita il GC con il comando: System.gc() oppure System.runfinalization();",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3644,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4006,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3575,
                  "rater": {
                    "raterId": 873,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3816,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5411,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il Garbage Collection? Quali sono i vantaggi e gli svantaggi che introduce?\r\nQuando viene eseguito? Come il programmatore può forzare la sua esecuzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage collection"
            },
            {
              "keyword": " memory management"
            },
            {
              "keyword": " heap "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5316,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "A quale scopo posso estendere una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " OOP"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5308,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i pro e i contro dell'uso del garbage collector?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " garbage collector"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5373,
          "asker": {
            "courseId": 100,
            "askerId": 880,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "È corretto dire che in Java non ci sono i puntatori? Motivare la risposta.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5374,
          "asker": {
            "courseId": 100,
            "askerId": 855,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si ottimizza una coda in modo da sfruttare la memoria al pieno senza lasciare \"buchi\" nella memoria allocata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5410,
          "asker": {
            "courseId": 100,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in Java, diversamente da come accade in linguaggi come il c, non è necessario deallocare esplicitamente la memoria allocata dinamicamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " allocazione dinamica"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5415,
          "asker": {
            "courseId": 100,
            "askerId": 878,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "se in\r\nPoint punto = new Point(10,10);\r\npunto è solo un riferimento ad un oggetto Point, \r\nPoint puntodue=punto;\r\nquesta operazione crea una copia del riferimento allo stesso oggetto,\r\noppure due oggetti diversi con identici parametri?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5304,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Dai una breve definizione del termine \"Memory management\", visto nel linguaggio di programmazione Java. Inoltre spiega quale ruolo importante svolgono i \"costruttori\" e \"distruttori\".",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttori"
            },
            {
              "keyword": " distruttori"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5369,
          "asker": {
            "courseId": 100,
            "askerId": 858,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java non ci sono i puntatori. Quali sono gli eventualiti vantaggi e svantagvi? \"chi\"  e come si occupa della loro gestione togliendo questo onere al programmatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": "  puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5342,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra i diversi tipi public, private e protected?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tipi"
            },
            {
              "keyword": " visibilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5400,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la firma di una classe? Come la firma della classe influisce sul numero e sul tipo dei costruttori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "firma"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5318,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Il concetto di \"firma\" di una funzione in Java differisce dal concetto che si ha in C/C++?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "conflitto di nomi"
            },
            {
              "keyword": " funzione"
            },
            {
              "keyword": " firma"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5629,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Il concetto di \"firma\" tra java e c/c++, ma anche con qualsiasi altro linguaggio di programmazione di alto livello, non cambia :\r\n\r\n            <tipo_funzione> <nome_funzione> (<parametro_1>, ... , <parametro_n> );\r\n\r\nLa firma è composta solamente dal nome della funzione e dai parametri necessari. Il tipo della funzione non influenza la firma! Infatti :\r\n            int funzione(int n);\r\n            float funzione(int n);\r\nhanno la stessa firma! \r\nMa :\r\n            int funzione(int n);\r\n            float funzione(int n1, int n2);\r\nsono due forme diverse! (In questo caso si parla di overloading, cioè funzioni con lo stesso nome ma diversa firma!)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3704,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3919,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3934,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3708,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3872,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5723,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 824,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Il C/C++ ed il Java utilizzano lo stesso principio per decidere quale funzione utilizzare in caso di nomi/argomenti simili. Per concetto di \"firma\" entrambi prendono in considerazione il nome (in modo case sensitive) dei metodi/funzioni ed il tipo ed il numero dei parametri formali in ingresso alla funzione. Due funzioni quindi saranno indistinguibili solo se avranno lo stesso nome, lo stesso numero di parametri formali in ingresso e lo stesso tipo dei parametri formali in ingresso. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3703,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3707,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3871,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3933,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3918,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5689,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, essi differiscono per un aspetto fondamentale: mentre in java è possibile definire metodi con nomi uguali (basta che abbiano parametri diversi, per numero o per tipo, e quindi conseguentemente firma diversa) in C/C++ non è possibile definire funzioni con nome uguale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3920,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3873,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3935,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3705,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3709,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5735,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "In Java la firma di un metodo comprende il nome del metodo stesso e i tipi dei parametri che gli vengono passati, ma non il tipo di parametro che restituisce (ex.: pippo(int, float) ).\r\nIn C/C++ la firma equivale al prototipo della funzione che comprende il nome della funzione, i tipi dei parametri che le vengono passati e il tipo del parametro che ritorna \r\n(ex.: int pippo(int, float) ). Quindi il concetto di \"firma\" differisce.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3710,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3921,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3874,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3936,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3706,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5407,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Esistono differenze nella gestione di una struct tra il linguaggio C++ e quello Java? Se sì, fornire un esempio di una struct codificata nei due linguaggi sopra citati utile ad evidenziare tali differenze.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Struct"
            },
            {
              "keyword": " C++"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5331,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Prima con Lisp e successivamente con Java, viene introdotta la possibilità di andare a liberare aree di memoria non più referenziate e non deallocate;quali sono i vantaggi e gli svantaggi del GC, quali sono i modi di invocarlo ed in cosa differenziano l'uno dall'altro? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage collector"
            },
            {
              "keyword": "memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5343,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega che cos?è il garbage collector (GC), come e quando funziona e infine illustrane i principali vantaggi e svantaggi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage"
            },
            {
              "keyword": " Collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5393,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè la funzione public String toString(){} e' considerata Overriding[slide 14/27,ereditarietà]?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": " toString"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5365,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'ereditarietà in Java? Descriverne i vantaggli/svantaggi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5395,
          "asker": {
            "courseId": 100,
            "askerId": 886,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con il termine Garbage Collection (GC) e come viene utilizzato dal sistema?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " distruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5326,
          "asker": {
            "courseId": 100,
            "askerId": 907,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'ereditarietà e cosa implica.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5418,
          "asker": {
            "courseId": 100,
            "askerId": 829,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e cosa serve il garbage collection? Perché e' così importante?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memory management"
            },
            {
              "keyword": " distruttore"
            },
            {
              "keyword": " memory leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5334,
          "asker": {
            "courseId": 100,
            "askerId": 841,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale caso utilizzeresti Java e/o il C/C++ per programmare e perchè di tale scelta? Quali sono le principali differenze, ma soprattutto, i principali vantaggi e svantaggi (se ce ne sono) nell'utilizzare l'uno o l'altro? Tu che linguaggio consiglieresti per iniziare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Slides"
            },
            {
              "keyword": "5/6"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5303,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Una possibile strategia per rendere lo sviluppo di applicazioni più semplice e veloce consiste nel riutilizzare il codice. Ciò può essere ottenuto in maniera piuttosto banale copiando ed incollando il contenuto dei vari file. Quali sono i rischi associati a questa pratica? In che modo l'uso dell'ereditarietà permette di arginarli?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 21,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "code reuse"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5697,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Se ci si limita a copiare ed incollare il contenuto dei file, è possibile che si vada incontro a dei problemi; per esempio, è possibile andare a costruire una coda a partire dal codice della pila modificando soltanto la funzione estrai, mantenendo invece uguali le altri parti di codice. Però se in seguito si trovasse una migliore implementazione di pila, e si volesse andare a modificare non solo pila, ma anche coda, si dovrebbero modificare entrambi i codici. Possiamo invece definire Coda attraverso il comando extens (Pila), cambiando le funzioni che si vuole ed ereditando le altre; così facendo, se si va a modificare Pila, si modifica anche Coda.\r\nInoltre si potrebbe avere un conflitto di nomi, cioè avere funzioni con stessa firma (cioè nome della funzione e tipo degli argomenti in input); però queste due funzioni in realtà differiscono per il fatto che esse vivono in contesti diversi (Overriding, per esempio succede con la funzione estrai in Pila e Coda).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3689,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3908,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3563,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5741,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "L'ereditarietà è una delle caratteristiche fondamentali dell'OOP. Uno dei vantaggi derivanti dall'uso dell'ereditarietà è la maggiore facilità nella manutenzione del software.\r\nPer capire meglio questo concetto basta prendere come esempio un oggetto chiamato Persona, la quale avrà determinate caratteristiche che la descriveranno (nome, cognome), ossia le \"variabili di istanza\" e i \"metodi\".\r\nDefinendo due oggetti Studente e Insegnate, risulta naturale dire che questi possono ereditare le caratteristiche dell'oggetto Persona. Se successivamente si volesse aggiungere un ulteriore campo (per esempio \"età\" oppure \"professione\") all'oggetto Persona, grazie all'ereditarietà anche gli altri oggetti che ereditano le caratteristiche di Persona saranno \"aggiornate\" con questo nuovo campo.\r\nSenza il concetto di ereditarietà saremmo costretti ad aggiornare manualmente questo campo per ogni singolo oggetto, complicando la scrittura del codice e introducendo la possibilità di commettere errori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3568,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3906,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3687,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5719,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Copiando e incollando il contenuto dei files si rischia di avere problemi con l'assegnazione di variabili e la dichiarazione di metodi; si potrebbero inavvertitamente avere riferimenti a valori non più esistenti o errati. \r\nL'ereditarietà ci permette di fare riferimento ad una classe e a tutto il suo contenuto senza doverlo riscrivere per intero, in modo da ottenere un codice snello e probabilmente corretto (a meno di errori nella classe iniziale). Infatti, con l'ereditarietà una sottoclasse acquisisce automaticamente tutti i metodi e le variabili della superclasse, limitando così la possiblità di errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3566,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3688,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3907,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5646,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Avere più file che contengono lo stesso identico codice è da evitare per diversi motivi. Come prima cosa, è inefficiente la loro modifica e correzione; nel caso in cui si scopra di aver commesso errori nella scrittura del codice, bisognerebbe correggerlo in tutti i file contenenti quella porzione di programma, il che comporta una perdita di tempo e un'altra fonte di errori in quanto ci si potrebbe dimenticare di modificarli tutti. Senza dubbio l'uso dell'ereditarietà permette di arginare il problema: il codice per svolgere una determinata funzione è scritto solo una volta e viene richiamato dove è necessario. Quindi la sua modifica sarebbe immediata ed efficiente: senza perdite di tempo e senza correre il rischio di dimenticarsi di trasportare la modifica negli altri file. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3909,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3567,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3690,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5733,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 922,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un rischio che si corre copiando parti di codice per rendere il lavoro di sviluppo più breve, è quello di riportare in tutte le classi molti attributi e metodi che non sempre vengono sfruttati e che quindi porteranno il programma o l'applicazione ad \"appesantirsi\" per nessun motivo. Con l'ereditarietà, introdotta recentemente nelle ultime versioni di Java, questo problema viene risolto in modo efficace. Viene creata una classe \"base\" che contiene gli elementi comuni a tutte le classi, i quali verranno ereditati da ogni singola classe a cui poi si aggiungeranno gli attributi di uso singolo per ogni classe. Tutto questo porta ad un risparmio in termini di lunghezza e semplicità del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3565,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3692,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3911,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5758,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I rischi dell'utilizzare la strategia banale sono quelli dell'ononimia delle variabili o funzioni e dispendio di cicli macchina eccessivi, oltre alla modifica \"invololtaria\" di alcuni parametri. Attraverso l'ereditarietà invece i metodi che servono su più specifiche vengono implementati da superclassi a più sottoclassi, in modo da garantire un risparmio di risorse più efficiente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3564,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3910,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3691,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5341,
          "asker": {
            "courseId": 100,
            "askerId": 751,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza ci sono tra una pila e una coda in Java? Avendo una pila è possibile tramutarla in coda? Quali sono le differenze tra una pila in java e una pila in c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Coda"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5344,
          "asker": {
            "courseId": 100,
            "askerId": 917,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "spiega brevemente cosa è l'ereditarietà, come funziona e quali sono i vantaggi che comporta il suo utilizzo, citando qualche esempio di dove può essere vantaggioso usarla.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5404,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste il concetto di ereditarietà? Di che tipo possono essere le estensioni di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " metodi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5381,
          "asker": {
            "courseId": 100,
            "askerId": 762,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si intende con classe?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 23,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5749,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con classe si intende una struttura nominata omogenea dotata di variabili, valori e funzioni che la vanno a caratterizzare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3752,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3932,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3855,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3739,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3917,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5633,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Una classe è un insieme di metodi e attributi, un'entità in grado di contenere sia dati che funzioni che operano su essi. Essa costituisce sempre lo scheletro minimo di un codice scritto in Java. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3853,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3915,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3737,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3930,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3750,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5665,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Una classe è un tipo di dato user-defined, che può possedere variabili d'istanza e metodi; inoltre supporta i concetti di ereditarietà e polimorfismo, l'overloading e l'overriding, che stanno alla base della programmazione ad oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3735,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3748,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3851,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3913,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3928,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5752,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "nel paradigma della programmazione a oggetti, una classe è una categoria, ovvero è un modello di astrazione delle caratteristiche comuni ad alcuni oggetti. questa idea in java è implementata tramite la definizione di variabili di istanza (caratteristiche intrinseche dell'oggetto) e metodi (funzioni che rappresentano delle azioni in senso lato). Ad esempio, la classe dei rettangoli ha come variabili base e altezza, mentre ogni oggetto rettangolo avrà un proprio valore per base e un proprio valore per altezza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3854,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3916,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3751,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3931,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3738,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5641,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 873,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una classe in java è un tipo di dato, che può essere predefinito, come ad esempio String, tipo caratterizzante le stringhe, oppure definito dall'utente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3852,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3736,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3914,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3929,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3749,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5683,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Una classe e' un costrutto di particolari linguaggi di programmazione usato come modello per creare oggetti con attributi (dati che descrivono la classe) e metodi(funzioni che modificano i valori degli attributi o producono effetti collaterali). La classe permette di definire qualsiasi tipo di oggetto, individuando coloro che ne condividono comportamenti e caratteristiche simili e permettendo di raggiungere un livello di astrazione molto elevato. Una volta definita una classe, e' possibile istanziare tanti oggetti che hanno lo stesso modello della classe di riferimento, indipendenti tra di loro (cioe' modificare un attributo di una variabile riferita ad un oggetto che ha il modello di una determinata classe, non modifica gli attributi di una variabile riferita ad un oggeto che ha il modello della stessa classe), dato che hanno diverse locazioni in memoria. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3850,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3747,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3912,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3927,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3734,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5390,
          "asker": {
            "courseId": 100,
            "askerId": 849,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il ruolo del Garbage Collector? In quali casi interviene?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage"
            },
            {
              "keyword": " collector"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5382,
          "asker": {
            "courseId": 100,
            "askerId": 910,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con il termine override? Quando é utile utilizzarlo?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "override"
            },
            {
              "keyword": " ereditarietá"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5675,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'overriding è la ridefinizione in una sottoclasse di un metodo ereditato da una superclasse. In Java si richiede che i due metodi abbiano la stessa firma e che il metodo della superclasse non sia privato o final. La scelta di quale metodo sarà effettivamente invocato è effettuata a run-time (in esecuzione) in base al tipo dinamico del riferimento (binding dinamico).\r\nE' utile con i metodi toString() e equals() della classe Object in modo da poterli ridefinire per i propri scopi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3615,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3618,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3621,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3807,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5620,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 876,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il termine override consiste nel modificare un metodo ereditato da un padre in un'unità figlio. è utile utilizzarlo quando dobbiamo creare un'entità figlio che differenzia dalla classe padre di uno o pochi metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3622,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3616,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3619,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3808,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5748,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Con il termire override si intende una vera e propria riscrittura di un certo metodo di una classe che abbiamo ereditato(Le nostre classi sono in un certo senso la estensione di classe object,quindi il concetto vale anche per i metodi del linguaggio). E' utile in quanto con l'override, è possibile ridefinire un metodo di una classe più generale adattandolo così alla classe più specialista mantenendo comunque una coerenza per quanto riguarda la semantica del metodo che avrà lo stesso identico nome. Come esempio possiamo prendere il metodo di stampa println il quale,una volta ridefinito per una specifica classe mantiene tutte le stampe pulite. In un certo senso si effetua override anche con l'uso delle classi astratte e i metodi virtuali, ergo per quanto riguarda la OOP e la gestione della gerarchia,override e overload sono due concetti basilari.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3806,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3617,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3620,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3614,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5336,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega a parole tue cosa fa il garbage collection.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memory management"
            },
            {
              "keyword": "system.gc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5397,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Garbage collector: che cos'è, a cosa serve e perché Java ne ha bisogno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage"
            },
            {
              "keyword": "Collector"
            },
            {
              "keyword": "Java"
            },
            {
              "keyword": "Memory"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5375,
          "asker": {
            "courseId": 100,
            "askerId": 876,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella gestione della coda non vengono utilizzate le variabili primo e ultimo elemento per tenere traccia dell'indice?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "parole"
            },
            {
              "keyword": "chiave"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5422,
          "asker": {
            "courseId": 100,
            "askerId": 759,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il garbage collector ? Quali sono i suoi compiti e come avviene ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage collector"
            },
            {
              "keyword": " funzionalità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5353,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Posso creare una classe estensione di un'altra classe che era già a sua volta una estensione?\r\nSe sì, c'è un limite a quante sotto estensioni posso fare?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 22,
          "totalRelevanceLevel": 22,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": "estensione"
            },
            {
              "keyword": "limite"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5684,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 848,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì, è possibile creare classi estensioni di altre classi che erano a loro volta delle estensioni tramite il comando \"extends\". \r\nNon esistono limiti al numero di sottoclassi che si possono generare, le quali avranno tutte, però, attributi, operazioni e associazioni comuni alle proprie superclassi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3698,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3975,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3951,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4086,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5677,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 917,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "si, posso creare una sottoclasse di una sottoclasse.\r\nno, non c'è un limite alle sotto estensioni che posso fare",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3693,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3952,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3976,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4087,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5621,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Puoi creare una catena infinita di estensioni, il problema e quando devi andare a cercare un metodo in particolare devi stare attento a quale classe lo ha sovrascritto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3974,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3696,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3950,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4085,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5711,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, si può creare una classe estensione di un'altra classe che era già a sua volta una estensione, ed il limite è dato semplicemente dalla memoria dispoinibile del calcolatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3947,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3971,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3697,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4082,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5744,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 853,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Si, è possibile creare una classe estensione di un'altra classe che era a sua volta una estensione. Non dovrebbero esserci limiti alle sottoclassi, ma un uso massiccio di esse può avere qualche controindicazione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3972,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3948,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4083,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3694,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5670,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, basta modificare i parametri o gli elementi della classe di partenza,  quanto al limite delle estensioni dovrebbe essere limitato solo dalla memoria della macchina",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3949,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3695,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3973,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4084,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5371,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quanto conviene effetivamente affidarsi al garbage collection? \r\nè meglio che questo processo lo gestica autonomamente la macchina o è preferibile sia l'uomo a controllarne il procedimento?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage"
            },
            {
              "keyword": " Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5330,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi introdotti dal costrutto extends (ovvero dall'ereditarietà)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "extends"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5346,
          "asker": {
            "courseId": 100,
            "askerId": 434,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè Java non permette di usare i puntatori \"direttamente\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5305,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa e' in java la parola chiave extends,  perche' e' cosi importante? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Extends"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": "  oggetto"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5421,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il metodo distruttore 'finalize()' e come possiamo essere certi che il sistema lo chiami effettivamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "distruttore"
            },
            {
              "keyword": " finalize"
            },
            {
              "keyword": " memory management"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5324,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può affermare che Java non ha i puntatori? Perché?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": "puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5414,
          "asker": {
            "courseId": 100,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in Java non esiste l'aritmetica dei puntatori ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5349,
          "asker": {
            "courseId": 100,
            "askerId": 809,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il garbage collection?  Quando viene eseguito?  Come può essere richiesta dal programmatore la sua esecuzione? Ed essa viene sempre eseguita?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage"
            },
            {
              "keyword": "collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5406,
          "asker": {
            "courseId": 100,
            "askerId": 772,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Esistono i puntatori in java ? e la loro logica? nel caso non esistessero i puntatori, da cosa potrebbero essere \"sostituiti\" in java ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " logica dei puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5313,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Se di un metodo f faccio overloading non e` detto che ci siano piu` \"signatures\" (firme) di metodi legati al nome?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "metodo"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5709,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 852,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Per creare situazioni di overloading bisogna creare metodi con lo stesso nome ma con paeametri differenti. \r\nIl compilatore andrà poi a riconoscere I vari metodi grazie al nome al valore restituito e ai vari parametri presenti nella firma.\r\nQuindi due o più metodi devo differire fra loro per una di queste 3 cose.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3884,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3700,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3792,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3578,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3979,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5704,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 913,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Una firma dipende dal nome della funzione e dai suoi parametri. L'Overloading quindi genera sempre una funzione con firma diversa da quella della funzione base. Se la nuova funzione ha la stessa firma, allora si sta compiendo un overriding, che si limita a sostituire la funzione stessa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3885,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3793,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3701,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3980,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3579,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5649,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 907,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Falso, in quanto se faccio un overloading di un metodo ottengo sicuramente più firme.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3702,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3794,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3886,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3977,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3576,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5731,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 901,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Overloading significa \"sovraccaricare\" ovvero definire più versioni di un metodo, utilizzando lo stesso identificatore ma una firma diversa.\r\nPer firma di un metodo si intede il numero e/o il tipo di argomenti nella dichiarazione. Sulla base degli argomenti effettivamente passati alla routine, verrà riconosciuta la firma e richiamato il metodo corretto.È quindi necessario,se effettuiamo un overloading, creare firme differenti.\r\nL?overloading viene spesso usato nella definizione del costruttore di una classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3978,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3699,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3577,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3791,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3883,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5335,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è consigliabile l'utilizzo di \"extends\" (es.: public class Coda extends Pila) invece di utilizzare un semplice \"copia e incolla\" della parte di codice della classe che vogliamo utilizzare? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "extends"
            },
            {
              "keyword": " classi"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5380,
          "asker": {
            "courseId": 100,
            "askerId": 784,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "è corretto affermare che java non ha i puntatori? perché?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5408,
          "asker": {
            "courseId": 100,
            "askerId": 882,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "qual è la differenza tra Java e C++ riguardo ai puntatori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5340,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze fra una pila e una coda? Com'è possibile passare dalla prima alla seconda?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " coda"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5360,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'implementazione della funzione \"estrai\" per la coda (lezione 6, slide 9) abbiamo adottato la seguente tecnica: restituisci l'ultimo elemento e sposta tutti gli altri \"in giù\" di una posizione. Questo metodo è poco efficiente, ma ci sono dei buoni motivi per scegliere questo tipo di implementazione: quali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Coda"
            },
            {
              "keyword": " estrai"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5385,
          "asker": {
            "courseId": 100,
            "askerId": 811,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché Java non implementa l'aritmetica dei puntatori, che è così utilizzata in C/C++?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "aritmetica"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5634,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Java non implementa l'aritmetica dei puntatori per semplificare le operazioni di coding ed evitare, così facendo, errori comuni relativi all'uso dei puntatori come memory leaks, assai frequenti in altri linguaggi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3670,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3882,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3761,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3781,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3586,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3673,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5626,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 897,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Java non permette di manipolare i puntatori perchè una gestione esplicita dei puntatori provoca problemi quando ad esempio si libera in modo scorretto una zona di memoria e l?aritmetica dei puntatori può provocare riferimenti a zone di memoria non valide. Quindi anche se Java non utilizza esplicitamente i puntatori, esso si basa comunque su questi. Essenzialmente non si implementano i puntatori per evitare comportamenti dannosi da parte dei programmi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3668,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3779,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3880,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3671,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3584,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3759,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5698,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'utilizzo dell'aritmetica dei puntatori causa il maggior numero di errori di programmazione nei programmi scritti in C/C++.\r\nIn Java i dati vengono utilizzati sotto forma di variabili di oggetti o tipi primitivi. Il paesaggio di parametri avviene unicamente per valore, nel caso dei tipi primitivi, e per copia della referenza, nel caso degli oggetti. In questo modo non è necessario utilizzare direttamente i puntatori e la loro aritmetica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3585,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3669,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3760,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3780,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3672,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3881,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5368,
          "asker": {
            "courseId": 100,
            "askerId": 850,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi e opportuno che il garbage collector sia chiamato manualmente dal programmatore con System.gc() ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage"
            },
            {
              "keyword": " collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5378,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra l'attributo public e l'attributo private in Java? Quali potrebbero essere i vantaggi nell'utilizzare private? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "public"
            },
            {
              "keyword": " private"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5403,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In che senso Java non ha i puntatori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " puntatore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5328,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra l'overloading e l'overriding? Per quali scopi questi \"meccanismi\" sono presenti in alcuni linguaggi di programmazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5386,
          "asker": {
            "courseId": 100,
            "askerId": 756,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un \"costruttore\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " costruttore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5396,
          "asker": {
            "courseId": 100,
            "askerId": 833,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza principale tra struct e class?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "public"
            },
            {
              "keyword": " class"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5428,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "A livello progettuale, qual è la profonda differenza tra una \"programmazione funzionale\" (per esempio C) e una \"programmazione ad oggetti\" (per esempio java)? E quali sono i vantaggi principali che si hanno da quest'ultima?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 18,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "oggetti"
            },
            {
              "keyword": " funzioni"
            },
            {
              "keyword": " progettazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5712,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Inanzitutto C non è un linguaggio di programazione fuzionale ma strutturale. \r\n(penso sia stato fatto un errore a porre la domanda quindi facci finta che invece di \"funzionele\" ci sia sritto \"strotturale\").\r\nI linguaggi strutturali sono basati sulle variabili, le funzioni e i puntatori. Mentre i linguaggi orientati ad oggetti sono basati su un tipo di dato astratto (oggetto) che è composto da attributi (in sostanza variabili) e metodi (in sostanza funzioni), i puntatori spariscono dai compiti del programmatore. \r\nQuando si comincia a programmare in un linguaggio traditional (imperative e strotturale) ci si chiede che istruzzioni devo usare per crearlo, mentre nei linguaggi orientati ad oggetti ci si domanda in che mondo siamo, chi sono gli attori e cosa fanno. \r\nI principali vantaggi offerti dalla programmazione ad oggetti sono: astrazione, incapsulamento, erediterietà, polimorfismo e riuso del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4038,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3940,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3590,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3560,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3965,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3600,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5662,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "(Suppongo che chi ha posto la domanda intendesse \"programmazione strutturata\" o \"procedurale\", anziché \"funzionale\").\r\nUn programma ad oggetti viene pensato \"oggetti che compiono azioni ed interagiscono\", anziché come \"flusso di azioni da compiere\".\r\nI vantaggi sono molti: innanzitutto permette di avere un più alto livello di astrazione; le classi possono essere pensate come nuovi tipi di dato definiti dall'utente, che vanno ad affiancarsi a quelli predefiniti.\r\nInoltre un linguaggio che agevola la creazione di oggetti permette di evitare l'utilizzo esplicito dei puntatori, ed è quindi di fatto un linguaggio di più alto livello: il programmatore è in larga parte sollevato dall'incarico della gestione della memoria e può dedicarsi completamente alla progettazione del software, distanziandosi dal suo rapporto con l'hardware.\r\nAltri vantaggi: è più facile \"impacchettare\" il codeice in classi, e quindi riutilizzarlo; migliora anche la leggibilità del codice; si evita lo \"spaghetti coding\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4037,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3588,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3964,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3938,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3598,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3558,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5693,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Nella programmazione imperativa si hanno essenzialmente dei dati e un programma é una sequenza di operazioni che agiscono su di essi, mentre la programmazione ad oggetti permette di definire degli oggetti che hanno un comportamento(metodi) e uno stato(attributi). I principali vantaggi della programmazione ad oggetti sono:\r\n - information hiding: viene  mostrato solo ció che é neccessario e le altre informazioni vengono nascoste\r\n - ereditarietá: degli oggetti, e quindi le classi, possono estenderne altri, in questo modo si rende più chiaro il legame tra di essi e si ha la possibilità di introdurre nella classe figlia solamente ciò che cambia rispetto alla classe madre e ciò che invece viene aggiunto(metodi e attributi); questo permette di riutilizzare del codice giá implementato nella classe madre\r\n - polimorfismo: il sistema é in grado di riconoscere quale metodo chiamare in base all'oggetto sul quale viene chiamato quando abbiamo più metodi con lo stesso nome in classi differenti",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3937,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3587,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3562,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3963,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3597,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4036,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5696,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Da una parte la programmazione funzionale (ad esempio ML) si basa sulla progettazione di funzioni, in particolare ricorsive, in cui non esistono effetti collaterali. Questi side effects consistono nella modifica di valori o stati esterni allo scope, come ad esempio la modifica di una variabile o l'i/o su file.\r\nAl contrario la programmazione ad oggetti tipica di java sfrutta ampiamente questi effetti collaterali sia per l'interazione tra chiamante e chiamato (resa possibile dalla presenza di classi e dell'ereditarietá), che per l'interazione tra programmi ed utente (interfacce grafiche) e per la modifica di valori o file in memoria. Inoltre un programma scritto in Java è basato su un insieme di oggetti (o istanze) con proprietà e metodi (attributi e procedure): ciò permette una precisa astrazione del mondo reale, in cui vari oggetti interagiscono tramite scambio di messaggi.\r\nLa programmazione imperativa è invece un altra categoria diversa, e C è un esempio di questo paradigma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3939,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4035,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3561,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3599,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3962,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3589,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5700,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Anzitutto puntualizzerei che in C non si ha una programmazione funzionale, ma una programmazione imperativa, do per scontato che si volesse intendere questo, dato che la programmazione funzionale non è trattata da questo modulo del corso.\r\nLa programmazione ad oggetti, ha dei vantaggi, rispetto a quella imperativa:\r\n- la possibilità di creare appunto \"oggetti\" tramite l'utilizzo di classi;\r\n- raggiungere un livello di astrazione non possibile con l'imperativa;\r\n- il riutilizzo del codice (anche sfruttando l'ereditarietà tra classi);\r\n- facilita la scomposizione di un problema in varie parti;\r\nIn generale permette di affrontare in modo adeguato problemi che tramite un approccio imperativo sarebbero ostici, o talvolta impossibili da affrontare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3601,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3966,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3941,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3559,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4039,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3591,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5651,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Nella programmazione strutturata classica si hanno due enti distinti: funzioni e \"dati\". Le prime operano sui secondi per produrre altri dati.\r\nNella programmazione OOP questa distinzione viene a mancare e nasce il concetto di oggetto: un ente che contiene in sé i dati e i metodi che sono in grado di modificare il suo stato. Idealmente la programmazione avviene facendo interagire oggetti diversi solo attraverso messaggi (chiamate ai metodi). Lo stato dei vari oggetti viene nascosto e l'unica interfaccia sono i possibili messaggi. Inoltre nell'oop ereditaria gli oggetti risiedono in una gerarchia: è possibile ereditare da un oggetto per estenderne e/o modificarne il behavior.\r\nI vantaggi principali sono quindi il riutilizzo del codice, l'implementation hiding, l'estensione e la specializzazione del behavior.\r\nImportante è l'implementation hiding, fondamentale per il principio di Parna: ogni punto del codice deve poter vedere esattamente quello di cui necessita, né più, né meno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3557,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3602,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3942,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4034,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3592,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3961,
                  "rater": {
                    "raterId": 749,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5350,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java come è possibile avere dei puntatori? Cosa significa che il linguaggio Java defice dell'aritmetica dei puntatori, cosa significa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " aritmetica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5419,
          "asker": {
            "courseId": 100,
            "askerId": 853,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il Garbage Collection e quale costrutto devo utilizzare per essere sicuro che esso venga eseguito sicuramente prima della fine del programma? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Garbage Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5356,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste l'ereditarietà ? Che vantaggi può apportare ad un programma il suo utilizzo ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà "
            },
            {
              "keyword": "codice"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5332,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In che cosa consistono l'overriding e l'overloading?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5338,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende, in Java, con il termine \"ereditarietà delle classi\"?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "classi"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5636,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "L'ereditarietà delle classi è un concetto fondamentale nel paradigma di programazione ad oggetti. L'ereditarietà è una relazione tra classi stabilità dal linguaggio o dal programmatore. Siano due classi A e B. Se la classe B eredità dalla classe A, la B si dice sottoclasse e la A  si dice la superclasse. Che la classe B eredità dalla classe A significa che la B riutilizza codice già implementato in A, facendo poi programmazione per differenza, quindi estensioni in parti in cui vogliamo individualizzare la B. Le estensioni includono sia quelli strutturali (aggiunta di variabili d'istanza) sia comportamentali (aggiunta di nuovi metodi o modifica di quelli già esistenti). E in caso di cambiamenti nel codice della superclasse, quelli vengono automaticamente riflessi anche nel codice della sottoclasse. Quindi un grande vantaggio dell'ereditarietà è la riutilizzabilità del codice, quindi l'incremento della produttività in programmazione ad oggetti.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3553,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3556,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3762,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4031,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4070,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5730,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per ereditarietà si intende la possibilità di creare classi che ereditano le caratteristiche base di altre classi già definite.\r\nIn questo modo si possono aggiungere (o modificare) metodi e variabili senza alterare la superclasse, oppure modificare la superclasse per far si che tutte le sottoclassi ricevano in eredità la modifica.\r\nPer esempio:\r\npublic class Point {\r\n   public int x=0;\r\n   public int y=0;\r\n   Point(int x, int y){\r\n      this.x=x;\r\n      this.y=y;\r\n   }\r\n}\r\n\r\npublic class Point3D extends Point{\r\n   public int z=0;\r\n   Point3D(int x, int y, int z){\r\n      super(x,y);\r\n      this.z=z;\r\n   }\r\n}\r\n\r\nLa classe Point3D aggiunge una variabile alla classe Point in modo tale da poter rappresentare un punto in uno spazio tridimensionale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3763,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3554,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3551,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4072,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4033,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5745,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 831,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con il termine \"ereditarietà delle classi\" si intende quel meccanismo, tipico della programmazione OOP, che permette ad una classe B di ereditare (ottenere) gli stessi attributi e metodi di un'altra classe A. B viene detta sottoclasse (B estende A) e A superclasse. In altre parole, B ha tutte le funzionalità di A ma in più aggiunge qualche funzionalità, come nuovi attributi o nuovi metodi o fa override di alcuni o tutti i metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3555,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3764,
                  "rater": {
                    "raterId": 859,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3552,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4071,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4032,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5309,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste la garbage collection e perché è stata implementata in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage collection"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5333,
          "asker": {
            "courseId": 100,
            "askerId": 764,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Per cosa viene utilizzata la GC e cosa viene invocato assieme a lei e, per quale motivo vengono utilizzati entrambi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "domanda"
            },
            {
              "keyword": "GC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5379,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere come viene gestita la memoria (dinamica) in java.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Lezione6"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " gc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5413,
          "asker": {
            "courseId": 100,
            "askerId": 900,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale potrebbe essere un modo facile e rapido per monitorare il consumo di memoria di un programma? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5357,
          "asker": {
            "courseId": 100,
            "askerId": 893,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "I linguaggi C++ e Java prevedono nella definizione delle classi i metodi costruttore e distruttore. Quando vengono invocati questi particolari metodi nei due linguaggi? In quali casi, in Java, è necessario utilizzare System.runFinalization?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": "distruttore"
            },
            {
              "keyword": "garbagecollector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5387,
          "asker": {
            "courseId": 100,
            "askerId": 923,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzione del garbage collector e come agisce?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " garbage collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5424,
          "asker": {
            "courseId": 100,
            "askerId": 904,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono viste le classi per java rispetto all' utilizzo che viene fatto di loro in c++ ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "c++"
            },
            {
              "keyword": "java"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5401,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "E' vero che java non usa i puntatori? Che cosa è l'aritmetica dei puntatori?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " aritmetica"
            },
            {
              "keyword": " identificatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5643,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "L'utilizzo di puntatori é nascosto all'utente: infatti essi sono presenti anche se formalmente non abbiamo più bisogno del simbolo * [sostituito col simbolo \"[]\" in caso di SOLA creazione dell' array]e nemmeno dello zucchero sintattico \"->\"[cosa che in Java viene sostituito con il punto]. Tutti gli oggetti vengono salvati in heap ed è per questo che quando facciamo int p[]=new int[3] viene creata int p in stack e da qui la handle all'array in heap. La cosa che Java non ci permette di manovrare e' l'aritmetica dei puntatori, ossia il passare da un indirizzo di memoria ad un altro(manovrando quindi puntatori) tramite somme e sottrazioni.(es. se int v[] e' un array non mi permette di fare v+10 oppure v--).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4058,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3721,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3864,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5754,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Java implementa un concetto analogo a quello dei puntatori (detti reference) ma non esplicitamente come nel C++ e con funzionalità molto più limitate, vengono cioè utilizzati dal linguaggio ma in modo indiretto e indipendente dallo sviluppatore.\r\nIn Java, per esempio, non è possibile decidere il passaggio di parametri, se sono tipi primitivi vengono copiati mentre se sono oggetti vengono sempre passati per riferimento.\r\nL?aritmetica dei puntatori è un insieme di operazioni aritmetiche applicabili su valori di tipo puntatore. Le più importanti sono: differenza tra puntatori e somma/sottrazione tra puntatore e intero. Tali operazioni hanno lo scopo di conservare un alto livello di flessibilità, permettendo l?accesso a dati omogenei in posizioni contigue della memoria, utili per implementazioni come l?array. Queste operazioni sono tipiche di C e C++ mentre sono assenti in Java, questo per evitare i frequenti problemi di controllo che ne derivano.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3720,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3863,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4059,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5699,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Java non usa i puntatori per evitare (potenziali) catastrofi provocate dalla gestione esplicita degli stessi per cui è possibile far riferimento a zone di memoria errate o liberarle in modo scorretto (perdita handle) o non liberarle affatto (memory leak), ma solo apparentemente perché la dichiarazione di un oggetto è in realtà un riferimento, seguito da un?esplicita inizializzazione ES:\r\n Cartoon pluto, paperino;\r\n pluto = new Cartoon();\r\n paperino = pluto;\r\ne il punto per accedere a campi/metodi un riferimento indiretto, ES:\r\nstudente.nome\r\nL'aritmetica dei puntatori è un insieme di operazioni aritmetiche sulle variabili di tipo puntatore con lo scopo di accedere agevolemente a zone di memoria vicine e dello stesso tipo (array) ES: somma/differenza con interi, autoincremento/autodecremento.\r\nI puntatori scorrono di sizeof(tipo) bit alla volta ES: p è un puntatore a intero (int *p) e vale 4C20, la dimensione di un int è 2 byte, p+1 vale 4C22, p+2 vale 4C24, p+n vale 4C20+n*sizeof(int).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3723,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4061,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3866,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5639,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "I puntatori in java in realtà sono presenti [Point punto = new Point(15,15);]. Infatti come possiamo notare l'identificatore \"punto\" rappresenta un puntatore. Ciò che non troviamo in java è l'aritmetica dei puntatori, ciò che non ci permette di spostarci nella memoria, infatti in java io posso allocare dinamicamente esclusivamente nella HEAP.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4060,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3722,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3865,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5426,
          "asker": {
            "courseId": 100,
            "askerId": 873,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un costruttore e in che modo è correlato alle classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Costruttore"
            },
            {
              "keyword": " Classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5416,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè l'ereditarietà è un meccanismo molto utile nella programmazione OOP?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " oop"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5355,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In un programma Java è possibile avere più Pile? Se sì, in quali casi?\r\nE' possibile che la stessa funzione 'estrai' venga richiamata dalle diverse Pile senza scrivere ogni volta il codice di questa funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pile"
            },
            {
              "keyword": " Funzione estrai"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5307,
          "asker": {
            "courseId": 100,
            "askerId": 844,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste l'overriding di un metodo, e come viene implementato in java? Inoltre perché é particolarmente utile se utilizzato in presenza di una classe \"estesa\", ossia che utilizza la parola chiave \"extends\"?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": "extends"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5746,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'overriding di un metodo è la \"riscrittura\" che ridefinisce un metodo ereditato da una classe o da una superclasse, esso non può quindi esistere senza l'ereditarietà. E' utile in presenza di una classe estesa (es.: public class domanda extends risposta {...}) poiché è il termine Object Oriented che vine utilizzato per descrivere la caratteristica che hanno le sottoclassi di una superclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3630,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4022,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3857,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5681,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "L'overriding è la ridefinizione di una funzione di una sottoclasse, mantenendone comunque invariata la firma. E' utile nelle classi \"estese\" perché talvolta esse necessitano della ridefinizione di alcune funzioni. Prendiamo come esempio la definizione di una classe Punto: essa avrà due campi, uno che definisce la coordinata x e l'altro la coordinata y. Ci sarà un metodo chiamato ToString che restituirà una stringa nel formato \"(x,y)\". Se, però, andiamo a definire una classe derivata da Punto, per esempio PuntoZ, che oltre alle coordinate x e y ne ha una terza (la coordinata z), essa necessiterà di un overriding della funzione ToString, che non dovrà più restituire una stringa nel formato \"(x,y)\", bensì nel formato \"(x,y,z)\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3856,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3629,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 4023,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5657,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 802,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con overriding si intende la riscrittura di un metodo padre, ciò implica l'ereditarietà. È possibile ridefinire un metodo di una classe più generale adattandolo ad una classe più specifica mantenendo coerenza per la semantica del metodo, che manterrà lo stesso nome. Extends è il termine utilizzato per specificare da quale classe più generica si stiano prendendo le informazioni, appunto da estendere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3858,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4024,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3631,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5319,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Che funzione ha il garbage collector in Java? Come si implementa la funzione del GB in C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "garbage"
            },
            {
              "keyword": " collector"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5325,
          "asker": {
            "courseId": 100,
            "askerId": 896,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "A differenza del c++ e altri linguaggi simili, Java non permette al programmatore di gestire direttamente gli indirizzi in memoria, togliendogli la possibilità di utilizzare puntatori. L' allocazione nella memoria heap di nuove istanze di una classe è un' eccezione a questa regola - in che modo? \r\nLa responsabilità di deallocazione è sostituita dal garbage-collection eseguito dalla macchina virtuale di Java. Che implicazioni ha questo sulle prestazioni e sull' affidabilità dei programmi scritti in Java?",
          "totalDifficultyLevel": 21,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " allocazione"
            },
            {
              "keyword": " garbage-collection"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5707,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'allocazione di nuove istanze di una classe è un eccezione alla regola perchè ,sebbene implicitamente, vi è un effettivo utilizzo dei puntatori.\r\nLe implicazioni che si hanno sulle prestazioni e sull'affidabilità dei programmi scritti in Java con l'introduzione del garbage collector sono che il programma è meno efficiente ed affidabile ,per il fatto che\r\nlui \"decide\" in base alla memoria che serve al programma di liberarla che  è meno efficiente della deallocazione da parte del programmatore stesso  che è conscio della quantità di valori dinamici che sta usando e di conseguenza sa quando è necessario deallocarle",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3996,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3811,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5642,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "In Java i puntatori ci sono ma vengono nascosti al programmatore per far si che il codice sia robusto, che é una delle principali caratteristiche di Java. Per quanto riguarda i tipi primitivi come int e float java non usa puntatori.Come visto a lezione nell'esempio di passaggi di parametri a una funzione, questi tipi vengono passati per valore. Mentre per quanto riguarda le classi, quando viene instanziato un oggetto di una classe, java lo alloca all'interno dello heap e reslstituisce il puntatore a quell'oggetto, ma tutto ciò viene nascosto al programmatore. Esempio : \r\nObject obj = new Object(); l'operatore new torna il puntatore all'oggetto obj appena instanziato e allocato all'interno dello heap. Ma tutto ciò viene nascosto al programmatore.\r\n\r\n\" Garbage-collector\" non collection, fa si che non vengano lasciati memory leak perchè se l'oggetto non è dereferenziato, viene deallocato. Ma in quanto alle prestazioni, si perde di velocità e il programma risulta più pesante.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3997,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3810,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5742,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "In java i puntatori non sono stati completamente rimossi, bensì mascherati e \"nascosti\" al programmatore. Vediamo un esempio.\r\nQuando creiamo una nuova istanza di classe, utilizzando l'operatore new, alla fine del costruttore viene ritornato un riferimento (ovvero un indirizzo di memoria) all'oggetto appena creato. Esso verrà poi assegnato ad una variabile. (notiamo la simiglianza). Successivamente, per accedere ai campi e ai metodi di tale oggetto si utilizzerà il \".\" (es variabile.nome (ricorda molto i puntatori)).\r\nIl meccanismo del garbage-collector grazie allo sviluppo dei nuovi processori (multithreading) impatta in maniera molto meno pesante rispetto al passato. Non molti anni fa, infatti, in alcuni momenti l'esecuzione del programma veniva bloccata e sospesa temporaneamente per pulire la memoria. \r\nUna pecca tutt'ora presente però è il fatto che se la memoria si sta esaurendo noi non possiamo far nulla per pulire ciò che non ci serve più e dobbiamo aspettare il sistema.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3812,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3998,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5648,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "È un'eccezione perchè effettivamente quando allochiamo un oggetto in HEAP viene restituito un puntatore alla variabile che useremo per riferirci ad esso. Anche se poi ci riferiremo all'oggetto direttamente con la variabile senza dover dereferenziare.\r\nIl garbage-collection si occupa di de allocare tutti gli oggetti non più referenziati. Per farlo in ogni oggetto esiste un contatore di referenze. Ciò permette al programmatore di non doversi preoccupare di deallocare gli oggetti manualmente. Però il gc potrebbe non essere chiamato in caso di terminazione anomala del programma. Quindi, se si sono implementati dei distruttori che eseguono operazioni particolari bisogna invocare il System.runFinalization() dopo il gc. In questo modo si evitano i memory leak, però viene appesantito il carico di lavoro del sietema",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3809,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3995,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5685,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili che contengono le classi sono in realtà puntatori all'heap, il quale contiene veramente l'oggetto puntato.\r\nLa deallocazione tramite garbage-collector rende i programmi più semplici da scrivere, perchè il programmatore non deve più proccuparsi di liberare la memoria. Il garbage collector è molto \"pesante\" e richiede che tutti i processi vengano fermati quando esegue, quindi non viene invocato ogni volta che si cancella la reference a qualcosa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3813,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3999,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5348,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze nella creazione di un array e nel passaggio di parametri tra C++ e Java ?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": "parametri"
            },
            {
              "keyword": "java"
            },
            {
              "keyword": "c++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5673,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "In Java, quando definiamo un array, non è necessario specificare la sua dimensione (String[] strings), soltanto durante l'allocazione siamo obbligati a definire lo spazio desiderato ('strings = new String[3]' 'String[] strings = {'a'}'). In C++, questo non è possibile, infatti la dimensione da riservare all'array deve essere definita già nella dichiarazione (modo esplicito, 'int array[3]', modo implicito 'int array[] = {1}'). \r\nInoltre, in C++ è possibile manipolare gli array ricorrendo all'algebra dei puntatori, che non è presente in Java. \r\nPer quanto riguarda il passaggio di parametri, in C++ è possibile farlo in due modi: per valore o per riferimento (attraverso la keyword &). In C++ si può decidere liberamente quale dei due metodi usare in \r\nbase alla situazione. In Java invece, in caso l'elemento sia un tipo derivato, verrà passato\r\nper riferimento, mentre, in caso esso sia un tipo primitivo, verrà passato per valore. \r\nIl programmatore Java non ha controllo su questo fatto. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3542,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3744,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3639,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5747,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In C++ quando si dichiara una matrice la si dichiara esplicitamente viene subito allocata.\r\nEsempio: int A[10]; (array di lunghezza 10), A[10]=5; (5 è il valore in posizione 0, il primo).\r\nIn Java invece quando si dichiara una matrice vuol dire che stai dichiarando un puntatore di array, ma l'array stesso non viene allocato automaticamente fino a quando non si utilizza il \"new\".\r\nEsempio: int [] A; (A è un puntatore ad un array), A = new int [10]; (A punta ad un array di lunghezza 10), A [0]=5; (5 è l'array in posizione 0).\r\n\r\nInvece per il passaggio di parametri la differenza è che in C++ si passa solitamente per valore (es. ini x; x=5;) e sono variabili di tipo primitivi; Java tratta le variabili collegati ad oggetti come riferimento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3540,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3745,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3640,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5725,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 883,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In C++ è possibile dichiarare array staticamente e dinamicamente, mentre in Java si può fare solo dinamicamente, inoltre non è necessario dichiarare subito la lunghezza dell'array. Per quanto riguarda il passaggio di parametri, in Java non è possibile passare i parametri per puntatore, poiché sono gestiti dalla JVM. Sia in Java che in C++ gli array possono venir passati per riferimento, sebbene non ci sia l'aritmetica dei puntatori in Java.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3641,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3746,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3541,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5376,
          "asker": {
            "courseId": 100,
            "askerId": 912,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, come si può implementare una Coda conoscendo l'implementazione della Pila?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Coda"
            },
            {
              "keyword": " Pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5329,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le analogie trovate nel passaggio dalla pila in c++ alla pila in java? Come si può arrivare da questo al concetto di classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "c++"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " pila"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5391,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'assert \"this\"?\r\nCome viene usato? È ritenuto necessario?\r\nIn Java, con quale sintassi si accede alle istanze di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "assert"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5383,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'ereditarietà e quanti tipi di estensioni ci sono a riguardo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "estesioni"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5339,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Una caratteristica fondamentale di Java è la presenza del Garbage Collection. Spiegare come funziona, in particolare quando interviene e in che modo riconosce gli oggetti da eliminare.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage Collection"
            },
            {
              "keyword": " Funzionamento"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5398,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché c++ non è implementata la Garbage Collection? In particolare, dal punto di vista pratico, con quale elemento entrerebbe in contrasto e in che modo?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "garbage collection"
            },
            {
              "keyword": " puntatori"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5660,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Uno dei principi su cui si basa il C++ è quello di permettere di creare programmi veloci ed efficienti, lasciando molta libertà (ma anche responsabilità) al programmatore. Perciò, la presenza di un Garbage Collection di per sé sarebbe in conflitto con tale idea: se in contemporanea all'esecuzione di un programma il computer deve anche occuparsi del controllo e l'eventuale pulizia della memoria i processi verrebbero ovviamente rallentati.\r\n\r\nDal punto di vista pratico, un garbage collection potrebbe entrare facilmente in conflitto con l'aritmetica dei puntatori.\r\nUn semplice esempio è il seguente: pensiamo ad un array (che in C/C++ non è altro che un puntatore). Il primo elemento sarebbe \"puntato\" da qualcuno e perciò non verrebbe eliminato, ma come farebbe il GC a capire se anche gli elementi successivi appartengono all'array o se sono memoria allocata non più utilizzata?",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3546,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3827,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3944,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5664,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "In C++  il GC non e' implementato perche' l'allocazione e deallocazione dinamica della memoria heap e' totalmente responsabilita' del programmatore. \r\n\r\nDa un punto di vista pratico GC entrerebbe in contrasto con l'operatore delete che e' gia' implementato nei distruttori delle classi, ossia deallocazione della memoria impegnata.\r\n\r\nGC, a differenza di delete, agiste in automatico. Non e' quindi determinabile quando esso debba entrare in funzione.\r\nCio' implica un calo delle prestazioni del programma in quanto ,ad esempio, potrebbe interrompere la sua esecuzione momentaneamente al fine di attendere la completa esecuzione del GC.\r\n\r\nL'operatore delete invece viene utilizzato solamente qualora il programmatore lo volesse. E' buona prassi infatti deallocare ogniqualvolta si voglia liberare memoria non piu' necessaria.\r\n\r\nLo svantaggio di cio' e' che e' facile incorrere in situazioni d'errore come memory leaks o accesso ad aree di memoria non consentite.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3943,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3826,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3544,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5631,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 881,
                "courseId": 100,
                "courseFinalScore": 9
              },
              "answerText": "La garbage collection è una funzionalità integrata direttamente nel compilatore. Il suo obiettivo è liberare memoria in fasre di compilazione, liberando porzioni di memoria che non devono più essere usate in futuro. In c e c++, la gestione della memoria avviene in maniera deterministica: cioè è il programmatore che in maniera esplicita, libera la memoria allocata da un oggetto specifico. Seppur non sia presente di default, in c e c++ è possibile utilizzare la GC tramite librerie apposite.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3945,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3543,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3828,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5737,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 756,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Essenzialmente il C++ è un linguaggio molto potente, creato per massimizzare le prestazioni dei programmi scritti in questo linguaggio. La Garbage Collection (GC) influisce sulle prestazioni \"sprecando\" cicli macchina per cercare eventuali variabili dinamiche non deallocate e deallocarle.\r\nIn particolare, la GC entra in contrasto con i puntatori, perchè in C++ più puntatori possono puntare ad uno stesso spazio di memoria. Deallocando questo spazio con la GC, i puntatori che la puntavano, ora puntano sempre alla stessa area, però non sono più autorizzati a modificarla. Si possono creare quindi dei problemi per aver modificato dati ai quali, questi puntatori non erano autorizzati ad accedere. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3545,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3946,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3829,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5366,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra le estensioni strutturali e le estensioni comportamentali?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "estensioni strutturali"
            },
            {
              "keyword": " estensioni comportamentali"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5715,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Nel contesto object-oriented si può distinguere fra due possibili tipi di riflessione. La riflessione strutturale consente ai metaoggetti di osservare la struttura dei livelli sottostanti, ovvero la loro classe; si tratta del tipo di reflection offerto da Java. In un approccio completo alla riflessione strutturale, i metaoggetti dovrebbero avere la possibilità non solo di informarsi sulle caratteristiche delle classi del livello base (metodi, attributi, e così via) ma anche di modificare dinamicamente tale struttura.\r\nLa riflessione comportamentale consente ai metaoggetti di osservare il comportamento dinamico dei livelli sottostanti; in altre parole, osservare quali metodi vengono attivati e, potenzialmente, intercettarne e annullarne o modificarne l'invocazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3661,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3595,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3861,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4050,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5688,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 859,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando si parla di estensioni in un linguaggio di programmazione orientato agli oggetti si fa riferimento al concetto di ereditarietà. Essa consiste in una relazione che viene stabilità tra due classi, una classe A definita come sottoclasse di B eredita tutte le variabili di istanza, tutti i metodi di B e può avere variabili o metodi aggiuntivi. In particolare viene definita estensione strutturale l'aggiunta di variabili di istanza e estensione comportamentale\r\nl'aggiunta di nuovi metodi o la modifica di metodi esistenti da parte di una sottoclasse\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3594,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3860,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3660,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4053,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5691,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Esistono due tipi di estensioni.Le estensioni strutturali che permettono l' aggiunta di istanza oppure estensioni comportamentali che permettono l' aggiunta di metodi o modifica di metodi già esistenti.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3593,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4051,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3659,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3859,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5734,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 767,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le estensioni \"strutturali\" sono le modifiche che si fanno alla classe aggiungendo variabili di istanza mentre le estensioni comportamentali sono la modifica (aggiunta / modifica) dei metodi (funzioni) della classe.\r\n\r\nclass punto{\r\n    private double x;\r\n    private double y;\r\n    ...\r\n}\r\n\r\nclass punto2 extends punto{\r\n    private double x;\r\n    private double y;\r\n    private String nome;\r\n    ...\r\n}\r\n\r\nQuesto è un esempio di estensione strutturale.\r\n\r\nclass punto{\r\n    ...\r\n    punto estrai(punto h)\r\n    ...\r\n}\r\n\r\nclass punto2 extends punto{\r\n    ...\r\n    punto2 estrai(double x, double y)\r\n    ...\r\n}\r\n\r\nQuesta è un esempio di estensione comportamentale in quanto ho modificato la firma di estrai.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3662,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3862,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3596,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4052,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5314,
          "asker": {
            "courseId": 100,
            "askerId": 802,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestita la memoria in Java? Cosa si intende per costruttore e distruttore?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 24,
          "totalRelevanceLevel": 22,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " costruttori"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " distruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5666,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La gestione dinamica della memoria è automatica, tramite la creazione ( operatore new) e distruzione (garbage collection) di oggetti.\r\nLe operazioni da eseguire alla nascita dell'oggetto vanno definite nel metodo \"Costruttore\", ogni classe deve avere uno o più \"Costruttori\".\r\nLe operazioni associate all'eliminazione di un oggetto possono essere definite nel metodo \"Distruttore\" finalize().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3755,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3625,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4030,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4045,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3730,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5676,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 766,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La gestione della memoria avviene in modo dinamico e automatica. Tutta la memoria heap disponibile per l'allocazione degli oggetti viene suddivisa in pezzetti di dimensione prefissata.\r\n\r\nPer costruttore si intende quel metodo in cui vengono definite le operazioni da eseguirsi alla nascita dell'oggetto. Ogni classe deve avere uno o più costruttori. Essi possono differire per numero e tipo di parametri.\r\n\r\nIl distruttore invece è quel metodo in cui vengono definite le operazioni da associarsi con l'eliminazione di un oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3729,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4026,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3754,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4041,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3624,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5671,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La memoria in Java viene gestita tramite lo Stack e l'Heap.\r\nLo Stack si occupa di allocare le variabili automatiche in memoria, cioè le variabili utilizzate durante l'esecuzione del programma, l'Heap invece si occupa di richiedere uno spazio in memoria di un certo numero di bit della quale il programma ha bisogno.\r\nCostruttore e distruttore sono dei metodi, il primo dev'essere utilizzato alla nascita di un oggetto, il secondo  invece per l?eliminazione di un oggetto.\r\nOgni classe appartenente a Java deve avere uno o più costruttori. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3756,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3626,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3731,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4029,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4044,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5713,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La memoria in java si può pensare divisa in due parti: lo stack e la heap. Nello stack la memoria è gestita dinamicamente ed è organizzata in segmenti che vengono allocati alla chiamata di un metodo e eliminati poi (memoria locale), nella heap vengono allocati dinamicamente gli oggetti appena creati che verrano poi rimossi dal garbage collector.\r\nIn java il costruttore serve per allocare e inizializzare lo stato di un oggetto al momento della sua creazione. Puo' avere parametri a piacere ma non ha valore di ritorno.\r\nIl distruttore serve per deallocare un oggetto quando non serve più. \r\nSe il costruttore non viene definito di default verranno inizializzate a zero tutte le variabili, mentre se il distruttore non viene definito di default ne viene chiamato uno vuoto che non fà nulla.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4028,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3753,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3728,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3623,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4043,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5674,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 771,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Le variabili di tipo primitivo, come gli int o i char, possono essere allocate automaticamente, e vengono quindi messe nella stack, o dinamicamente, finendo quindi nello heap.\r\nGli oggetti, cioè istanze di classi, possono essere allocati solo dinamicamente, quindi solo con l'operatore new, e vengono opportunamente deallocati dal garbage colletor se non più referenziati.\r\nIl costruttore e il distruttore sono  metodi scritti dal programmatore all'interno della classe, e il loro identificatore è rispettivamente il nome della classe stessa e il nome della classe seguita da '~'.\r\nIl costruttore viene chiamato automaticamente quando si alloca un nuovo oggetto del tipo di quella classe tramite l'operatore new, e solitamente esegue operazioni di inizializzazione o di allocazione di ulteriore memoria, p.e. nel caso di dover allocare un array.\r\nIl distruttore viene evocato quando il garbage collector dealloca un oggetto, eseguendo istruzioni che sono solitamente di deallocazione di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4042,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3733,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3628,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 4027,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3758,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5710,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il costruttore è un metodo utilizzato per l'inizializzazione di un oggetto, mentre il distruttore è anch'esso un metodo, utile per liberare la memoria ed evitare così il problema del Memory leak.\r\nLa memoria viene gestita dal sistema operativo per le operazione che riguardano per esempio la garbage collection e i puntatori. Le uniche azioni che il programmatore può effettuare sulla memoria sono quelle di allocazione, sia dinamica che statica. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3627,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3732,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4025,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4040,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3757,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5361,
          "asker": {
            "courseId": 100,
            "askerId": 894,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale e' la differenza fondamentale tra i puntatori in Java e in C o C++? Posso deallocare esplicitamente un elemento in Java? Perché conviene farlo in alcuni casi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "aritmetica dei puntatori"
            },
            {
              "keyword": "garbage collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5337,
          "asker": {
            "courseId": 100,
            "askerId": 881,
            "courseFinalScore": 9
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Se il programma contiene 2 funzioni con lo stesso nome ma con firma differente, cosa succede se il linguaggio usato è il c++? E se fosse java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzioni"
            },
            {
              "keyword": " c++"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5423,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in java per essere certi che vengano chiamati i metodi finalize occorre chiamare la System.runFinalization()? \r\nSe il metodo finalize non c'è e viene chiamata la System.runFinalization() si ha errore? se si di che tipo?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "finalize"
            },
            {
              "keyword": "gc"
            },
            {
              "keyword": "metodi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5635,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Perché esiste la possibilità che il nostro programma java termini PRIMA di eseguire il metodo finalize.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4004,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3772,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3676,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5756,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per essere certi che i metodi finalize vengano invocati, bisogna invocare la System.runFinalization() subito dopo la System.gc(). Questa procedura è resa necessaria dal fatto che java non garantisce che il metodo finalize venga chiamato, dato che un programma può terminare prima che il finalizzatore venga chiamato.\r\nSe il metodo finalize non c'è, e viene chiamata la System.runFinalization() non si ottiene alcun errore",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3774,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 4001,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3678,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5743,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 749,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Per essere certi che vengano chiamati i metodi finalize occorre chiamare la System.runFinalization() perché la chiamata finalize() non garantisce che vengano finalizzati tutti gli oggetti.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 4000,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3675,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3771,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5757,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per essere certi che i metodi finalize vengano invocati, bisogna invocare la System.runFinalization() subito dopo la System.gc(). Questa procedura è resa necessaria dal fatto che java non garantisce che il metodo finalize venga chiamato, dato che un programma può terminare prima che il finalizzatore venga chiamato.\r\nSe il metodo finalize non c'è, e viene chiamata la System.runFinalization() non si ottiene alcun errore",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3770,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4003,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3674,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5716,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Normalmente non si può sapere quando e se viene eseguito finalize(), però esiste un metodo di System chiamato runFinalization() che esegue il metodo finalize() di tutti gli oggetti che aspettano di essere finalizzati.\r\nperciò chiamando la System.runFinalization() subito dopo la System.gc() si è certi che vengano chiamati i metodi finalize.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3677,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4002,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3773,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5402,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Java non ha l'aritmetica dei puntatori, quali sono le implicazioni (positive e negative) per un programmatore che impara Java conoscendo il C?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " puntatori"
            },
            {
              "keyword": " reference"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5679,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java i puntatori sono eliminati, dentro la Java Virtual Machine non sono permessi accessi a indirizzi specifici di memoria. \r\nAl posto dei puntatori, al momento dell' inizializzazione di un' istanza di una classe, si crea una reference, ovvero una variabile che permette di operare su quell' oggetto.\r\nIl programmatore di C conosce già l'operatore malloc che inizializza nell' area heap una nuova struttura; questa conoscenza in Java è riutilizzata nei costruttori, che sono effettivamente un' estensione di questo operatore. \r\nLa creazione di strutture è dunque semplificata, e se si è familiari con il C++, che estende le struct in classi, ci si troverà del tutto a proprio agio.\r\nE' invece tolto al programmatore il controllo manuale della deallocazione, che è sostituito dal garbage collector. \r\nIl trade-off in questo caso è una minore efficienza in cambio dell' impossibilità di causare memory leaks o accedere ad aree proibite di memoria, quindi sono eliminati i segmentation faults.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3893,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4009,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3536,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5705,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 835,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per prima cosa deve dimenticare l'utilizzo di \"*\" e \"&\" che in Java perdono di significato(come era inteso in C), nonostante ciò il linguaggio rimane praticamente invariato ma così facendo si perde le utilità che i puntatori hanno in  C. Si ha il vantaggio che diminuiscono gli errori, perché Java fa delle cose al posto del programmatore, ma allo stesso tempo si perde il controllo su cosa realmente fa il computer.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3537,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 4010,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3891,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5656,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'assenza dell'aritmetica dei puntatori in Java porta a molte conseguenze. Quella più evidente è la semplificazione nella scrittura del codice e per l'algoritmo che il programmatore deve implementare, visto che in C sono da gestire tutte le situazioni \"manualmente\", mentre in Java le gestisce automaticamente la JVM. Esempio lampante è l'accesso tramite puntatore ad una classe del C (classe->elemento), che in Java rimane come vi si accedesse senza il riferimento, ma in modo diretto (classe.elemento). Gli aspetti negativi si concentrano principalmente sulla minore possibilità di gestione degli indirizzi e dei passaggi da parte del programmatore: ciò implica spesso anche una perdita di efficienza del programma (poichè deve essere la JVM a decidere autonomamente, implicando quindi l'uso di ulteriori processi).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3894,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4011,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3538,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5724,
              "task": {
                "taskId": 158,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Un'implicazione positiva è che con l'eliminazione dell'aritmetica dei puntatori Java ha posto un limite a diversi errori causati principalmente dai programmatori, come la creazione di un puntatore a una cella di memoria inesistente, o puntante ad un'area di memoria non allocata e/o contenente un valore casuale (che a sua volta può comportare un'incongruenza tra il dato richiesto dal programma e quello contenuto in memoria). Per contro un'implicazione negativa, seppur leggera, può essere considerata il dover imparare e comprendere i nuovi meccanismi (e.g: riferimenti e garbage collection) che permettono di ottenere risultati analoghi a quelli ottenibili in C tramite i puntatori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3539,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3892,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 4008,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 158,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5405,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 157,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il default constructor?\r\nPuò esserci più di un costruttore per classe? Se si, in cosa differiscono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": " classe"
            },
            {
              "keyword": " default constructor"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 61,
      "lectureTitle": "Lecture 11",
      "questions": [
        {
          "questionId": 5710,
          "asker": {
            "courseId": 100,
            "askerId": 823,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Slide della lezione, pagina 15, \"equals per la classe P, v.3\"\r\nPerché nel return del metodo \"equals\" l'oggetto P è scritto tra parentesi tonde?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " object"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6124,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 883,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nel return del metodo equals c'è bisogno delle parentesi tonde poiché è il programmatore a chiedere l'uguaglianza della variabile interna all'oggetto. In fase di compilazione va'e potrebbe essere vista come oggetto di tipo object e non come tipo P, e con questo metodo si evitano equivoci. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5670,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5524,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6101,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5700,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5736,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6087,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Perché la sintassi (P)var indica che stiamo facendo un casting della variabile var; infatti il metodo equals prende come parametro \"Object var\" e per poter accedere ai campi x e y di tale variabile è necessario fare questo casting per \"specializzare\" l'oggetto di tipo Object in un oggetto di tipo P. Senza questo casting, il compilatore troverebbe \"var.x\", ma nella classe Object non esiste una variabile x, e quindi darebbe errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5737,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5701,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5523,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5671,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6100,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5664,
          "asker": {
            "courseId": 100,
            "askerId": 844,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega per quale motivo è comune nella programmazione orientata agli oggetti effettuare l'overriding del metodo \"equals\" della classe Object. E quali sono le \" regole\" da seguire per effettuare una buona implementazione di tale metodo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "Object"
            },
            {
              "keyword": "regole"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5721,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "perché nella tombola usiamo degli hashset e non degli arraylist",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashset"
            },
            {
              "keyword": "collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5750,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione del metodo hashcode() e  quando dovrebbe essere implementato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "HashCode"
            },
            {
              "keyword": "Equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5731,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'esempio \"Tombola\" visto in classe, vengono creati oggetti di tipo HashSet. Che tipo è? A che cosa serve? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashset"
            },
            {
              "keyword": " tombola"
            },
            {
              "keyword": " collections"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5684,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi offre il metodo \"equals()\" per comparare 2 oggetti, rispetto al comune \"if ()\" ?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " if"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5752,
          "asker": {
            "courseId": 100,
            "askerId": 912,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si utilizza il motodo equals()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "utilizzo"
            },
            {
              "keyword": " motodo"
            },
            {
              "keyword": " equals()"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5715,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella re-implementazione di Equals() fatta a lezione abbiamo posto x.Equals(y) = False se y è NULL. Analizziamo il seguente esempio: \r\n\r\nx=null;\r\ny=null;\r\n\r\nOra avremmo x.Equals(y)= FALSE; Ma x e y sono uguali.\r\nAbbiamo \"sbagliato\" l'overriding di Equals oppure c'è un motivo per cui ha senso porre sempre Equals(null)=False?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " uguali"
            },
            {
              "keyword": " null"
            },
            {
              "keyword": " false"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6136,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ha sempre senso poichè x e y sono dei puntatori ed hanno senso solo se puntano a qualcosa. Non puntando a niente ( non riferendosi cioè e nessun oggetto) ha perfettamente senso far risultare Equals FALSE nel caso il metodo venga chiamato su un oggetto che di fatto non esiste. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5634,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6123,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5746,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6133,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5601,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5795,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5307,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6029,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "perchè in caso in cui un oggetto sia null, l'equals ritorna sempre falso senza fare nessuna operazione di confronto. Anche dalle API viene descritto che se un oggetto dato in pasto all'equals è NULL, la funzione ritorna il valore falso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5748,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6121,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5797,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6131,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5603,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5306,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5636,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6099,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per qualsiasi riferimento di valori x e y, il metodo equals restituisce true se e solo se x e y si riferiscono allo stesso oggetto (x == y ha valore True).\r\nQuindi presuppongo che se x e y sono entrambi null il valore corrisponda a False.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5796,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5602,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6122,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6132,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5747,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5635,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5308,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5740,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel programma della tombola dove devo intervenire per implementare la creazione di più cartelle?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "giocatori"
            },
            {
              "keyword": " cartella"
            },
            {
              "keyword": " tombola"
            },
            {
              "keyword": " esercizio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5678,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "quale è la differenza  tra variabile statica e dinamica ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5696,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è importante effettuare overriding del metodo equals invece di un semplice overloading? Es.:\r\n\r\npublic class Libro{\r\n    \r\n    public boolean equals(Object o){ ... }\r\n\r\n    //public boolean equals(Libro lib){ ... }\r\n\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overriding"
            },
            {
              "keyword": "overloading"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5669,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un hashcode? Perché è importante effettuare un override del metodo hashCode() della classe Object, laddove si effettui un override del metodo equals(Object o) ?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " equals"
            },
            {
              "keyword": " object"
            },
            {
              "keyword": " override"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6088,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 838,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo hashCode() produce un numero intero,  l'hashValue,  ottenuto dalla manipolazione dei dati dell'oggetto su cui è chiamato.  L'idea dell'hashcode è quindi quella di rappresentare un insieme di dati con un intero,  più facilmente valutabile. L'hashcode torna utile ad esempio per ottimizzare il metodo equals(obj): se i due oggetti confrontati hanno diverso hashValue allora sono diversi. Questo suggerisce anche perché si debba fare override di hashCode() ogni volta che si fa override di equals(obj): il primo deve fornire risultati consistenti col secondo altrimenti può risultare inutile (l'hashValue non è sufficientemente discriminante),  o,  peggio, dannoso (l'hashValue è troppo discriminante). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6021,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6007,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5560,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5688,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6127,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo hashCode è un metodo che ritorna un intero dato un oggetto. Ad esempio dato un oggetto o, il suo intero corrispondente è o.hashCode(). In java ogni oggetto ha accesso al metodo equals() (metodo che compara gli indirizzi di memoria degli oggetti) poichè questo è ereditato dalla classe Object. Nel caso in cui tu voglia fare un override del metodo equals() devi per forza farlo anche sul metodo hasCode() altrimenti incorrerai in una violazione del contratto fatto da java per Object.hashCode il quale potrebbe avere ripercussioni inaspettate nel momento in cui la tua classe e collegata con tutte le tavole hash.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5562,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6005,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5690,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6019,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6141,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'hashCode è un metodo della classe Object, che dato un oggetto restituisce un valore in genere intero, associato ad esso. È una funzione non iniettiva, dinque non invertibile: dato un valore hash infatti non è sempre possibile risalire all'istanza associata ad esso poiché i valori hash sono finiti; tuttavia due oggetti che per il metodo equals() sono uguali hanno lo stesso hashCode associato. Un esempio pratico è il codice fiscale: l'ultimo carattere viene generato a partire da quelle precedenti, ma essendo una lettera ci sono 26 casi possibili, perciò due persone pur avendo identità diverse possono produrre la stessa ultima lettera nel loro CF. \r\nDetto questo è buona norma far overriding dell'hashCode quando si fa quello dell'equals per questa proprietà di equivalenza tra due oggetti che implica lo stesso valore hash di default.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6022,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6008,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5691,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5561,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6068,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un hashcode è una funzione che associa ad ogni elemento del dominio un numero intero. Questo tipo di funzioni permette di creare tabelle associative (chiave - valore), in modo che gli algoritmi di ricerca siano più efficienti. \r\n\r\nE' importante fare override del metodo hashCode() perché per il contratto del metodo equals() bisogna rispettare le seguenti implicazioni:\r\n(1) equals T ->hashCode T\r\n(2) hashCode F ->equals F\r\ndove T= True e F= False.\r\nDunque, nel momento in cui faccio override di equals(), possono esistere dei casi in cui queste implicazioni non valgano più e di conseguenza si deve modificare anche il metodo hashCode().\r\n\r\nA che cosa serve questo contratto? \r\nE.g. per verificare velocemente se un oggetto A è già presente all'interno di un Set I. Infatti, per la (2) se nessun elemento di I ha un digest uguale a quello di A, si può concludere che A non appartiene all'insieme I. Al contrario, se trovo un hashCode coincidente con quello di A non si può affermare nulla.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6006,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5689,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5559,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6020,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5714,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega come avviene l'ordinamento degli oggetti in Java: quali sono le interfaccie fondamentali per l'ordinamento di oggetti e quali metodi ci obbligano ad implementare. Una volta implementato l'ordinamento come posso ordinare una collezione?",
          "totalDifficultyLevel": 24,
          "totalInterestingnessLevel": 24,
          "totalRelevanceLevel": 22,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ordinamento"
            },
            {
              "keyword": " collection"
            },
            {
              "keyword": " compare"
            },
            {
              "keyword": " compareTo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6058,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "In Java esistono due metodi per ordinare oggetti.\r\n1 - L'interfaccia Comparable: se una classe la implementa significa che i suoi oggetti saranno confrontabili secondo un ordinamento che viene chiamato \"ordinamento naturale\", ad esempio l'ordinamento lessicografico. Tale interfaccia ci obbliga ad implementare il metodo: public int compareTo(object o) . Una collezione potrà poi esser ordinata utilizzando il metodo statico Collections.sort(Lista).\r\n2 - L?interfaccia Comparator: permette di ordinare la lista secondo un numero differenti di criteri. Tale interfaccia ci obbliga a implementare il metodo: public int compare(Object x, Object y). Una collezione potrà poi essere ordinata utilizzando il metodo Collections.sort(Lista, new NomeClasseComparator).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5775,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5529,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6037,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5276,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5802,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5734,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6057,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ci sono due modi per ordinare oggetti:\r\nL'interfaccia Comparable fornisce automaticamente l'ordine naturale sulle classi che devono attuarla.\r\nL'interfaccia comparatore dà al programmatore il controllo completo su un' oggetto da ordinare.\r\nQuesti non sono la raccolta di base interfacce , ma le infrastrutture di base.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6035,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5532,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5771,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5275,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5798,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5730,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6098,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 881,
                "courseId": 100,
                "courseFinalScore": 9
              },
              "answerText": "Una delle interfaccie fondamentali per l'ordinamento può essere la Comparable. Tramite questa, si fa un confronto degli oggetti per determinarne un ordine. Tramite un Collections.sort(oggetto) abbiamo direttamente una funzione che permette un ordinamento degli oggetti. \r\nSe invece gli oggetti non implementano la comparable, abbiamo 2 possibilità. La prima consiste nell'implementazione manuale di una Comparable, creando quindi un esempio simile al precedente. \r\nLa seconda, invece, richiede un'implementazione di un Custom Comparator. Ad esempio:\r\npublic int compare(Persona p1, Persona p2) {\r\n    return p1.getEta().compareTo(p2.getEta());\r\n  }",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5772,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5531,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5273,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5799,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5731,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6034,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6040,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Le interfacce da utilizzare per ottenere l'ordinamento di oggetti in java sono List, SortedSet, SortedMap. Tramite l'overriding del metodo \"sort()\", un metodo dell'interfaccia, possiamo sviluppare l'algoritmo che ordina i nostri oggetti (ovviamente seguendo certe regole di ordinamento che abbiamo deciso a priori. Per esempio possiamo decidere di ordinare una lista di studenti in ordine alfabetico secondo il cognome, in ordine di matricola crescente o decrescente ecc...). Una volta implementato il nostro metodo sort, possiamo creare una lista di oggetti, popolarla e utilizzare \"lista.sort();\" per ordinarla.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5533,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5271,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5776,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5735,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5803,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6036,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6143,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Le interfacce fondamentali per l'ordinamento in Java sono Comparable e Comparator e impongono l'implementazione dei metodi compareTo(T o) e compare (T o1, \r\nT o2).\r\nCompareTo ordina secondo un ordine naturale,  mentre con compare il programmatore definisce un ordine (che deve essere totale)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5774,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6032,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5801,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5733,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5530,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5274,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6131,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 831,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le interfacce (senza la i) fondamentali per l'ordinamento di oggetti sono due: Comparable e Comparator. La prima fornisce un ordinamento naturale automatico per le classi che implementano tale funzionalità (es. interi, stringhe, ecc) tramite l'implementazione del metodo int compareTo (Object obj) mentre la seconda richiede l'implementazione del metodo int compare (T o1, T o2).\r\nPer ordinare una collezione è sufficiente chiamare il metodo statico sort (Collections.sort) passando come parametri solo la lista degli oggetti da ordinare (nel caso l'ordinamento sia naturale o già specificato) oppure anche un comparatore che definisca l'ordine per quel tipo specifico di oggetti. Il metodo sort ha overloading: https://docs.oracle.com/javase/6/docs/api/java/util/Collections.html",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5773,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5272,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6033,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5800,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5732,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5528,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5735,
          "asker": {
            "courseId": 100,
            "askerId": 893,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Stai scrivendo il codice di funzionamento di una cassa del supermercato. Implementa il metodo equals della classe Prodotto.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "writesomecode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5747,
          "asker": {
            "courseId": 100,
            "askerId": 858,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che caratteristiche deve avere un buon hashcode? Come si genera? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " hascode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5768,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è la classe Common? Come si usa correttamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "class"
            },
            {
              "keyword": " common"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5699,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere l'operatore == e l'equals() e spiegare le differenze che ci sono tra di essi ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Differenze "
            },
            {
              "keyword": " teoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5679,
          "asker": {
            "courseId": 100,
            "askerId": 874,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Di default l'operatore == e il metodo equals fanno la stessa cosa?\r\nSpiega il perché.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " =="
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5713,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve il metodo hashCode() e per quale motivo e buona norma riimplementarlo ogni volta che si sovrascrive il metodo equals()?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashCode"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6051,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "Il metodo hashCode() serve a differenziare due oggetti dello stesso tipo generando un intero calcolato sulla base dei dati presenti nell'oggetto stesso. Ogni volta che si rende necessaria l'implementazione del metodo equals(), è buona norma eseguire l'override anche al metodo hashCode() per definire correttamente quali sono i dati che verranno rimaneggiati per ottenere l'intero (che dovrebbe essere univoco per ogni oggetto con quei valori alle variabili, e quindi definire con una buona precisione se due oggetti dello stesso tipo sono uguali) ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5722,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6072,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5677,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5921,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5872,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6112,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6067,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 836,
                "courseId": 100,
                "courseFinalScore": 19
              },
              "answerText": "Il metodo hashCode() serve per identificare un oggetto assegnando un valore numerico in base al valore delle variabili interne. Quando si va a riimplementare il metodo equals() si vanno a ridefinire le regole di uguaglianza e quindi va riimplementato pure il metodo hashCode() affinchè rispecchi queste nuove regole.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5678,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5873,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5922,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5723,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6074,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6114,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6138,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 897,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo hashCode() ritorna un intero che si basa sull'identità dell'oggetto, sovrascrivendo il metodo equals(), che controlla se 2 oggetti hanno la stessa identità, e quindi pur cambiando il valore delle variabili d'istanza il metodo hashCode() ritornerà lo stesso intero, non fare l'override di quest'ultimo darà due interi diversi e così andando in conflitto con la regola \"Oggetti uguali hanno hashCode uguale\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5920,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5871,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5721,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6073,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5676,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6113,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5712,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale vantaggio comporta l'utilizzo delle cosiddette variabili e/o metodi di classe (ossia quelle variabili e/o metodi definiti static) all'interno di un programma? Per quale motivo non è necessario creare un'istanza per poter utilizzare queste variabili oppure richiamare questi metodi?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 22,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " metodi"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6031,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il vantaggio che comporta l'utilizzo delle variabili static è che fungono da variabile condivisa. Per i metodi invece il vantaggio è che possono essere richiamati senza aver prima creato un'istanza dell'oggetto della classe  di riferimento. La seconda domanda la ritengo inutile per il fatto che suggerisce la soluzione alla prima ed inoltre è una ripetizione della stessa ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5441,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6191,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6148,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5320,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5652,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6065,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La parola static è usata per definire, all'interno di una classe, variabili e metodi associati alla classe stessa e non alle singole sue istanze. Ciò significa che tali metodi e variabili saranno uguali per ciascuno oggetto che ha come tipo la classe o una sua sottoclasse. Come conseguenza non dipendono dalla singola istanza ma solo dalla classe per cui è possibile chiamarli anche dalla classe e non è più necessario averla istanziata.  Ad esempio è necessario che il main sia static perchè deve essere eseguito per primo, quindi senza che in precedenza la sua classe sia stata istanziata. È utile dichiarare una variabile static anche nel caso sia necessario che questa sia modificata da metodi di oggetti diversi ma appartenenti a una classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5653,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6193,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6150,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5322,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5443,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6094,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il vantaggio principale consiste nella possibilità di utilizzare metodi appartenenti a una classe senza doverla prima istanziare (NB: come nel caso del metodo main).\r\nLe variabili statiche servono come singola variabile condivisa: se avessimo invece una variabile non static, ogni istanza della classe a cui appartiene avrebbe un valore per quella variabile indipendente o diverso dalle altre istanze.\r\nI metodi static possono accedere solo ai campi static, come si denota dall'esempio seguente.\r\n\r\nclass S {\r\n  static int instanceCount = 0; //variabile ?di classe?\r\n  S() {instanceCount++;}\r\n  static void azzeraContatore() {instanceCount=0;} //metodo ?di classe?\r\n} \r\n\r\nPossiamo notare l'utilità di avere variabili e metodi static prendendo in esempio ulteriore la classe Collections, dove abbiamo campi quale\r\n \"static List\tEMPTY_LIST\"\r\ne metodi come\r\n \"static void shuffle\"\r\nche possiamo utilizzare sulle nostre istanze di ArrayList senza aver creato un oggetto concreto della classe Collections.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5440,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5656,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6190,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5319,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6147,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6048,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "\r\n\r\nIl vantaggio che comporta l'utilizzo di variabili e/o metodi statici è che, come hai ben detto, non è necessario creare un'istanza della classe per poterli utilizzare dato che sono uguali per tutte le istanze della classe.\r\nQuesto però scaturisce che i metodi statici non possono usare variabili e/o metodi non-statici senno dipenderebbero da ogni istanza.\r\nPer esempio la classe Math ha come variabile static double PI ovvero il valore di PiGrego e questa variabile può essere chiamata direttamente tramite la classe ovvero Math.PI\r\n\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5651,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5442,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6149,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5321,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6192,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6135,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una Variabile static è unica per ogni classe cioè ogni istanza fa riferimento alla stessa variabile, e quindi se la cambi in una istanza cambia in tutte. I metodi static possono accedere a solo variabili static a causa del fatto che possono essere eseguiti senza istanziare una classe e quindi potenzialmente altre variabili potrebbero non essere inizializzate. Questi metodi infatti non usando variabili (non static )che potrebbero differire da istanza a istanza, e poiché il valore di ritorno non dipende dall'istanza,  possono (dovrebbero) essere chiamati senza che la classe dove sono contenuti sia istanziata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5318,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5438,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6145,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6188,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5655,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6069,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 773,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili di classe, definiscono un dato comune a tutti gli oggetti di una classe.\r\nQuesto fa si che venga memorizzato un unico valore in una specifica cella di memoria che e' comune a tutti gli oggetti di quella classe(mentre per le variabili di istanza, queste avevano valori diversi per ogni oggetto creato).\r\nLe variabili di classe sono definite statiche; questo significa che modificando il valore di una variabile statica, la modifica sara' valida per tutti gli oggetti della classe.\r\nI metodi di classe agiscono sulla classe e non sullo specifico oggetto, sono quindi utilizzabili senza legarli ad oggetti.\r\nAnche i metodi di classe vengono definiti statici i quali non accedono ad alcuna variabile d'istanza di un oggetto.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5317,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6146,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6189,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5439,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5654,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5701,
          "asker": {
            "courseId": 100,
            "askerId": 894,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Dato il seguente codice:\r\n\r\nclass P {\r\n  int x;\r\n}\r\nclass Q extends P {\r\n  int y;\r\n\r\n  public boolean equals(Object var){\r\n      if(var==null) return false;\r\n      if (!(var instanceof P)) return false;\r\n              return false;\r\n      return (x==((Q)var).x);\r\n   }\r\n}\r\n\r\n...\r\nP p1 = new Q();\r\np1.x=2;\r\nP p2 = new P();\r\np2.x=2;\r\nSystem.out.println(p1.equals(p2));\r\n\r\nPerchè non funzionerebbe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "casting"
            },
            {
              "keyword": " subclassing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5730,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile testare l'eguaglianza in Java? Quali sono le proprietà? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eguaglianza"
            },
            {
              "keyword": " equals"
            },
            {
              "keyword": " propririetà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5680,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il comando equals in java?Quali sono le differenze sostanziali tra a==b e a.equals(b)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "confronti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5666,
          "asker": {
            "courseId": 100,
            "askerId": 784,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene simulata la randomicità in Java? Perché si parla di pseudocasualità?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "randomicità"
            },
            {
              "keyword": " pseudocasualità"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6047,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "In java si parla di pseudocasualità perché i numeri sono  generati da un apposito algoritmo che opera in maniera deterministica (cioè fornendo sempre lo stesso output a fronte di un identico input) ma che permette di generare una sequenza di numeri che ha caratteristiche statistiche analoghe a quelle di una sequenza estratta casualmente.L'input di cui si parla è il cosiddetto sede, ossia un parametro che indica il punto di partenza della sequenza. Se il seme è estratto in maniera casuale, essendo utilizzato una sola volta, si ottiene una sequenza a priori non prevedibile. Spesso il seme viene generato prendendo un numero ricavato dall'orologio di sistema: in questo modo, in due esecuzioni distinte del programma, eseguite manualmente, si ha una sua buona \"casualità\". A livello di di codice dovremo includere il package java.util.Random e per \r\ncreare il numero generatore Random(long seed).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5841,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5832,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5287,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6063,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Come in c++ i numeri random, in java, vengono generati in base ad un seme (per lo stesso motivo si parla di pseudocasualità in quanto non è proprio vero che i numeri sono completamente casuali). In base al seem che viene passato che solitamente è il time attuale vengono generati i numeri",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5840,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5286,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5831,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6122,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "In java viene utilizzato un algoritmo per la generazione di numeri pseudo-casuali chiamato generatore lineare congruenziale (LCG) che ha la seguente formula:\r\nX(n+1)=(25214903917*X(n)+11) mod 2^48 dopo di che java prende i 32 bit più significativi (i numeri variano da linguaggio a linguaggio).\r\nX(0) è detto seed il quale determina il risultato dell'algoritmo (seed uguali generano risultati uguali). L'algoritmo è più efficace a seconda della più bassa correlazione tra il seed e il numero semi-casuale creato. Infatti si parla di pseudo-casualità perché questa correlazione è diversa da 0.\r\nIn genere in java viene usato come seed i millisecondi passati dalla mezzanotte del primo gennaio del 1970.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5830,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5288,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5839,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5692,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Con quali metodi è possibile testare se due oggetti sono uguali? Descrivine le differenze",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodi"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5717,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le proprietà richieste al metodo equals?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "proprietà"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6092,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il linguaggio Java richiede che qualunque ridefinizione del metodo equals rispetti determinate proprietà che forniscono una vera e propria relazione di equivalenza:\r\n\r\nRiflessività, per ogni oggetto x, avremo che x.equals(x) è vero;\r\nSimmetria, dati due oggetti x ed y, avremo che se x.equals(y) è vero , allora y.equals(x) è vero;\r\nTransitività, dati tre oggetti x, y e z, se x.equals(y) è vero e y.equals(z) è vero, allora x.equals(z) è vero.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6134,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5457,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5752,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5893,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5430,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6028,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 823,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo equals deve implementare una relazione d'equivalenza, cioè deve essere:\r\n- riflessivo: per ogni oggetto A, A.equals(A)\r\n- simmetrico: per ogni oggetto A e per ogni oggetto B tale che A.equals(B) si ha B.equals(A)\r\n- transitivo: per ogni tripla di oggetti A,B,C, (A.equals(B) and B.equals(C)) ==> A.equals(C)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6137,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5750,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5429,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5891,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5456,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6046,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le proprietà richieste dal metodo equals sono:\r\n(con a e b diversi da null)\r\nRiflessiva: a.equals(a) deve dare true\r\nSimmetrica: a.equals(b) deve dare lo stesso risultato di b.equals(a)\r\nTransitiva: se a.equals(b) e b.equals(c) a.equals(c)\r\nConsistente: deve dare sempre lo stesso risultato nel confronto di due istanze.\r\nSe b è null a.equals(b) deve essere false",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5749,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5431,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5458,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6135,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5890,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6097,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo equals verifica l'uguaglianza di due oggetti. Alla base del funzionamento del metodo è necessario l'implementazione delle seguenti proprietà(relazione d'equivalenza):\r\n \r\n1.Riflessività -> (dato un oggetto (x) non nullo e oggetto (y) il confronto x.equals(y) deve ritornare vero);\r\n\r\n2.Simmetria -> (dato un oggetto (x) non nullo e oggetto (y), se il confronto x.equals(y) ritorna vero allora il confronto y.equals(x) deve ritornare vero e viceversa se il primo confronto risulta falso);\r\n\r\n3.Transitività -> (dato tre oggetti (x),(y) e (z) non nulli se il confronto x.equals(y) ritornare vero e il confronto y.equals(z) ritorna vero allora anche il confronto x.equals(z) risulterà vera);\r\n    \r\n4.Coerenza -> (dato un oggetto (x) non nullo e oggetto (z), una multipla convocazione del confronto x.equals(z) deve costantemente ritorna vero e in caso fosse stato falso deve costantemente ritornare falso);\r\n\r\nNota: per ogni oggetto x non nullo, x.equals(null) deve ritornare falso;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5459,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5892,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5432,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6136,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5751,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5764,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è conveniente usare l'hashcode e in cosa consiste?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "veloce"
            },
            {
              "keyword": "somma gli attributi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5675,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che utilità ha il metodo hashcode() della classe object? Lo devo implementare ogni qualvolta si implementa il metodo equals()? Quando lo devo utilizzare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodi"
            },
            {
              "keyword": " hashcode"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5688,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Facendo l'overriding del metodo equals di Object, di quale altro metodo bisognerebbe fare l'overriding? Spiegare la funzionalità di questo metodo",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding "
            },
            {
              "keyword": " equals "
            },
            {
              "keyword": " Object"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5742,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'operatore == nel caso vengano confrontati due dati di tipo primitivo o due oggetti? Perchè esiste tale differenza nel comportamento?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "=="
            },
            {
              "keyword": " uguaglianza"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6102,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nel caso in cui vengano confrontati tipi di dato primitivi l'operatore di uguaglianza \"==\" si comporta esattamente come nel caso del C/C++, cioè verifica se il valori assegnati a due variabili sono uguali o meno; se invece vengono confrontati due oggetti, l'operatore di uguaglianza si comporta come un  OPERATORE DI IDENTITA', cioè verifica se gli identificatori si riferiscono allo stesso oggetto in memoria, senza considerarne il contenuto effettivo.\r\nP p1=new P(); p1.x=3; p1.y=2;\r\nP p2=new P(); p2.x=3; p2.y=2;\r\n(p1==p2)=>FALSE\r\nSe si vuole confrontare il contenuto di due oggetti si dovrà ricorrere al metodo equals(), implementato nella classe Object, dunque disponibile per qualsiasi oggetto (tutte le classi derivano da Object), esclusi i tipi di dato primitivi; tuttavia, poiché il comportamento di default del metodo equals() è quello di confrontare le referenze degli oggetti che si stanno confrontando, dovrà essere sovrascritto (overriding) per soddisfare le esigenze del programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5950,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5694,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5364,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5381,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5630,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6070,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 762,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ai tipi primitivi confronta il valore della variabile invece, agli oggetti confronta gli indirizzi di memonria.\r\nInoltre se si vogliono confrontare 2 oggetti bisogna implementare dei metodi come equals o compareTo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5627,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5378,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5361,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5695,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5948,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6096,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "L'operatore di confronto '==' per dati di tipo primitivo confronta il vero valore posseduto, mentre per due oggetti confronta il loro attuale indirizzo. In poche parole, l'operatore '==' nel caso di tipi primitivi restituisce true se i valori dei due dati confrontati corrispondono (es int x=3,y=3; x==y restituisce true) mentre nel caso di oggetti restituisce true solo se corrispondono alla stessa area di memoria; ossia si tratta di un oggetto unico (Oggetto p1=new Oggetto(); Oggetto p2=new Oggetto(); p2=p1; p2==p1 restituisce true perchè in realtà i due nomi puntano alla stessa area di memoria dopo l'assegnamento p2=p1).\r\nNel caso di confronto tra due oggetti dunque è consigliato l'override del metodo equals ereditato dalla classe Object, in modo da definire correttamente come confrontare i due oggetti. Il metodo ereditato da Object infatti non fa altro che confrontare due oggetti con l'operatore '=='; questo perchè è impossibile sapere a priori come saranno composte le classi figlie.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5951,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5362,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5693,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5628,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5379,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6109,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 874,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore == è un operatore booleano che restituisce TRUE solo se i due oggetti  sono identici, ovvero puntato alla stessa cella di memoria. Nel caso dei tipi di dato primitivo, invece, l'operatore restituisce TRUE se gli viene assegnato a tutti e due il medesimo valore.\r\nTale differenza esiste perché",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5629,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5949,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5363,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5380,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5692,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5756,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi brevemente il funzionamento e l'utilità della classe Random e fanne un esempio. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Random"
            },
            {
              "keyword": " Pseudocasualità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5769,
          "asker": {
            "courseId": 100,
            "askerId": 886,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si fa Overriding sul metodo \"equals\" sarebbe buona convenzione sovrascrivere opportunamente anche il metodo \"hashCode\", tuttavia non è invece necessario il contrario. Perché?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5695,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Se implemento una classe che riscrive il metodo equals, perchè devo riscrivere anche il metodo hashCode?\r\nSpiegare inoltre nel dettaglio le implicazioni di HashCode.",
          "totalDifficultyLevel": 23,
          "totalInterestingnessLevel": 23,
          "totalRelevanceLevel": 23,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " equals "
            },
            {
              "keyword": " ovveride"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6045,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il metodo equals() è ereditato dalla superclasse Object e determina se 2 istanze sono uguali o equivalenti.\r\nNormalmente questo metodo dovrebbe essere sovrascritto perché il metodo equals() della classe Object è equivalente all?operatore ==, cioè restituisce true se e solo se le 2 referenze si riferiscono allo stesso oggetto.\r\n\r\nQuando 2 oggetti risultano uguali in base a equals() allora anche i loro hash code devono essere uguali, quindi è buona norma, quando si sovrascrive equals(), sovrascrivere anche hashCode(), un metodo ereditato dalla superclasse Object.\r\nNella implementazione in Object, hashCode() restituisce un intero diverso per ogni oggetto ma in generale è possibile che oggetti diversi condividano lo stesso hash code anche se questo rende il codice meno efficiente.\r\nUn altro vantaggio nello sovrascrivere hashCode() è una più efficiente ricerca nelle Collections come HashMap o HashSet che usano l?hash code nella gestione degli oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6090,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6158,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5497,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5250,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5489,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6079,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perchè quando si implementa la classe equals si riscrivono le regole di uguaglianza di due oggetti, con HashCode si va a dare un valore identificativo a ogni oggetto.\r\nL'HashCode serve per identificare univocamente un determinato oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5253,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6091,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6159,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5487,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5495,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6111,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo equals() normalmente viene riscritto in quanto, quello ereditato dalla classe Object è equivalente all'operatore == (che restituisce TRUE solo se gli oggetti sono identici). L'implementazione del nuovo metodo equals() prevede il controllo dell'uguaglianza tra due oggetti andando a considerare i contenuti delle varie variabili: ciò può rendere l'operazione molto lunga. Per questo motivo è buona norma sovrascrivere anche il metodo hashCode() (anch'esso è definito nella classe Object), attraverso cui è possibile fare una prima selezione, individuando oggetti che sono sicuramente diversi. Il metodo hashCode() infatti restituisce ad ogni oggetto un intero: gli interi restituiti sono tali che se due oggetti hanno hashCode differenti, allora sono certamente diversi (per esempio, se consideriamo due oggetti di tipo Coordinata, un possibile hashCode potrebbe essere la somma delle coordinate). Non è vero il viceversa, ovvero che due oggeti con hashCode uguale, sono uguali. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5252,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6160,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5496,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5488,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6092,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6112,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo hashCode restituisce un codice che permette di identificare un oggetto senza analizzare nei dettagli i suoi attributi. Quando si riscrive il metodo equals è bene riscrivere il metodo hashCode, che di default restituisce zero, ed utilizzarlo in equals per ottimizzarne i tempi di esecuzione. Due oggetti uguali dovranno avere hashCode uguali, e due oggetti diversi avere hashCode diversi.  È necessario scegliere un algoritmo di generazione del codice Hash che tenga in considerazione tutti gli attributi dell'oggetto che lo caratterizzano. Nel caso visto a lezione di due punti del piano cartesiano si può, per esempio, moltiplicare x per una potenza di 10 adeguata al numero di cifre delle coordinate; poi sommare y. \r\n\r\nx=28\r\ny=65\r\nhashCode=2865",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6088,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5494,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5248,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5486,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6156,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6139,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Se si implementa una classe che riscrive il metodo equals, è necessario riscrivere anche il metodo hashCode poichè deve essere soddisfatta la legge generica riguardante il metodo \"Object.hashCode\". In particolare, ad ogni equals implementato corrisponde un generico \"1.hashCode()==2.hashCode(\"). Ciò implica che se equals da true hashCode è uguale, mentre se hashCode è diverso equals ritorna false.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5498,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6087,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6155,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5490,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5251,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6142,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Hashcode è un metodo fornito implicitamente o esplicitamente da tutte le classi in Java.Questo metodo converte i dati contenuti in un?istanza in un intero con segno (32 bit) detto?hash value?.\r\nE? un metodo di Object per mappare la memoria degli indirizzi in un intero. Il metodo hashcode e il metodo equals sono equivalenti, entrambi entrambi devono soddisfare la relazione di equivalenza.Le proprietà degli algoritmi di hash sono l?impossibilità computazionale della ricerca di una stringa in input che dia un bash uguale ad un dato bash, della ricerca di una stringa che dia un hash uguale a quello di una stringa data e infine della ricerca di una coppia di stringhe aventi lo stesso hash.\r\nHashcode viene utilizzato nelle basi di dati per realizzare particolari strutture dati dette ?hash table?.Hash è utilizzato per le firme digitali in quanto identifica un oggetto, di qualunque mole di dati,in modo univoco.Gli algoritmi SHA1 e MD5 sono molto diffusi nella moderna crittografia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5491,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5499,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5249,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6089,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6157,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5759,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le proprietà che sono richieste ad equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "proprietà"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5693,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Ammettiamo che una classe Poligono contenga un'istanza della classe java.util.HashSet destinata a contenere istanze della classe Punto. Quali metodi è necessario implementare all'interno della classe Punto, al fine di poterla correttamente ed efficientemente utilizzare in questo contesto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " hashing"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5694,
          "asker": {
            "courseId": 100,
            "askerId": 910,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può fare ovverride e overload del metodo equals? Se si, in che modo si possono implementare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " override"
            },
            {
              "keyword": " overload"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5689,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le interfacce Comparable e Comparator e in cosa differiscono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Comparable"
            },
            {
              "keyword": " Comparator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5682,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella creazione del gioco della tombola completa (con più giocatori e cartelle) quali sarebbe le classi coinvolte e le loro relazioni? Si potrebbe implementare attraverso le collections?p",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Lezione11"
            },
            {
              "keyword": " Tombola"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5765,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Vale la pena di spendere tempo nella progettazione e nella suddivisione dei ruoli fra le varie classi? Non è solo tempo rubato alla scrittura di codice? Non è meglio partire subito con l'implementazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "design"
            },
            {
              "keyword": " programming practice"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5757,
          "asker": {
            "courseId": 100,
            "askerId": 836,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Se due oggetti dello stesso tipo hanno hashcode uguale, è sempre vero che la loro comparazione con equals(), restituisce true? Illustrare con un esempio.",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6129,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "No, non è vero. Questo perché l'hashcode fornisce una condizione necessaria, ma non sufficiente affinché equals restituisca true: se l'hashcode è diverso, allora equals restituirà sicuramente false; se hashcode è uguale, allora nulla si può dire sul valore che restituirà equals.\r\n\r\nPer convincerci di ciò, analizziamo il seguente esempio. \r\nSupponiamo di avere una classe Rettangolo con variabili base e altezza, per cui:\r\n- l'hashcode di due rettangoli è uguale se hanno la stessa area, diverso altrimenti;\r\n- equals dà true se le basi hanno lo stesso valore e le altezze hanno lo stesso valore, false altrimenti.\r\nSe considero rettangolo_1 con base = 6 e altezza = 2, rettangolo_2 con base = 4 e altezza = 3, avrò:\r\n- hashcode uguale, poiché l'area di rettangolo_1 è 6x2 = 12 e l'area di rettangolo_2 è 4x3 = 12;\r\n- equals false, poiché le basi e le altezze differiscono.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5813,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5817,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6054,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dipende dall'implementazione che facciamo dell'equals. L'Hash può avere collisioni anche con oggetti diversi per natura della funzione di hash. L'equals è \"più pesante\" poiché controlla in maniera totale campo per campo (o quelli che decidiamo noi di controllare).\r\nSe l'equals è unicamente un controllo dell'hash (senza controllare caratteristiche dell'oggetto), rischiamo di cadere nel problema delle collisioni e ottenere true anche con oggetti diversi.\r\nSe controlliamo i campi (e questi vengono generati dall'hash), abbiamo trovato una collisione di due campi diversi. Equals tornerà false, il confronto degli hashcode sarà true.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5815,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5811,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6052,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Se due oggetti dello stesso tipo hanno hashcode uguale, NON è detto che la loro comparazione restituisca true. Infatti se abbiamo: \r\nA a=new A();      a.x=1; b.y=2;      \r\nB b=new B();      a.x=2; b.y=1; \r\nQueste due classi avranno hashcode uguale ma restituiranno false se chiameremo il metodo equals(); GGWP",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5810,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5814,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6134,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In generale hashCode è un metodo della classe object che restituisce un intero, il cosiddetto \"codice hash\" ,che è legato all'oggetto sul quale viene richiamato.\r\nOgni qualvolta si effettua l'overriding del metodo equals è consigliato effettuare l'overriding anche di questo metodo tenendo presente che: se due oggetti sono uguali secondo equals, i metodi hashCode applicati a ciascuno di questi devono restituire lo stesso codice hash, dunque lo stesso intero.\r\nIl viceversa non è garantito: due oggetti che hanno lo stesso codice hash non è detto che siano uguali. Ad esempio se istanziassimo:\r\nHashSet insieme1=new HashSet();\r\nHashSet insieme2=new HashSet();\r\ne considerassimo la equals secondo cui due oggetti di tipo HashSet sono uguali se e solo se sono identici, ovvero insieme1==insieme2; in questo caso i metodi hashCode applicati ad insieme1 e insieme2 restituiscono lo stesso codice hash, cioè 0, ma insieme1 e insieme2 sono diversi, perchè puntano a due indirizzi di memoria differenti!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5816,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5812,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5760,
          "asker": {
            "courseId": 100,
            "askerId": 884,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Siano p1 e p2 due oggetti della classe Point3d i cui attributi sono identici(p1.x = p2.x, p1.y = p2.y, p1.z = p2.z), quale sarà allora il valore dell'espressione (p1 == p2) in Java? Perchè? In Java come viene stabilito che due oggetti della stessa classe sono uguali? Perchè secondo te è stato utilizzato questo tipo di approccio?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5716,
          "asker": {
            "courseId": 100,
            "askerId": 809,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è implementato il metodo equals Nella Classe object?  Per quale motivo se si usa tale metodo per confrontare due oggetti di un tipo complesso viene ritornato false anche se i due oggetti sono apparentemente uguali ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " object"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5743,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo e' possibile verificare che un elemento non sia gia' stato estratto dal banco nell'esercizio della Tombola?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "tombola"
            },
            {
              "keyword": " hashset"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5748,
          "asker": {
            "courseId": 100,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " metodo"
            },
            {
              "keyword": " coins"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5746,
          "asker": {
            "courseId": 100,
            "askerId": 751,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un hashCode? Qual'è la sua utilità?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5741,
          "asker": {
            "courseId": 100,
            "askerId": 896,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è lo scopo del metodo hashCode e perchè va sovrascritto se una classe sovrascrive il metodo equals?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 21,
          "totalRelevanceLevel": 19,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashCode"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6077,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Il metodo hashCode in generale serve per generare un codice arbitrariamente complesso a partire dallo stato di un oggetto che servirà poi nell'equals per controllare l'uguaglianza tra due oggetti oppure puó essere usato in un HashMap o in un HashSet come chiave per identificare uno o più oggetti. In particolare l'hashCode deve essere generato in modo tale che se due oggetti sono uguali sicuramente hanno stesso hashCode, ma non è vero il viceversa. È buona norma nel momento in cui si fa overriding del metodo equals della classe Object, fare overriding anche del metodo hashCode e utilizzarlo per verificare l'uguaglianza. Risulta particolarmente utile nel momento in cui ci sono molte variabili d'istanza, prima di controllare per ogni variabile d'istanza se hanno tutte lo stesso valore negli oggetti che si stanno confrontando si può effettuare una verifica  sull'hashCode che, nel caso in cui dia esito positivo, risparmia molta computazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5428,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6178,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5645,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5583,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6034,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Lo scopo del metodo hashCode è verificare la diseguaglianza di due oggetti tramite un algoritmo, ad esempio sommando le componenti degli oggetti e confrontando il risultato. Il metodo equals viene sovrascritto quando si hanno esigenze specifiche in base alle quali stabilire l'uguaglianza tra determinati oggetti, è chiaro che a questo punto è conveniente sovrascrivere anche il metodo hashCode in tal senso per ottimizzare (potenzialmente) il confronto. Infatti, hashCode permette di stabilire con sicurezza se due oggetti NON sono uguali, evitando potenzialmente uno step successivo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5643,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6180,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5426,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5581,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6081,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "L'hashCode è un metodo che data un istanza di una classe restituisce come valore di ritorno un valore hash che corrisponde a un intero, viene usato principalmente nel caso in cui si vogliano utilizzare collections basate su hash table come per esempio HashMap e HashSet per rendere più efficiente la ricerca.\r\nInoltre se il metodo equals va sovrascritto è generalmente necessario sovrascrivere anche hashCode infatti il contratto di quest'ultimo metodo dice che se due istanze risultano uguali in base a equals devono corrispondere allo stesso valore hash, quindi l'Override serve per fare rispettare la coerenza del metodo.\r\nQuesto porta a degli evidenti vantaggi come la maggior efficienza del codice e a una facilitata ricerca sulle Collections prima citate che usano i valori hash per gestire gli ogetti.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6181,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5580,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5642,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5425,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6064,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In termini di efficienza, su alcuni tipi di oggetto richiamare il metodo equals può essere molto costoso (si pensi ad esempio al confronto di due strutture dati, come due liste o due alberi, che contengono molti elementi). Il metodo hashCode serve ad arginare questo problema; associando ad ogni oggetto un valore intero rende possibile verificare velocemente se due oggetti sono diversi confrontando il loro hashCode: se due oggetti hanno hashCode diverso, saranno diversi (una delle specifiche richieste al metodo hashCode di essere consistente, cioè di restituire sempre lo stesso valore se richiamato sullo stesso oggetto) e si può quindi evitare di richiamare equals. Non è vero il viceversa (oggetti diversi possono avere lo stesso hashCode), e in tal caso bisogna chiamare il metodo equals.\r\nIl metodo hashCode va sovrasctitto se si si sovrascrive equals per migliorare l'efficienza del codice, perché in alcuni casi (costruzione di hashSet o hashMap) Java \"si aspetta di trovarlo\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5644,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6183,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5427,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5582,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6084,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Di default il metodo hashCode() ritorna un intero basato sull'identità dell'oggetto quindi indpendemente dal valore dei suoi attributi;esso rimarrà tale durante tutta la vita dell'oggetto.Per esempio se creo una classe A, un hashset che contiene oggeti di tipo A e inserisco un elemento x.Se provo a cercare se l'oggetto y(che ha gli stessi valori di x) nell'hashset appena creato mi ritornerà null come risultato perchè gli hashcode dell'elemento x e dell'oggetto y sono diversi;diventa quindi necessario dire al compilatore come calcolare gli hashcode,tramite un override, in modo tale che non si verichino questo tipo di errori.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5578,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5640,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6182,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5423,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6071,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 766,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo hashCode ha lo scopo di eliminare degli elementi per facilitare la comparazione e quindi di evitare la collisione tra istanze diverse.\r\nVa sovrascritto perchè cambia in base alle proprietà degli oggetti presi in considerazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5641,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6179,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5424,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5579,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5668,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è HashCode, a cosa serve e come si implementa ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5739,
          "asker": {
            "courseId": 100,
            "askerId": 814,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra due oggetti uguali e due identici? ",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Oggetti"
            },
            {
              "keyword": " Equals "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6106,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Prendiamo come esempio\r\nclass Punto{\r\nint x;\r\nint y;\r\n}\r\nNel main dichiaro due oggetti di tipo Punto, ossia p1 e p2, assegnando ad ognuno di essi lo stesso valore di x e y. \r\nIn Java due oggetti si dicono uguali se puntano(si riferiscono) allo stesso spazio di memoria. Questo tipo di uguaglianza prende il nome di uguaglianza superficiale.\r\nIn questo caso se dovessi verificare l'uguaglianza con p1==p2 avrei come risultato un false visto che p1 e p2 si riferiscono a due spazi differenti. Adesso nel main dichiaro una variabile di tipo Punto(nota bene:tipo) con nome p3 alla quale assegno p1. Se verifico l'uguaglianza con p1==p3 otterrei un true perché i due punti si riferiscono allo stesso spazio di memoria.\r\nVerificare l'identicità tra due oggetti significa verificare l'uguaglianza profonda tra essi, ossia controllare che ogni singola variabile coincida tra i due oggetti. In Java bisogna fare l'Override del metodo equals() e stabilire in che modo bisogna fare il confronto tra due oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5290,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5886,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5368,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5864,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6086,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Due oggetti sono uguali se possiedono almeno una caratteristica rilevante in comune. La rilevanza di tale caratteristica dipende dalla scelta di uno standard di valutazione, in base al quale gli oggetti in questione sono considerati uguali.Identità indica che due o più oggetti hanno in comune tutte le caratteristiche,indica cioè,che quegli oggetti sono uno e lo stesso oggetto. In java la questione si complica un po'.Si pensi a due oggetti relativamente identici come \r\nPersona p1 = new Persona(\"Mario\", \"Rossi\")\r\nPersona p2 = new Persona(\"Mario\", \"Rossi\")\r\nche confrontati p1==p2 danno false(p1,p1 puntano zone di memoria diverse)\r\nE' necessario usare il metodo equals che confronta gli oggetti in merito al contenuto dell?oggetto.A variare dell'implementazione di questi,si possono ottenere risultati diversi(getClass,instanceof). Due oggeti non saranno mai identici a meno che non condividano la stessa zona di memoria, equals però è ugualianza più vicina che ci sia.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5292,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5883,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5366,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5861,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6076,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Due oggetti sono uguali quando hanno lo stesso valore. La sintassi per poterlo verificare è: System.out.println(p1.equals(p2));  Si dicono identici, invece, quando si riferiscono allo stesso oggetto, hanno quindi lo stesso indirizzo. La sintassi di verifica è: p1==p2.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5884,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5289,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5367,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5862,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6137,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Identici vuol dire che raggiungono la stessa zona di memoria. Uguali significa invece che sono oggetti dello stesso tipo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5885,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5291,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5863,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5365,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5670,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la sostanziale differenza tra il metodo boolean equals (Object o) e l'utilizzo dell'operatore ==? ",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " =="
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6033,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Quando applicato a oggetti, l'operatore == si limita a confrontare i loro indirizzi di memoria. Spesso però due istanze distinte (e dunque poste in locazioni di memoria diverse) risultano essere logicamente uguali (per esempio, perché tutte le loro variabili d'istanza sono uguali). Per questo motivo gli oggetti andrebbero sempre confrontati con il metodo equals, in quanto esso permette alle singole classi di sovrascriverlo per definire il loro significato di \"uguale\".\r\nL'implementazione \"base\" del metodo, fornita dalla classe Object, si limita ad applicare l'operatore ==.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5412,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5570,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5395,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5277,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5573,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6002,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6100,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Equals è un metodo della classe object. Se esso non viene sovrascritto nella sottoclasse di object a cui appartegono gli ogetti che si intende comparare, non vi è nessuna differenza con l'operatore ==. Comunemente invece il metodo equals viene sovrascritto per avere un test di ugualianza ovvero non la semplice ugualianza di indirizzi di memoria che verifica ==.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5572,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5569,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5279,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5394,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6001,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5411,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6074,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java l'operatore == è utilizzato per comparare due oggetti, questo mi restituisce True se e solo se il primo oggetto e il secondo sono il medesimo altrimenti ritorna False.\r\nPer equals è possibile fare Overload o Override per definire che se ogni variabile dell'oggetto è uguale all'altro oggetto allora i due oggetti sono uguali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6000,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5574,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5413,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5396,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5571,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5278,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5729,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono utilizzati i package? e a cosa servono?\r\nAl loro interno posso avere funzioni solo public o anche private?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "package"
            },
            {
              "keyword": " public o  private"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5776,
          "asker": {
            "courseId": 100,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'esempio \"Tombola\", come agisce il package java.util e in che modo esso viene implementato? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java.util"
            },
            {
              "keyword": " java collections framework"
            },
            {
              "keyword": " tombola"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5778,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos?è e quali possono essere gli algoritmi per generare un numero casuale o meglio pseudo-casuale con un computer? Quali sono le problematiche nel farlo e perché non è realmente casuale? Cosa si intende per seme?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Random"
            },
            {
              "keyword": " Numbers"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5737,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai viene istanziata una classe Common nella tombola? Qual e' il suo utilizzo e la visibilità delle sue variabili di istanza?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Tombola"
            },
            {
              "keyword": " Common"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5727,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i pro e i contro nell'usare l'overloading invece che l'overriding per il metodo equals delle classi definite dall'utente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5777,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è utile avere un metodo equals() con il quale confrontare due oggetti, invece dell'espressione \"a == b\"?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " confronto"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6059,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La differenza sostanziale tra i due è che con il metodo equals noi possiamo equiparare due oggetti e controllare se hanno gli stessi valori in base al criterio di uguaglianza che stabilisce il programmatore. Mentre l'== controlla che l'indirizzo di una variabile (a) sia uguale all'indirizzo di un altra variabile (b).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6164,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5471,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5963,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5807,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6141,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6101,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il metodo equals() della Superclasse (Object) che viene implementata per default usa la logica dell'espressione \"a==b\", quindi si confrontano due locazioni di memoria, e ritorna true se e solo se le variabili si riferiscono alla stessa locazione di memoria, quindi se sono lo stesso oggetto (identici). Però ci sono tanti casi in cui può essere più utile fare il test di \"uguaglianza\" tra gli oggetti. In questi casi si fa l'overriding del metodo equals().Cosi possiamo usare una logica di confronto secondo criteri più specifici che a noi possa interessare a secondo del caso. Per esempio si possono confrontare i campi della classe uno alla volta e il risultato sara \"true\" se i campi di un oggetto coincidono(sono uguagli) a i campi del altro. Es:la classe Integer usa il metodo equals() per un confronto puro numerico. Se il metodo equals() viene sovrascritto bisogna fare l'override anche del metodo hashCode() visto la implicazione che se a.equals(b) da true => a.hashCode() ==b.hashCode().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5473,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6167,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5806,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6144,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5964,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6091,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Utilizzare l'espressione \"a == b\" per confrontare due variabili equivale a confrontare il valore contenuto in esse. Nel caso di variabili di tipo non primitivo, questo si traduce nel confronto dell'indirizzo in memoria degli oggetti ai quali si riferiscono.\r\nPerciò, a e b sono uguali se e solo se sono (puntano a) lo stesso oggetto.\r\nSpesso, però, può essere utile una definizione di equivalenza meno stretta. A tale scopo la classe Object implementa il metodo \"equals(Object o)\", che viene ereditato da ogni classe. Di base, questo metodo funziona come l'operatore binario \"==\", ma può essere ridefinito con l'override. In questo modo è possibile creare una nuova relazione di equivalenza tra gli oggetti della nostra classe adatta al nostro progetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5962,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6166,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5474,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6143,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5805,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6042,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "L'operatore \"==\" restituisce TRUE solo nel caso in cui due oggetti sono IDENTICI, cioè se entrambi puntano alla stessa area di memori.\r\nPer confrontare due oggetti, quindi, risulta utile l'implementazione (OVERLOADING) del metodo EQUALS tramite cui possiamo andare a verificare l'uguaglianza di ogni singolo attributo degli oggetti e determinare quindi se sono UGUALI.\r\nPuò tornare comodo all'interno del metodo EQUALS che andiamo ad implementare, effettuare dei controlli supplementari oltre al semplice confronto :\r\n - controllare la compatibilità della classe e del tipo OBJECT passato come parametro;\r\n - verificare che l' OBJECT non sia di valore NULL.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5472,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6142,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5804,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6165,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5961,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5728,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo è possibile modificare un set in modo tale da poter inserire due elementi uguali?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " set"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5676,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono in Java i due modi per ordinare degli oggetti? In cosa consistono nello specifico?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 24,
          "totalRelevanceLevel": 23,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "comparable interface"
            },
            {
              "keyword": " comparator interface"
            },
            {
              "keyword": " ordinamento"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6110,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I due modi per ordinare oggetti in Java sono l'interfaccia Comparable e l'interfaccia Comparetor. L'interfaccia Comparable fornisce un ordine naturale sulle classi che la implementano e permette agli oggetti della classe di essere ordinati automaticamente; essa ha il metodo compareTo(Object o) che permette di comparare quest'oggetto con l'oggetto o, e restituisce un intero negativo, zero o un intero positivo se quest'oggetto sia minore, uguale o maggiore di quello specificato. \r\nL'interfaccia Comparator permette anch'essa di ordinare oggetti, ma dà al programmatore completo controllo sull'ordinamento di questi (è quindi utile nel caso si voglia ordinare non secondo l'ordine naturale); ha il metodo compare(T o1, T o2) che permette di comparare i due argomenti, ed esso può essere sovrascritto a seconda dell'utilizzo che se ne deve fare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5710,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5589,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5822,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5553,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6118,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "In Java esistono due modi per ordinare degli oggetti: la comparable interface e la comparator interface.\r\n\r\nLa comparable interface ordina gli oggetti della collection secondo l'ordine naturale delle cose: per esempio, se si tratta di String ordina in ordine alfabetico, se si tratta di date in ordine cronologico.\r\nIl metodo compareTo ha come parametro un Object e confronta quindi l'oggetto della collection con lo specifico oggetto passato come Object.\r\n\r\nLa comparator interface invece permette al programmatore di specificare in che modo ordinare gli oggetti, dandogli pieno controllo sull'ordinamento della collection.\r\nIl metodo compare ha invece come parametri due oggetti. Su questi due oggetti il programmatore andrà a specificare l'ordinamento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5709,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5821,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5590,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5554,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6093,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "I 2 modi per ordinare gli oggetti in java sono l'interfaccia Comparable e l'interfaccia Comparator.\r\nL'interfaccia Comparable ordina gli oggetti in modo \"naturale\", ossia in ordine crescente (alfabetico in caso siano stringhe, numerico in caso siano numeri, in ordine cronologico se si tratta di Date) tramite il metodo Collections.sort(List) o per esempio tramite il metodo int compareTo(Object o) (in quest'ultimo caso ordine i 2 oggetti in questione).\r\nL'interfaccia Comparator, invece, permettono un ordine totale sugli oggetti che normalmente non avrebbero un loro ordinamento naturale. Esso avviene tramite il metodo int compare (Object p1, Object p2). Il compilatore confronta tra loro p1.x e p2.x. In caso essi siano coincidenti, confronta tra loro p1.y e p2.y.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5592,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5556,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5825,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5713,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6113,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un insieme di oggetti per poter essere ordinato tramite un algoritmo, deve seguire una certa relazione d'ordine, che può essere specificata implicitamente nel tipo d'oggetto contenuto nell'insieme oppure può essere fornita esternamente all'algoritmo. In questo caso java ci mette a dispozione due semplici interfacce per conseguire questo scopo: java.lang.Comparable e java.util.Comparator. Queste due interfaccie ci permettono di esprimere la relazione d'ordine di un determinato oggetto in due maniere strutturalmente diverse. Infatti abbiamo due tipologie di ordinamento tramite la classe Collections:\r\n\r\n-static void sort;\r\n-static void sort;\r\n\r\nIl primo metodo si avvale dell'interfaccia Comparable (che ci permette di implementare il cosiddetto ordinamento naturale di un oggetto) definita negli oggetti contenuti nella List per ordinare l'insieme, mentre il secondo metodo si avvale del Comparator (fornisce un unico metodo molto simile al compareTo() ) passato come secondo parametro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5557,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5711,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5823,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5593,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6140,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I due metodi per ordinare gli oggetti in Java sono definiti dalle interfacce Comparable e Comparator. La prima ha come argomento un oggetto dello stesso tipo di quelli che si vogliono confrontare e quindipermette di comparare l'istanza stessa con un altro oggetto; è necessario modificare la classe su cui si lavora in modo tale che essa implementi l'interfaccia Comparable e ordini la lista secondo la logica del metodo compareTo che viene di volta in volta sovrascritto in maniera conveniente; si parla in questo caso di \"ordine naturale\".\r\nInvece l'interfaccia Comparator permette di ordinare gli oggetti secondo un numero differente di criteri; in questo caso è necessario creare una nuova classe che implementi tale interfaccia, che ha per argomento due oggetti che possono anche essere diversi e quindi non misurabili in \"modo naturale\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5555,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5824,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5712,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5591,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6066,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I due modi per ordinare oggetti in Java sono: l'interfaccia Comparable e l'interfaccia Comparator. Nello specifico con la Comparable si otterrà automaticamente un ordine naturale sugli oggetti della classe in questione. Con la Comparator il programmatore avrà controllo completo su come ordinare gli oggetti della classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5558,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5594,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5820,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5708,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5700,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale utilità ha l'utilizzo del metodo HASHCODE? Può essere utilizzato solo questo metodo per il confronto tra due oggetti o vi è bisogno anche del metodo EQUALS? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashCode"
            },
            {
              "keyword": " Uguaglianza"
            },
            {
              "keyword": " Identicità"
            },
            {
              "keyword": " Equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5720,
          "asker": {
            "courseId": 100,
            "askerId": 853,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il comando equals()? Qual'è la differenza fra equals() ed il costrutto \"==\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals()"
            },
            {
              "keyword": " eguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5690,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Dare una breve definizione e soffermarsi sul compito che svolge il metodo \"equals ()\"",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " fondamenti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5733,
          "asker": {
            "courseId": 100,
            "askerId": 792,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa serve il modificatore static?\r\nUna variabile d'istanza è accessibile all'interno di un metodo con modificatore static?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 19,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " variabile di istanza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6107,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'effetto di dichiarare un metodo static è quello di rendere il metodo di fatto comune a tutte le istanze della classe. \r\nI metodi statici non sono associati ad una istanza ma solo ad una classe. Quindi non potranno interagire con le variabili di istanza, ma solamente con quelle statiche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5851,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5449,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5262,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5453,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6080,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 798,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'effetto di dichiarare un metodo static è quello di rendere il metodo di fatto comune a tutte le istanze della classe.\r\nuna variabile d'istanza è accessibile nel metodo static in modo da eseguire operazioni su di essa e se il metodo static è visibile per quella istanza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5454,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5853,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5263,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5450,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6035,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I metodi statici non sono associati ad una istanza, ma solo ad una classe e quindi non riescono ad interagire con le variabili di istanza, ma solamente con quelle statiche.\r\nSe vogliamo che una variabile sia la stessa per tutte le istanze di una classe sappiamo che deve essere definita static.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5264,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5852,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5451,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5455,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6073,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Il modificatore static è un istruzione molto potente.\r\nSe viene dichiarato un metodo static questo sarà utilizzabile senza dover istanziare la classe che contiene tale metodo :\r\n\r\npublic class Prova {\r\n public static int metodo (){\r\n     //codice del metodo\r\n   }\r\n}\r\n\r\nIn questo modo per utilizzare metodo normalmente dovremmo istanziare una nuova classe e poi richiamare la procedura :\r\n  Prova p = new Prova();\r\n  p.metodo();\r\n\r\nMa visto che il metodo è static basta semplicemente fare :\r\n  Prova.metodo();\r\nsenza istanziare la classe.\r\nQuando invece si usa il modificatore static su una variabile di istanza questa diventa \"comune\" a tutte le istanze della classe. Questa significa che se istanzio due oggetti della stessa classe e andrò a operare sulla variabile static prima su un oggetto e poi sull'altro questa verrà modificata perché opero sempre sulla stessa variabile.\r\n\r\nLa risposta alla seconda domanda è no. Semplicemente perché in un metodo static posso usare qualsiasi variabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5261,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5448,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5452,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5850,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5753,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per uguaglianza? perche deve essere testata e a cosa serve il metodo equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Uguaglianza"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5663,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è consigliabile effettuare l'overriding del metodo equals della classe Object al posto di crearne una nuova con firma diversa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " override"
            },
            {
              "keyword": " overload"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5775,
          "asker": {
            "courseId": 100,
            "askerId": 897,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra il metodo equals() e l'operatore ==?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5718,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, che cosa ottengo (output) in una condizione if con l'operatore '='? E con l'operatore '==??",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Uguaglianza"
            },
            {
              "keyword": " operatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5662,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Qualo caratteristiche deve avere la funzione equals quando viene reinizializzata in una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "override"
            },
            {
              "keyword": "lezione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5671,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è più comodo usare l'overloading invece che l'overriding del metodo equals? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " ereditarietà"
            },
            {
              "keyword": " overriding"
            },
            {
              "keyword": " overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5724,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Differenza tra uguale e una coppia",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Uguaglianza"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5677,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cosa accade quando poniamo un oggetto o2, di tipo \"Tipo\", uguale ad un oggetto o1 sempre di tipo \"Tipo\":\r\n\r\n...\r\npublic static void main(){\r\n...\r\nTipo o1, o2;\r\no1 = new Tipo();\r\no2 = o1;\r\n...\r\n}\r\n...\r\n\r\nSe, inoltre, creassimo due oggetti dello stesso tipo, cosa dovremmo fare per poterli confrontare tra loro e per poter dire correttamente se sono uguali? E per dire che sono identici?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "referenze"
            },
            {
              "keyword": "oggetti"
            },
            {
              "keyword": "uguali"
            },
            {
              "keyword": "identici"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5736,
          "asker": {
            "courseId": 100,
            "askerId": 922,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, è possibile implementare degli array che cambiano la loro dimensione durante l'esecuzione del programma? Se sì, come?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " Array"
            },
            {
              "keyword": " implementazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6043,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 824,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Gli array di default di java non permettono di modificare la loro dimensione durante l'esecuzione del programma. È però possibile farlo con alcuni trucchetti oppure con delle strutture dati pronte all'uso che Java ci mette a disposizione.\r\n1) Un array dinamico potrebbe essere concepito come una classe contenente un array statico ed alcuni metodi tali da creare un nuovo array più grande o più piccolo, nel momento dell'aggiunta o rimozione di elementi, che sostituisca quello precedente. Chiaramente deve essere effettuata anche la copia degli elementi dal vecchio al nuovo array.\r\n2) Utilizzare strutture dati più complesse messe a disposizione da Java come Liste e Set. Queste permettono di creare array ordinati e non senza dover specificare le dimensioni dell'array stesso. Inoltre forniscono metodi intuitivi per aggiungere e rimuovere elementi. L'unica piccola pecca è che bisognerà creare una propria classe per i tipi di dato primitivi, in quanto in ingresso vengono accettati solo oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5539,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5946,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5929,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5874,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5900,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6061,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 925,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì, è possibile. Per avere un vettore dalla dimensione modificabile in fase di esecuzione, bisogna ricorrere a due classi del package java.util: la classe Vector e la classe ArrayList. \r\nNella classe Vector viene creato un vettore caratterizzato da una dimension (size) e da una capacità (capacity). L'ArrayList, invece, è una versione migliorata di quest'ultima e viene data meno importanza al concetto di capacity.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5930,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5944,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5901,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5541,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5875,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6105,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java un array, una volta inizializzato, ha dimensione fissa. Se si vuole ridimensionare un array a, è possibile fare questo: 1)Inizializzare un nuovo array b più grande. 2)Copiare gli elementi dell' array vecchio in quello nuovo. 3)Assegnare all' array vecchio la reference dell' array nuovo, ovvero a = b . Se non si vuole creare una classe nuova avente un metodo simile, un' impementazione già pronta è la classe ArrayList del framework Collections, che espande da sola l'array se pieno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5945,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5931,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5540,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5902,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5876,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6062,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si,  è possibile implementare degli array che cambiano la loro dimensione durante l'esecuzione del programma, attraverso gli array dinamici.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5903,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5877,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5932,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5947,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5542,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5665,
          "asker": {
            "courseId": 100,
            "askerId": 756,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali possono essere i vantaggi nell'utilizzare delle variabili di tipo static?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 10,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6030,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Il vantaggi nell'utilizzare delle variabili static sono la possibilità di condividere informazioni tra le diverse istanze di una stessa classe e di poter accedere alle variabili statiche di una classe senza aver bisogno di creare alcuna istanza della suddetta classe (accedo ad esse attraverso il nome della classe, es: Classe.varStatica).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5468,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5957,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5761,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6072,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Le variabili di tipo static permettono la creazione di un codice molto flessibile ed efficiente. Static e' un modificatore che rende la memorizzazione dell'oggetto o tipo di dato primitivo a cui si riferisce differente rispetto allo standard. Infatti se si riferisce ad un tipo di dato primitivo, la variabile sara' accessibile e modificabile da tutti gli oggetti della stessa classe. Se invece static si riferisce ad un metodo, questo sara' utlizzabile anche non instanziando nessun oggetto per quella classe, risparmiando memoria e efficienza computazionale. Il metodo static non puo' comprendere nel suo codice dati che appartengono alla classe perche' non viene passato all'interno del metodo l'oggetto 'this' e quindi risulta piu' veloce il passaggio della funzione.\r\n\r\npublic static int =0; \r\n\r\npublic static double random(); ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5469,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5759,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5956,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6026,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili istanziata static non puo` essere modificata durante l'esecuzione, questo permette al programmatore di utilizzarla per contenere dei valori che non si vogliono o devono modificare durante l'esecuzione, es. il classico Pi greco.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5955,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5470,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5760,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5691,
          "asker": {
            "courseId": 100,
            "askerId": 788,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che strumenti ha un programmatore Java a sua disposizione per poter definire il confronto (uguaglianza, identicità e paragone) tra due oggetti? Elencali e definisci se sono interfacce, operatori o metodi [e di quale classe].",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "confronto"
            },
            {
              "keyword": " comparable"
            },
            {
              "keyword": " equals"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5709,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come posso generare un numero casuale in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "random"
            },
            {
              "keyword": " util"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5686,
          "asker": {
            "courseId": 100,
            "askerId": 925,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Per cosa vengono utilizzate le interfacce Comparable e Comparator? In cosa differiscono?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "comparable"
            },
            {
              "keyword": " comparator"
            },
            {
              "keyword": " oggetti"
            },
            {
              "keyword": " ordinamento"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6032,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Entrambe le interfacce servono per implementare nel codice metodo e/o classe per ordinare secondo dei criteri definiti dall'utente o dalla macchina, una List di oggetti. \r\nNel primo caso si parla di un metodo che sistema la nostra list o in automatico(per esempio in una list di stringhe, lo ordina in ordine alfabetico) o implementando tramite override il criterio che deve seguire per l'ordinamento. \r\nIl comparator invece serve per ordinare secondo più criteri e può essere implementato come classe assestante in un file .java o come classe interna alla classe di cui di andrà a fare la lista di oggetti",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6026,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5568,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6132,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 771,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Implementare un Comparator significa creare una classe che implementa un metodo compare(Object, Object), questo metodo restituisce -1 se il primo oggetto è da considerarsi minore rispetto al secondo, 0 se pari e 1 se superiore. L'istanzazione di un Comparator viene solitamente usata passandola come secondo parametro al metodo sort della classe Collections, per \"comunicare\" come confrontare gli oggetti contenuti nella lista da ordinare.\r\nUna classe che implementa l'interfaccia Comparable implementa il metodo compareTo(T), dove T è la classe in questione. Questo metodo permette un ordinamento totale degli oggetti di questa classe, restituendo -1 se l'oggetto su cui questo metodo è chiamato è minore rispetto al paramentro attuale, 0 se pari e 1 se superiore. Le liste e gli array di una classe che implementa questa interfaccia possono essere ordinate dal metodo sort senza il bisogno di passare come secondo parametro l'istanza di una implementazione di un Comparator.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6027,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5567,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6036,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Esse sono utilizzate per l'ordinamento di gruppi di elementi. \r\nComparable ordina gli elementi secondo il loro \"ordine naturale\".\r\nComparator invece da libertà al programmatore di decidere come ordinare gli elementi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6025,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5566,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5685,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Consideriamo il metodo equals della classe Studente sotto riportata.\r\n\r\npublic class Studente {\r\n  protected String nome\r\n                 , cognome\r\n                 , matricola\r\n                 ;\r\n  .\r\n  .\r\n  .\r\n\r\n  public boolean equals(Object s) {\r\n    boolean eq = false;\r\n    if(s != null || s instanceof Studente) {\r\n      eq = (this.nome = s.nome && this.cognome = s.cognome && this.matricola = s.matricola)\r\n    }\r\n    return eq;\r\n  }\r\n\r\n  .\r\n  .\r\n}\r\n\r\nIl metodo è implementato in modo corretto? Motivare la risposta ed eventualmente correggere eventuali errori.\r\n\r\nSe chiamo il metodo equals passandogli come parametro un oggetto di tipo Universitario, che estende la classe Studente, come posso essere sicuro che l'equals mi ritorni un valore false, sapendo che (in questo caso) uno Studente deve essere un oggetto diverso da Universitario (nonostante sussista la relazione IS-A)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " instanceof"
            },
            {
              "keyword": " getClass"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5774,
          "asker": {
            "courseId": 100,
            "askerId": 772,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può implementare un modo per determinare in che modo devono essere ordinate varie istanze di una classe ?",
          "totalDifficultyLevel": 22,
          "totalInterestingnessLevel": 23,
          "totalRelevanceLevel": 25,
          "numEvaluators": 7,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Object ordering"
            },
            {
              "keyword": " comparablr"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6108,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Esistono due interfacce da implementare (E Da Sovrascrivere ) Chiamate comparable e comparator. La principale differenza sta nel fatto che la comparable viene implementata direttamente bella classe in cui viene usata mentre la comparator viene implementata in una classe esterna così da poter essere usata su diverse istanze di diverse classi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5611,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6103,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6104,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Il criterio di ordinamento di elementi appartenenti ad una collection si può specializzare implementando le interfacce comparable o comparator. E possibile infatti ridefinirne l'algoritmo di comparazione tra due oggetti appartenenti alla collection. La differenza si presenta nel fatto che l'interfaccia comparator effettua un confronto su due oggetti dello stesso tipo. La nuova classe comparator sarà poi passata come parametro al metodo di sorting della collection scelta. La classe comparable invece è relativa ad una classe che chiamerà il metodo comparable su di un altra classe dello stesso tipo su cui effettuare il confronto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6105,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5610,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6115,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per ordinare due istanze di una classe ci sono due principali metodi su cui basarsi:\r\n1. Comparable interface = è un'interfaccia (quindi da implementare) che ordina gli oggetti che vogliamo riordinare seguendo un ordine naturale.\r\n2. Comparator interface = è un'interfaccia (quindi anch'essa da implementare) che ordina gli oggetti secondo una chiave scelta dal programmatore, che quindi ha facoltà di decidere secondo quale logica verranno riordinati gli oggetti (esempio concreto: una query su un database).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6102,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5607,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6121,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 802,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per ordinare varie istanze, si può usare l'array con tutti i suoi metodi annessi, sort etc",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6107,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5609,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6089,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ci sono due modi per ordinare oggetti:\r\nL'interfaccia Comparable, la quale fornisce un ordinamento naturale alle sue sottoclassi (ordine lessicografico, cronologico ecc..)\r\n\r\nL'interfaccia Comparator invece lascia completa autonomia al programmatore riguardo al modo di ordinare oggetti ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6108,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5612,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6055,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I due metodi per ordinare le varie istanze di una classe è utilizzando le interfacce comparable e comparator. La primà da un'ordinamento naturale degli oggetti (e' la stessa JVM che ordina in base al valore degli elementi trovati nell'istanza). Utilizzando la comparator dà invece completo controllo al programmatore sulle chiavi di ordinamento necessarie al progetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5606,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6104,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6082,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Per ordinade varie istanze di una classe posso usare le interfaccie 'Comparator' o 'Comparable'.\r\n\r\nEntrambi forniscono all'utente la possibilità di specificare come due oggetti devono essere comparati. Dopo il confronto entrambe restituiscono un int che descrive la relazione tra i due oggetti:\r\n- 0, se uguali;\r\n- int positivo, se il primo è maggiore del secondo;\r\n- int negativo, se il primo è minore del secondo.\r\n\r\nIl metodo compare() permette di confrontare due oggetti di qualsiasi tipo lasciando al programmatore la possibilità di specificare come ciò deve avvenire. Il metodo compareTo() invece permette di confrontare due oggetti dello stesso tipo usando l'ordine naturale del tipo di oggetto passato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5608,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6106,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5704,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponiamo di creare una classe Strada, una classe Ponte e di fare l'overriding del metodo equals() la classe casa. Sia poi\r\n\r\nStrada s = new Strada();\r\n\r\nPonte p = new Ponte();\r\n\r\nQuale metodo equals() verrà richiamato al comando p.equals(s) ? e quale invece al comando s.equals(p)? Motivare le risposte.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " overriding"
            },
            {
              "keyword": " method"
            },
            {
              "keyword": " hierarchy"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5681,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si fa ovverriding sul metodo equals, bisogna anche ridefinire il metodo hashCode di object? Motivare la risposta.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashCode"
            },
            {
              "keyword": "equals"
            },
            {
              "keyword": "ovverriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6120,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Sì. I metodi equals() e hashCode() forniti della superclasse Object si basano entrambi sugli indirizzi di memoria, equals() restituisce true solo se le due istanze si riferiscono allo stesso indirizzo di memoria (quindi sono fisicamente la stessa cosa) e hashCode() restituisce l?indirizzo di memoria convertito in int. Il contratto generale prevede che qualora equals() restituisca true allora hashCode deve restituire lo stesso valore (ma non il contrario). Viene da se che ridefinendo equals() sulla base di altre inormazioni contente nella classe in esame è necessario ridefinire anche hashCode sempre sulla base delle stesse informazioni o un sottoinsieme di esse. Un metodo hashCode() che restituisce in ogni caso lo stesso valore non è concettualmente sbagliato ma altamente inefficiente, al contrario un algoritmo hashcode perfetto (ovvero che genera valori diversi in tutti i casi in cui equals() restituisce false) è plausibile ma perde di significato e generalmente è inefficiente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5997,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5393,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5515,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5978,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6133,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 745,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Secondo convenzione, ogni classe che fa overriding del metodo equals deve anche fare overriding del metodo hashCode.\r\n\r\nCi sono 2 implicazioni vere: \r\n- se un oggetto invoca il metodo equals su un altro oggetto e questo restituisce true, allora l'hashcode tra i due sarà uguale;\r\n- se l'hashcode è diverso, allora equals restituirà false.\r\nIl contrario delle suddette implicazioni non è vero.\r\n\r\nUn esempio in cui l'hashcode interviene semplificando le cose è nella ricerca di 2 oggetti uguali. È vero che, se 2 oggetti hanno hashcode uguale, non implica che equals restituisca true (cioè che gli oggetti siano uguali), ma sappiamo che 2 oggetti con hashcode diversi sono sicuramente diversi, per cui la ricerca risulta più veloce, perché è stata fatta a monte una scrematura, prima di confrontare gli oggetti per cui equals restituisce true.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5979,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5998,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5390,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5512,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6117,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Dal momento che il metodo hashCode() ritorna un intero che dovrebbe indicare univocamente un oggetto e che il metodo equals() serve per verificare se due oggetti sono uguali segue che se due oggetti sono effettivamente uguali allora lo sono anche i loro hash e, viceversa, se i due oggetti sono diversi, lo devono essere anche i loro hash. Pertanto se si fa overriding di equals() è necessario fare overriding anche di hashCode(), poiché sebbene sia raro impiegare direttamente il metodo hashCode(), questo viene utilizzato di implicitamente da alcune classi (come Hashtable e HashMap) e pertanto in un buon programma è necessario che sia implementato correttamente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5999,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5513,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5391,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5980,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6085,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Si, ogni volta che si sovrascrive il metodo equals per utilizzarlo in base alla propria struttura dati è necessario ridefinire alche l'hashCode. Questo perchè i due metodi sono strettamente correlati tra di loro, ovvero prima di eseguire l'equals per comparare due oggetti innanzitutto viene controllato che il valore di ritorno del loro hashcode sia lo stesso e solo dopo questo controllo verrà invocato e controllerà in base a come è stato definito l'uguaglianza tra gli stessi. Nel caso in cui non venga sovrascritto anche l'hashCode i risultati possono essere decisamente sballati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5514,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5392,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5977,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5996,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5708,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il main è di tipo static?",
          "totalDifficultyLevel": 1,
          "totalInterestingnessLevel": 4,
          "totalRelevanceLevel": 5,
          "numEvaluators": 1,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "tipo"
            },
            {
              "keyword": " static"
            },
            {
              "keyword": " main"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6130,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "I metodi static possono essere raggiunti anche senza aver instanziato nulla; \r\nnon esistono istanze della classe \"main\"; \r\ndi conseguenza il \" main \" deve essere un metodo static.\r\n\r\nIn altri termini, essendo il main un metodo privo di istanze, l'unico modo perché possa essere utilizzato è quello di fornirgli il modificatore static.",
              "notes": "-",
              "rating": 0,
              "coins": []
            }
          ]
        },
        {
          "questionId": 5706,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Il metodo \"equals\", ereditato dalla classe Object, di base controlla se entrambe le variabili si riferiscono allo stesso oggetto. In genere, quindi, il suo utilizzo dovrebbe essere equivalente ad usare l'operatore == con le due variabili. Qual è, allora, l'utilità di questo metodo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5711,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella implementazione del gioco Tombola delle slide della lezione 11 si importa la classe Iterator, dove è usata all'interno del programma? A cosa serve?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "iterator"
            },
            {
              "keyword": " tombola"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5738,
          "asker": {
            "courseId": 100,
            "askerId": 811,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di aver implementato \"equals\" come una funzione, invece di un operatore? Cioè, perché Java ha una funzione \"equals()\" invece di un operatore \"~==\" per testare l'uguaglianza di due oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " operatori"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5722,
          "asker": {
            "courseId": 100,
            "askerId": 861,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che collegamento vi è tra l'utilizzo del metodo equals e l'Hashcode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5723,
          "asker": {
            "courseId": 100,
            "askerId": 907,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Il metodo equals, sua definizione e utilizzo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5673,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve il modificatore static? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "modificatori"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5749,
          "asker": {
            "courseId": 100,
            "askerId": 862,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra il metodo get class getClass e il metodo instanceof, come cambia il metodo equals in riferimento a l'uso di questi due metodi?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 15,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "getClass"
            },
            {
              "keyword": "instanceof"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6103,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Entrambi i metodi getClass e instanceof restituiscono un boolean e vengono utilizzati in situazioni differenti nell'implementazione dell' override dell'equals di Object: l'instanceof ritorna true se esiste la relazione IS-A, ovvero se B extends A, infatti, (o instanceof B) mi dà true; il metodo getClass, invece, mi specifica se un (Object o) che passo come argomento all'override di equals appartiene o meno alla classe di interesse, infatti, if(o getClass() !=this.getClass()) return false; <--Questo è il controllo che faccio subito dopo aver controllato che If(o==null) return false; e subito prima del confronto sul parametro che voglio controllare all'interno dell'equals ovverrided.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5914,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5339,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5667,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5858,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5346,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6128,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Ci sono sostanzialmente due differenze riguardo la comparazione di due oggetti con l'implementazione di equals(). Una classe può permettere la comparazione  tra oggetti mixati di super e subclassi tramite l'operatore instanceof, oppure una classe può trattare oggetti di differenti tipi come non uguali tramite l'utilizzo di getClass().\r\nGeneralmente un'implementazione di equals() mediante getClass() è più robusta.\r\n\r\nL'utilizzo di instanceof è corretto solo per 'final class' oppure se il metodo equals() è dichiarato come 'final' nella superclasse. Questo significa che le sottoclassi potranno aggiungere solo funzionalità che saranno irrilevanti per lo stato o il comportamento dell'oggetto.\r\nL'utilizzo di getClass() non permette la comparazione tra oggetti di sub e superclassi, anche se la subclasse non aggiunge alcun campo o modifica di override a equals().\r\n\r\nEs. \r\nif (staff[1] instanceof Manager) {etc}\r\n\r\nSe staff[1] è un oggetto di una sottoclasse di Manger, instanceof ritorna VERO.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5912,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5344,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5336,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5856,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5665,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6083,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Prima di tutto, instanceof è un operatore e non un metodo. \r\n\r\n(+)o.getClass() è un metodo che restituisce l'oggeto che rappresenta la classe con cui o è stato creato.\r\n\r\n(+)o instanceof SomeClass è un operatore che restituisce true se o is-a SomeClass, ovvero se è un instanza di SomeClass o di una sua classe derivata. (Lo stesso vale per classi astratte e interfaccie, con l'ovvia differenza che quest'ultime non possono essere instanziate.\r\n\r\n\r\nCiò si riflette nell'implementazione di .equals  nel modo seguente:\r\n\r\n(*) utilizzando getClass due oggetti possono risultare uguali se e solo se sono stati instanziati dalla stessa classe.\r\n\r\n(*) utilizzando instanceof due oggetti possono risultare uguali se sono istanziati dalla stessa classe anche con una relazione di is-a, ovvero se il secondo è instanziato dalla stessa classe o da una derivata.\r\n\r\nOvviamente instanceof è più generico, ed è anche generalmente il metodo corretto di definire .equals.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5666,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5913,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5348,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5338,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5857,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6041,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "getClass è un metodo gia implementato che va quindi modificato, intanceof controlla se l'oggetto che passi è del tipo desiderato e il metodo equals controlla solo elementi dello stesso tipo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5337,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5910,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5347,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5663,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5854,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6123,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo getClass restituisce \"uguaglianza\" solo se due oggetti appartengono alla stessa classe, mentre instanceof funziona anche per i sottotipi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5855,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5345,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5911,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5340,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5664,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5763,
          "asker": {
            "courseId": 100,
            "askerId": 859,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è il metodo equals fornendo un esempio",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodo"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5773,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano le equals? Qual'è la loro utilità? Fornire un esempio",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": "esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5705,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Dovendo implementare il programma Tombola (in java) visto in classe con l'ambo la terna la quaterna e la cinquina. Quali classi modificheresti? Devi aggiungerne delle altre o puoi farne a meno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Tombola"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5674,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci possono essere piu` metodi public static void main in una classe,ma con numero di parametri diversi?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "main"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6090,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 899,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Si, a patto che abbiano parametri formali diversi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6059,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5373,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5509,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6038,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Certo, all'interno di una classe è possibile dichiarare più metodi\r\npublic static void main a patto che essi abbiano una firma diversa fra di loro.\r\nDurante l'esecuzione del file, verrà eseguito soltanto il metodo main\r\nsettato in questo modo: 'public static void main(String[] args), mentre gli \r\naltri verranno trattati come semplici metodi. \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5372,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5508,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6058,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6050,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 863,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Tecnicamente è possibile effettuare overloading del metodo main, tuttavia l'entry point del programma sarà sempre un metodo che ha firma:\r\n\r\npublic static void main(String[] args){...}\r\n\r\nI metodi main con overloading devono essere chiamati esplicitamente da quella o altre classi.\r\nEsempio:\r\n\r\npublic class Test {\r\n   public static void main(String args[]){\r\n       main(420);\r\n       main('d');\r\n   }\r\n   public static void main(int i){\r\n       System.out.println(i);\r\n   }\r\n   public static void main(char c){\r\n       System.out.println(c);\r\n   }\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6061,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5511,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5375,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6037,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, posso avere più di un metodo public static void main, tuttavia la segnatura dei parametri deve essere diversa, in particolare se ho un caso dove al main passo una array di stringhe rgb.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6060,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5510,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5374,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5687,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per oggetti identici? E per uguali? Che metodi si possono dichiarare in funzione di questi due concetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Uguali"
            },
            {
              "keyword": " Identici"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5767,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'operatore equals, cioè cosa ritorna di default e perché allora è utile implementarlo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5772,
          "asker": {
            "courseId": 100,
            "askerId": 833,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In classe è stato discusso un metodo Hash per rendere più veloce il confronto di un insieme, che chiamiamo S, di (molti) oggetti e presumibilmente dotati di una grande quantità di parametri.\r\nÈ corretto dire che, nel caso generale, il valore di hashcode ci dice solo se due elementi di S sono differenti e non ci da alcune informazione sull'uguaglianza?\r\nPossiamo pensare di usare il valore di hashcode per effettuare una partizione su S?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Hash"
            },
            {
              "keyword": " Implicazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5754,
          "asker": {
            "courseId": 100,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè quando creo due oggetti punto con le stesse coordinate, applicando la funzione equals() viene restituito \"false\"? Come si potrebbe modificare il codice affinchè venga restituito \"true\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "uguaglianza"
            },
            {
              "keyword": " identità"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5703,
          "asker": {
            "courseId": 100,
            "askerId": 829,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Guardando questo codice:\r\n\r\nclass P{\r\n int x; \r\n\r\n public boolean equals(Object var){\r\n       if(var==null) return false;\r\n       if (!(var instanceof P)) return false;\r\n       return (x==((P)var).x && y==((P)var).y)\r\n } \r\n}\r\n\r\nclass Q extend P{int y;}\r\n\r\n.....Test()\r\n{\r\n      P p1 = new P();\r\n      p1.x = 1;\r\n      Q p2 = new Q();\r\n      p2.x = 1;\r\n      System.out.println(p1.Equals(p2););\r\n}\r\n\r\nCosa stamperebbe il \"println\" ? True o False? E perchè?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5762,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo la sovrascrittura del metodo Object.equals rende necessaria la sovrascrittura del metodo Object.hashCode? A cosa serve effettivamente lo hashcode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5770,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In java, quali funzioni posso usare per la generazione di numeri casuali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "numero"
            },
            {
              "keyword": " casuale"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5697,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Scrivete un metodo equals(Object) per la classe Pila (lezione 5, slide 2):\r\n\r\npublic class Pila {\r\n    int size;\r\n    int defaultGrowthSize;\r\n    int marker;\r\n    int contenuto[];\r\n    /* eccetera */\r\n}\r\n\r\nCi sono diverse possibili implementazioni che possono essere giudicate corrette: giustificate le vostre scelte.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5758,
          "asker": {
            "courseId": 100,
            "askerId": 880,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Il metodo \"equals\" è un metodo che si trova naturalmente dei package di Java. Può essere impiegato per verificare l'uguaglianza di qualsiasi oggetto? Motivare la risposta.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " oggetto"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5726,
          "asker": {
            "courseId": 100,
            "askerId": 494,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che porta l'hashcode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": "algoritmo"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5766,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il significato dell'operatore \"==\" in Java? Si comporta come in c/c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "confronto"
            },
            {
              "keyword": " operatore"
            },
            {
              "keyword": " indirizzi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5707,
          "asker": {
            "courseId": 100,
            "askerId": 848,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo (o modi) si può testare l'eguaglianza in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eguaglianza"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5719,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quand'è che il metodo equals, sovrascritto in una sottoclasse, si dice consistente? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " sottoclasse"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5732,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi nell'utilizzo della classe Common?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Common"
            },
            {
              "keyword": " vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5725,
          "asker": {
            "courseId": 100,
            "askerId": 855,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai la classe di confronto equals lasciata così com'è funziona solo con gli Object? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Object"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5672,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Il metodo equals (della classe predefinita Object), applicato a due oggetti A e B, non fa altro che restituire il valore di verità dell'espressione \"A==B\". Quali sono, dunque, l'utilità e l'uso opportuno di tale metodo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5702,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi l'operatore (==) e il metodo equals (dopo che è stato sovrascritto) restituiscono TRUE se applicati a due oggetti? ",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " differenze"
            },
            {
              "keyword": " confronto"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6078,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"==\" restituisce TRUE se e solo se i due elementi da confrontare puntano allo stesso oggetto, e la stessa cosa fa \"equals()\" prima dell'override.\r\n\r\nUna volta eseguito l'override del metodo \"equals()\", il fatto che questo restituisca TRUE o FALSE dipende strettamente dall'implementazione eseguita dal programmatore (per esempio in un esercizio che abbiamo fatto, due oggetti di tipo Libro erano uguali se avevano lo stesso codice ISBN).\r\n\r\nE' opportuno che il programmatore che scrive l'override di equals() lo scriva in modo che se due elementi puntano allo stesso oggetto ritorni sempre TRUE.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5971,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5991,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5331,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5358,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5483,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6049,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "L'operatore == restituirà true solamente se gli oggetti in questione sono identici ovvero se sono due istanze allo stesso oggetto. L'operatore equals se è stato opportunamente sovrascritto restituirà a sua volta true anche se sono due oggetti uguali. Quindi l'unico caso in cui entrambi restituiranno true è se si tratta dello stesso oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5485,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5329,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5972,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5992,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5360,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6114,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 783,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "L'operatore (==) e il metodo equals, dopo che è stato sovrascritto, restituiscono TRUE se e solo se sono applicati ad oggetti identici, ovvero allo stesso oggetto.\r\nCiò deriva dal fatto che l'operaore == è un operatore che testa l'identità, se applicato ad oggetti( ciò non è più vero nel caso di interi, floating point et cetera..); invece il metodo equals, se non sovrascritto, ovvero quello ereditato da Object, ha lo stesso effetto dell'operatore == (infatti il metodo equals della classe Object non fa altro che applicare ==), mentre se sovrascritto può testare anche l'uguaglianza tra due oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5330,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5359,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5484,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5993,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5973,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5755,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si fa overriding del metodo equals() nella classe Object le API di Java suggeriscono di fare una ulteriore operazione.  Quale e perché? \r\nQuesto non succede se si fa overloading. Come mai? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": "  overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5744,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra metodo (e variabile) final, static e nessuno dei due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "final"
            },
            {
              "keyword": " static"
            },
            {
              "keyword": " variables"
            },
            {
              "keyword": " method"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5761,
          "asker": {
            "courseId": 100,
            "askerId": 901,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare una libreria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "libreria"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5734,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Avendo definito una classe per esempio Utente contenente le stringhe di Nome Cognome e altri campi, è possibile creare una lista, un set o una collezione di oggetti contenente vari oggetti della classe Utente e richiamarli successivamente con l'utilizzo dell'iteratore o di qualsiasi altro modo che permetta di accedere o ricercare gli oggetti precedentemente inseriti attraverso i singoli campi Nome e Cognome?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collezioni "
            },
            {
              "keyword": " ricerca"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6053,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 769,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si è possibile in quanto le collections permettono l'archiviazione di oggetti differenti. Inoltre è possibile accedere ad essi attraverso l'iteratore. Inoltre è possibile anche ricercare, accedere o rimuovere i singoli oggetti inserendo l'identificativo dei singoli campi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6082,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6049,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5548,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6060,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Si. Bisogna scegliere con attenzione il tipo di collection da usare in base alle specifiche dell'oggetto che la collection andrà a contenere (in questo caso si potrebbe usare una List). Poi usando un iteratore con un ciclo for e qualche if si può accedere ad ogni elemento della collection",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5547,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6050,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6083,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6075,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Si è possibile. Basta istanziare una classe concreta che implementa l'interface Collection(ArrayList, HashSet, LinkedList eccetera). L'interface Collection richiede di poter ottenere dalla collezione un oggetto con il quale è possibile accedere a tutti gli oggetti inseriti, di conseguenza si possono salvare riferimenti a quelli a cui si è interessati (es Cognome=\"Rossi\")\r\nCodice:\r\nCollection utenti = new ArrayList<Utente>(); // utilizzare il costruttore della struttura dati preferita\r\n// Inserimento dei vari utenti\r\nUtente u = new Utente(\"Rossi\",\"Mario\",...);\r\nutenti.add(u);\r\nCollection ricerca=new ArrayList<Utente>();\r\n//cerco chi mi interessa\r\nIterator i=utenti.iterator();//oggetto per scorrere gli utenti\r\nUtente corrente;\r\nwhile(i.hasNext()){  //se non li ho passati tutti\r\n  corrente=(Utente)i.next(); // downcast necessario e sicuro: i.next() ritorna un Object \r\n  if(curr.cognome.equals(\"Rossi\")) ricerca.add(corrente);\r\n}//in ricerca ci sono gli utenti selezionati",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6081,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6048,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5549,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5667,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "In questo estratto di codice:\r\n Test() {\r\n P p1=new P();\r\n p1.x=1; p1.y=2;\r\n P p2=new P();\r\n p2.x=1; p2.y=2;\r\n System.out.println(p1.equals(p2));\r\n System.out.println(p1==p2);\r\n }\r\n}\r\nQual'è il risultato del primo println e quale è quello del secondo, ma soprattutto perchè?\r\nRispondere argomentando",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " =="
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5751,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche dei variabili e dei metodi dichiarati 'static'?",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 5,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": "metodi"
            },
            {
              "keyword": "static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6125,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": "Normalemente ogni metodo appartiene ad una classe. Da una classe possiamo ottenere molteplici istanze e per ciascuna istanza si hanno variabili dai nomi identici ma dai valori distinti. Se poi vogliamo che una variabile sia la medesima per tutte le istanze di una classe sappiamo che la dobbiamo invece definire come static.\r\n\r\nPer i metodi avviene sostanzialmente la medesima cosa: possiamo pensare che dei metodi definiti in una classe ne esista normalmente  una ?copia? per ogni istanza della classe, mentre dei metodi statici ne esista una sola copia associata alla classe stessa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5266,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6202,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5341,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6013,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5268,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6126,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": "Normalemente ogni metodo appartiene ad una classe. Da una classe possiamo ottenere molteplici istanze e per ciascuna istanza si hanno variabili dai nomi identici ma dai valori distinti. Se poi vogliamo che una variabile sia la medesima per tutte le istanze di una classe sappiamo che la dobbiamo invece definire come static.\r\n\r\nPer i metodi avviene sostanzialmente la medesima cosa: possiamo pensare che dei metodi definiti in una classe ne esista normalmente  una ?copia? per ogni istanza della classe, mentre dei metodi statici ne esista una sola copia associata alla classe stessa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5269,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6204,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6015,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5267,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5343,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6039,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 100,
                "courseFinalScore": 16
              },
              "answerText": "All'interno di una classe (ovvero, ovunque in Java), static permette di definire delle variabili e metodi di classe, condivise da tutte le istanze, che vengono allocate solo una volta, al carimento della classe stessa (e non alla creazione di ogni istanza).\r\n\r\nOltre al solito modo di utilizzo di esse tramite l'istanza (mioOggetto.miaMetodo()), è possibile accedervi anche tramite la classe (MiaClasse.mioMetodo()). È considerata buona cosa accedervi con la seconda modalità quando possibile.\r\n\r\nÈ di particolare importanza, se si vuole rendere eseguibile una classe, dichiarare static la sua main, che altrimenti non sarebbe disponibile in quanto non sarebbe presente fino all'allocazione di una istanza della classe, cosa che non potrebbe avvenire.\r\n\r\nAnche se non affrontato a lezione (mi pare), ci tengo ad aggiungere che con static si può dichiarare del codice che verrà eseguito implicitamente al *caricamento della classe* (static block)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6014,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5342,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5265,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6203,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5270,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5683,
          "asker": {
            "courseId": 100,
            "askerId": 917,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "equals di object: scrivi il corpo della funzione e elenca le caratteristiche che deve avere equals in generale.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "object"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5698,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali metodi bisogna implementare per le interfacce Comparable e Comparator? \r\nE' importante che il metodo equals sia coerente con i metodi di queste interfacce? Perche'?",
          "totalDifficultyLevel": 23,
          "totalInterestingnessLevel": 22,
          "totalRelevanceLevel": 24,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " comparator"
            },
            {
              "keyword": "comparable"
            },
            {
              "keyword": "interface"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6116,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Comparable impone un ordinamento totale sugli oggetti di ogni classe che implementa. Questo ordinamento viene indicato come ordinamento naturale della classe,  bisogna implementare (fare un overraide) il metodo compareTo per essere utilizzato, e compareTo viene indicato come metodo di confronto naturale.\r\nComparator è una funzione di confronto, che impone un ordinamento totale su alcuni insieme di oggetti.  Però ha bisogno di due override dei metodi: equals(Object obj) e compare(T o1, T o2).\r\nSi. Deve essere coerente se no un comparatore in grado di imporre un ordinamento incompatibile con eguali per ordinare un insieme ordinato (o mappa ordinati). Supponiamo che un insieme ordinato (o mappa ordinato) con un comparatore c esplicita viene utilizzato con elementi (o chiavi) tratte da un set S. Se l'ordine imposto dal c on S è incompatibile con eguali, l'insieme ordinato (o mappa ordinati) si comportarsi \"stranamente\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6038,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5402,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5769,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6062,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5659,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6095,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Per l'interfaccia Comparable bisogna implementare il metodo \"compareTo(Object o)\" che confronta un determinato oggetto, con l'oggetto \"o\" e ritorna un intero negativo, zero o positivo, in base se l'oggetto è minore, uguale o maggiore di \"o\". Per l'interfaccia Comparator i metodi da implementare sono due \"compare(Object o1, Object o2)\" e \"equals(Object o)\". Il primo metodo si comporta come \"compareTo\" in base se il primo oggetto è minore, uguale o maggiore del secondo, mentre il secondo metodo controlla se due determinati oggetti puntano alla stessa locazione di memoria, quindi in definitiva se sono lo stesso oggetto. Ovviamente questi comportamenti sono riferiti a Object, ad esempio reimplementando equals si può fare in modo che rispetti determinate regole di uguaglianza decise dal programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5657,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5767,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5400,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6042,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6066,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6056,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Comparator richiede l'implementazione del metodo equals() che non è richiesta dal metodo comparable, ed entrambi richiedono l'implementazione dei metodi compare() per il comparator e di compareTo() per il comparable.\r\nIl metodo equals deve essere consistente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6067,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5399,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5660,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6043,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5765,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6027,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Con l'interfaccia comparable si implementa il metodo compareTo, mentre con l'interfaccia comparator  si ha bisogno del metodo compare. L'equals è un metodo atto allo svolgimento di confronti tra due oggetti,  non di classi predefinite numeriche. I metodi compare e compareTo sono utilizzati dai metodi sort per ordinare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5770,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6041,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5658,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5397,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6065,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6119,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 748,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Per l'interfaccia Comparable è necessario implementare il metodo compareTo.\r\nPer l'interfaccia Compator è necessario implementare il metodo compare.\r\nIl metodo equals se non implementato con overriding confronterà gli oggetti come si confrontano due oggetti Objects. Per poter confrontare due oggetti di qualsiasi sottoclasse di Object senza che ci siano risultati inaspettati dovremmo ridefinire il metodo equals per la classe specifica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5768,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6039,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6063,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5401,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5662,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6044,
              "task": {
                "taskId": 167,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Bisogna implementare compareTo(Object) e compare().\r\nE' importante che equals sia coerente coi metodi perchè questi verranno chiamati da equals.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6040,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5661,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6064,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5398,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5766,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 167,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5745,
          "asker": {
            "courseId": 100,
            "askerId": 904,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo quando ci ritroviamo a confrontare gli argomenti di due oggetti dobbiamo applicare l' override sul metodo equals() di Object ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": "Object"
            },
            {
              "keyword": "Ugualianza"
            },
            {
              "keyword": "oggetti"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5771,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 166,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa hashCode? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Hashcode"
            },
            {
              "keyword": " significato"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 57,
      "lectureTitle": "Lezione 3-4",
      "questions": [
        {
          "questionId": 5201,
          "asker": {
            "courseId": 100,
            "askerId": 907,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Stringhe: definizione e loro implementazione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": " implementazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5253,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "void cresci (Pila *s, int increment) {\r\n   cout << \" entro in cresci \" << endl;\r\n     s->size+=increment;\r\n   int * temp  =new int[s->size];\r\n     for (int k = 0; k < s->marker; k++) \r\n         temp[k] = s -> contenuto[k];\r\n         s -> contenuto = temp;\r\n      delete [ ] (s -> contenuto); \r\n}\r\nLa funzione scritta cosi va bene?In caso la risposta non dovesse essere affermativa spiegare il perche. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Deallocazione"
            },
            {
              "keyword": " Gestione memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5257,
          "asker": {
            "courseId": 100,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa comporta la frammentazione della heap? Perché si rende necessaria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Frammentazione"
            },
            {
              "keyword": " Heap"
            },
            {
              "keyword": " Programmazione"
            },
            {
              "keyword": " Unitn"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5293,
          "asker": {
            "courseId": 100,
            "askerId": 813,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo implemento il codice di un metodo che sta all interno di una struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " metodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5271,
          "asker": {
            "courseId": 100,
            "askerId": 850,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "come sono implementate le stringhe in c e c++? e in che modo si possono creare (potenziali) catestrofi tramite il loro utilizzo?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": " c"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5517,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le stringhe in c/c++ sono implementate come semplici array di caratteri. Per segnalare la fine della stringa viene messo un carattere di controllo, '\\0'. Si dichiara quindi:\r\nchar stringa[DIM]=\"Ciao\"; o in alternativa\r\nchar* stringa={'C', 'i', 'a', 'o', '\\0'};\r\nSono molte le funzioni che gestiscono le stringhe e la maggior parte si trovano nella libreria string.h/cstring.\r\nUno dei classici errori è dichiarare la stringa di dimensione DIM e utilizzare di conseguenza DIM caratteri: ciò è errato. La stringa può infatti contenere al massimo DIM-1 caratteri, proprio per la presenza del carattere di controllo '\\0': ciò può generare errori o risultati imprevedibili. E' inoltre necessario fare attenzione all'utilizzo di \"cin >>\" per prendere in ingresso una stringa: questa funzione prenderà infatti in ingresso tutti i caratteri fino al primo '\\0' (tipicamente fino allo spazio); altre funzioni come cin.getline(stringa,#caratteri) permettono invece una diversa memorizzazione delle stesse.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3096,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3428,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5601,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sono implementate come un array di char terminante con un elemento che contiene NULL.\r\nEssendo un array di caratteri, le stringhe sono in sostanza dei puntatori quindi possono generare tutti gli errori derivanti dall'uso non corretto dei puntatori.\r\nPer esempio restituendo una stringa allocata come variabile locale tramite una funzione: la stringa viene allocata nello stack; quindi appena si esce dallo scope in cui è stata dichiarata, la memoria ad essa dedicata viene deallocata, ma punta ancora ad un area valida di memoria in cui nel frattempo potrebbe essere stata allocata qualsiasi altra cosa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3429,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3097,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5502,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le stringhe possono essere implementat in due modi: tramite un array di char(per il quale lo standard c offre delle funzionalità uniche) o il tipo string della omonima libreria. Come negli array normarli si rischia di sforare, inoltre bisogna stare attenti al fatto che l'ultimo carattere di un array-stringa è il '\\0'.\r\nPer quanto riguarda invece la libreria bisogna stare attenti a tutte le funzionalità messe a disposizione per poterne usufruire correttamente. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3430,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3098,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5266,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Come incide sulle prestazioni del disco la deframmentazione? e cosa accade hai puntatori?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 9,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "deframmentazione"
            },
            {
              "keyword": " dico"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5564,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La frammentazione avviene perché, quando un file deve essere scritto su disco, esso occupa il primo blocco libero. Se non ci sono abbastanza blocchi contigui per contenere tutto il file, esso viene spezzato in frammenti non contigui. Questo comporta un rallentamento delle operazioni di input e output, in quanto la ricerca dei pezzi del file non è completamente sequenziale e nel caso di dischi meccanici la testina deve spostarsi tra settori anche molto distanti. Nei sistemi operativi esistono tool che permettono di deframmentare, cioè riordinare tutti pezzi dei file per velocizzare le operazioni di accesso al disco. La frammentazione porta anche ad un rallentamento delle operazioni di paging e swap della RAM.\r\nLa frammentazione della RAM invece può creare degli spazi vuoti tra i blocchi allocati ai diversi processi: se un processo completato lascia un blocco di memoria libera, e ne viene riallocata solo una parte, può avvenire una perdita di memoria utilizzabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2990,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3241,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3300,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3004,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5575,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 584,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un disco deframmentato permette alla testina di un disco rigido di percorrere una distanza minore per leggere le stesse informazioni rispetto ad uno su cui non è stata effettuata questa procedura: i frammenti del file sono organizzati in zone contigue di memoria,  permettendo così una lettura non interrotta. Il sistema operativo oltre a dover copiare i file in un'altra posizione, deve riaggiornare tutti i puntatori della lista di ogni file spostandoli verso le zone di memoria allocate dopo la procedura.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3238,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3001,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2987,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3299,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5523,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "La deframmentazione rende l'accesso e la lettura dei files sul disco decisamente più veloci, in quanto i files sono riorganizzati in modo contiguo.\r\nDurante la deframmentazione i puntatori vengono aggiornati alla nuova posizione dei files.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3005,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2991,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3242,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3298,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5573,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 100,
                "courseFinalScore": 16
              },
              "answerText": "[In 1000 caratteri è pressocchè impossibile spiegarlo bene e con un esempio chiaro, quindi intanto inizio a rispondere qua, il resto l'ho linkato.]\r\n\r\n1) Un hard disk possiamo vederlo come una testina per leggere e scrivere, ed un nastro su cui sono scritti sezioni di file dentro a uno o più blocchetti di dimensione fissa. La testina scorre avanti e indietro sul nastro, un blocchetto alla volta.\r\n\r\nConsideriamo si debba leggere un file che occupa 10 blocchetti. La situazione ideale è avere i dati di questo file memorizzati in 10 blocchetti consecutivi e in ordine. Quindi, la testina si posizionerà all'inizio di questa sequenza, legge, procede di uno, legge, procede di uno, ....\r\n\r\nConsideriamo invece il caso in cui il file sia memorizzato in blocchetti sparsi. La testina si posiziona sul primo, legge, poi si sposta avanti o indietro quanta è la distanza che la separa dal secondo, legge, e bla bla bla.\r\n\r\n[ continua qui: http://pastie.org/private/bfdc6xlojd2sxkxm6bjbq ]",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3302,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2988,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3002,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3239,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5577,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La deframmentato del disco causa una maggiore prestazione sull'esecuzione di qualsiasi programma, perchè deframmentando un disco  si crea una maggiore disponibilità della memoria in modo compatta.\r\nGli indirizzi dei puntatori cambiano dopo aver deframmentato e quindo è il dovere del programmatore aggiornare tutti gli indirizzi del puntatore onde di evitare che puntino in una cella di memoria non permessa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3003,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3240,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2989,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3301,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5188,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nel creare una copia di una pila bisogna prestare attenzione al creare due strutture uguali ma separate? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "copia"
            },
            {
              "keyword": " pila"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5184,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è importante l'ordine con cui si dealloca? A cosa serve l'unità di deframmentazione del disco?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Deallocazione"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5294,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una pila? Spiegare su quale principio si basa e perché è una struttura dati così importante.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5256,
          "asker": {
            "courseId": 100,
            "askerId": 881,
            "courseFinalScore": 9
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il pre-processore? Fornire un esempio di codice sul quale il pre-processore lavora.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pre-processore"
            },
            {
              "keyword": " esempio"
            },
            {
              "keyword": " codice"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5208,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per Handle Leak (perdita di handle) all?interno di un programma, e in che modo questo tipo di Memory Leak può influenzare le prestazioni del programma stesso?\r\n(si prenda in considerazione un?errata implementazione di una funzione che ha il compito di deallocare/liberare uno spazio di memoria non più utilizzato).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Handle"
            },
            {
              "keyword": " Memory"
            },
            {
              "keyword": " Leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5236,
          "asker": {
            "courseId": 100,
            "askerId": 772,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può utilizzare la funzione assert e a cosa serve? che rischi si possono evitare utilizzandola?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "assert"
            },
            {
              "keyword": " controllo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5204,
          "asker": {
            "courseId": 100,
            "askerId": 859,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è un array e quali sono le sue limitazioni. Implementa inoltre una funzione che,\r\ndato in input un array di interi, restituisca il prodotto di tutti gli elementi al suo interno.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "omogeneità"
            },
            {
              "keyword": " ciclo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5249,
          "asker": {
            "courseId": 100,
            "askerId": 869,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché in C++ é importante separare le API dall'implementazione?\r\nOvvero, come mai per ogni costrutto implementato in un file (name.cpp) si ha una definizione dello stesso in un file separato (name.h)?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "API"
            },
            {
              "keyword": " header"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5497,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "E' importante separare le api dall'implementazione vera e propria del codice perchè in questo modo si ottiene un codice più flessibile, portabile e modulare. Infatti se la definizione è posta in un file separato il codice può essere sostituito anche dopo tempo senza dover ricontrollare l'intero programma.\r\nInoltre con questo metodo si riduce il codice esposto al programmatore (principio del soldato che deve sapere solo quello che gli serve per la missione e NON di più).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2918,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3074,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3156,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3188,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5551,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "L'importanza è evidente nel caso in cui il programmatore voglia nascondere l'implementazione del costrutto rendendo inaccessibile il codice sorgente a terzi, infatti così facendo l'utente che intende usare il programma in questione avrà a disposizione solo il file oggetto (name.o) e il file (name.h) e quindi non avrà accesso al file (name.cpp) dove sono definite le funzioni, quindi a tutti gli utenti sarà disponibile solo l'interfaccia e non le informazioni su come quest'ultima sia stata creata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3154,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3186,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3072,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2916,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5548,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sono separate sia per proteggere l'implementazione dalla lettura, ma soprattutto per sottolineare agli occhi dell'utilizzatore cosa riguarda l'interfaccia e cosa è \"dettaglio implementativo\", che non deve interessare. È possibile sfruttare ciò per distribuire solo gli header necessari e il codice già compilato per l'implementazione. Inoltre, ogni .cpp viene compilato separatamente, ma deve avere già pronte le dichiarazioni dei tipi e delle funzioni impiegate, per cui si includono i .h.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3157,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3189,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2919,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3075,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5544,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 773,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Innanzitutto questo migliora la leggibilità del programma e riduce sensibilmente le dimensioni del programma ed, inoltre, fa velocizzare la sua esecuzione. \r\nSi hanno cosi' le proprie librerie (statiche) già compilate e vengono forniti solo gli headers (le API)che servono appunto per poterle usare. \r\nDopo aver compilato il tutto, entra in azione il linker che \"linka\" l'eseguibile con tutti i riferimenti esterni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3187,
                  "rater": {
                    "raterId": 764,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3073,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2917,
                  "rater": {
                    "raterId": 745,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3155,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5199,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa succede in Java se si \"chiama\" più di una volta la stessa libreria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " libreria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5277,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzione del preprocessore e come agisce, nello specifico la differenza di sinstassi tra: #include <filename> e #include \"filename\" e il significato di pathname.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Preprocessore"
            },
            {
              "keyword": " pathname"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5268,
          "asker": {
            "courseId": 100,
            "askerId": 899,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè nella pagina 70 della slide della 3a-4a lezione si dice \"Una copia (troppo) sbrigativa...\"? \r\nIn questo caso, a cosa punta \"w\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " copia"
            },
            {
              "keyword": " puntatore"
            },
            {
              "keyword": " aliasing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5160,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il rischio che si incorre copiando puramente una pila ed i suoi puntatori? Come lo si può evitare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5171,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando conviene usare una pila con array, mentre quando conviene con i puntatori? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Array"
            },
            {
              "keyword": " Puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5190,
          "asker": {
            "courseId": 100,
            "askerId": 830,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Principio di Parna",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "information"
            },
            {
              "keyword": " hiding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5163,
          "asker": {
            "courseId": 100,
            "askerId": 809,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il contenuto della pila viene memorizzato nella heap ?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": "heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5246,
          "asker": {
            "courseId": 100,
            "askerId": 876,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "è possibile gestire una pila senza l'utilizzo di puntatori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Parole"
            },
            {
              "keyword": "chiave"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5287,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si costruisce uno stack, quali sono le funzioni fondamentali da scrivere? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " funzioni"
            },
            {
              "keyword": " stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5193,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel seguente codice, basato sull'implementazione di stack presentata a lezione e disponibile sulle slide, è presente un grave errore. Individuarlo, analizzare le potenziali conseguenze che può causare e proporre una correzione al codice.\r\n\r\nPila* copia(Pila* from)\r\n{\r\n    cout<<\"entro in copia\"<<endl;\r\n    Pila* to = new Pila;\r\n    to->size = from->size;\r\n    to->defaultGrowthSize = from->defaultGrowthSize;\r\n    to->contenuto = from->contenuto;\r\n    to->marker = from->marker;\r\n    return to;\r\n} ",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " puntatore"
            },
            {
              "keyword": " copia"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5515,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 917,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "l'errore si trova nella riga che ho commentato nel codice sottostante insieme a una possibile correzione.\r\nl'errore consiste che con l' istruzione: to->contenuto = from->contenuto; non si farà una copia del array puntato da to->contenuto ma del indirizzo del suddetto e quindi si otterranno 2 pile che punteranno allo stesso array allocato nella heap e che quindi modificando il contenuto di una delle due pile si modificherà involontariamente anche quello del altra con risultati imprevedibili e assai dannosi.\r\n\r\nPila* copia(Pila* from)\r\n{\r\n    cout<<\"entro in copia\"<<endl;\r\n    Pila* to = new Pila;\r\n    to->size = from->size;\r\n    to->defaultGrowthSize = from->defaultGrowthSize;\r\n    \r\n    // to->contenuto = from->contenuto; ERRORE\r\n    \r\n    //possibile correzione\r\n    for (int k=0; k<from->marker;k++) {\r\n        to->contenuto[k]=from->contenuto[k];\r\n    }\r\n    \r\n    to->marker = from->marker;\r\n    return to;\r\n} ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3499,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3497,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3224,
                  "rater": {
                    "raterId": 867,
                    "courseId": 100,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3337,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2900,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5540,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 766,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'errore che è presente nel codice consiste nel non aver inizializzato il vettore contenuto. In questo caso contenuto veniva usata come variabile e veniva assegnato il valore presente nella Pila from con indice 0.\r\n\r\nIl codice corretto sarebbe dovuto essere:\r\n\r\nPila* copia(Pila* from)\r\n{\r\n    cout<<\"entro in copia\"<<endl;\r\n    Pila* to = new Pila;\r\n    to->size = from->size;\r\n    to->defaultGrowthSize = from->defaultGrowthSize;\r\n    to->contenuto = new int [from->size];\r\n    for(int k=0;k<from->marker;k++)\r\n    {\r\n         to->contenuto[k]=from->contenuto[k];\r\n     }\r\n    to->marker = from->marker;\r\n    return to;\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3338,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3496,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3223,
                  "rater": {
                    "raterId": 867,
                    "courseId": 100,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3498,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2899,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5182,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Indicare vantaggi e svantaggi in un linguaggio di programmazione che utilizza i puntatori. Quali le differenze tra C++ e Java se si parla di puntatori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "C++"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " puntatori "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5164,
          "asker": {
            "courseId": 100,
            "askerId": 832,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è importante che a ogni new/malloc/calloc segua una delete/free?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": " allocazione dinamica"
            },
            {
              "keyword": " out of memory"
            },
            {
              "keyword": " memory leaks"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5200,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Esprimi il concetto di memory leak relativo all'allocazione dinamica di memoria nell'area Heap",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memory"
            },
            {
              "keyword": " leak"
            },
            {
              "keyword": " allocazione"
            },
            {
              "keyword": " dinamica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5273,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono le API?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "librerie"
            },
            {
              "keyword": "lezione3"
            },
            {
              "keyword": "lezione4"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5500,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le API servono per permettere ad un determinato programma di usare e gestire elementi di uno specifico settore. Un esempio di ciò sono le librerie che implementano particolari funzioni matematiche utilizzabili dai programmatori per sviluppare programmi ad esse collegate",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2927,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3374,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2891,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3235,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3030,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3422,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5559,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 923,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le API (Application Programming Interface) indicano l'insieme delle funzioni a disposizione del programmatore, solitamente raggruppate per svolgere un determinato compito all'interno di un programma (es. librerie). Il loro scopo è quello di espandere le funzionalità di un programma; un programmatore può infatti mettere a disposizione un set di API del suo software dando così a chiunque la possibilità di interagire con la sua piattaforma e poterla espandere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3371,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3233,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2925,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2889,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3028,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3419,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5598,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 823,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le API sono un insieme di librerie, istruzioni e strumenti utilizzabili dal programmatore per interfacciarsi con una certa componente di un software, invece che doverne analizzare il codice riga per riga.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2892,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3423,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3236,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3375,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3031,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2928,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5542,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 910,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con Application Programming Interface (in acronimo API), si indica ogni insieme di metodi disponibili al programmatore, di solito raggruppate a formare un set di strumenti specifici. Spesso con tale termine si intendono le librerie software disponibili in un certo linguaggio di programmazione.\r\nNello specifico in Java le API sono una serie di metodi a disposizione del programmatore costituiti da un COSTRUTTORE e dei METODI di IMPLEMENTAZIONE. \r\nIl costruttore non è altro che il come si inizializza un certo metodo mentre i metodi di implementazione sono come questo metodo posso implementarlo nel mio programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3373,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3029,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3234,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3421,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2926,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2890,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5609,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le API rappresentano un'interfaccia aperta di un software, ovvero una particolare interfaccia che librerie, software o piattaforme possono usare per interagire con un programma.\r\nPer uno sviluppatore mettere a disposizione un set di API di un suo software significa dare la possibilità ad altri di interagire con la sua piattaforma e, soprattutto, estendere le funzioni e le caratteristiche della struttura base della piattaforma.\r\nUn esempio di API sono le librerie \"cmath\" o \"cctype\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2893,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3032,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3237,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2929,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3372,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3420,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5281,
          "asker": {
            "courseId": 100,
            "askerId": 886,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'esempio proposto a lezione quale funzione svolge la struttura Pila, e attraverso quali tipo di variabili sono composte le sue quattro parti principali?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5243,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Si può affermare che, quando si dichiara un vettore, la scrittura\r\n\r\n\"int v[100];\"\r\n\r\nè equivalente a\r\n\r\n\"int *v; v=new int[100];\"?\r\n\r\n",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "vettori"
            },
            {
              "keyword": "puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5591,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 769,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "No in quanto nel primo caso si dichiara un array con allocazione statica. Mentre nel secondo caso l'allocazione è dinamica. Nello specifico nel secondo caso dichiariamo un puntatore (*v) a cui attribuiamo l'indirizzo del primo elemento di un array di 100 elementi. \r\nI due tipi di dichiarazione (statica e dinamica) influiscono molto sulla programmazione, in quanto nel secondo caso l'allocazione e la deallocazione sono responsabilità del programmatore. \r\nAnche se l'utilizzo dell'array (manipolazione, stampa, inserimento) dell'array può sembrare simile i due casi esposti vengono implementati diversamente dal compilatore. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3118,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3358,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3424,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5569,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "No, le due scritture non sono equivalenti. Nel primo caso l'array viene allocato nello stack. Nel secondo, attraverso il costrutto new, l'array viene allocato nello heap. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3359,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3425,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3117,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5617,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 850,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "No, all'atto della dichiarazione la differenza è che, nel primo caso l'array è allocato staticamente (ovvero all'interno della stack), mentre nel secondo caso è allocato dinamicamente (ovvero all'interno della heap) e solo \"v\" (un puntatore al primo elemento dell'array, praticamente un indirizzo di memoria) si trova nella stack. A causa del fatto che in C tutti gli array sono gestiti implicitamente tramite puntatori non si notano differenze sostanziali nel loro utilizzo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3360,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3119,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3426,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5579,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "In entrambi i casi vengono allocati un array di 100 interi, ma cambia la memoria utilizzata per farlo.\r\nCon \"int v[100]\", vengono allocati 100 interi nello stack, cioè la memoria utilizzata anche per i frame di chiamata delle funzioni.\r\nNel secondo caso invece l'array viene allocato nello heap, cioè la memoria destinata alla memoria utilizzata dinamicamente e allocata manualmente dal programmatore.\r\nSi possono definire le scritture \"equivalenti\" perchè in tutti e due i metodi viene riservata della memoria per un array di 100 interi, ma cambia la zona di memorizzazione (stack e heap).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3361,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3427,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3116,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 5206,
          "asker": {
            "courseId": 100,
            "askerId": 814,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "struct Pila {\r\n int size;\r\n int defaultGrowthSize;\r\n int marker;\r\n int * contenuto;\r\n} ; \r\nSpiega cosa rappresenta la variabile \"marker\" e chiarisci perchè è così importante per la corretta esecuzione della pila.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": "Controllo_esecuzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5173,
          "asker": {
            "courseId": 100,
            "askerId": 921,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il procedimento per cancellare correttamente una pila? (pila che contiene un array di int per esempio)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " cancellare"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5177,
          "asker": {
            "courseId": 100,
            "askerId": 810,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Illustra cosa si intende per frammentazione della memoria descrivendo sinteticamente il caso dell'accrescimento di una pila tramite la funzione 'void cresci(Pila *s; int increment);' ed i relativi effetti sulla memoria Heap.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": " pila"
            },
            {
              "keyword": " frammentazione"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5279,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra una variabile globale e una const?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "globale"
            },
            {
              "keyword": " const"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5546,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "la principale differenza tra variabili globali e costanti è che le prime hanno un l-value che può essere modificato durante l'esecuzione del programma al contrario delle costanti; quest'ultime vengono anche chiamate read-only variable.Le variabili globali vengono dichiarate, come dice il nome, a livello globale e sono quindi viste da qualunque funzione.Le costanti vengono nella maggior parte dei casi dichiarate globalmente ma non è obbligatorio.Infine queste due espressioni vengono memorizzate in punti diversi della memoria le variabii globali vengono immagazzinate in uno spazio definito come initialized\r\nread/write data mentre le costanti hanno uno spazio di memoria definito come initialized read/only data. Lo spazio riservato alle costanti non è supportato da tutti i tipi di hardware.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3369,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3315,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3323,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5503,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 848,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La variabile globale può essere ridefinita all'interno di una funzione, mentre la const non può essere ridefinita. Inoltre la variabile globale è visibile a tutte le funzioni del programma, mentre la const è visibile solamente nel blocco in cui è dichiarata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3322,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3368,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3316,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5594,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Quasi tutto... Una constante è una variable che viene inizzializzata solo una volta è non puo essere modificato nel corso del programma, è utile durante la fase  di sviluppo  di un programma perché permette di modifiche il codice in modo efficiente quando si ha una ridondanza di una dato. Ad esempio la dimensione di un vettore. In c++ vengono usate le costanti nelle funzione che passano parametrica per riferimento per evitare che la variabile si modifiche nel corso della funzione. \r\nUna variable globale invece è una variable che persiste  nel programma fino al suo termine ,  puo essere richiamata in qualsiasi funzione. Le variabili globali sono utili per creare errori e casini nei programmi ma se usate in modo corretto si possono usare per variabili che vengono usate in tutto o quasi il programma. Ad esempio la matrice  3x3 in un programma che gioco a tris.\r\nLe variabili globali e costanti invece sono utilissime per ovvie ragioni. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3313,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3370,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3324,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5586,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 819,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una variabile globale è una variabile dichiarata fuori da qualsiasi funzione, in modo da essere raggiungibile e soprattutto modificabile da qualsiasi istruzione in qualsiasi punto del nostro programma. Una variabile const invece indica una variabile che oltre ad avere un tipo (come ad esempio int, char, float) è anche dichiarata costante, e quindi dopo esser stata creata ed aver acquisito un valore, questo non potrà essere più modificato da nessuna istruzione durante l'esecuzione del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3326,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3312,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3367,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5590,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La differenza principale è che alla costante il valore assegnato non viene cambiato, mentre quello della variabile globale può subire variazioni. Inoltre esse vengono allocate in zone di memoria diverse. E poi le variabili globali sono 'cattive', violano il principio di Information Hiding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3314,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3325,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3366,
                  "rater": {
                    "raterId": 811,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5196,
          "asker": {
            "courseId": 100,
            "askerId": 917,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "le due seguenti istruzioni hanno significati differenti è ciò è molto\r\nspesso fonte di errori.\r\nspiega la differenza fra le due.\r\n\r\nif (a==b) cout << ?OK\\n?;\r\n\r\nif (a=b) cout << ?OK\\n?;",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Costrutti"
            },
            {
              "keyword": "idiomatici"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5218,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Abbiamo visto che in C e in C++ non esiste il tipo di dato primitivo per definire una stringa, bensì bisogna utilizzare gli array di caratteri (char). Quali funzioni, caratteristiche e pericoli presenta questa soluzione di gestione delle stringhe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": "array"
            },
            {
              "keyword": "char"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5212,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il compito del preprocessore e quali sono i possibili problemi che potrei incontrare se, in un file C++, includessi due volte la stessa libreria?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "preprocessore"
            },
            {
              "keyword": " compilazione"
            },
            {
              "keyword": " librerie"
            },
            {
              "keyword": " guardie"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5180,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale ragione i puntatori in C/C++ sono della forma \"type  *\" anziché utilizzare un tipo \"adress\"? ",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " tipo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5511,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Con i tipo address (indirizzo) sappiamo dove il puntatore sta puntando ma non sappiamo di che tipo esso sia (es. integer, long, char, etc).\r\nInvece con la forma type * (es. int * a;) sappiamo di che tipo il puntatore esso sia e dove sta puntando.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3446,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2981,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3152,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3327,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3090,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3405,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5510,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 907,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I puntatori in C/C++ sono nella forma \"type *\" poichè hanno voluto dare maggiore importanza al tipo di dato che viene puntato dal puntatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3443,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3088,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3150,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3402,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2979,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3329,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5587,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 873,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perchè in questo modo si da maggiore importanza al tipo di dato puntato dal puntatore",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3330,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3445,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2980,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3151,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3089,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3404,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5567,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 802,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perchè con la forma \"type *\" si va ad accedere alla cella di memoria (un indirizzo di memoria) puntata e ritorna il valore contenuto nella stessa, mentre con \"address\" si ritorna solo l'indirizzo della cella e non il valore contentuto",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2982,
                  "rater": {
                    "raterId": 852,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3153,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3403,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3328,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3444,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3091,
                  "rater": {
                    "raterId": 434,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5262,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando avviene l'errore denominato \"memory leak\"?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 20,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memory"
            },
            {
              "keyword": " leak"
            },
            {
              "keyword": " errore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5552,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 897,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La memory leak avviene quando non si dealloca la memoria allocata dinamicamente (in c++ avviene non usando il 'delete' dopo il 'new'), diventando così inutilizzabile e causando un incremento dell'occupazione della memoria finchè il programma non termine.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3135,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3182,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3066,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5471,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "L'errore denominato \"Memory Leak\" avviene quando il programmatore dimentica di deallocare una variabile che è stata precedentemente allocata dinamicamente nella memoria Heap tramite l'operatore \"new\".\r\nQuesta dimenticanza può succedere in linguaggi che permettono al programmatore di gestire la memoria, come ad esempio il C++. Invece in linguaggi (come Java) in cui è il sistema che si occupa di gestire l'allocazione/deallocazione della memoria esiste un meccanismo chiamato \"Garbage Collector\" che evita gli errori di \"Memory Leak\" deallocando le varibili allocate dinamicamente non più usate dal programma (senza alcun riferimento verso di esse).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3064,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3133,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3180,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5516,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un \"memory leak\", letteralmente perdita (quindi spreco) di memoria, avviene quando una parte di memoria viene allocata (di solito dinamicamente dal programmatore), ma poi, finito il suo impiego, non viene subito deallocata. In questo modo quella porzione di memora non deallocata rimane inutilizzabile per tutta la durata del programma, compromettendo l'efficienza e le prestazioni dell'intera macchina.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3136,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3067,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3183,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5476,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Quando non viene rilasciata la memoria allocata dall'heap. In C/C++ quando a new/malloc/calloc non segue delete/free.\r\n\r\nI problemi maggiori si verificano in un programma che esegue a lungo in quanto, non rilasciando ripetutamente la memoria, si rischia di esaurire quella disponibile.\r\nPer applicazioni di breve durata i problemi sono molto attenuati: è improbabile esaurire la memoria libera e, normalmente nei sistemi moderni, l'OS riscatta la memoria a termine.\r\n\r\nAllo scopo di eliminare questo ed altri problemi (es Invalid Pointer Dereference) è stato introdotto il garbage collector, il quale si occupa al posto del programmatore di rilasciare la memoria allocata. Questo introduce un certo overhead, a volte rilevante e/o non accettabile, ma garantisce l'assenza di alcuni errori difficili da prevedere, riprodurre ed eliminare: es il riferimento ad una zona di memoria già deallocata (ciò può \"far girare\" correttamente il programma in molti casi presentando errori in circostanze oscure).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3178,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3062,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3131,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5526,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 434,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il memory leak si verifica quando un programma si dimentica di liberare la memoria che ha occupato. Questo può portare ad avere segmenti di memoria \"inutilizzabile\" che crescono sempre di più, fino a quando questa finisce e il sistema si blocca.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3063,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3132,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3179,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5535,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il \"memory leak\" avviene in seguito alla mancata deallocazione di memoria di variabili che non vengono più utilizzate.\r\nEsso provoca un una diminuzione della memoria disponibile e può dunque causare l'interruzione dell'esecuzione di un programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3181,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3065,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3134,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5202,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è bene ricordarsi sempre di deallocare lo spazio in precedenza allocato?\r\n \r\nAll'interno di una funzione alloco dinamicamente un array. \r\nIn quale area di memoria vengono allocati l'array e il puntatore al primo elemento dell'array?\r\nAl termine della funzione, lo spazio sullo stack ad essa riservato viene eliminato. Che problema si può quindi presentare con l'array allocato dinamicamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " heap"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5289,
          "asker": {
            "courseId": 100,
            "askerId": 878,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzione, ma soprattutto l'importanza del preprocessore nella compilazione del codice c++?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 9,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "preprocessore"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5568,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il preprocessore e' un software che manipola il codice scritto prima che esso venga compilato. Svolge le direttive di processamento, (ovvero dai comandi che sono preceduti dal simbolo #) che servono per includere librerie standard, file header oppure MACRO (costanti o espressioni ripetute nel programma). La sua importanza e' data dal fatto che inserisce le dichiarazioni e le implementazioni delle funzioni scritte in altri file all'interno del file dove e' contenuto il main una sola volta anche se ci sono chiamate multiple allo stesso file. In questo modo si evita l errore in fase di compilazione in cui il compilatore incontra definizioni multiple della stessa funzione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3257,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3407,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3126,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3197,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3377,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5600,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 514,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il preprocessore serve per effettuare la precompilazione del codice che si vuole eseguire, linkando tutte le librerie che vengono chiamate nel codice (#) e includendone i file che servono. La sua funzione maggiore consiste nel dare la possibilità di unire codici implementati in linguaggio di alto livello con altri scritti in linguaggi di livello minore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3196,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3256,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3379,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3125,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3409,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5488,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 867,
                "courseId": 100,
                "courseFinalScore": 15
              },
              "answerText": "In C++, il preprocessore è una specie di editor che interviene prima della compilazione del programma. Il suo scopo è trovare ed eseguire le direttive: istruzioni caratterizzate dal # ad inizio riga. Queste vengono usate per includere file e librerie (#include ...) o per definire costanti (#define ...), (anche se quest'ultimo è sconsigliato). \r\n\r\nIl preprocessore è molto importante in quanto modifica il codice sorgente, per il compilatore. Per esempio, per includere una classe, al programmatore basta scrivere #include \"nomeclasse\", invece che importare ogni singolo file, perché di questo si occupa il preprocessore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3406,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3124,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3195,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3376,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3255,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5550,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'importanza del preprocessore nella compilazione c++ consiste nella possibilità di poter includere librerie permettendo dunque di accedervi con chiamate dal main alleggerendo notevolmente il codice che si intende scrivere facendo appoggio su funzioni e metodi la cui funzionalità è certa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3194,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3378,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3408,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3254,
                  "rater": {
                    "raterId": 853,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3123,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5267,
          "asker": {
            "courseId": 100,
            "askerId": 897,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cosa serve il \"marker\" nell'implementazione di una pila e come viene usato nelle varie funzioni (crea, cresci, inserisci, estrai, copia).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " marker"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5231,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella soluzione vista a lezione di una possibile implementazione di Pila di dimensione crescente questa è la procedura che viene chiamata quando devono crescere le dimensioni della pila:\r\n \r\n void cresci(Pila *s, int increment){\r\n\t//aumenta la dimensione dello Pila\r\n\tcout<<\"entro in cresci\"<<endl;\r\n\ts->size+=increment;\r\n\tint * temp=new int[s->size];\r\n\tfor (int k=0; k<s->marker;k++) {\r\n\ttemp[k]=s->contenuto[k];\r\n\t}\r\n\tdelete [](s->contenuto);\r\n\ts->contenuto=temp;\r\n  }\r\n  \r\nIn quale situazione può fallire l'esecuzione di una chiamata a tale procedura? \r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5241,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai le variabili globali nel linguaggio di programmazione C++ sono altamente dannose sia per il programma che per il programmatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "variabili"
            },
            {
              "keyword": " globali"
            },
            {
              "keyword": " dannose"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5166,
          "asker": {
            "courseId": 100,
            "askerId": 862,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa bisogna fare attenzione operando con i puntatori, quali sono errori più comuni ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": "pila"
            },
            {
              "keyword": "memoria"
            },
            {
              "keyword": "copia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5234,
          "asker": {
            "courseId": 100,
            "askerId": 853,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella costruzione di uno Stack, nella funzione distruggi qual'è l'ordine di deallocazione della Heap? (Motiva la risposta).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "heap"
            },
            {
              "keyword": " stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5242,
          "asker": {
            "courseId": 100,
            "askerId": 893,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare il fenomeno detto memory leak. In particolare spiegare in quali situazioni si presenta, quali linguaggi di programmazione ne sono maggiormente affetti, quali tecniche e strumenti vengono utilizzati per rilevarlo e quali per prevenirlo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoryleak"
            },
            {
              "keyword": "heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5244,
          "asker": {
            "courseId": 100,
            "askerId": 514,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la funzione assert?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": " assert"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5259,
          "asker": {
            "courseId": 100,
            "askerId": 434,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "In C++, a cosa equivale scrivere a[3]?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "C++"
            },
            {
              "keyword": "puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5298,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per \"memory leak\" e che relazione c'è con l'allocazione di memoria di tipo \"at run time\"?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " errore"
            },
            {
              "keyword": " allocazione"
            },
            {
              "keyword": " programmatore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5519,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 756,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Il \"memory leak\" è un tipo di errore, causato dalla mancata deallocazione delle variabili allocate dinamicamente dal programmatore, e causa uno spreco di memoria, la quale può risultare non disponibile ad altri programmi. Questo implica una riduzione delle prestazioni della macchina.\r\nL'allocazione di tipo \"at run time\" è appunto l'allocazione dinamica della memoria che il programmatore effettua nel suo programma, grazie all'istruzione new o malloc. Questa spazio di memoria viene riservato al programma nello heap. Se il programmatore quando smette di utilizzare una variabile allocata dinamicamente o \"at run time\", omette l'istruzione di deallocazione (es. delete[] o free()), lo spazio in memoria sarà comunque riservato per quella variabile, ma questo spazio non verrà più utilizzato per tutta l'esecuzione del programma, causando il memory leak.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3203,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2931,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3138,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2921,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3048,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5545,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per memory leak si intende il consumo di memoria involontario dovuto alla mancata cancellazione (deallocazione) di spazio dopo averlo usato. Il memory leak avviene quando, dopo aver riservato uno spazio con l'operatore new(), non viene prontamente cancellato(delete()) al termine del suo utilizzo, ciò può portare alla saturazione della memoria utile da parte di variabili o classi che non verranno più utilizzate ed impedirne l'allocamento ad processi che ne necessitano.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3050,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2933,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2923,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3140,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3205,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5566,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 811,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un \"memory leak\" avviene quando un programma o il sistema operativo non deallocano una porzione di memoria allocata a \"run time\" quando è necessario farlo, lasciando degli spazi di memoria occupati ma inutilizzati. Questo è dannoso perchè, accumulandosi, i memory leak possono arrivare a bloccare il sistema operativo stesso per mancanza di RAM.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2932,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3204,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3049,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3139,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2922,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5507,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Con il termine 'memory leak' si intende il consumo non previsto di una certa quantità di memoria, che viene resa inutilizzabile a causa di un errata deallocazione. Per esempio, se considero un puntatore *p che punta ad una certa area di memoria (immaginiamo 4 byte) ed eseguo 'p=NULL', prima della chiamata 'delete p', creerò un memory leak, poichè quello spazio di 4 byte non verrà più utilizzato. Sarà anche impossibile riallocarlo, poichè il sistema operativo lo vedrà come ancora in uso.  \r\nQuesto evento è molto comune quando si gestiscono spazi di memoria creati a 'run time', cioè\r\ntramite la chiamata 'new' che alloca una determinata quantità di memoria all'interno della heap. Queste\r\ninformazioni vengono 'liberate' solo in modo esplicito, indicato dal programmatore, o quando il programma termina. Invece un dato statico, definito nello stack, viene deallocato subito dopo l'uscita dal blocco dove è definito.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2934,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2924,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3206,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3141,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3051,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5556,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 853,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Per memory leak si intende un consumo non voluto della memoria dovuto alla mancanza della deallocazione della stessa. Se la memoria di tipo at run time (all. dinamica) non viene deallocata, questa non verrà liberata fino a fine processo e si potrà generare un memory leak. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2930,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3047,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3202,
                  "rater": {
                    "raterId": 787,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2920,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3137,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5175,
          "asker": {
            "courseId": 100,
            "askerId": 861,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è rischioso eseguire la copia nell'implementazione di uno stack? Che rischi posso incontrare se utilizzo un'implementazione errata? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "rischi"
            },
            {
              "keyword": "stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5261,
          "asker": {
            "courseId": 100,
            "askerId": 751,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra un allocazione statica e un allocazione dinamica? Quali complicanze comporta non deallocare un array? Fare un esempio di allocazione e deallocazione di un array. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione"
            },
            {
              "keyword": " deallocazione"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5226,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa significano i principi di \"information hiding\" e di \"need to know\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "information"
            },
            {
              "keyword": " hiding"
            },
            {
              "keyword": " need"
            },
            {
              "keyword": " know"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5195,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli aspetti fondamentali da considerare per la costruzione di una pila in c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " c++"
            },
            {
              "keyword": " costruzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5185,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "data una funzione incrementa ,la quale va a incrementare lo spazio allocato dinamicamente in memoria per lo stack, quali problematiche possono sorgere?In particolare cosa avviene se lo spazio riservato alla heap e lo spazio riservato allo stack collidono?Fornire inoltre una soluzione al problema sopracitato in dettaglio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": "stack"
            },
            {
              "keyword": "heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5276,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "prendendo come riferimento l'esempio di pila fornita dal prof. Ronchetti nelle slide del corso, sottolineare l'importanza dei vari elementi della struct per la creazione della pila.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5203,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Definisci cos'è uno stack e un heap, poi spiega la differenza fra allocazione dinamica e statica di memoria.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "compile time"
            },
            {
              "keyword": " run time"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5240,
          "asker": {
            "courseId": 100,
            "askerId": 802,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa serve e fa la 'delete'? e cosa crea un mancato uso della stessa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "operatori"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5230,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si alloca dinamicamente, c'è li rischio che la memoria heap possa sovrascrivere quella stack? Se sì, come posso evitare che ciò accada?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Heap"
            },
            {
              "keyword": " Stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5278,
          "asker": {
            "courseId": 100,
            "askerId": 882,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "qual è la modalità che ci permette di inserire ed estrarre dati omogenei da una pila?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5297,
          "asker": {
            "courseId": 100,
            "askerId": 904,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché l' utilizzo delle variabili globali è sconsigliato ?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "variabili "
            },
            {
              "keyword": "globali"
            },
            {
              "keyword": "sconsigliate"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5599,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Utilizzare variabili globali è sconsigliato perché hanno scope su tutte le funzioni del progetto ed il loro valore è quindi visibile a tutte le funzioni. Questa particolarità delle variabili globali fa sì che sia difficile gestire le variabili locali all'interno di singole funzioni (soprattutto in progetti di grandi dimensioni), dato che sarà sempre necessario tenere conto anche delle variabili globali, che saranno sempre visibili ad esse. In un contesto del genere, è facile l'insorgere di effetti collaterali e inaspettati; per questo motivo è sempre opportuno rispettare il \"principio della località dell'informazione\" e dichiarare solamente variabili locali, così da avere un maggior e più immediato controllo del loro valore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2939,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3100,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3469,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3226,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5553,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Anzitutto le variabili globali rendono più difficile la lettura di un programma da parte del programmatore in caso di errori: infatti, se una variabile può essere vista e modificata in ogni blocco, il suo valore può essere modificato in un qualsiasi punto del programma (se poi il programma contiene migliaia di righe di codice...) e anzi, addirittura può essere modificato in file differenti. Inoltre rendono più confusa la gestione dei nomi da associare alle variabili (sia globali che locali); infine le funzioni, pur avendo il \"vantaggio\" di non necessitare di alcun passaggio di parametri, ha per contro il grandissimo svantaggio che il programmatore dovrebbe conoscere a priori tutte le variabili globali dichiarate e inizializzate all'interno del programma, cosa pressoché improbabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3468,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2938,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3099,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3225,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5585,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Il loro utilizzo è sconsigliato principalmente per due motivi: prima di tutto la leggibilità. L'utilizzo delle variabili globali rende infatti il codice molto meno leggibile. Utilizzando le varaibili globali bisogna inoltre considerare che il loro valore può essere modificato ovunque nel programma. Quest'ultimo motivo rende anche molto più difficile trovare eventuali errori",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3467,
                  "rater": {
                    "raterId": 900,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2940,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3227,
                  "rater": {
                    "raterId": 917,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3101,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5179,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi brevemente la funzione \" Pila * copia(Pila * from)  \", soffermandoti sui passaggi fondamentali per far sì che vada a buon fine.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": "copia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5245,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Con che carattere terminano gli array di caratteri (o stringhe) in c++ e per quale motivo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe "
            },
            {
              "keyword": " carattere_nullo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5248,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per \"memory leak\"? E da che cosa è provocato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memory"
            },
            {
              "keyword": " leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5205,
          "asker": {
            "courseId": 100,
            "askerId": 584,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Dare la definizione di \"stringa\" in C/C++ ed elencare le possibili operazioni da applicarvi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringa"
            },
            {
              "keyword": " operazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5216,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Da cosa dipende la quantità di memoria che il sistema operativo destina ad un programma? Posso aumentarla o diminuirla tramite opzioni di compilazione o in run time?",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": "os"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5574,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 827,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "(forse domanda più adatta al modulo2 del corso) \r\nDipende dall'allocazione definita: se essa è statica allora un predefinito spazio di memoria verrà allocato in base agli elementi del codice che si compila; se essa è dinamica allora l'utente nel codice dovrà definire quando e quanta memoria necessita il programma e quando deallocarla.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3349,
                  "rater": {
                    "raterId": 873,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3111,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3267,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3046,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5603,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "La memoria che il sistema operativo destina ad un programma deve essere innanzitutto sufficiente a contenere il codice di testo del programma stesso. Poi tramite la dichiarazione di variabili, per esempio, vengono occupati dei byte che dipendono dal tipo della variabile stessa: un intero occupa quattro posizioni, un carattere una posizione, un double otto, ecc. Lo stesso per costanti o altri tipi di dato che richiedono uno spazio di memoria. Ovviamente in questo caso si parla di stack di memoria, ossia quello spazio di memoria che il compilatore assegna in qualsiasi caso per l'esecuzione del programma. Un'altro tipo di memoria è la heap, che viene gestita dinamicamente sulla base del codice scritto dal programmatore e che può richiedere o deallocare memoria anche a run time.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3266,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3352,
                  "rater": {
                    "raterId": 873,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3110,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3045,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5608,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 806,
                "courseId": 100,
                "courseFinalScore": 30
              },
              "answerText": "La quantità di memoria destinata dipende da diversi fattori, tra cui la quantità di chiamate ricorsive che riservano variabili nella memoria stack, l'uso di funzioni come malloc(), che occupano \"a vuoto\" dello spazio in memoria... ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3043,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3108,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3350,
                  "rater": {
                    "raterId": 873,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3264,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5616,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La quantità di memoria che un s.o. destina a un programma non è definita a priori, dipende da quanto esso ne abbia a disposizione all'interno della RAM. Quello che un programmatore può fare è ottimizzarla. Il programmatore può utilizzare due modi differenti per allocare memoria:at Compile Time e at Run Time. Nel primo caso, allochiamo memoria nella heap senza possibilità di liberarla. Nel secondo caso si utilizzano i costrutti New e Delete. Con New definiamo della memoria da allocare e con Delete la deallochiamo, cioè la liberiamo. In questo modo è possibile riutilizzare quello stesso spazio di memoria, di nuovo, durante l'esecuzione del programma. Il metodo at Run Time ci permette di evitare il problema del Memory Leak, cioè della mancanza di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3351,
                  "rater": {
                    "raterId": 873,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3109,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3265,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3044,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5235,
          "asker": {
            "courseId": 100,
            "askerId": 879,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le Stringhe in C/C++?? E perché sono pericolose??",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "strings"
            },
            {
              "keyword": " c"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5250,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Esporre quali sono le aree principali che costituiscono il modello di memoria durante l?esecuzione di un programma, ponendo particolare attenzione sull?area HEAP e l?area STACK descrivendone le diverse mansioni che ricoprono durante il processo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Heap"
            },
            {
              "keyword": " Stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5228,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Indicare, nella sottostante struct, la specifica funzione della variabile \"marker\".\r\nstruct Pila {\r\nint size;\r\nint defaultGrowthSize;\r\nint marker;\r\nint * contenuto;\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " marker"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5189,
          "asker": {
            "courseId": 100,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la principale differenza tra array e struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " struct"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5178,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel momento in cui si costruisce una Pila si ha a disposizione solo un certo spazio in memoria, come si fa a capire che lo spazio a disposizione non è più abbastanza? E in che momento è più opportuno chiamare la funzione 'cresci'? E' sempre possibile richiamare questa funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " cresci"
            },
            {
              "keyword": " spazio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5219,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella funzione \"distruggi\" (costruzione della Pila, slide 61) è importante l'ordine in cui vengono eseguiti i due comandi delete? Perché?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " distruggi"
            },
            {
              "keyword": " delete"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5221,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è importante deallocare la memoria quando si utilizza l'allocazione dinamica?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": "allocazione"
            },
            {
              "keyword": "dinamica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5288,
          "asker": {
            "courseId": 100,
            "askerId": 759,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qualè la durata di un?Allocazione Dinamica ? Cos'è \"memory leak\" ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Allocazione"
            },
            {
              "keyword": " Dinamica"
            },
            {
              "keyword": " Memory leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5260,
          "asker": {
            "courseId": 100,
            "askerId": 828,
            "courseFinalScore": 14
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa fanno gli operatori New e Delete?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "New"
            },
            {
              "keyword": " Delete"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5170,
          "asker": {
            "courseId": 100,
            "askerId": 815,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "La gestione della HEAP risulta non facile, ma allora a cosa serve? Quali vantaggi porta la HEAP rispetto alla STACK?",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Heap"
            },
            {
              "keyword": " stack"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5543,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La HEAP è un blocco di memoria riservata al programma, ove l' allocazione di memoria non avviene più automaticamente da parte del programma stesso, bensì tramite esplicita richiesta del programmatore, attraverso funzioni come new (C++), malloc, calloc (C). Il suo scopo  principale è quello di poter allocare memoria dinamicamente (a runtime), in risposta alle esigenze del programma, quando non è possibile conoscere a priori la quantità di spazio necessario. I principali vantaggi della HEAP rispetto allo STACK sono quindi una gestione manuale e dinamica della memoria, la cui durata dipende dal programmatore e non più dalla vita della specifica funzione, in modo che le variabili siano accessibili per un periodo di tempo maggiore, a discrezione del programmatore stesso, il quale ha il compito di rilasciarle la memoria quando non più necessaria, per non incorrere in memory leak; lo scope di queste variabili è globale, tuttavia l'unico mezzo per accedervi avviene tramite puntatori (Handle). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2908,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2943,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2999,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3094,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3345,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5534,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 881,
                "courseId": 100,
                "courseFinalScore": 9
              },
              "answerText": "Con la gestione tramite HEAP abbiamo che la memoria è allocata dinamicamente ad un blocco di memoria chiamato heap. Per allocare memoria sull'heap, il programmatore deve usare le funzioni malloc() o calloc(), che sono già implementate in C. Per liberare memoria basta chiamare una free(). \r\nRispetto allo stack, l'heap non ha restrizioni sulla dimensione delle variabili. Dato che per accedervi si usano puntatori, la lettura e scrittura sono più lente. Inoltre, le variabili create nell'heap sono accessibili da qualunque funzione del programma. Si può dire che hanno uno ''scope'' globale.\r\nTuttavia l'heap può portare anche a frammentazioni  della memoria, se sono presenti eccessive allocazioni seguite da deallocazioni. \r\nSe serve allocare un grande blocco di memoria (per allocare una grossa struttra dati, ad esempio) e servono variabili che siano sempre visibili per molto tempo, allora conviene usare la gestione tramite heap. Oltrettutto le variabili possono essere anche ridimensionate.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3000,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3095,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2909,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2944,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3347,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5480,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Non ci sono vantaggi, perche' sono due parti di memoria dediche a compiti diversi, nello STACK vengono salvate \r\n-Le variabili locali per la chiamata al metodo\r\n-L'ambiente di esecuzione del metodo stesso\r\n-Lo stack degli operandi\r\nNella HEAP vengono allocati gli oggetti appena creati.\r\nA differenza del C++ non occorre eliminare personalmente gli oggetti nella HEAP ma ci penza il Garbage collector.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3092,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3348,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2997,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2906,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2941,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5604,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Servono per l'allocazione della memoria, lo stack viene usato per le variabili automatiche mentre l'heap mantiene le variabili, si crea all'inizio del programma e si elimina al suo termine viene usata per le variabili dinamiche.\r\nSono due metodi diversi che hanno i loro pro e contro, il primo utilizza una pila quindi se vuoi eliminare tutte le variabili di una funzione è relativamente semplice.\r\nIl secondo invece ti permette una gestione dinamica delle tue variabili, potendo aggiungerne di nuove e toglierle.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2998,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3093,
                  "rater": {
                    "raterId": 815,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2907,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3346,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2942,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 5211,
          "asker": {
            "courseId": 100,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra allocazione statica della memoria e allocazione dinamica? Inoltre come funzionano gli operatori \"new\" e \"delete\"? Il mancato uso di \"delete\" cosa provoca?\r\nSe possibile fare anche un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Allocazione"
            },
            {
              "keyword": "memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5214,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "In C++ non esiste il tipo stringa, in che modo può essere comunque definita?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringa"
            },
            {
              "keyword": " C++"
            },
            {
              "keyword": " array"
            },
            {
              "keyword": " stringhe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5191,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare il funzionamento della funzione \"cresci\", per la gestione di una pila, vista a lezione:\r\n\r\nvoid cresci(Pila *s, int increment){\r\n//aumenta la dimensione dello Pila\r\n cout<<\"entro in cresci\"<<endl;\r\n s->size+=increment;\r\n int * temp=new int[s->size];\r\n for (int k=0; k<s->marker;k++) {\r\n temp[k]=s->contenuto[k];\r\n }\r\n delete [](s->contenuto);\r\n s->contenuto=temp;\r\n} ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzione cresci"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5283,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Dove alloca in memoria la variabile  new? E cosa le cambia tra heap e stack?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "New"
            },
            {
              "keyword": "memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5486,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "New alloca dinamicamente in cellette della dimensione (size of) adatta al tipo indicato degli elementi che vado a allocare. Lo stack è una struttura dati in cui gli elementi sono collocati secondo la modalità Last In First Out (LIFO) in cui l'ultimo elemento inserito è il primo che viene prelevato e/o letto, l'heap invece è una struttura dati in cui gli elementi, collocati in una struttura a albero, rispettano la condizione che ogni elemento è maggiore di quello posizionato sotto di lui e minore di quello sopra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2969,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3311,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3473,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3455,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5614,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 901,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore new type alloca sizeof(type) bytes nella memoria heap. La heap è una parte di memoria destinata a contenere le variabili dinamiche( di dimensioni non prevedibili a tempo di compilazione), mentre la stack è quello spazio in memoria in cui sono contenuti le variabili locali e i parametri formali delle funzioni.\r\nLe variabili allocate tramite operatore new nell'area heap devono essere sempre deallocate a fine esecuzione del programma con l'operatore delete per evitare inutili sprechi di memoria. Anche se alcune macchine deallocano automaticamente le variabili dinamiche è buona prassi liberare manualmente la memoria usando il comando delete.\r\nLa memoria stack non ha bisogno di tali accorgimenti poiché viene svuotata dopo il runtime.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3454,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2967,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3472,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3308,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5610,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Operatore new costruisce uno o più oggetti nell'area heap.\r\nStack e heap sono due zone di memoria differenti, con funzioni e finalità diverse.\r\n-Lo stack:\r\n+Organizzazione di memoria di tipo LIFO.\r\n+Memorizza le variabili locali alle funzioni o blocchi, una volta terminata l'esecuzione la memoria viene liberata automaticamente.\r\n+La memoria viene gestita in automatico.\r\n-Heap:\r\n+Zona di memoria libera ad uso del programmatore\r\n+Gestita dal programmatore(dipende dal linguaggio),Dunque ciò che viene allocato deve essere deallocato finita la sua utilità\r\nDifferenze\r\n-A variare del linguaggio l'uso efficace del heap può richiedere abilità(c,c++).\r\n-Lo stack è più veloce dato che heap viene letto attraverso puntatori.\r\n-Heap è più grande ma è più suscettibile allo spreco di memoria, (memory leaks,strutture di grandezza variabile),uso di memoria poco efficiente a prolungarsi dell'esecuzione.\r\n-Heap permette l'uso di variabili di grandezze non definite a priori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3453,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3309,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3471,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2966,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5504,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "La variabile \"new\" alloca nello heap, che è l'area di memoria dove gli elementi vengono allocati dinamicamente dal programmatore, mentre lo \"stack\" è l'area di memoria statica allocata dalle funzioni e dalle variabili automatiche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2968,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3452,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3310,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3470,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5489,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "in c++ la variabile new costruisce uno o più oggetti nella memoria dinamica heap e ne restituisce l'indirizzo. Per questo, diversamente dalla memoria statica, tutte le variabili new allocate nello heap dal programmatore devono essere poi distrutte quando non sono più necessarie, per evitare un problema chiamato ?memory leaks?, ovvero per evitare che la memoria allocata rimanga tale anche dopo la fine del programma. In C++ per distruggere una variabile puntatore si usa l'istruzione \"delete\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2970,
                  "rater": {
                    "raterId": 844,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3307,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3474,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3456,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5158,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il rischio che si incorre copiando puramente una pila ed i suoi puntatori? Come lo si può risolvere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5209,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel metodo distruggi (void distruggi (Pila *s)) della struttura Pila, la scrittura\r\n delete [] (s->contenuto);\r\ndelete s;\r\nè equivalente a scrivere\r\ndelete s;\r\ndelete [] (s->contenuto);\r\n?(motivare la risposta)\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "delete"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5213,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Memory Leak?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Memory"
            },
            {
              "keyword": " Leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5265,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Durante la costruzione di uno stack, in memoria, andiamo ad utilizzare entrambi i blocchi dinamici (stack e heap), in che modo? In quale caso andiamo in contro alla cosiddetta \"FRAMMENTAZIONE DELLA HEAP\" e cosa significa?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 18,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": " Frammentazione"
            },
            {
              "keyword": " Costruzione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5524,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Inizialmente nella funzione \"crea\" viene allocata nello stack la variabile s di tipo Pila*, contenente cioè l'indirizzo della variabile di tipo Pila, che invece viene allocata nella heap. In seguito viene posto all'interno della cella contenuto della Pila l'indirizzo di un nuovo array che viene allocato sempre nella heap. Tale array ha dimensione fissata (pari ad initialSize nel nostro esempio).\r\nPoichè l'obiettivo iniziale era quello di costruire una pila con un numero arbitrario di elementi, viene introdotta anche la funzione \"cresci\" che crea un nuovo array nella heap, di dimensione più grande, nella cui prima parte vengono copiati i valori dell'array di dimensione più piccola precedentemente costruito. Infine quest'ultimo viene rimosso mediante l'istruzione \"delete\".\r\nL'applicazione di queste due funzioni causa la cosiddetta \"frammentazione\" della memoria, poichè nella heap ci sarà un blocco di memoria occupato da Pila, uno libero ed un altro occupato dall'ultimo array costruito.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3228,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3388,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3145,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3293,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3280,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5501,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La memoria e' definita dinamica perche' utilizzata ed allocata a run-time. \r\n\r\nL'allocazione nello stack avviene nel momento in cui una funzione viene invocata.\r\nQuest'area di memoria con accesso di tipo LIFO permette alla funzione un eventuale allocazione di variabili locali alla funzione (parametri formali), risultati temporanei, indirizzi di ritorno dei risultati. Lo spazio allocato viene deallocato al termine della funzione\r\n\r\nLo heap e' un'area di memoria utilizzabile dal programmatore la quale e' accessibile tramite gli operatori NEW e DELETE.\r\n\r\nLo heap differisce dallo stack perche' la quantita' di memoria allocabile e' variabile (dipende appunto dalla scelta compiuta dal programmatore).\r\n\r\nEcco perche' esiste il fenomeno detto \"FRAMMENTAZIONE DELLO HEAP\" dove ogni blocco allocato dinamicamente nello heap puo' assumere dimensioni diverse.\r\n\r\nSta al S.O gestire al meglio il riordinamento e l'ottimizzazione dello heap affinche' venga utilizzato nel modo piu' efficiente possibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3387,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3146,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3229,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3281,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3294,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5475,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Durante la costruzione di uno stack andiamo ad utilizzare sia lo stack che la heap in quanto le variabili (come ad esempio i campi statici) della struct Pila andranno allocati nello stack, e l'array \"contenuto\" che conterrà gli elementi contenuti effettivamente nello stack, essendo un array dinamico allocato tramite \"new\", verrà allocato nella heap.\r\nLa frammentazione della heap è un fenomeno che si verifica quando si verifica una condizione in cui è necessario scegliere, parlando di allocazione, tra la soluzione \"first fit\" e \"best fit\". Nel primo caso si alloca il nuovo \"oggetto\" nella prima area di memoria disponibile in grado di contenere tale oggetto, nel secondo si utilizza la prima area che genera il minor surplus possibile. In entrambi i casi però, si generano aree di memoria vuote più o meno grandi, che possono appunto generare una \"frammentazione della heap\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3231,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3148,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3385,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3296,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3283,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5538,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Lo stack e l'heap sono due blocchi già definiti in memoria, con due ruoli distinti. \r\nLo stack si occupa di allocare le variabili automatiche in memoria, cioè le variabili utilizzate durante l'esecuzione del programma. \r\nL'heap invece si occupa di richiedere uno spazio in memoria di un certo numero di bit, esso inoltre viene allocato dinamicamente dal programmatore.\r\nL'heap essendo allocato dinamicamente, e quindi non avendo dei blocchi già predefiniti, verrà suddiviso (frammentato) in base alle esigenze di spazio richiesto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3295,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3147,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3230,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3282,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3386,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5554,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Durante la costruzione di uno Stack(pila) andiamo a utilizzare entrambi i blocchi di memoria perché la struttura dati dello Stack(pila) viene allocato nella Heap mentre lo Stack(memoria) è utilizzato dai metodi che lavorano sullo Stack(pila)\r\nFrammentazione della Heap significa che nella parte di memoria dedicata alla Heap i dati di un processo non sono disposti in modo sequenziale, ma c'è dello \"spazio vuoto\" tra un dato e l'altro; questo fenomeno è causato dal fatto che se allochiamo in Heap ad esempio 3 variabili  A,B,C e poi lo spazio di memoria dedicato alla variabile B viene liberato (perché B non è più utilizzata), allocando una variabile D di maggiori dimensioni rispetto a B, ad essa non potrà essere assegnato lo spazio tra A e C, e quindi tale spazio resta \"vuoto\". ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3297,
                  "rater": {
                    "raterId": 767,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3149,
                  "rater": {
                    "raterId": 751,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3232,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3284,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3389,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5183,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cos'è il \"memory leak\", elencandone le cause. Come viene risolto questo problema?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memory"
            },
            {
              "keyword": " leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5290,
          "asker": {
            "courseId": 100,
            "askerId": 887,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Che funzione svolge il \"this->\"?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": "attributi"
            },
            {
              "keyword": "self"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5562,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "In c++ all'interno di ogni classe/struct esiste una variabile di istanza implicita chiamata \"this\".\r\nSi tratta di un puntatore ad \"un oggetto di tipo questa classe/struct\".\r\n\r\nSi può quindi usare l'operatore -> per riferirsi ad un membro (variabile o metodo) della classe/struct.\r\n\r\nGrazie alle regole di scope statico adottate dal c++, appartenendo this al blocco della definizione della classe/struct, questa variabile sarà visibile anche all'interno di ogni metodo.\r\nInizialmente, potrebbe sembrare inutile dato che anche ogni altro membro (variabile o metodo) della classe/struct dovrebbe essere visibile all'interno degli altri suoi metodi. Due possibili applicazioni di tale costrutto possono essere:\r\n- il caso in cui devo passare da dentro l'oggetto (da dentro un suo metodo) un riferimento di se stesso a qualcun'altro\r\n- il caso in cui nel blocco attuale esista una variabile con lo stesso nome di una variabile di istanza e a me serva un riferimento ad entrambe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3085,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3501,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3015,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3120,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5536,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 800,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Innanzitutto il this è un puntatore proprio di una funzione membro che viene implementato automaticamente. Esso fa punta ad una istanza della funzione chiamata nella classe, che può essere puntata automaticamente se essa è unica oppure svolge la funzione di un puntatore di scope locale alla funzione, quindi a seconda di ciò a cui il programmatore lo fa puntare. E' utile anche perché all'interno di una classe che si supponga abbia una variabile di nome \"a\", e richiamando una funzione membro con una istanza anch'essa chiamata \"a\", il puntatore this punterà sempre alla variabile con scope locale alla propria funzione, senza permettere errori di scope.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3500,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3087,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3122,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3017,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5592,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 831,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il this-> è un puntatore all'istanza della classe (oggetto) a cui appartiene il metodo che utilizza il this. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3502,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3121,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3086,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3016,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5172,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere la struttura standard e le funzioni principali della pila (stack). Utilizza tecnica LIFO o FIFO?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack "
            },
            {
              "keyword": " pila "
            },
            {
              "keyword": " struttura"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5275,
          "asker": {
            "courseId": 100,
            "askerId": 884,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi il concetto di pila in ambito informatico e rispondi alle seguenti domande:\r\n-Quali sono le principali funzioni per la gestione di una pila?\r\n-Puoi fare degli esempi in cui essa è utilizzata? Se sì, perchè secondo te è stata scelta questa struttura?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": "memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5291,
          "asker": {
            "courseId": 100,
            "askerId": 824,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Consideriamo una pila composta da tanti singoli nodi o blocchetti costruiti nel seguente modo:\r\nnodoPila{\r\n    int value; //contente il valore di questo nodo\r\n    nodoPila * link; //puntatore al blocchetto precedente\r\n}\r\nOgni blocchetto punterebbe al blocchetto precedente tramite la variabile puntatore a nodoPila link. \r\n    ........<- |nodo1| <- |nodo2| <- |nodo3| <- |nodo4| .......\r\nSi potrebbero implementare delle funzioni per l'aggiunta dinamica di nuovi blocchi e quindi valori, per la loro rimozione e distruzione in memoria ecc...\r\nA partire dal primo blocchetto si potrebbe scorrere tutta la pila leggendo man mano il puntatore al blocchetto seguente e quindi estrarre tutti i valori.\r\nMa a cosa dovrebbe puntare il primo blocchetto non avendone nessun altro alle spalle, per fare anche in modo che durante la lettura ci si fermi?\r\nCome si può rimediare al fatto che il primo blocco non è raggiungibile dagli altri perché niente punta a lui?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " struct "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5258,
          "asker": {
            "courseId": 100,
            "askerId": 910,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i passaggi da seguire per lo spostamento di un array?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "spostamento"
            },
            {
              "keyword": " array."
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5223,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestita la memoria nel caso del passaggio di un array a una funzione rispetto al passaggio di una variabile semplice, ad esempio di tipo int?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " funzione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5292,
          "asker": {
            "courseId": 100,
            "askerId": 821,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'implementazione di una pila quali funzioni sono necessarie?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": "Implementazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5181,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Dichiarare un vettore corrisponde in qualche modo a dichiarare un puntatore. Spiegare analogie e differenze tra le forme:\r\n\r\nint a[10]   e   int *a; a = new int[10]",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Vettore"
            },
            {
              "keyword": " Puntatore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5472,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "In entrambi i casi, la variabile \"a\" può essere utilizzata come un puntatore (sono valide istruzioni del tipo \"*a\" e \"a+2\"). Ma, mentre nel primo caso l'allocazione dello spazio necessario agli elementi avviene sul record di attivazione della funzione (nello stack), nel secondo caso essa ha luogo nella memoria dinamica (heap). Ciò comporta che, mentre nel primo caso la vita dell'array è legata a quella del blocco in cui è dichiarato, nel secondo caso essa continua fino a che non viene chiamato l'operatore \"delete[]\". Inoltre, nel secondo caso, la variabile \"a\" può essere successivamente riferita ad un'altro array allocato dinamicamente, mentre nel primo caso punterà sempre solo all'array statico iniziale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2974,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2904,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3380,
                  "rater": {
                    "raterId": 923,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3457,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5607,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Le differenze sono le seguenti: la prima forma occupa 10 spazi di memoria nello stack (e gli assegna \"a\" come nome) e lo fa staticamente, mentre la seconda crea una variabile puntatore nella memoria heap e lo fa (attraverso il new) in modo dinamico. \r\nLe analogie stanno nel fatto che entrambe creano un array riservando dieci spazi di memoria. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2905,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3382,
                  "rater": {
                    "raterId": 923,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2975,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3459,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5530,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 849,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Entrambe eseguono l'allocamento di un array di dimensione pari a 10 interi.\r\nLa prima forma lo alloca staticamente, la seconda dinamicamente. Nel secondo caso il programmatore ha il ruolo di controllare il comportamento del puntatore, in modo che non si generino memory leaks (quindi calo delle prestazioni della macchina) o dangling references (con rischio di accedere ad aree di memoria deallocate o utilizzate da altri processi).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2973,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3381,
                  "rater": {
                    "raterId": 923,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3458,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2903,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5549,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 783,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Entrambe le forme dichiarano un vettore di tipo int di dimensione 10,però la prima alloca il vettore staticamente e la seconda dinamicamente.I vettori statici sono la struttura dati efficiente quando si conosce la loro lunghezza al momento di scrivere il programma,ma non sono adeguati se la dimensione del vettore può essere nota solo in fase di esecuzione(infatti bisognerebbe inizializzare vettori grandi comportando uno spreco di memoria).Infatti per i vettori statici viene riservato spazio nella memoria principale già al momento della compilazione, e quindi si deve già conoscere lo spazio necessario per il vettore ancora prima di eseguire il programma.\r\nÈ invece molto frequente non conoscere  la quantità di memoria necessaria fino al momento dell'esecuzione del programma,ed è qui che interviene l'allocazione dinamica della memoria.Inoltre l'allocazione dinamica presenta un altro vantaggio:mentre un vettore statico(non globale) non può essere restituito da una funzione,uno dinamico sì.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2902,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3383,
                  "rater": {
                    "raterId": 923,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2972,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3460,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5514,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 839,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La differenza fra le due forme sta in quale parte di memoria viene allocato l'array. Nel primo caso vengono riservate 10 allocazioni di memoria per l'array in stack, nel secondo caso vengono allocate nell'heap. L'analogia è che in ambedue i casi avremo il puntatore 'a' che punta alla prima allocazione di memoria dell'array che quindi si può scorrere incrementando l'indirizzo 'a' e i due array sono uguali a meno della posizione in memoria(come detto prima). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2901,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2971,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3461,
                  "rater": {
                    "raterId": 882,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3384,
                  "rater": {
                    "raterId": 923,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5299,
          "asker": {
            "courseId": 100,
            "askerId": 791,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono le API (Application programming interface)? Qual è il loro scopo? ",
          "totalDifficultyLevel": 23,
          "totalInterestingnessLevel": 25,
          "totalRelevanceLevel": 24,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Application"
            },
            {
              "keyword": " programming"
            },
            {
              "keyword": " interface"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5518,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le API possono essere considerate come delle librerie che contengono tutte le istruzioni per far leggere a una macchina un determinato programma.\r\nNe esistono diversi tipi quindi è necessario inserire nel programma la giusta API per far si che la macchina lo possa riconoscere e quindi eseguirlo.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3023,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3177,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3344,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3492,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5508,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 757,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le API(Application programming interface) in sostanza rendono la programmazione piu semplice. In che senso e come? Tutto nasce dallo sviluppo di un particolare software o anche di un sistema operativo, i programmatori di questi ultimi durante lo sviluppo di questi progetti scrivono una serie di funzioni complesse o semplici. Al momento della vendita del software o della pubblicazione gratutita di esso(open source) i programmatori mettono a disposizione le API di tale programma agli altri sviluppatori, per permettere a questi ultimi  di poter sfruttare tutte le potenzialità del programma o del sistema operativo, rendendo quindi la programmazione effetivamente meno complicata e più veloce nel senso, la finalità quindi è ottenere un'astrazione a più alto livello, di solito tra l'hardware e il programmatore o tra software a basso e quello ad alto livello semplificando così il lavoro di programmazione poichè permettono infatti di evitare di riscrivere ogni volta tutte le funzioni da zero.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3173,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3339,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3019,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3490,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5541,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "API è un insieme(collezione) di classe, procedure, interfaccie , chiamate anche librerie software, disponibili in un certo linguaggio di programmazione. Le API sono già implementate, testate, documentate  è molto usate per la realizzazione di un determinato compito di un programma. Lo scopo principale delle API é evitare ai programmatori di riscrivere ogni volta tutte le funzioni necessarie al programma dal nulla. Quindi in generale le API  aiutano a ottenere un'astrazione a più alto livello (più vicino al linguaggio comprensibile dall' uomo che a quello comprensibile dalla macchina) di solito tra l'hardware e il programmatore o tra software a basso e quello ad alto livello semplificando così il lavoro di programmazione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3343,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3172,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3494,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3018,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5555,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "L'acronimo API (Application Programming Interface) può assumere significati e definizioni diverse. In generale,le APIs sono un insieme di funzioni,routine o tools con lo scopo di espandere le funzionalità di un determinato software. La finalità delle APIs è quella di ottenere un livello di astrazione maggiore (sia tra hardware/software sia tra vari livelli software), facilitando il programmatore nel riutilizzo del codice.\r\n\r\nNel caso di Java, le APIs proprietarie raccolgono una gran quantità di funzioni utilizzate per creare software programmati in linguaggio Java. Sono contenute nella piattaforma Java, disponibile in tre versioni: Java SE,EE,ME.\r\nPer visionare le API docs (Java SE 7): http://docs.oracle.com/javase/7/docs/api/\r\n\r\nCiascun sistema operativo utilizza un proprio sistema di API; inoltre anche la maggior parte dei portali web di un certo spessore offre determinate APIs in modo da poter creare applicazioni collegate agli stessi applicativi web (Facebook, Twitter, Youtube..)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3174,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3493,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3342,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3020,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5563,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le API sono essenzialmente delle \"librerie\" che consentono all'utente di interfacciarsi da un programma proprio con quello di qualcun altro. Non necessariamente quest'ultimo è un programma, ma possono essere anche servizi web. Queste API devono ovviamente esser messe a disposizione dal creatore del servizio/programma agli utenti, per poter esser in seguito utilizzate e implementate in programmi di terzi. Lo scopo delle API è di rendere disponibile il proprio lavoro in modo che possa esser implementato in programmi creati da altre persone. Da notare è il fatto che le API non possono essere modificate se non dal creatore. L'utente che andrà ad utilizzarle riceverà un \"pacchetto\" chiuso; si avranno delle descrizioni delle funzionalità presenti in esso in modo da poterle utilizzare.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3022,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3341,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3176,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3491,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5470,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Le API sono un insieme di funzioni e di strutture dati che realizzano una qualche funzionalità (es. Collegamento ad un Database) . Esse possono essere integrate dal programmatore nel proprio programma per utilizzare appunto le funzionalità che queste mettono a disposizione. Uno dei principali vantaggi nell'utilizzo delle API é che non é importante per il programmatore sapere come queste vengono implementate, basta conoscere l'interfaccia ovvero come usare il set di funzioni e strutture dati messe a disposizione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3495,
                  "rater": {
                    "raterId": 791,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3021,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3340,
                  "rater": {
                    "raterId": 876,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3175,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5186,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella creazione della pila viene implementata una funzione chiamata \"cresci\" che ha il compito di aumentare la dimensione dell'array della pila nel caso si voglia aggiungere un valore ma lo spazio a dimensione sia finito.\r\nPerché in questa funzione viene creato un array temporaneo (dove verranno copiati gli elementi) e l'array \"originario\" della pila viene deallocato invece di aumentarne semplicemente la dimensione?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 20,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Lezione4"
            },
            {
              "keyword": " pila"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5494,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Nella funzione \"cresci\" l'array \"originario\" della pila non viene semplicemente aumentato perché, il marker(indice del primo spazio di memoria disponibile) risulta uguale all'indice dell'ultimo elemento inserito, indicando quindi un'area di memoria occupata. Per cui l'intera struttura viene spostata in un'altra posizione in memoria tramite la creazione di un array temporaneo, la copia degli elementi all'interno di quest'ultimo, l'incremento della sua grandezza e la deallocazione dell'array \"originario\" per liberare la memoria precedentemente occupata. \r\nAttraverso queste operazioni però si incorre in un grosso problema che di fatto non si può correggere, quale la frammentazione della memoria heap.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2993,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3353,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3483,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5572,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Se si procedesse in questa maniera abbastanza intuitiva, si incorrerebbe nel rischio di \"invadere\" lo spazio di menoria occupato dalla HEAP. Per come invece è stata definita la funzione \"cresci\", non avverrà questo problema, ma la memoria potrà risultare in seguita frammentata, un inconveniente che comunque è risolvibile con macchine dotate di FileSystem.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2992,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3354,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3481,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5482,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 835,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "per l'array originario nella heap viene allocata tanta memoria quanta indicata da size inizialmente, poi può essere che la memoria che segue viene allocata per altre variabili e quindi se si aumenta semplicemente la dimensione dell'array originario si rischia di sovrascrivere altre informazioni.\r\nAl contrario se si crea un nuovo array questa ha già la dimensione richiesta e non si rischia di perdere dei dati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3485,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3355,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2994,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5531,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Aumentare semplicemente la dimensione significherebbe occupare la memoria successiva a quella occupata dall'array \"contenuto\". Tale memoria però, non essendo stata allocata come array, potrebbe essere stata occupata da altri dati che andrebbero persi nella sovrascrittura. Quindi è necessario occupare il primo blocco di memoria libero di dimensione sufficiente ed è possibile farlo creando un nuovo array.  Inoltre non esiste un comando in c++ che permetta l'aumento di dimensione di un array.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3482,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2995,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3357,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5597,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Perchè verrebbe a crearsi un overloading. Infatti non si può aggiungere elementi oltre alla dimensione originaria dell'array. Quindi creando un nuovo array con un elemento in più si permette di aggiungere elementi e si dealloca il precedente per evitare memory leaks.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3356,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3484,
                  "rater": {
                    "raterId": 514,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2996,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5197,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare in breve in che cosa consiste l'allocazione dinamica e dove vengono salvati i dati allocati dinamicamente. Descrivere inoltre uno dei casi più comuni di inefficienza e di errore: il memory leak.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Allocazione dinamica"
            },
            {
              "keyword": " memory leak"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5296,
          "asker": {
            "courseId": 100,
            "askerId": 784,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le idee fondamentali nel passaggio dal concetto di struttura a quello di classe?",
          "totalDifficultyLevel": 18,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 21,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classe"
            },
            {
              "keyword": " struct"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5606,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 786,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le classi possono essere viste come le evoluzioni delle struct, e con esse viene introdotto il concetto di ereditarietà e di polimorfismo. La differenza principale è che, se non diversamente specificato, i suoi membri vengono considerati privati, mentre nelle struct vengono considerati pubblici.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3440,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3393,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3160,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3104,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3039,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5581,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "una classe è essenzialmente la stessa cosa di una struct ma con molte più caratteristiche e potenzialità.\r\nla creazione di tipi di dati astratti (classi) è un concetto fondamentale in programmazione orientata agli oggetti.\r\nÈ possibile creare le variabili di un tipo (chiamati oggetti o istanze) e manipolare queste variabili. I membri (elementi) di ciascuna classe hanno qualche somiglianza.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3162,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3041,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3394,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3106,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3441,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5588,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Una struttura è un tipo di valore. Quando viene creata una struttura, la variabile alla quale è assegnata, contiene i dati effettivi della struttura. Quando la struttura è assegnata a una nuova variabile, viene copiata. La nuova variabile e la variabile originale contengono pertanto due copie separate degli stessi dati. Eventuali modifiche apportate a una copia non influiscono sull'altra copia.\r\nInvece, una classe è un tipo di riferimento. Quando viene creato un oggetto della classe, la variabile alla quale è assegnato l'oggetto contiene solo un riferimento a quella memoria. Quando il riferimento a un oggetto è assegnato a una nuova variabile, la nuova variabile si riferisce all'oggetto originale. Le modifiche apportate tramite una variabile vengono riflesse nell'altra variabile perché entrambe si riferiscono agli stessi dati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3037,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3390,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3102,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3437,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3158,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5528,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Nella pratica, la differenza sta nel fatto che nel linguaggio C++ i campi (variabili, metodi) di una struttura (struct), se non diversamente specificato, sono pubblici (public), mentre quelli di una classe (class) sono privati (private).\r\nDa un punto di vista concettuale, la struct è un \"tipo composito\" definito dall'utente, mentre la class è qualcosa in più, che rende più semplici alcune buone pratiche di programmazione (ad esempio il nascondere alcuni campi) tipiche della programmazione ad oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3042,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3392,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3163,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3439,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3107,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5506,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Entrambe partono dal concetto di struct del c, ossia una collezione di \"oggetti\" eterogenei(definiti tramite i dati membro[le cosiddette variabili di istanza in java]), ma la classe differisce dalla struct per l' inclusione al suo interno dei metodi(quelli che in c chiamavamo funzioni) che risultano in questo modo molto più legati dal punto di vista logico e utilitaristico al costrutto. Inoltre vengono inseriti meccanismi di protezione per evitare sgradite modifiche da parte dell' utente(tutto ciò che in una classe non è esplicitamente dichiarato public è private, viceversa per la struct). E' proprio sfruttando l'inclusione delle funzioni nella definizione stessa della struct che siamo arrivati al concetto di classe[fondamentale per la programmazione ad oggetti, tale che un programma risulta proprio essere un insieme di classi].",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3103,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3391,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3438,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3159,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3038,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5560,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Oltre ai dati, che vengono inseriti nella struttura, la classe presenta implementate anche le varie funzioni, che possono essere private (visibili solo alla classe in cui vengono implementati) o public (visibili anche all'esterno della classe)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3040,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3395,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3105,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3161,
                  "rater": {
                    "raterId": 907,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3442,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5232,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "le variabili globali sono sate in java ? motiva la tua riposta",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5263,
          "asker": {
            "courseId": 100,
            "askerId": 841,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la significativa differenza tra lo Stack (Stack Pointer) e lo Heap? Dire anche chi ne decide le dimensioni e dove vengono allocati in memoria.\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": "Heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5210,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono i file .h e perché il compilatore ne ha bisogno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": ".h "
            },
            {
              "keyword": " compilatore "
            },
            {
              "keyword": " file.h"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5264,
          "asker": {
            "courseId": 100,
            "askerId": 849,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè nell'implementazione di una pila bisogna usare una serie di sotto-funzioni convenzionali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5295,
          "asker": {
            "courseId": 100,
            "askerId": 833,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le ragioni per la quale si può verificare un memory leak? Come è possibile prevenirlo?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 17,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Memory"
            },
            {
              "keyword": " Leak"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5613,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il memory leak è un errore molto comune che si presenta quando si perde il controllo su un?area di memoria allocata dinamicamente che diventa inutilizzabile perché non più accessibile, comportando uno spreco di memoria (fino al termine del programma).\r\nNei linguaggi che non prevedono un garbage collector automatico, il controllo e la prevenzione dei memory leak sono responsabilità dello sviluppatore, che per evitare il problema deve sempre deallocare le aree di memoria non più necessarie prima di perderne il controllo. Esistono, inoltre, dei software di debug che permettono di individuare nel programma l?insorgere di memory leak.\r\nI linguaggi, invece, che utilizzano un garbage collector hanno una gestione della memoria più automatica, questo comporta un vantaggio per lo sviluppatore che non deve più preoccuparsi della dellocazione che viene gestita dal sistema con lo svantaggio di un maggior consumo di risorse, una pulizia non sempre precisa ed una gestione non deterministica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2898,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3253,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3448,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2949,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3289,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3411,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5593,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il memory leak indica un consumo non richiesto di memoria. Solitamente è dovuto al fatto che il programmatore dimentica di deallocare la memoria dopo che il processo ha finito di utilizzare i dati contenuti in quella locazione di memoria. Per prevenirla si può prestare attenzione nella programmazione e ricordare che per ogni funzione che alloca che viene richiamata, bisognerà poi chiamare una \"free\" che liberi la memoria in questione. Altrimenti si possono utilizzare linguaggi che gestiscono autonomamente la disallocazione della memoria per esempio Java attraverso il GarbageCollector.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3450,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2895,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2946,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3413,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3250,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3286,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5584,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 859,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un memory leak è un consumo non voluto di memoria causato dalla mancata deallocazione della stessa. Per prevenire il memory leak è sufficiente utilizzare l'operatore delete (*p) che dealloca la memoria puntata dal puntatore p è la rende nuovamente utilizzabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3249,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2894,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3285,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3451,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2945,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3414,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5558,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Il fenomeno di memory leak si verifica quando avviene uno spreco della memoria dovuto ad un malfunzionamento del software. \r\nIn particolare si manifesta quando non si effettuata il deallocamento di dati all'interno  di un programma, il quale, a lungo andare,  porterà ad una saturazione della memoria.\r\nPer prevenire tale problema, è fondamentale (nei linguaggi che lo permetto, come il C e il C++) deallocare le variabili/dati quando non sono più necessari.\r\nPer ovviare a tale mancanza, alcuni linguaggi implementano (come Java) un meccanismo chiamato Garbage collection, il quale si occupa di liberare automaticamente parte della memoria deallocando (e quindi eliminando) i dati non più utilizzati e quindi inutili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3288,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3412,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3252,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3449,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2897,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2948,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5483,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Memory leak è una perdita di informazioni in memoria. Accade quando si gestiscono male i puntatori finendo per sovrascrivere celle di memoria prima allocate e ancora in uso. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2947,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3447,
                  "rater": {
                    "raterId": 774,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2896,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3410,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3287,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3251,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5237,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "In C e C++ non esiste il tipo di dato primitivo \"stringa\", spiega come viene implementato questo tipo di dato nei linguaggi in riferimento elencandone le principali caratteristiche.",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": " caratteristiche"
            },
            {
              "keyword": " C"
            },
            {
              "keyword": " C++"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5512,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 745,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "In C e C++ le stringhe possono essere rappresentate come array di caratteri oppure come puntatori a caratteri. Nel primo caso, se abbiamo un array di char lungo n, allora avremo n - 1 caratteri con l'aggiunta in coda del carattere di terminazione '\\0'. Questo vale anche per i puntatori a char, i quali o vanno inizializzati in fase di dichiarazione (es. char* s = \"stringa\") e quindi non è più possibile modificarla, o devono essere allocati dinamicamente (es. char* s = new char[n], con n > 0 e intero).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3278,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3013,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2953,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3463,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3083,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5529,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 883,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il tipo di dato stringa viene implementato in C e C++ come array di char con carattere terminatore NULL (\\0), vengono considerate tali perché le librerie di input/output considerano in maniera differente le regioni di memoria dove sono contenuti i char. Un array di size n può contenere al massimo n-1 caratteri, come viene spiegato sopra, a causa del carattere terminatore NULL. Altra caratteristica delle stringhe è la libreria string.h, che permette la manipolazione di esse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3279,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2954,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3084,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3466,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3014,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5602,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 890,
                "courseId": 100,
                "courseFinalScore": 17
              },
              "answerText": "Una stringa, in C e C++ ,è un array di char il cui ultimo elemento è il carattere nullo \"\\0\". Di conseguenza la dimensione dell'array deve essere sempre maggiore di 1 della parola che si vuole inserire. Es: La parola ciao è inserita in questo modo, char c[5]={'C','I','A','O','\\0'}.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3465,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3011,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3081,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3276,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2951,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5487,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 836,
                "courseId": 100,
                "courseFinalScore": 19
              },
              "answerText": "Il tipo di dato primitivo stringa viene implementato tramite l utilizzo di un vettore di caratteri, quindi con una determinata lunghezza, si accede ai vari caratteri della stringa nello stesso modo dei vettori e il carattere di fine stringa è '\\0'.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3464,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3012,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3082,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3277,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2952,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5612,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "È possibile usare come stringhe dei particolari array di elementi char in cui è presente un elemento terminatore NULL ( o \\0) che indica la fine della stringa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3080,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3462,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2950,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3010,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3275,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5225,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il primo indice di un array è zero?",
          "totalDifficultyLevel": 7,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Array"
            },
            {
              "keyword": " indici"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5496,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Questa è uno zuccherino sintattico utilizzato nella maggior parte dei linguaggi di programmazione. Viene utilizzato per facilitare l'algebra dei puntatori e la gestione della memoria. Per esempio se abbiamo int vettore[10] :\r\n\r\nnel caso in cui si utilizzasse 1 per indicare il primo elemento si avrebbe che la prima cella di memoria avrebbe come indirizzo l'indirizzo diminuito di 4 byte. \r\n\r\nmentre con lo zuccherino sintattico l'indirizzo di memoria è effettivamente vettore[0]. \r\n\r\nquindi:\r\n\r\npartendo da 1: inizio_vettore = (&vettore)-4byte;\r\n\r\ncon zuccherino sintattico sarebbe: inizio_vettore = indirizzo di vettore[0].\r\n\r\nQuindi questa è una convenzione utilizzata per semplificare la gestione di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2915,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3185,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3244,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3321,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2959,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5561,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'indice  viene inizializzato a zero in modo da cominciare dal primo elemento dell'arra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2958,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3243,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2914,
                  "rater": {
                    "raterId": 885,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3184,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3320,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5229,
          "asker": {
            "courseId": 100,
            "askerId": 799,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cos'è lo Stack e fare un esempio in C++ commentato.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5233,
          "asker": {
            "courseId": 100,
            "askerId": 769,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è importante l'utilizzo della libreria cassert (o assert.h in C) in C++ nello sviluppo di una pila? Come viene implementata la funzione assert() e con quale scopo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " assert"
            },
            {
              "keyword": " controllo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5286,
          "asker": {
            "courseId": 100,
            "askerId": 852,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i flag che costituiscono una pila? Descrivili brevemente.\r\nQuando una pila è quasi piena cosa bisogna fare? Quali sono i passaggi fondamentali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " Ridimensionamento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5284,
          "asker": {
            "courseId": 100,
            "askerId": 839,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze fra una pila ed un array? In quali casi conviene usare una o l'altra?",
          "totalDifficultyLevel": 20,
          "totalInterestingnessLevel": 20,
          "totalRelevanceLevel": 19,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " array"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5492,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una pila è una struttura dati di tipo LIFO (Last In First Out),e viene tipicamente realizzata con array o liste concatenate. Un array è una struttura dati che può essere  realizzata dinamicamente o staticamente. Conviene usare la pila quando non sono previste molte modifiche e soprattutto perchè può contenere diversi tipi di dati, mentre l'array soltanto un tipo (array di interi o array di char,ecc..) ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3336,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3215,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3056,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3401,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5533,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un array è una collezione di elementi omogenei ed il cui numero è fissato e non può essere modificato in run time. \r\nUna pila è invece una struttura dati tipicamente implementata mediante un array, nonché un particolare tipo di lista in cui i dati vengono estratti in ordine inverso rispetto a come erano stati inseriti; la pila può aumentare la sua dimensione ed è carettirizzata da una serie di metodi, ossia funzioni che stabiliscono le sue caratteristiche e le sue proprietà. La pila è quindi un costrutto molto più complesso dell'array, di cui utilizza la struttura ma migliora le potenzialità. \r\nUn array è utile per collezionare dati, facili da ritrovare in seguito; mentre una pila è un tipo di struttura dati che può essere implementata da un programma ed utilizzata per diversi scopi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3216,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3398,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3334,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3057,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5505,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Un array è una struttura dati omogenea. Contiene un numero di dati limitati, solitamente da 0 a meno uno e tutti dello stesso tipo. Viene dichiarato all'inizio. La pila, invece, è un contenitore realizzato tipicamente da array, appunto, o liste ed è utilizzata per forzare una particolare modalità di accesso ai dati. Essa è una struttura dati di tipo LIFO(last in first out), i dati vengono tolti dalla stessa parte in cui vengono inseriti. Per memorizzare un numero di elementi limitato, viene utilizzato un array con una dimensione massima specificata dall'array stesso e viene utilizzato un puntatore all'ultimo elemento. Per avere invece una capacità illimitata viene utilizzata una lista. E' sicuramente conveniente utilizzare un array quando abbiamo pochi elementi da gestire e tutti dello stesso tipo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3214,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3400,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3055,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3333,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5473,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "La differenza principale è il metodo di accesso. per la pila si usa la modalità LIFO, mentre per l'array si può accedere a qualunque dato a patto di conoscerne l'indice. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3212,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3331,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3053,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3396,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5513,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 767,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La pila è una struttura dati che permette l'inserimento o l'estrazione solo dalla \"cima\" della pila, comprende un marker che denota il prossimo spazio che verrà usato se ci fosse un inserimento ed è una struttura dinamica.\r\nL'array è una struttura dati che permette la lettura, la scrittura e la modifica dei dati in qualsiasi posizione dell'array, ha una dimensione finita e una volta data non può essere cambiata.\r\nL'array è più utile se si conosce già la quantità di dati che si dovranno trattare e si ha bisogno di modificare tutti i dati dell'array mentre la pila è più versatile quando non si sa la quantità di dati con cui si lavorerà.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3213,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3054,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3335,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3399,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5595,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 899,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "la prima differenza riguarda l'implementazione. Un array è una collezione di elementi omogenei mentre la pila è una struttura, composta, tra le altre, da un array.\r\nLa seconda riguarda invece la funzionalità, in qualsiasi momento si può accedere ad ogni elemento dell'array, in una pila invece esiste un ben determinato ordine di accesso (LIFO).\r\nUn'altra differenza è la dimensione, modificabile a runtime per una pila ma non per un array.\r\n\r\nConviene usare un array quando si ha a che fare con programmi matematici, una pila è più adatta a database o programmi in cui non devo manipolare gli elementi.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3397,
                  "rater": {
                    "raterId": 849,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3332,
                  "rater": {
                    "raterId": 883,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3211,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3052,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5238,
          "asker": {
            "courseId": 100,
            "askerId": 848,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "if (a==b) cout << \"Prova.\\n\";\r\nif (a=b) cout << \"Prova.\\n\";\r\n\r\nQuali sono le differenze? In quali errori si può incorrere?",
          "totalDifficultyLevel": 16,
          "totalInterestingnessLevel": 18,
          "totalRelevanceLevel": 20,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "errori"
            },
            {
              "keyword": " assegnazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5589,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Le due istruzioni sono molto diverse, la prima si limita a confrontare la variabile \"a\" e la variabile \"b\", se queste due hanno lo stesso valore viene eseguita l'istruzione. La seconda istruzione invece assegna alla variabile \"a\" il valore della varibile \"b\" ed esegue l'istruzione solo se la variabile \"a\" è diversa da 0, quindi corrisponde a scrivere:\r\na=b;\r\nif(a!=0) cout << \"Prova.\\n\";\r\nNell'utilizzare l'operatore \"=\" bisogna fare molta attenzione a ciò che si vuole fare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3431,
                  "rater": {
                    "raterId": 843,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3475,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3217,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3258,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2960,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5493,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Nel primo caso il doppio uguale indica l'operatore di confronto (\"se a è uguale a b allora è vero e stampa la stringa di prova\"). \r\nNel secondo caso il simbolo \"=\" indica l'operatore di assegnamento, cioè alla variabile a viene assegnato il valore della variabile b.\r\n\r\nSi possono riscontrare errori logici nella valutazione della seconda espressione perchè la valutazione viene fatta sulla base del valore di a. L'espressione significa infatti \"a prende il valore di b, se a è uguale a zero, stampa la stringa di prova\". ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3433,
                  "rater": {
                    "raterId": 843,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3261,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2963,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3477,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3220,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5547,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il costrutto if (expression) {statement} permette di eseguire lo statement se expression ha valore di verità non falso.\r\n\r\nNella prima riga, lo statement {cout<<\"Prova.\\n\";} viene eseguito se a==b è non falso, ovvero se ho verificato che a e b hanno lo stesso valore (se l'uguaglianza è soddisfatta, allora si procede alla stampa).\r\nNella seconda riga di codice, il compilatore interpreta l'assegnazione a=b valutando il contenuto della variabile b: lo statement {cout<<\"Prova.\\n\";} viene eseguito se a=b è non falso, ovvero se ho assegnato ad a un valore di verità b non falso (se b è diverso da 0 o dal valore booleano false, allora si procede alla stampa).\r\n\r\nDunque un errore di battitura si ripercuote in maniera pesante nell'esecuzione: mentre nel primo caso eseguirò lo statement ogni volta che a è uguale a b, nel secondo caso eseguirò lo statement tutte le volte che b è non falso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3435,
                  "rater": {
                    "raterId": 843,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2961,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3259,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3479,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3218,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 5527,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il primo è l'operatore di confronto (==) , mentre il secondo (=) di assegnazione. L'errore si verifica quando, nel secondo caso, prima il valore di b viene assegnato ad a e poi sullo stesso valore viene effettuato un test.\r\nSe il valore di a è 0 (falso), non viene stampato nulla, mentre se la variabile a ha qualsiasi altro valore diverso da 0, la stampa viene effettuata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3480,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3436,
                  "rater": {
                    "raterId": 843,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3219,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2962,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3260,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5565,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 824,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "La prima condizione contenuta nell'if è una espressione che verifica l'eguaglianza di due valori. Essa restituisce true se a contiene lo stesso numero di b e falso altrimenti. Prova. viene dunque stampato se nella variabile a è contenuto lo stesso valore di b.\r\nNel secondo caso invece nella condizione dell'if è contenuta una operazione di assegnamento: il valore di b viene copiato in a e l'epressione restituisce il nuovo valore di a. La stampa di Prova. dipende quindi dal valore di b e non più dall'uguaglianza dei valori contenuti in a e b. Se b vale 0 non verrà stampato niente mentre se b è diverso da 0 verrà stampato Prova.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2964,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3434,
                  "rater": {
                    "raterId": 843,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3478,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3262,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3221,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5571,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 898,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In questo caso, nella prima riga, l'espressione  a==b rappresenta un operazione relazionale tra a e b. L'output dunque sarà  \"Prova\\n\" se l'operazione restituisce true ovvero se il valore di a è uguale al valore di b. Nella seconda riga invec, compare un'espressione di assegnazione (a=b) e l' output sarà \"Prova\\n\" se la suddetta operazione andrà a buon fine.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3476,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 2965,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3263,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3432,
                  "rater": {
                    "raterId": 843,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3222,
                  "rater": {
                    "raterId": 848,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5282,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Un vettore si può indicizzare con l'aritmetica dei puntatori.\r\nChe tipo di puntatore dovrebbe essere definito per indicizzare una matrice?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatore"
            },
            {
              "keyword": " matrice"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5162,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Funzione per creare la copia una pila: descrivere il funzionamento e le eventuali problematiche che si potrebbero presentare",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "copia"
            },
            {
              "keyword": "pila"
            },
            {
              "keyword": "c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5251,
          "asker": {
            "courseId": 100,
            "askerId": 836,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Secondo i principi di Parna il committente di una funzione deve dare allo sviluppatore le informazione necessarie a realizzare la funzione e niente di più, e l' implementatore dovrà dare le informazioni solo strettamente necessarie per l' utilizzo e nient' altro. Qual è il motivo di tale fiscalità, per modo di dire, nel realizzare un lavoro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "funzione"
            },
            {
              "keyword": " commissione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5255,
          "asker": {
            "courseId": 100,
            "askerId": 819,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega brevemente il funzionamento e le problematiche riguardanti gli Arrays",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": "problematiche"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5187,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'ambito dell'allocazione dinamica, cosa succede quando un programma tenta di accedere ad una locazione di memoria non più allocata? E quando tenta di allocare nuova memoria, sapendo che la quantità attuale non è sufficiente?\r\nQuali strategie si possono adottare per gestire gli errori derivanti dai casi precedenti?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 12,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "MemoryLeak"
            },
            {
              "keyword": " StategieGestioneErrore"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5477,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Se si tenta di accedere a uno spazio di memoria non più allocato, si rischia di incorrere in un valore diverso da quello che vi si era memorizzato l'ultima volta durante il \"periodo\" di allocazione, questo perché la macchina può avervi automaticamente memorizzato un qualsiasi valore autonomamente in un momento successivo. Se si tenta di allocare memoria in misura superiore alla quantità disponibile, il programma termina. La strategia da adottare consiste nel deallocare sempre una memoria dinamicamente allocata in precedenza quando si è sicuri di non doverla più utilizzare, affidandone la responsabilità di deallocazione all'opportuna funzione, e nell'ottimizzare l'uso della memoria (in termini pratici, non allocare più memoria di quanto sia necessario)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3291,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3317,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2956,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5481,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Un programma può tranquillamente accedere ad una zona di memoria non più allocata, ma i valori che troverà al suo interno potrebbero essere diversi dagli ultimi memorizzati dal programma stesso, in quanto un qualunque processo attivo potrebbe avere usato quella memoria (non essendo più \"riservata\") e cancellato i precedenti valori. \r\nSe si tenta di allocare più memoria di quanta disponibile, il nostro programma termina con un opportuno messaggio d'errore",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2957,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3292,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3319,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5484,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 900,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un programma che tenta di accedere ad una casella di memoria deallocata o cresha, in caso sia stata successivamente occupata da un altro programma, o da risultati indesideratii.\r\nIn caso si sfori la memoria disponibile semplicemente il programma da errore (out of memori) e cresha.\r\nPer evitare questi errori una corretta costruzione del programma facilita il rilevamento del problema, inoltre sforare la memoria disponibile è pressoché improbabile devi veramente sprecare il mondo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2955,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3290,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3318,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5167,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella funzione di copia della Pila, perché è importante creare una nuova Pila e copiarne tutti i valori al posto di crearne una e passare i riferimenti così come sono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " puntatori"
            },
            {
              "keyword": " copia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5270,
          "asker": {
            "courseId": 100,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'uso dell'operatore C++ \"new\" (e del suo corrispettivo \"malloc\" in C)? In particolare, esso influisce sull'area heap o stack della memoria? Cosa può comportare, inoltre, una mancata deallocazione dei dati successivamente all'uso di questo operatore?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " operatore"
            },
            {
              "keyword": " memoria dinamica"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5490,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "L' operatore new type alloca sizeof(type) bytes in memoria e restituisce un puntatore che punta alla base della memoria. Tali bytes vengono allocati in memoria heap e non stack perché si stratta di memoria allocata dinamicamente.\r\nNel caso di mancata deallocazione si provoca l' errore memory leak.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2887,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5478,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per allocare in modo dinamico la memoria il C++ mette a disposizione l'operatore \"new\". Questo operatore costruisce uno o più oggetti nell'area heap e ne restituisce l'indirizzo. In caso di errore (memoria non disponibile) restituisce NULL. Pertanto il programmatore dovrà controllare l?allocazione dello spazio di memoria.\r\nTirando le somme, l'uso della new equivale a queste due operazioni:\r\n\r\n1) chiamata della funzione standard Malloc (significa \"memory allocation\"). Il compito di questa funzione è quello di allocare la zona di memoria e di restituire il puntatore iniziale alla zona allocata;\r\n\r\n2) chiamata del costruttore;\r\n\r\nLa mancata deallocazione dei dati successivamente all'uso dell'operatore NEW può portare ad un \"memory leak\", ovvero la memoria allocata resta tale anche dopo la terminazione del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2885,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5570,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Gli operatori new e malloc servono ad allocare dinamicamente la memoria,ed in particolar modo vado ad influenzare l'area heap della memoria.Una mancata deallocazione della memoria mediante il comando delete[],comporta un memory leak,e ciò causa dei danni in quanto a lungo termine gran parte della memoria risulterà inutilizzabile.\r\nCon java viene introdotto il garbage collector,un programma che controlla periodicamente che non vi siano memory leak,ed in caso affermativo provvede a rimuoverlo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2886,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5485,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 790,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore new o malloc che dir si voglia non è altro che il comando per allocare informazioni in memoria. È bene, e imperativo, notare che le informazioni verrabno allocate nello heap e non nello stack. Quando noi allochiamo utiliziamo una zona di memoria utilizzabile tramite un riferimento (o puntatore come dir si voglia). Se noi non deallochiamo andremo in contro al cosi detto \"memory leak\" cioè richiamiamo tramite puntatore una zona di memoria non più utilizzata e quindi \"perdiamo il riferimento\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2884,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5498,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"new\" permette di registrare le variabili nell'area heap e non nello stack della memoria, cosicchè queste vengano gestite dall'utente; per questo tali variabili devono essere necessariamente eliminate quando diventano inutilizzabili, attraverso il comando delete.\r\nSe non viene usato delete per eliminare le variabili allocate nell'area heap, si può venire incontro al Memory Leak, cioè alla perdita di memoria, nel senso che si perde spazio utilizzabile per registrare variabili.\r\nUn altro problema a cui si può venire incontro è la perdita dell'handle, cioè l'impossibilità di accedere a dei dati.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2888,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5207,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare a cosa serve la funzione \"cresci\" nella costruzione di una pila.\r\nQual'e' il giusto ordine di deallocazione  delle variabili/puntatori, utilizzati?\r\nSpiegare inoltre perche' il contenuto della pila viene memorizzato nella heap e non nello stack.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Pila"
            },
            {
              "keyword": " deallocazione"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5192,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Come gestisce il C++ le operazioni di pre incremento (y=++x) e post incremento (y=x++) e quali sono le loro sostanziali differenze, anche nelle pile?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Incremento"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5522,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le operazioni di post e pre incremento in C++ sono molto delicate e possono causare errori all'insaputa del programmatore. Se facciamo y=++x; incrementiamo la variabile x prima di assegnare il suo valore alla variabile y. Se facciamo y=x++; assegniamo il valore di x alla variabile y e poi incrementiamo x di 1 unità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3143,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3273,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2977,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 2936,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5605,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 922,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le operazioni citate vengono eseguite in ordine di lettura. Quindi nel caso del pre incremento (y=++x), avremo una variabile (y) che assumerà il valore dell'altra variabile (x) il quale però verrà prima incrementato, quindi entrambe le variabili dopo questa operazione conterranno il valore già modificato dal \"++\". Con il post incremento invece, la Y riceverà il valore \"originale\" di X, ovvero prima dell'incremento, successivamente X verrà aumentata e le due variabili avranno così due valori differenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2935,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3272,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3142,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 2976,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5525,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Entrambe le operazioni x++ e ++x sono traducibili con x=x+1. Vi è però una sostanziale differenza quando assegnamo questi costrutti ad una nuova variabile:\r\n\r\n- L'operazione di pre-incremento consiste nell'incrementare di 1 il valore di x e poi assegna questo ad y. (Cioè se inizialmente x=2, avremo poi che x=3, y=3).\r\n\r\n- L'operazione di post-incremento consiste invece nell'assegnare prima ad y il valore di x e poi incrementare x di 1 (Cioè se inizialmente x=2, avremo poi che x=3, y=2).\r\n\r\nNella funzione \"inserisci\" di una pila, per esempio, viene usato l'operatore post-incremento per incrementare la variabile \"marker\" (marker++) che memorizza l'indice nell'array \"contenuto\" della prima entata libera. Inoltre trova un grande uso all'interno dei cicli. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2937,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 2978,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3274,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3144,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5227,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "In che occasione si usano gli operatori new e delete? A cosa servono? Che vantaggio hanno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "New"
            },
            {
              "keyword": "Delete"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5272,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'esempio di stack fatto a lezione è presente una funzione chiamata \"estrai\": qual'è la sua utilità nello stack? Inoltre, che utilità ha il \"assert(s->marker>0);\" e per quale motivo in \"contenuto[--(s->market)];\" viene inserito un \"--\" prima di \"s-->marker\"? Sotto è proposto il testo. \r\n int estrai(Pila *s) {\r\n cout<<\"entro in estrai\"<<endl;\r\n assert(s->marker>0);\r\n return s->contenuto[--(s->marker)];\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " funzione"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5159,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Una struct  puo` contenere una struct?",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Struct"
            },
            {
              "keyword": " contenere"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5539,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 815,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Sì, una struct può contenere all'interno della sua definizione un'altra struct. \r\n\r\nSi pensi ad esempio ad una struct Persona che abbia come campo una struct Residenza. Quest'ultima potrà contenere i campi Nazione, Provincia, Comune, Indirizzo,...\r\n\r\nIl tipo struct non è altro che un tipo personalizzabile di variabile usato per fornire maggiore visibilità e praticità al programmatore, il quale ha il compito di implementarlo nella maniera più efficiente possibile.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3059,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3208,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3069,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3191,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3025,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5578,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Si, una struct può contenere una struct.\r\nSi parlerà in  questo caso di struct annidiate.  Attenzione però!\r\nLa definizione, dichiarazione e implementazione della struct \"contenuto\" deve essere fatta al di fuori della struct \"contenitore\" e all'interno di quest'ultima si troverà un puntatore alla struct che si vuole contenere.\r\nEsempio :\r\n\r\nstruct contenuto {\r\n//implementazione\r\n}\r\n\r\nstruct contenitore {\r\ncontenuto * punt;\r\n//implementazione\r\n}\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3024,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3068,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3207,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3058,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3190,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5491,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "In sè, la risposta sarebbe sì; tuttavia è più corretto considerare tutti i casi possibili.\r\nSupponiamo di avere definito in ordine due struct chiamandole S1 e S2 :\r\n-S2 può contenere una variabile di tipo S1.\r\n-S2 non può contenere una variabile di tipo S2 perchè il compilatore non sarebbe in grado di decidere quanta memoria S2 occuperebbe(teoricamente infinita). S2 può però contenere un puntatore ad una variabile di tipo S2 in quanto un puntatore occupa sempre lo stesso spazio di memoria.\r\n-è anche possibile definire strutture mutualmente ricorsive in questo modo:\r\nstruct S2; // dichiarazione di S2 (senza la quale il compilatore genererebbe un errore)\r\nstruct S1{ \r\n    int value;\r\n    S2* next; \r\n}; // Ok!\r\nstruct S2{ // definizione di S2 \r\n    int value;\r\n    S1* next;\r\n};",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3071,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3061,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3210,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3193,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3027,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5580,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 216,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Si, all'interno di una struct è possibile dichiarare un'altra struct. Non è possibile invece definire un nuovo tipo di dato, mediante typedef, che contenga se stesso. Un breve esempio (funzionante) di struct annidate può essere questo:\r\n\r\n#include <iostream>\r\nstruct num{\r\n   int n;\r\n   struct alf{\r\n      char c;\r\n   };\r\n   alf cc;\r\n};\r\n\r\nint main(){\r\n   num N;\r\n   N.n=5;\r\n   cout << N.n << endl;\r\n   return 0;\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3209,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3060,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3192,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3070,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3026,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5247,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "che differenza c'è tra le seguenti scritture\r\n#include <filename>\r\n#include ?filename?\r\nimplementando la libreria cassert che funzione posso utilizzare e in che modo va utilizzata",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "include"
            },
            {
              "keyword": " assert"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5169,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra stack e heap?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5222,
          "asker": {
            "courseId": 100,
            "askerId": 855,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè é necessario deallocare una variabile dinamica col comando \"delete\" dopo che si ha finito di utilizzata? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione"
            },
            {
              "keyword": " dinamica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5220,
          "asker": {
            "courseId": 100,
            "askerId": 823,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché i vettori sono indiciati a partire da zero?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vettore"
            },
            {
              "keyword": " indice"
            },
            {
              "keyword": " puntatore"
            },
            {
              "keyword": " zero"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5239,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nella procedura \"cresci\" dello stack, prima si cancella il contenuto dello stack iniziale e poi si fa l'assegnamento al indirizzo base dell nuovo stack (tmp),e no viceversa? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "cresci"
            },
            {
              "keyword": "stack"
            },
            {
              "keyword": "base"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5254,
          "asker": {
            "courseId": 100,
            "askerId": 827,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è fortemente sconsigliato il costrutto \"goto\" nella programmazione? Quale aspetto del codice ne risente maggiormente ? ",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "regole"
            },
            {
              "keyword": "programmazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5615,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il GOTO era, prima di essere dibattuto negli anni '60-'70, un metodo comune, in vari linguaggi di programmazione, per uscire da cicli iterativi, ritornare da sottoprogrammi e gestire eccezioni.\r\nE' stato abbandonato come costrutto comune perchè la leggibilità del codice è fortemente ridotta dalle istruzioni di salto, che rendono difficile capire rapidamente la logica del codice, e ciò influisce negativamente sulla sua mantenibilità e aumenta la probabilità di errori o bug.\r\nPer questo il GOTO ora è deprecato come \"spaghetti programming\", contrario all' idea di programmazione strutturata, e sostituito nei linguaggi moderni da costrutti che rendono le iterazioni, i ritorni e i salti condizionali facili da implementare. \r\nNel linguaggio Java il GOTO è assente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3035,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3505,
                  "rater": {
                    "raterId": 898,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3166,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3270,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3129,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5532,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'utilizzo del costrutto goto è fortemente sconsigliato nella programmazione perché il programma non è leggibile e quindi un'eventuale mantenimento o modifica del programma stesso diventano molto difficili. L'aspetto della programmazione che ne risente maggiormente è la sua stessa qualità dal momento che come comando il GOTO viola le basi della programmazione strutturata facendo \"jumpare\" il programma all'esterno di un ciclo, ad una specifica riga oppure ad un determinato indirizzo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3167,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3271,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3506,
                  "rater": {
                    "raterId": 898,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3130,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3036,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5495,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Utilizzando il GoTo si crea un problema di difficoltà di lettura del flusso del codice (il famoso \"spaghetti code\") per questo è sconsigliato utilizzarli (allo stesso modo i break e i continue per i cicli).\r\nNel caso vi siano dei GoTo, è difficile sapere \"da dove\" si arriva a quella label e in un progetto complesso, potrebbe creare dei problemi nel flusso del programma poiché bisogna continuamente mantenere traccia del \"dove\" e \"come\" ci si deve muovere nel codice portando a errori gravi e a problemi di sicurezza (basta pensare alla possibilità di iniettare codice e saltellare tra le varie label per ottenere informazioni sensibili).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3268,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3164,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3504,
                  "rater": {
                    "raterId": 898,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3127,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3033,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5611,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 791,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Goto è un'istruzione di controllo del flusso di esecuzione: consente di effettuare salti incondizionati da un punto all'altro del codice.\r\nNei linguaggi di alto livello può essere usata per uscire rapidamente da cicli profondamente nidificati. Ai giorni nostri l'uso di questa istruzione in tali linguaggi è generalmente considerato indice di cattiva programmazione (il cosiddetto \"spaghetti code\", cioè quei programmi che hanno una struttura di controllo del flusso complessa e/o incomprensibile) perché viola le basi della programmazione strutturata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3269,
                  "rater": {
                    "raterId": 856,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3165,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3034,
                  "rater": {
                    "raterId": 765,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3128,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3503,
                  "rater": {
                    "raterId": 898,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5285,
          "asker": {
            "courseId": 100,
            "askerId": 901,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i operatori su stringhe usati più frequentemente e che operazione compiono alle variabili date in ingresso a tali funzioni?  ",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 8,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "operatori"
            },
            {
              "keyword": " stringhe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5582,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Partendo dal presupposto che la domanda è posta poco chiaramente, considero che essa richieda una descrizione delle principali funzioni relative alla classe \"String\" di Java. \r\n\r\nLe funzioni vengono utilizzate sintatticamente nella forma \"nomeStringa.funzione(tipo1 parametro1, ...);\" e le più utilizzate sono:\r\n\r\n- int length() : restituisce un valore di tipo intero corrispondente alla lunghezza della stringa\r\n- char charAt(int n) : restituisce il carattere corrispondendte all'elemento di posizione n della stringa (si ricordi che la posizione del primo elemento è 0)\r\n- int Integer.parseInt(String s) : converte il contenuto della stringa in intero, e ne restituisce il valore. (analogamente Float.parseFloat(String s) )\r\n- String concat(String s) : concatena la stringa passata per parametro alla fine della stringa che richiama la funzione.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3487,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3363,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3168,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3198,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 5509,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 765,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le seguenti funzioni e operatori sono definiti per le stringhe in C++, non avendole ancora trattate in altri linguaggi. A differenza degli array numerici per le stringhe sono definiti gli operatori di input ed output : std::cin, std::cout. Questi operatori permettono di leggere da tastiera e stampare a video informazioni di tipo char. Esistono anche delle varianti degli operatori cin e cout : cin.eof,cin.fail,cin.clear. eof restituisce un valore booleano se lo stream di input ha raggiunto la fine del file, fail restituisce un valore booleano se lo stream ha trovato errori o se ha raggiunto la fine del file mentre clear ripristina lo stato di errore. Abbiamo visto altri 3 operatori appartenenti alla libreria IOS, cin.getline(x,y),cinget(x) e cout.put(x). getline legge da input y-1 caratteri nella stringa x, get legge 1 carattere in x e put stampa x a video. Esistono molte altre funzioni per la manipolazione di stringhe apparteneti alla libreria cstring.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3170,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3200,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3362,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3486,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5583,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Gli operatori su stringhe usati più frequentemente sono:\r\n\r\nchar *strcpy(a,b); // copia b su a\r\nint strcmp(a,b); // restituisce<0 se a<b,0 se a=b,>0 se a>b \r\nchar *strcat(a,b); // appende b in coda ad a \r\nsize_t strlen(a); //restituisce la lunghezza della stringa a \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3364,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3171,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3201,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3488,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5576,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Dopo aver riscritto la domanda ho cercato di ottenere la risposta più sensata.\r\nGli operatori non effettuano modifiche alle stringhe, così come negli interi, svolgono solo una funzione di controllo.\r\nGli operatori sulle stringhe sono, ad esempio, == (scritto anche \"stringa1\".equals(\"stringa2\") e equalsIgnoreCase(String anotherString)), !=, etc\r\nLe operazioni che si possono effettuare sulle stringhe sono svariate. Oltre a tutte le operazioni che si possono fare considerando una stringa come array di caratteri, le funzioni più usate in java sono Str.toUpperCase(); e Str.toLowerCase()",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3365,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3489,
                  "rater": {
                    "raterId": 901,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3169,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3199,
                  "rater": {
                    "raterId": 881,
                    "courseId": 100,
                    "courseFinalScore": 9
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5217,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la Pila.h? A cosa serve?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "pila"
            },
            {
              "keyword": " pila.h"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5215,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra allocazione dinamica e allocazione statica di memoria? Si portino degli esempi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione"
            },
            {
              "keyword": "memoria"
            },
            {
              "keyword": "statica"
            },
            {
              "keyword": "dinamica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5280,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè quando si lavora con strutture allocate dinamicamente bisogna poi preoccuparsi di deallocarne la memoria? Cosa accade altrimenti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione dinamica"
            },
            {
              "keyword": " memory leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5174,
          "asker": {
            "courseId": 100,
            "askerId": 756,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega in poche parole il principio di funzionamento dello stack.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5274,
          "asker": {
            "courseId": 100,
            "askerId": 764,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "quali sono le \"parti\" che compongono uno stack? Esistono delle parti create dal programmatore in modo tale che l'utente non possa utilizzarle?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "blocchi"
            },
            {
              "keyword": "stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5224,
          "asker": {
            "courseId": 100,
            "askerId": 745,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere quali sono le problematiche che si possono incontrare nell'implementazione delle stringhe come vettori di caratteri. Proporre due esempi, l'uno con allocazione statica, l'altro con allocazione dinamica e un esempio di copia di concatenazione di stringhe senza l'uso di funzioni di libreria.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " stringhe"
            },
            {
              "keyword": " caratteri"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5161,
          "asker": {
            "courseId": 100,
            "askerId": 749,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa differenzia x=i++ da x=++i?",
          "totalDifficultyLevel": 9,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "c++"
            },
            {
              "keyword": " variabili"
            },
            {
              "keyword": " incremento"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5537,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "x=i++ assegna a x il valore i e poi incrementa i, ad esempio se prima dell'istruzione i vale 2 dopo l'istruzione x vale 2 e i vale 3;\r\n\r\nx=++i prima incrementa i e poi assegna a x il valore incrementato, ad esempio se prima dell'istruzione x vale 2 dopo l'istruzione x vale 3 e i vale 3.\r\n\r\nPer evitare inutili errori (a meno di non essere sicuri al 100%) è meglio scrivere le 2 istruzioni sparate (ES x=i; i++; oppure i++; x=i;)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3417,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2912,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3008,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3303,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5596,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 876,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "x=i++ incrementa prima la i e poi la assegna alla x mentre x=++i funziona al contrario, incrementa quindi prima la x della i",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3007,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3306,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3416,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2911,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 5474,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 852,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Sono due tecniche per incrementare una variabile, la prima è detta postfissa e l'altra prefissa.\r\nGli operatori prefissi modificano il valore della variabile cui sono applicati prima che sene utilizzi il valore. Glio peratori postfissi modificano il valore della variabile dopo l?utilizzo del vecchio valore nell?espressione.\r\nSostanzialmente x, alla fine dell'esecuzione dello stralcio di codice, assume lo stesso valore in tutti i due i casi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3305,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 3006,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2910,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3415,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5557,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "L'operatore unario ++ può essere utilizzato in due modi diversi, ossia quello di POST-Incremento oppure quello di PRE-incremento.\r\nNel primo caso (x=i++) si tratta di un post-incremento; il valore della variabile 'i' viene prima assegnato ad 'x' e solo dopo viene incrementato di 1 (unario).\r\nNel secondo caso invece (x=++i) si tratta di un pre-incremento; il valore della variabile 'i' viene incrementato di 1 e successivamente assegnato alla variabile 'x'.\r\n ESEMPIO:\r\n  int x=0;\r\n  int i=2;\r\n     // nel caso di post-incremento\r\n         x=i++;     // Output x=2; y=3;\r\n     // nel caso di pre-incremento\r\n         x=++i;     // Output x=3; y=3;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2913,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3418,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3009,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 3304,
                  "rater": {
                    "raterId": 914,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5176,
          "asker": {
            "courseId": 100,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è fondamentale ricordarsi di utilizzare l'operatore \"delete\" in seguito alla dichiarazione di un operatore \"new\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "operatori"
            },
            {
              "keyword": " new"
            },
            {
              "keyword": " delete"
            },
            {
              "keyword": " memory leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5198,
          "asker": {
            "courseId": 100,
            "askerId": 792,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è necessario deallocare una cella o un'insieme di celle di memoria allocate dinamicamente nello heap prima di cancellarne il puntatore? Quali side effects si ottengono se non si dealloca? E se si prova ad accedere alla memoria appena deallocata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Memoria"
            },
            {
              "keyword": " Heap"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5194,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella funzione \"int estrai(Pila* S)\" vista a lezione è presente un richiamo ad una funzione denominata \"assert()\". Perchè è stata inserita? Qual'è il suo scopo? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack"
            },
            {
              "keyword": " pila"
            },
            {
              "keyword": " estrai"
            },
            {
              "keyword": "assert"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5269,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il motivo dell'implementazione della funzione \"estrai()\" dentro la struttura Pila e cosa rappresenta il \"this\" all'interno di alcune righe di codice della funzione stessa?\r\n\r\nstruct Pila {\r\n                 int size;\r\n                 int defaultGrowthSize;\r\n                 int marker;\r\n                 int * contenuto;\r\n                 int estrai() {\r\n                                   cout<<\"entro in estrai\"<<endl;\r\n                                   assert(this->marker>0);\r\n                                   return this->contenuto[--(this->marker)];\r\n                  }\r\n};",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "re-implementazione "
            },
            {
              "keyword": " estrai"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5165,
          "asker": {
            "courseId": 100,
            "askerId": 798,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestita la memoria durante la creazione di una nuova pila di elementi, considerando che la pila è dinamica, se la precedente è piena??",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gestione memoria"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5252,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando dichiaro un puntatore (per esempio: int *n;) viene anche allocato lo spazio in memoria per il suo contenuto?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 10,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": " C"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 5479,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 921,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando viene eseguita questa istruzione viene riservata una zona di memoria che corrisponde al \"nome\" p che sarà adibita a contenere l'indirizzo di memoria di una variabile di tipo int allocata un altra posizione in memoria. La zona \"p\" che viene allocata non contiene nulla fino a che al suo interno gli venga inserito un indirizzo di memoria del tipo \"&a\" oppure non venga inizializzata una variabile di tipo int in modo dinamico cioè mediante il costrutto \"new int ...\". Non comprendo bene la domanda essendo che a mio parere è un po ambigua... comunque per rispondere in modo esauriente: viene allocato in memoria uno spazio corrispondente alla variabile \"p\" che conterrà un indirizzo di memoria di una variabile int. Non viene allocata nessuna variabile int a cui il puntatore verrà collegato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3247,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3114,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2985,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3078,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 5520,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando dichiaro un puntatore viene allocato lo spazio di memoria per la variabile puntatore, ma non per la variabile puntata.\r\nP.S.\r\nQuando dichiaro invece un array viene allocato lo spazio di memoria non solo per la variabile puntatore (il nome dell'array), ma anche per l'area puntata, di cui viene predefinita la lunghezza; inoltre il puntatore viene dichiarato di tipo const e inizializzato con l'indirizzo dell'area puntata (cioè del primo elemento dell'array).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 2984,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3077,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3113,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 3246,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 5521,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 771,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "Se con contenuto si intende il valore dell indirizzo a cui punta si, in quanto allocare in memoria un puntatore è appunto allocare una cella in memoria il cui valore verrà interpretato come un indirizzo.\r\nSe con contenuto si intende un valore di tipo int allora no, non viene allocato un int, ma solo una cella per il puntatore.\r\nInoltre facendo \"int* n;\" il puntatore starà puntando ad un indirizzo che equivale al valore contenuto nella cella che è stata allocata per il puntatore, interpretato come un indirizzo, ma quel valore è un residuo della scrittura in memoria da parte di altri programmi e dereferenziarlo porterebbe a errori e comportamenti indefiniti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3245,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3112,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 3076,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 2983,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 5499,
              "task": {
                "taskId": 155,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "No, la dichiarazione di un puntatore comporta l'allocazione di memoria solo per una variabile puntatore (4 byte) ma non per la variabile puntata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 3115,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 2986,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 3079,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 3248,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 155,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5168,
          "asker": {
            "courseId": 100,
            "askerId": 844,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 154,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono considerate le stringhe in C/C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": "C++"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 62,
      "lectureTitle": "Lecture 15-16, Java FX",
      "questions": [
        {
          "questionId": 5792,
          "asker": {
            "courseId": 100,
            "askerId": 794,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Mediante quale processo e quali metodi si associa un \"controllore di eventi\" (EventHandler) ad un oggetto e ne vengono gestiti gli eventi relativi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": " EventHandler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5819,
          "asker": {
            "courseId": 100,
            "askerId": 855,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono gli stage, le scene, i parent e i nodi e come sono collegati tra loro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "streuttura"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5812,
          "asker": {
            "courseId": 100,
            "askerId": 850,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in javafx la classe Node è una classe astratta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " Node"
            },
            {
              "keyword": " abstract"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5834,
          "asker": {
            "courseId": 100,
            "askerId": 741,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "La relazione tra quali classi permette la ricorsività nella creazione di Stage e di Scene (Stage che contengono Stage e Scene che contengono Scene) ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stage"
            },
            {
              "keyword": " Scene"
            },
            {
              "keyword": " Ricorsività"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5859,
          "asker": {
            "courseId": 100,
            "askerId": 916,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di avere la classe Listener all'esterno della classe che estende Application? Quali sono però le difficoltà implementative?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Java FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5860,
          "asker": {
            "courseId": 100,
            "askerId": 816,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Attraverso l'implementazione di quale classe posso controllare la gestione degli eventi in JAVA FX? Di cosa ho bisogno per gestire la comunicazione tra questa classe e la shape ad essa connessa? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Events"
            },
            {
              "keyword": " Controller"
            },
            {
              "keyword": " Protocollo"
            },
            {
              "keyword": " JAVA FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5862,
          "asker": {
            "courseId": 100,
            "askerId": 775,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si aggiungono elementi multipli all'interno di una finestra? (ad esempio mettere un cerchio e un rettangolo nella stessa finestra)",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 20,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "parent"
            },
            {
              "keyword": " getChildren"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6191,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 571,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "si creano gli elementi e successivamente si aggiungono ad esempio all'HBOx in questo modo:\r\n\r\nparent.getChildren().addAll(cerchio,rettangolo);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5703,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5778,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6115,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5905,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6194,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Elementi multipli come un cerchio e un rettangolo nella stessa finestra si aggiungono attraverso la classe astratta Shape, la quale fornisce le definizioni per le proprietà che hanno in comune i diversi oggetti che rappresentano diverse forme geometriche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5704,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5906,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5779,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6118,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6200,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 753,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per poter aggiungere più di un oggetto (ossia per poter dare ad un parent più di un nodo \"figlio\") è necessario utilizzare  il metodo getChildren del parent. In pratica si prende la lista che contiene tutti i figli del parent (che inizialmente sarà vuota) e ci si aggiungono gli oggetti desiderati. \r\nAd esempio, se si vogliono aggiungere un cerchio c ed un rettangolo r ad un gruppo g, si scriverà\r\n...\r\ng.getChildren().addAll(r, c);\r\n...\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5782,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6116,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5707,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5909,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6248,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 893,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In JavaFX il contenuto da visualizzare (Node) viene raggruppato in oggetti Parent. Questi oggetti Parent possono essere layout, un insieme di forme geometriche, ecc \r\nQuando creiamo dei Parent possiamo utilizzare il costruttore per specificare un Node.\r\nSe vogliamo in seguito aggiungere un altro Node all'oggetto Parent dovremo utilizzare il metodo getChildren(), che restituisce una lista di Node, e concatenarlo con il metodo add(oggetto), che agisce sulla lista.\r\n\r\nGroup g = new Group();\r\nRectangle r = new Rectangle();\r\ng.getChildren().add(r);\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6120,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5908,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5706,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5781,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6227,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 858,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Per aggiungere elementi multipli ad una finestra si usa l'istruzione:  \r\n\"root.getChildren().add(elemento);\" più volte. Nello specifico della domanda per metter un cerchio e un rettangolo nella stessa finestra bisogna: \\n   \r\nPane\troot = new Pane();   //creare un nuovo Pane    \r\nCircle circ = new Circle(40, 40, 30);   //creare un nuovo cerchio    \r\nroot.getChildren().add(circ);   //aggiunger il cerchio al pane    \r\nPolygon tri= new Polygon();   //creare un poligono   \r\ntri.getPoints().addAll(new Double[]{\r\n    0.0, 0.0,\r\n    20.0, 10.0,\r\n    10.0, 20.0 });   //settare le coordinate e i numero dei vertici    \r\nroot.getChildren().add(tri);   //aggiunger il triangolo al pane   \r\nScene scene = new Scene(root, 300, 250);\t// infine aggiungiamo il pane alla scene    \r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5777,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5702,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5904,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6117,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6153,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 817,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Basterà prendere il Group che poi visualizzeremo, usare getChildren() per ottenere la lista degli oggetti che sono presenti in quel gruppo e poi usare addAll(Node primonodo, ...).\r\nIn questo modo abbiamo aggiunto diversi oggetti nello stesso gruppo che poi potrà esser visualizzato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5780,
                  "rater": {
                    "raterId": 866,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5907,
                  "rater": {
                    "raterId": 870,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5705,
                  "rater": {
                    "raterId": 823,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6119,
                  "rater": {
                    "raterId": 775,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5826,
          "asker": {
            "courseId": 100,
            "askerId": 831,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In java, cosa è un evento, a cosa serve e come viene usato (codice java)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "evento"
            },
            {
              "keyword": " listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5807,
          "asker": {
            "courseId": 100,
            "askerId": 777,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel programmare un'interfaccia grafica tramite JavaFX, esistono diversi modi di implementare un Listener per un determinato evento. Quali sono questi modi? Quali vantaggi/svantaggi comportano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " event listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5785,
          "asker": {
            "courseId": 100,
            "askerId": 851,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si implementa l'uso del mouse listener? E a cosa serve? Fare anche degli esempi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "mouse"
            },
            {
              "keyword": "listener"
            },
            {
              "keyword": "java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5845,
          "asker": {
            "courseId": 100,
            "askerId": 836,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo a volte è più comodo comporre figure con le shape di base al posto dell' utilizzo di canvas ? ",
          "totalDifficultyLevel": 11,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 12,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "canvas"
            },
            {
              "keyword": " javaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6169,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 816,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Perché con l'utilizzo di canvas si va a creare degli oggetti statici, quindi per poterci applicare delle animazioni bisogna disegnare ogni singolo movimento degli elementi. Mentre con le shape di base o le altre primitive per creare le animazioni basta spostare lo stesso oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6097,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5846,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5545,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5833,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6144,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 773,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perché con canvans si è limitati dall'uso della canvas si è costretti a scrivere il codice per disegnare qualsiasi figura.\r\nCon le shape,invece, abbiamo gia delle figure predefinite con il loro codice che quindi possono essere usate senza dover preoccuparsi di implementare. \r\nMa quando abbiamo bisogno di un disegno libero che non è gia predefinito o diadi alcuni metodi particolari, l'utilizzo di canvans è preferito.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5848,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6096,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5835,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5546,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6199,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 786,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Perchè nel caso di dover progettare animazioni, se istanziate come shape basta implementarne lo spostamento, se disegnate sul canvas bisogna invece cancellarle e ridisegnarle moltissime volte per dare l'idea del movimento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5849,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5836,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6098,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5543,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6172,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 560,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Tra i vari contenitori Java il Canvas è una semplice superficie di disegno particolarmente utile per visualizzare immagini o per effettuare altre operazioni grafiche. Un oggetto di tipo Canvas è semplicemente una porzione rettangolare di schermo, una specie di pannello che possiede un proprio metodo paint() che, pur diverso dall?omonimo metodo di un Applet, usa anch?esso oggetti della classe \r\nGraphics ed è richiamato dal sistema in fase di creazione e aggiornamento in modo che l?oggetto \r\nGraphics associato possa aggiornarsi. Una istanza della classe Canvas non è molto utile: riceve eventi da tastiera e da mouse, ma non li tratta, ed il metodo paint() non disegna alcunché. Generalmente la classe Canvas è usata solo come base per subclassi, che possono generare oggetti più utili: una subclasse di Canvas generalmente farà almeno un?override del metodo paint() e possibilmente anche dei metodi di gestione degli eventi come quelli del mouse e della tastiera.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6099,
                  "rater": {
                    "raterId": 796,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5847,
                  "rater": {
                    "raterId": 838,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5834,
                  "rater": {
                    "raterId": 836,
                    "courseId": 100,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5544,
                  "rater": {
                    "raterId": 817,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5786,
          "asker": {
            "courseId": 100,
            "askerId": 792,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si gestiscono gli eventi in JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": " JavaFx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5801,
          "asker": {
            "courseId": 100,
            "askerId": 891,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i generics e in cosa differiscono dalle collezioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collezioni"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5840,
          "asker": {
            "courseId": 100,
            "askerId": 830,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "alla creazione di un nuovo progetto è opportuno usare settings particolari? con che benefici?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "fx"
            },
            {
              "keyword": " nuovo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5871,
          "asker": {
            "courseId": 100,
            "askerId": 858,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il paradigma di astrazione usato da javafx?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " astrazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5831,
          "asker": {
            "courseId": 100,
            "askerId": 875,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra Canvas e ImageView?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "image"
            },
            {
              "keyword": " javafx"
            },
            {
              "keyword": " grafica"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6196,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 841,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Canvas (area di disegno o tela) è una semplice superficie di disegno particolarmente utile per visualizzare immagini o per effettuare altre operazioni grafiche.\r\nUn oggetto di tipo Canvas è semplicemente una porzione rettangolare di schermo, una specie di pannello che possiede un proprio metodo paint().\r\nGeneralmente la classe Canvas è usata solo come base per subclassi, che possono generare oggetti più utili: una subclasse di Canvas generalmente farà almeno un?override del metodo paint() e possibilmente anche dei metodi di gestione degli eventi come quelli del mouse e della tastiera.\r\n\r\nL'ImageView è un Node utilizzato per caricare le immagini utilizzando la classe Image.\r\nQuesta classe consente di ridimensionare l'immagine visualizzata (con o senza mantenere le proporzioni originali) e specificando una finestra dentro l'immagine di origine per limitare i pixel visualizzati da questo ImageView.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5754,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6140,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5576,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5476,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6146,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 772,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "ImageView è un controllo che permette di visualizzare delle immagini mentre il componente Canvas permette di disegnare anche forme all'interno di uno spazio oltre a caricare un'eventuale immagine di background",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5755,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5575,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6139,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5475,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6155,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 795,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Sono entrambe classi di java, ed entrambe servono per rappresentare un qualcosa di grafico dentro un'applicazione di java FX. La differenza sta in quel \"qualcosa\".\r\n\r\nUn oggetto di tipo Canvas è rappresentato come un rettangolo bianco, e si può immaginare come una tela bianca nella quale la nostra applicazione può disegnare in vari modi, ricevendo anche input dall'utente.\r\n\r\nImageView serve invece per rappresentare un immagine predefinita dentro la nostra applicazione.\r\nEsempio d'uso:\r\nImageView  iw  = new  ImageView(image);\r\nDove image è un oggetto di tipo Image",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5477,
                  "rater": {
                    "raterId": 875,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6138,
                  "rater": {
                    "raterId": 835,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5753,
                  "rater": {
                    "raterId": 824,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5577,
                  "rater": {
                    "raterId": 830,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5827,
          "asker": {
            "courseId": 100,
            "askerId": 594,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos' è Java FX? Qual è il suo scopo nella programmazione in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5793,
          "asker": {
            "courseId": 100,
            "askerId": 774,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un ascoltatore? \r\nIl sistema genera molti eventi ogni volta che viene eseguita una certa azione. E' possibile specificare il genere di eventi che l'ascoltatore deve \"ascoltare\"?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 6,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6157,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 830,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "un listener contiene una serie di azioni che vengono svolte quando accade l'evento per cui l'ascoltatore è in ascolto. Ogni ascoltatore è specifico per un genere di evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5294,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5860,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5350,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5604,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5492,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6176,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 845,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un ascoltatore è un metodo che permette di \"ascoltare\" tutti gli eventi che avvengono all'interno di una classe, facendo ciò si possono utilizzare delle azioni specifiche come digitare una lettera nella tastiera, premere il tasto sinistro con il mouse, trascinare il mouse, ecc e associarlo a un'azione che vogliamo che accada. E possibile dunque specificare tramite appositi comandi quali azioni ci interessano e quali il programma può non considerare per esempio ActionEvent.ACTION.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5859,
                  "rater": {
                    "raterId": 779,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5493,
                  "rater": {
                    "raterId": 888,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5293,
                  "rater": {
                    "raterId": 794,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5349,
                  "rater": {
                    "raterId": 801,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5605,
                  "rater": {
                    "raterId": 905,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5799,
          "asker": {
            "courseId": 100,
            "askerId": 910,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "non ho capito cosa vuol dire il cocetto di handle e di come si gestisce un evento. Descrivere questo concetto.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "handle"
            },
            {
              "keyword": " evento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5854,
          "asker": {
            "courseId": 100,
            "askerId": 779,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione di mode, view e controller? Che relazione intercorre tra di loro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Gestione"
            },
            {
              "keyword": " Dati"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5883,
          "asker": {
            "courseId": 100,
            "askerId": 801,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra lo stage e la scene?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stage"
            },
            {
              "keyword": " scene"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5805,
          "asker": {
            "courseId": 100,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "E` preferibile avere un Listener esterno, interno o interno anonimo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " interno"
            },
            {
              "keyword": " anonimo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5811,
          "asker": {
            "courseId": 100,
            "askerId": 778,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, attraverso quale meccanismo si possono gestire gli eventi che si scatenano interagendo con un'applicazione grafica?\r\n\r\nRiguardo alla modalità di programmazione, che cos'è l'MVC? Perché viene usato?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "MVC"
            },
            {
              "keyword": " designPattern"
            },
            {
              "keyword": " gestioneEventi"
            },
            {
              "keyword": " eventHandler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6218,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 746,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "In Java vengono utilizzati Listeners, ossia classi che implementano l' interfaccia EventHandler; possono essere esterni, interni oppure anonimi. Questi rientrano nel concetto di controllers che possiamo integrare nella definizione di MVC[Model-View-Controller], ossia uno dei pattern architetturale molto sfruttato nella programmazione ad oggetti. Il Model fornisce i metodi per accedere ai dati, il View si occupa dell' interfaccia grafica e quindi ciò che riguarda l'interazione con l'utente, il Controller gestisce i comandi dell'utente che riceve dalla View modificando lo stato del Model. Viene usato principalmente per l'utilizzo di una logica applicativa di separazione chiamata anche logica di business in modo che le varie componenti siano divise, ma inerconnesse e pronte a reagire ad eventuali cambiamenti da parte dell' utente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5584,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5500,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5414,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5743,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6109,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6241,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 741,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java gli eventi vengono gestiti tramite un Listener, cioè un metodo che \"ascolta\" ciò che avviene su un determinato oggetto (per es. un Bottone) e agisce seguendo i comandi contenuti nel metodo handle. \r\nL?architettura MVC è un modello software utilizzato nella programmazione ad oggetti. L?obiettivo principale dell?architettura MVC è quello di separare la logica di business e dati applicativi dal livello di  presentazione  dei dati all?utente. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5501,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5745,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5585,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5415,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6110,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6226,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 891,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Viene usata la classe EventHandler, e nel particolare bisogna fare un override del suo metodo handle, il quale riceve come parametro un evento o più che quando si verificano vanno ad eseguire le istruzioni scritte all'interno del metodo handle. Se per esempio ho un oggetto bottone chiamato btn vengono passati gli eventi o in questo caso l'evento click del mouse richiamando btn.addEventHandler(ActionEvent.ACTION,a) dove 'a' è l'oggetto della classe che andrà ad implementare appunto l'EventHandler, oppure sarà sostituito da 'this' nel caso in cui si voglia solo sovrascrivere il solo metodo handle. L'MVC è un pattern architetturale che va a separare la logica applicativa a carico del Controller e del Model dall'interfaccia utente a carico del View. Quest'ultimo, infatti, si occupa di visualizzare i dati del model e dell'interazione con l'utente. Il controller riceve i comandi dell'utente e li attua modificando gli altri due componenti e il model fornisce i metodi utili all'applicazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6111,
                  "rater": {
                    "raterId": 833,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5586,
                  "rater": {
                    "raterId": 890,
                    "courseId": 100,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5416,
                  "rater": {
                    "raterId": 778,
                    "courseId": 100,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5744,
                  "rater": {
                    "raterId": 535,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5502,
                  "rater": {
                    "raterId": 777,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5858,
          "asker": {
            "courseId": 100,
            "askerId": 840,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In una Scena posso aggiungere più gruppi? Se si come?\r\nE in uno stage più scene? Come?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 8,
          "totalRelevanceLevel": 7,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "stage"
            },
            {
              "keyword": " scene"
            },
            {
              "keyword": " group"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6186,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 844,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "In una scena posso aggiungere un solo gruppo in quanto è presente una relazione 1 a 1, lo stesso vale per le scene e per gli stage.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5988,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5870,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5404,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5526,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5952,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6161,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 777,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Una Scene può contenere un solo nodo. Però questo nodo può a sua volta contenere molti nodi figli, permettendo dunque di avere più gruppi all'interno di un'unica Scene.\r\nUno Stage non può contenere più Scene contemporaneamente. E' però possibile avere, in momenti diversi, Scene diverse all'interno dello stage, attraverso chiamate al metodo setScene.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5990,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5953,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5869,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5403,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5525,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6239,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 774,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "No in una scene si può aggiungere un solo grupo in quanto un gruppo contiene la lista di tutti gli elementi che voglio visualizzare nella finestra.\r\nÈ altrettanto impossibile inserire più scene sullo stesso stage.\r\nPosso però creare più finestre. A questo punto devo creare due stage distinti, ai quali passare due scene distinte ognuna col proprio gruppo come contenuto.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5954,
                  "rater": {
                    "raterId": 850,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5405,
                  "rater": {
                    "raterId": 770,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5527,
                  "rater": {
                    "raterId": 840,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5989,
                  "rater": {
                    "raterId": 766,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5868,
                  "rater": {
                    "raterId": 762,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5814,
          "asker": {
            "courseId": 100,
            "askerId": 762,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si intende con stage/scene/parent/node?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": "stage"
            },
            {
              "keyword": "scene "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5853,
          "asker": {
            "courseId": 100,
            "askerId": 837,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere a cosa serve e come può essere implementato un controllore , detto anche listener",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": "controllore"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5824,
          "asker": {
            "courseId": 100,
            "askerId": 881,
            "courseFinalScore": 9
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la gerarchia degli eventi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " gerarchia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5841,
          "asker": {
            "courseId": 100,
            "askerId": 788,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Nello schema delle classi di JavaFX (Stage, Scene, Parent, Node), c'è una relazione interessante tra Parent e Node: Parent HAS-A Node e Parent IS-A Node. Che tipo di situazioni particolari permettono queste relazioni? (Si ricorda che la classe Parent rappresenta il contenitore, e Node il contenuto da visualizzare sullo stage in una scena)",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 13,
          "totalRelevanceLevel": 13,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "parent"
            },
            {
              "keyword": " node"
            },
            {
              "keyword": " ricorsione"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6234,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 767,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Questo particolare tipo di relazione ci permette di avere oggetti che contengono oggetti dello stesso tipo.\r\n\r\nPer esempio, possiamo costruire una finestra contenente una finestra, che a sua volta può contenere delle finestre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5259,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6068,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5354,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6149,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 796,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Questa relazione é una relazione ricorsiva nel senso che un parent é un node e un node é un parent. Questo significa che dentro la scene ci sarà un parent può includer un node che a sua volte può essere parent di un altro node.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5351,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6070,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5258,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6189,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 594,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le situazioni particolari si ottengono quando fra la Parent e la Node subentra l'utilizzo della classe Abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5257,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5352,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6071,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6166,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 854,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La relazione Parent HAS-A Node permette di inserire nel contenitore del contenuto (bottoni, label ecc); tuttavia esiste anche la relazione Parent IS-A Node, che rende il contenitore un possibile contenuto per un altro contenitore. Grazie a questa relazione, infatti, un contenitore può contenere altri contenitori, che a loro volta possono contenere altri contenitori e così via.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5260,
                  "rater": {
                    "raterId": 560,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6069,
                  "rater": {
                    "raterId": 788,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5353,
                  "rater": {
                    "raterId": 862,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5848,
          "asker": {
            "courseId": 100,
            "askerId": 767,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quanti e quali tipi di listener esistono? Qual è la loro funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": "interno"
            },
            {
              "keyword": "esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5869,
          "asker": {
            "courseId": 100,
            "askerId": 888,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il nodo \"canvas\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "nodo"
            },
            {
              "keyword": " canvas"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5837,
          "asker": {
            "courseId": 100,
            "askerId": 784,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cosa sono stage, scene, parent, node e in che rapporto si trovano.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stage"
            },
            {
              "keyword": " scene"
            },
            {
              "keyword": " parent"
            },
            {
              "keyword": " node"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5791,
          "asker": {
            "courseId": 100,
            "askerId": 776,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è strutturata la gerarchia delle classi di un'applicazione JavaFX? Che rapporto c'è, in particolare, tra la classe Node e la classe Parent?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " Node"
            },
            {
              "keyword": " Parent"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5884,
          "asker": {
            "courseId": 100,
            "askerId": 854,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si parla di eventi in java FX, cosa si intende? Fai degli esempi per spiegare come questi influiscono sul normale flusso del programma.",
          "totalDifficultyLevel": 14,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 21,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": "javafx"
            },
            {
              "keyword": "evento"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6221,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 809,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Un evento è un oggetto che rappresenta il verificarsi di un?azione dell?utente o del sistema(es click del\r\nmouse o click su un tasto della tastiera oppure eventi temporizzati ecc.).\r\nLa libreria standard di Java contengono delle classi che rappresentano gli eventi che più spesso occorre gestire. Un listener (ascoltatore=ricevitore di eventi) è un oggetto che riceve una notifica quando si verifica un evento.\r\n?Eventi e listener (ascoltatori) sono elementi fondamentali per la GUI perché consentono di\r\nintercettare l?interazione con l?utente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5878,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5507,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5410,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6130,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5538,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5389,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6177,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 866,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Per evento in java si intende una particolare informazione che viene passata al programma in modo che essa possa attivare determinati comandi definiti in precedenza. Ci sono molti tipi di eventi e quindi divisi in categorie. Eventi di tipo azione (quando premiamo un bottone del mouse),di tipo Input (pressione del tasto della tastiera), di tipo Finestra (pressione dei bottoni standard e non solo di ogni finestra del desktop). Un evento e' passato ad un gestore (una classe o un metodo) che sara' incaricato a valutare l'informazione dell'evento e quindi eseguire il codice a lui associato. In JavaFX il gestore e' un classe da implementare da un interfaccia EventHandler e da fare overriding sul metodo handle().\r\n\r\nGestore gestoreEvento= new Gestore(); \r\n\t// Gestore e' la classe implementata da EventHandler\r\nButton btn =new Button();\r\nbtn.addEventHandler(ActionEvent.Action,gestoreEvento);\r\n\r\nAl bottone e' associato un gestore che eseguira il codice non appena l'evento verra' chiamato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5409,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5537,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5388,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5506,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5882,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6126,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6233,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 847,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Gli eventi sono azioni compiute dal programma o dall'utente che ne modificano l'esecuzione. Per esempio il click del mouse, l'attivazione di un componente come un bottone o la chiusura/apertura di una finestra",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5503,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5385,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5406,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5880,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5534,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6128,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6160,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 851,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Gli eventi sono un modo per permettere all'utente di interagire con il programma o comunque permettono di comunicare con il programma. Per esempio si potrebbe pensare all'evento di tasti della tastiera premuti oppure il click del bottone. Eventi non sono solo questi ma potrebbero essere anche hardware.Per esempio una lettura dalla seriale, dove un evento gestisce la lettura dei dati, ovvero l'evento scatta quando quando c'è qualcosa da leggere in input",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5505,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6129,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5881,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5536,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5387,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5408,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6229,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 888,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un semplice evento in java FX è il movimento del cursore all'interno di una finestra che si è aperta nel corso del processo. Attraverso un controller posso gestire gli eventi legati, per esempio, ad un bottone e direzionare il processo in maniera diversa se questo viene cliccato o meno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5535,
                  "rater": {
                    "raterId": 904,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5879,
                  "rater": {
                    "raterId": 841,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5386,
                  "rater": {
                    "raterId": 510,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6127,
                  "rater": {
                    "raterId": 893,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5504,
                  "rater": {
                    "raterId": 783,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5407,
                  "rater": {
                    "raterId": 854,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5790,
          "asker": {
            "courseId": 100,
            "askerId": 753,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo un controller può modificare il contenuto di un'applicazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "eventi"
            },
            {
              "keyword": " controller"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5838,
          "asker": {
            "courseId": 100,
            "askerId": 822,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Le relazioni\" parent is a node\" e \"node has a parents\" cosa permettono di fare ottenere in java fx?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": "fx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5806,
          "asker": {
            "courseId": 100,
            "askerId": 797,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In JavaFX per impostare l'effetto, per esempio, di un bottone si può sfruttare il sistema degli eventi e dei listener. Un listener di solito è un'istanza di una classe che implementa l'interfaccia EventHandler. Supponiamo di usare un listener esterno (ovvero una classe separata da quella della mia Application): in che modo possiamo far si che dal suo interno si possa interagire con la finestra (o i suoi elementi) nella quale è stato generato l'evento da gestire?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " Gestione Eventi"
            },
            {
              "keyword": " Listener Esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5878,
          "asker": {
            "courseId": 100,
            "askerId": 835,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che relazione c'è tra stage, parent, scene e node?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stage"
            },
            {
              "keyword": " parent"
            },
            {
              "keyword": " scene"
            },
            {
              "keyword": " node"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5857,
          "asker": {
            "courseId": 100,
            "askerId": 750,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando la classe \"Listener\" è esterna alla classe della applicazione, come fanno a \"comunicare\" le due classi e qual è la relazione tra loro?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 16,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": "esterna"
            },
            {
              "keyword": "relazione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6164,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 825,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Avere il Listener esterno alla classe application può essere una cosa scomoda: per la gestione degli eventi è infatti più comodo averlo all'interno. Avendolo all'esterno è necessario porlo public e serve che abbia all'interno un riferimento alla finestra. Si può quindi chiamare dalla classe application il costruttore e creare un'istanza di listener. Fra le due classi non c'è relazione di ereditarietà.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5420,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6051,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5300,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5315,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6028,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6249,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando la classe \"Listener\" è esterna alla classe dell'applicazione, essa comunica con quest'ultima implementandola all'interno dell'EventHandler. Così facendo, la classe principale diviene argomento di un secondo listener che la richiama a sua volta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5298,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5422,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6052,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5313,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6029,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6180,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 865,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "Partiamo dall'esempio noto:\r\n...\r\nListener a=new Listener(this);\r\nbtn.addEventHandler(ActionEvent.ACTION, a); \r\n...\r\nIn queste due righe avviene ciò che interessa a noi. Tramite il metodo addEventHandler andiamo a creare un nuovo gestore per gli eventi (nel nostro caso click con il mouse sul bottone). Nel momento in cui premiamo viene istanziato un oggetto di classe Listener al quale viene passato un riferimento alla classe corrente. Tale riferimento viene creato grazie a \"this\" e in tal modo la comunicazione viene garantita.\r\nInfatti, sempre menzionando lo stesso esempio, quando andremo a scrivere: \r\n...\r\nListener(AppWithEvents1 a) { awe=a; } \r\n...\r\nsapremo esattamente a quale classe ci riferiamo (quella chiamante) e il codice \r\n...\r\nawe.updateText(++counter);\r\n...\r\nprodurrà il risultato che desideriamo.\r\nL'esempio sopra riportato è stato preso in considerazione per cercare di spiegare più in dettaglio come avviene la comunicazione in caso di Listener Esterno\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6053,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5419,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6030,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5316,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5299,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6203,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 801,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Esistono diversi modi per far comunicare una classe Listener esterna con la classe della applicazione.\r\n\r\nQuello visto a lezione, consiste nell'istanziare la classe Listener esterna all'interno della applicazione, questa prende come argomento la classe applicazione e, al suo interno, viene richiamata una funzione update che permette al Listener di sentire.\r\n\r\nIn sintesi la relazione è: nell'applicazione viene richiamata la listener che a sua volta richiama l'applicazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5421,
                  "rater": {
                    "raterId": 826,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5314,
                  "rater": {
                    "raterId": 845,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6031,
                  "rater": {
                    "raterId": 829,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6054,
                  "rater": {
                    "raterId": 802,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5301,
                  "rater": {
                    "raterId": 750,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5822,
          "asker": {
            "courseId": 100,
            "askerId": 769,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Attraverso quale interfaccia vengono gestiti gli eventi? A quale classe deve essere implementata tale interfaccia? Inoltre in quale modo si possono gestire eventi differenti su uno stesso oggetto? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5787,
          "asker": {
            "courseId": 100,
            "askerId": 820,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile passare da un Listener esterno a uno interno? Quali modifiche bisogna apportare al codice e perché?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 13,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener esterno"
            },
            {
              "keyword": " listener interno"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6183,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 785,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "E' possibile inserire il Listener in una classe definita internamente alla classe dell'applicazione per poter accedere ai metodi della classe applicazione senza creare riferimenti aggiuntivi. Il problema è che, in questo caso, questo Listener può essere utilizzato solo all'interno del programma. \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5520,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5613,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5369,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5637,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5974,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5563,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6222,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 832,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Ci sono principalmente 2 metodi:\r\n\r\nUna classe anonima:\r\ncontrol_instance.addEventHandler(event_type, new EventHandler() {\r\n  @Override\r\n  public void handle(Event e) {\r\n    //handle\r\n  }\r\n});\r\n\r\nUna classe interna:\r\nclass ... {\r\n  //...\r\n    controlInstance.addEventHandler(event_type, new Listener(params));\r\n  //...\r\n  class Listener implements EventHandler {\r\n    public Listener(params) {\r\n      //...\r\n    }\r\n    \r\n    @Override\r\n    public void handle(Event e) {\r\n      //...\r\n    }\r\n  }\r\n}\r\n\r\n\r\nUn altro modo è implementare l'interfaccia EventHandler e passare come parametro this a addEventHandler:\r\nclass ... implements EventHandler {\r\n  //...\r\n    controlInterface.addEventHandler(event_type, this);\r\n  //...\r\n  \r\n  @Override\r\n  public void handle(Event e) {\r\n    //...\r\n  }\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5522,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5565,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5615,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5371,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5976,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5639,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6236,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 749,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Per passare da un Listener esterno a uno interno si può semplicemente scrivere la classe del Listener all'interno della classe principale e quindi non è più necessario fare il cast e non serve nemmeno passare il listener come parametro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5638,
                  "rater": {
                    "raterId": 789,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5521,
                  "rater": {
                    "raterId": 820,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5975,
                  "rater": {
                    "raterId": 741,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5564,
                  "rater": {
                    "raterId": 912,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5614,
                  "rater": {
                    "raterId": 772,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5370,
                  "rater": {
                    "raterId": 851,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5864,
          "asker": {
            "courseId": 100,
            "askerId": 760,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza a livello logico e a livello di programmazione tra Listener interno e esterno? L'implementazione del Listener esterno realizza uno dei concetti fondamentali della OOP, quale?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " MVC"
            },
            {
              "keyword": " Listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5865,
          "asker": {
            "courseId": 100,
            "askerId": 751,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un applicazine javaFX? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javaFX"
            },
            {
              "keyword": " grafica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5876,
          "asker": {
            "courseId": 100,
            "askerId": 757,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per interfaccia e in che relazione sta con il concetto di ereditarietà?\r\n",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6151,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 803,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Supponendo che si intenda interfaccia grafica si definisce come l'insieme delle aree e dei componenti che formano la stessa e che rendono intuitivo il programma finale all'utente.\r\nL'interfaccia è molto legata all'ereditarietà in quanto ogni zona è legata alle altre come mostrato nella diapositiva 1 di javaFX. Si può dire che senza ereditarietà non si possa avere un interfaccia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5519,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6186,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5310,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6170,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6217,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 807,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'interfaccia è una classe composta da metodi astratti. Non è istanziabile direttamente ma tramite ereditarietà permette alle classi che la implementano di avere una struttura comune. Viene soprattutto utilizzata nel caso in cui ci siano diverse classi che hanno funzioni simili ma le implementano in maniera differente. Nel caso delle interfacce java consente di ereditare da una classe sola ma da molteplici interfacce. Se una classe che implementa un'interfaccia non ne implementa tutti i metodi allora tale classe deve essere dichiarata astratta. Un'inerfaccia non può implementare un'altra interfaccia. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5518,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5311,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6171,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6187,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6187,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 778,
                "courseId": 100,
                "courseFinalScore": 27
              },
              "answerText": "Un'interfaccia è una classe che contiene solo dichiarazioni di metodi (e possibili costanti final) che dovranno poi essere definiti all'interno delle classi che implementeranno tale interfaccia. Inoltre le interfacce non possono essere istanziate ma possono essere usate come tipi. \r\n\r\nRispetto al concetto di ereditarietà, che serve per effettuare modifiche strutturali e/o comportamentali delle sottoclassi, un'interfaccia serve per creare dei comportamenti superficialmente comuni a più classi, ma che in realtà sono diversi in base alla definizione di tali metodi all'interno delle classi che implementano l'interfaccia specifica.\r\n\r\npublic interface Pulsante {\r\n  .\r\n  .\r\n  public premiPulsante();\r\n  .\r\n  .\r\n}\r\n\r\nNell'esempio sopra riportato tutte le classi che implementeranno l'interfaccia Pulsante dovranno definire al loro interno il metodo premiPulsante() che espliciterà un comportamento più specifico di quel pulsante.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6168,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6184,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5516,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5312,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6245,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 886,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per interfaccia (interface) si intende un insieme di metodi astratti e di costanti che verranno poi implementati da una o più classi. Poiché in ogni interfaccia si avrà solo la firma dei metodi e non la descrizione del loro corpo, saranno le classi che la dovranno implementare a doverne poi dare una loro descrizione formale, altrimenti si otterrà un errore di compilazione. Per questo motivo le interfacce non sono vere istanze, ma si comportano similmente alle classi astratte, e analogamente possono ereditare da una o più interfacce, senza il vincolo dell'ereditarietà singola. Un altro vantaggio è che una classe può implementare più di un'interfaccia permettendo così un applicazione di ereditarietà multipla che tra classi non è possibile. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5309,
                  "rater": {
                    "raterId": 757,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6169,
                  "rater": {
                    "raterId": 216,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6185,
                  "rater": {
                    "raterId": 878,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5517,
                  "rater": {
                    "raterId": 818,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5780,
          "asker": {
            "courseId": 100,
            "askerId": 785,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa é un evento?",
          "totalDifficultyLevel": 5,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 8,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "evento"
            },
            {
              "keyword": " definizione"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6207,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 912,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Un evento è una modalità di comunicazione tra l?utente (sistema) e il programma in esecuzione. La gestione di esso all?interno di un?applicazione permette di modificare il comportamento dell'applet (o applicazione)in base alle informazioni fornite dall?utente. Un evento può essere di vari tipi: \r\nInput da parte dell?utente:\r\n? pressione del(i) bottone(i) del mouse\r\n? spostamento del mouse\r\n? pressione di un tasto della tastiera\r\nEvento dell?interfaccia utente:\r\n? click su bottoni\r\n? spostamento di una barra di scorrimento\r\n? visualizzazione di menu\r\nEvento delle finestre: apertura, chiusura e uscita da una finestra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5764,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5867,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6231,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 783,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Un evento è un oggetto che rappresenta il verificarsi di un?azione dell?utente o del sistema, ad esempio il movimento o ilclick del mouse o pressione su un tasto della tastiera oppure eventi temporizzati et cetera.\r\nLa libreria standard di Java contengono delle classi che rappresentano gli eventi che più spesso occorre gestire.\r\nPer ricevere una notifica quando si verifica un evento occorre i Listener, un oggetto che aspetta che si verifichi un evento e quando ciò accade compie un azione in risposta. .\r\nEventi e listener (ascoltatori) sono elementi fondamentali per la GUI perché consentono di intercettare l?interazione con l?utente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5763,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5866,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6181,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 855,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Un evento è un qualunque segnale che il computer riceve in input, ad esempio lo spostamento del mouse, la pressione di un tasto, il click del mouse, ecc.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5762,
                  "rater": {
                    "raterId": 756,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5865,
                  "rater": {
                    "raterId": 785,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5888,
          "asker": {
            "courseId": 100,
            "askerId": 901,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "che cosa sono la circle,la shape e i group in java FX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "circle"
            },
            {
              "keyword": "shape"
            },
            {
              "keyword": "group"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5788,
          "asker": {
            "courseId": 100,
            "askerId": 754,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Elencare le principali differenze e/o vantaggi che contraddistinguono il controller/listener interno (e self-listener) ed esterno.",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "listener interno"
            },
            {
              "keyword": " listener esterno"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6219,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 905,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "la differenza fondamentale e' che il listener esterno e' una vera e propria classe mentre quello interno può essere anche un mero di implementazione della HandleEvent e quindi anonimo. Inoltre quello esterno solitamente si occupa di un singolo evento. Peraltro la classe che implementa un listener interno avrà appunto un \"inplements EventHandler\"   ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5460,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5784,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5827,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6150,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 884,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "I Listener sono quegli oggetti che ci permettono di effettuare delle azioni in corrispondenza del verificarsi di determinati eventi ( solitamente scatenati dall' utente che interagisce con l'interfaccia). Creiamo un Listener esterno nel caso in cui abbiamo bisogno di un Listener che svolga le stesse azioni per diversi componenti, in diverse classi. Invece un listener interno sarà utilizzabile solo nella classe in cui è dichiarato. Un listener interno può anche essere anonimo nel caso in cui ci serve un listener che gestisca gli eventi di un' unico controller e non vogliamo vi sia la possibilità( o non crediamo vi sia la necessità) di riutilizzarlo. Un self listener invece può essere utile quando vogliamo che gli eventi interagiscano direttamente con la classe in cui sono presenti i controller attraverso i quali vengono scatenati gli eventi. In conclusione non ne esiste uno migliore, ma possono venir utilizzati tutti tenendo a mente i loro vantaggi differenti e le nostre esigenze.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5826,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5463,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5783,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6242,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 763,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Essenzialmente in quello interno hai il vantaggio di poter accedere a tutto quello a cui può accedere la classe stessa e mantieni la logica \"interna\" alla classe. In quello esterno hai il vantaggio che puoi implementarlo in maniera astratta ed utilizzarlo con più classi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5461,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5786,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5829,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6206,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 857,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Fondamentalmente il listener esterno è una classe e si occupa di una singolo evento di solito, mentre quello interno può essere una semplice implementazione di un HandleEvent",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5828,
                  "rater": {
                    "raterId": 795,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5785,
                  "rater": {
                    "raterId": 760,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5462,
                  "rater": {
                    "raterId": 754,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5851,
          "asker": {
            "courseId": 100,
            "askerId": 846,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In java, quanti tipi di Listener esistono? In quali casi è preferibile usare ciascuno di essi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5821,
          "asker": {
            "courseId": 100,
            "askerId": 796,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale librerie e metodi si possono utilizzare per il settaggio di uno stage con svariati oggetti a schermo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Settaggio"
            },
            {
              "keyword": " Stage"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5842,
          "asker": {
            "courseId": 100,
            "askerId": 838,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Giochiamo un po' con le forme (class Shape): voglio creare una forma (ad esempio un cerchio) cliccabile. Come posso fare? Scrivere un esempio di codice.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Shape"
            },
            {
              "keyword": " MouseEvent"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5781,
          "asker": {
            "courseId": 100,
            "askerId": 826,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestita la chiusura del processo nelle javafx?\r\nCambia qualcosa se lo stesso programma si utilizza su sistemi operativi differenti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": "OperatingSystem"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5829,
          "asker": {
            "courseId": 100,
            "askerId": 818,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'interfaccia che garantisce la sincronia tra l'azione di schiacciare il bottone e l'azione seguente? Descrivine brevemente il suo funzionamento.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfaccia"
            },
            {
              "keyword": " EventHandler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5866,
          "asker": {
            "courseId": 100,
            "askerId": 902,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una Canvas? E quali differenze presenta rispetto allo Stage?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 17,
          "totalRelevanceLevel": 19,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Canvas"
            },
            {
              "keyword": " Stage"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6179,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 779,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il Canvas è una sottoclasse di Node, importabile con javafx.scene.canvas, che permette la creazione dinamica di disegni. Il suo funzionamento è così suddiviso:\r\n- si crea un oggetto Canvas, \r\n- si ottenie il GraphicsContext,\r\n- si invocano delle operazioni utili a visualizzare le forme create dall'utente.\r\n\r\nDifferenze:\r\nUn Canvas ha due \"dimensioni\": una per l'elemento in sè ed una per la superficie di disegno. Nello Stage invece si possono attribure delle misure solo all'oggetto e non allo spazio in cui esso viene creato.\r\nInoltre nel Canvas se il disegno risulta più grande della finestra associata, esso ingrandirà questa affinchè posso contenerlo, mentre nello Stage no.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5622,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5918,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6228,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Una Canvas è un \"foglio bianco\" sul quale si possono disegnare svariate cose tramite le primitive che contiene (fillOval, strokeArc eccetera) tramite il suo GraphicContext.\r\nStage è la classe \"top\" di jafaFX, crea una finestra in cui si possono aggiungere oggetti per inserire testo, immagini o altro.\r\nSenza Stage una Canvas non può esistere (bisogna sempre avere una finestra sui cui inserire contenuti), inoltre Stage non ha metodi propri per la creazione di grafica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5624,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5916,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6215,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 810,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Una Canvas può essere descritta come una tela vuota, un nodo che verrà aggiunto alla Scene e a cui è associato il suo GraphicsContext.\r\nTutti i metodi che permettono al programmatore di modificare e disegnare graficamente sulla Canvas sono in realtà chiamati dal GraphicsContext, ad esempio:\r\nfillArc(); fillRect(); drawImage();\r\nAl contrario gli unici metodi appartenenti alla classe Canvas sono i get/set per gli attributi Height e Width della stessa, oltre al getGraphicsContext2D.\r\n\r\nLa differenza principale tra Canvas e Stage risiede nel fatto che la prima è una semplice tela su cui disegnamo e coloriamo oggetti che però non sono manipolabili separatamente nè modificabili se non sovrascrivendoli con altre immagini; lo Stage è invece una finestra su cui possiamo disporre oggetti di qualsiasi tipo (Scenes, Shapes, Buttons, MediaView,ecc), collegati gerarchicamente alla stessa.\r\nQuesta gerarchia permette la modifica del contenuto e del Layout facilmente ed in qualsiasi momento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5625,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5919,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6225,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 820,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il Canvas è una classe che estende Node ed è un'immagine su cui è possibile disegnare usando un set di comandi grafici offerti da GraphicContext. Un Canvas è costruito con una larghezza e un'altezza che specificano la dimensione dell'immagine in cui i comandi di disegno del Canvas sono dati. Tutti i comandi di disegno non hanno più effetto al di fuori dei bordi dell'immagine.\r\nLo Stage invece è una classe che estende Window ed è il più grande contenitore di JavaFX; quindi il Canvas può essere contenuto all'interno di una Scene, contenuta in uno Stage, e quindi queste due classi sono a due livelli di gerarchia differenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5623,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5915,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6173,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 776,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Canvas è una sottoclasse di Node che permette di \"disegnare\" direttamente sul suo GraphicContext attraverso varie primitive: fillArc(), fillRect(), drawImage, ...\r\nRispetto allo Stage, possiamo pensare alla Canvas come ad un elemento con cui gestire l'aspetto grafico a livello più basso: anziché specificare il tipo di elementi che vogliamo far apparire e il loro layout, lasciando a Java il compito di disegnare tali elementi, possiamo creare manualmente \"pixel per pixel\" quello che vogliamo (figure geometriche o altro).\r\nDa notare inoltre che una Canvas, essendo un Node, è in un livello \"più basso\" della gerarchia delle classi di JavaFX: uno Stage può contenere una o più canvas, che possono essere gestite come qualunque altro Node.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5626,
                  "rater": {
                    "raterId": 825,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5917,
                  "rater": {
                    "raterId": 902,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5889,
          "asker": {
            "courseId": 100,
            "askerId": 874,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si chiama la finestra sulla quale si sviluppa la scene?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "scene"
            },
            {
              "keyword": " parent"
            },
            {
              "keyword": " node"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5823,
          "asker": {
            "courseId": 100,
            "askerId": 755,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono i listener?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " eventi"
            },
            {
              "keyword": " FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5836,
          "asker": {
            "courseId": 100,
            "askerId": 746,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che relalzione c'è tra node e parent? Cosa ci permette di fare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "node"
            },
            {
              "keyword": " parent"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5882,
          "asker": {
            "courseId": 100,
            "askerId": 789,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Da chi eredita la classe Stage?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javaFX"
            },
            {
              "keyword": " stage"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5789,
          "asker": {
            "courseId": 100,
            "askerId": 752,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve Event.ANY e in quali sottogruppi si divide?",
          "totalDifficultyLevel": 6,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 7,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Event.ANY"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6204,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 904,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Quando all' interno delle parentesi di addEventHandler scriviamo Event.ANY vogliamo che vengano considerati tutti i possibili eventi che riguardino quel oggetto che per esempio potrebbe essere un bottone.I Sottogruppi in cui si divide sono : InputEvent.ANY che a sua volta è diviso : KeyEvent.Any , MouseEvent.any ecc.. E si occupa di vedere se gli oggetti sono stati premuti o rilasciati .\r\nActionEvent.ACTION che tiene conto degli spostamenti del mouse sugli oggetti.\r\nWindowEvent.ANY il quale gestisce tutti gli sventi che riguardano la finestra che stiamo utilizzando.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6023,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5434,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5377,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5808,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5994,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6244,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 846,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Event è una classe utilizzata per gestire gli eventi, nello specifico Event.ANY indica un qualsiasi tipo di evento.\r\nLa classe si suddivide in 3 sottoclassi principali: InputEvent, ActionEvent e WindowEvent",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5376,
                  "rater": {
                    "raterId": 494,
                    "courseId": 100,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6024,
                  "rater": {
                    "raterId": 894,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5995,
                  "rater": {
                    "raterId": 752,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5433,
                  "rater": {
                    "raterId": 837,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5809,
                  "rater": {
                    "raterId": 769,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5808,
          "asker": {
            "courseId": 100,
            "askerId": 866,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono gli eventi in javaFX?  Perché sono cosi importanti? Cosa e' un event handler? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Eventi"
            },
            {
              "keyword": "  gestore"
            },
            {
              "keyword": "  handler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5870,
          "asker": {
            "courseId": 100,
            "askerId": 853,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le classi più importanti, di cui si compone Java FX?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 10,
          "totalRelevanceLevel": 18,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6223,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 916,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le classi più importanti di Java FX sono Stage, Scene, Parent, Node. Lo Stage corrisponde alla finestra mentre la Scene è ciò che è visibile all'interno della finestra. I Parent e i Node sono il contenuto della Scene. I primi contengono i Node e permettono, ad esempio, layout differenti. Parent è una classe abstract e di essa abbiamo visto la sottoclasse Group e Region. Quest'ultima a sua volta contiene molte sottoclassi che corrispondono a disposizioni differenti. Infine i Node sono gli elementi da mostrare. Anche questa è una classe abstract le cui sottoclassi si differenziano per cosa disegnano. Esempi sono la classe Shape (forme), Image (immagini), Text (testo), Button (pulsanti). Anche i Parent posson essere dei Node. Altre classi importanti sono quelle legate agli eventi come EventHandler che permette di impostare ad una azione un comando.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5674,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5681,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5698,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6010,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6152,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6162,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 822,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le classi piú importanti sotto java fx sono la classe Stage, la classe Scene , la classe Parents e la classe Node",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5682,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5699,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6012,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6154,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5675,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6159,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 760,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "Java FX è un framework per realizzare la parte grafica (ció che nel modello Model View Control corrisponde alla componente denominata View, ovvero la classe o l'insieme di classi che si occupano della parte grafica e della rappresentazione dei dati) di una applicazione java. In generale Java FX racchiude tutta una serie di classi strutturate in una gerarchia a partire da Stage che consiste in una finestra della nostra Application(classe che deve essere estesa dalla classe pricipale) che è composta da uno o più oggetti di tipo Scene che sono il contenuto principale di una finestra(Stage). È consentito anche avere più finestre per la stessa Application e è possibile switchare in una stessa finestra tra più Scene. A sua volta Scene è composto da dei Parent, che sono dei Node e che possono essere composti da più Node - le loro sottoclassi concrete (dato che queste sono abstract) ad es.Group per Parent e ImageView per Node, realizzano il contenuto di un oggetto di tipo Scene.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6151,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6009,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5673,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5680,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5697,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6209,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 754,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Le classi fondamentali di JavaFX sono le seguenti:\r\nStage = fisicamente, la finestra che vogliamo creare per ospitare gli oggetti che vogliamo visualizzare.\r\nScene = letteralmente, la scena che è contenuta nello Stage e che conterrà gli oggetti. La Scene può essere organizzata seguendo dei layout, che permettono di organizzare gli oggetti creati secondo degli schemi prestabiliti.\r\nParent = oggetti che andiamo a creare e che verranno visualizzati nella Scene. Ha una sottoclasse chiamata Node, alla quale è legato anche da una relazione \"is a\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6011,
                  "rater": {
                    "raterId": 816,
                    "courseId": 100,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5679,
                  "rater": {
                    "raterId": 809,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6153,
                  "rater": {
                    "raterId": 897,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5696,
                  "rater": {
                    "raterId": 810,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5672,
                  "rater": {
                    "raterId": 874,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5877,
          "asker": {
            "courseId": 100,
            "askerId": 494,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale modo posso realizzare dei listener?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": "javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5825,
          "asker": {
            "courseId": 100,
            "askerId": 770,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il getChildren() ? Ed invece che funzione ha il Parent? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "getchildren"
            },
            {
              "keyword": " parent"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5815,
          "asker": {
            "courseId": 100,
            "askerId": 817,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è l'utilità di creare una classe esterna per ogni ascoltatore presente su un interfaccia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " esterni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5843,
          "asker": {
            "courseId": 100,
            "askerId": 571,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In java fx cosa succede se ad uno stage non setto l'altezza ma solo la larghezza? e se dimentico di inserire la scene?",
          "totalDifficultyLevel": 8,
          "totalInterestingnessLevel": 9,
          "totalRelevanceLevel": 9,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " fx"
            },
            {
              "keyword": " stage"
            },
            {
              "keyword": " scene"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6214,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 797,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "In uno stage, se non specifico manualmente la sua altezza e la sua larghezza, esse verranno impostate automaticamente in modo da adattarsi alle dimensioni della scena contenuta (calcolate a loro volta in base alle dimensioni preferite dei suoi componenti o specificate dal programmatore). Nel caso io imposti solo una delle due dimensioni, verrà adattata solo l'altra.\r\nSe non specifico alcuna scena per lo stage, comparirà una finestra vuota delle dimensioni impostate o di dimensioni predefinite dalla classe. Se, però, specifico solo uno dei due parametri lo stage adatta l'altra dimensione alla scena vuota, ovvero la azzera.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5888,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5256,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6163,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6095,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6167,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Quando crei uno stage non e` presente la funzione di creazione con un solo un parametro numerico da passargli, mentre se non inserisci la scena ti posta solo la barra del titolo con i 3 bottoni di default.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5889,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6094,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5255,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 6162,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6193,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 818,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In generale se nello stage non settiamo l'altezza e la larghezza, lo stage si adatta alla scene in esso contenuta. Se settiamo solo l'altezza con il metodo setHeight(), viene attribuita allo stage l'altezza da noi specificata, mentre alla larghezza viene attribuito un valore predefinito.\r\nOccorre però prestare attenzione: possiamo infatti allargare manualmente lo stage.\r\nDiverso invece è il caso in cui settiamo un'altezza massima che lo stage più raggiungere, con il metodo setMaxHeight; infatti in questa situazione non possiamo allungare lo stage oltre la suddetta altezza. \r\nPoichè la scene rappresenta il contenuto dello stage, se non inserissimo la scene, otterremmo una finestra vuota.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6161,
                  "rater": {
                    "raterId": 571,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6093,
                  "rater": {
                    "raterId": 855,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5887,
                  "rater": {
                    "raterId": 814,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5254,
                  "rater": {
                    "raterId": 806,
                    "courseId": 100,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5861,
          "asker": {
            "courseId": 100,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza fra Circle,Shape e Group?",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 11,
          "totalRelevanceLevel": 11,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "circle"
            },
            {
              "keyword": " shape"
            },
            {
              "keyword": " group"
            },
            {
              "keyword": " differenza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6247,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 789,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Shape è una classe astratta da cui eredita la classe Circle. Quest'ultima, dunque, ne implementa i metodi. Tutti e tre sono dei node, però soltanto Group può contenere altri Node.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5355,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6018,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5650,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5437,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5792,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6198,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 756,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "La classe Circle crea un cerchio dato un raggio e un centro. La classe Shape offre delle proprietà che tutte le forme geometriche hanno in comune. Un Gruop invece è un contenitore che raffigura ordinatamente gli oggetti in esso contenuti. Se il Group viene visualizzato più volte, anche gli oggetti in esso contenuti, verranno visualizzati più volte.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5794,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5436,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6017,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5357,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5648,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6202,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 831,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe Circle crea un cerchio con un determinato centro e un raggio arbitrario. La classe Shape (astratta) fornisce dei metodi che definiscono le principali proprietà degli oggetti che rappresentano alcune forme geometriche. Group, invece, contiene una lista di figli che vengono renderizzati ogni qualvolta un nodo viene renderizzato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5356,
                  "rater": {
                    "raterId": 776,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6016,
                  "rater": {
                    "raterId": 911,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5649,
                  "rater": {
                    "raterId": 842,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5793,
                  "rater": {
                    "raterId": 884,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5435,
                  "rater": {
                    "raterId": 792,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5875,
          "asker": {
            "courseId": 100,
            "askerId": 216,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'event handler? Come viene implementato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": " handler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5832,
          "asker": {
            "courseId": 100,
            "askerId": 905,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos' è Canvas in java FX? cosa modifica nel programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "canvas"
            },
            {
              "keyword": " java"
            },
            {
              "keyword": " fx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5855,
          "asker": {
            "courseId": 100,
            "askerId": 842,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza strutturale intercorre tra JavaFX e Swing per la gestione della grafica?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFx"
            },
            {
              "keyword": "Swing"
            },
            {
              "keyword": " Grafica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5852,
          "asker": {
            "courseId": 100,
            "askerId": 747,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per Model-View-Controller? Quali vantaggi comporta l'utilizzo di questo tipo di pattern?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Model"
            },
            {
              "keyword": "View"
            },
            {
              "keyword": "Controller"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6175,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 861,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "E' un pattern di tipo architetturale dell'interfaccia utente (la cosiddetta GUI). Esso consiste nella visualizzazione del modello, la scrittura della parte grafica per l'utente e l'iterazione/collegamento fra queste 2 parti, in modo da permettere una iterazione diretta tra utente e macchina.\r\nI vantaggi nell'utilizzo di questo pattern consistono nella possibilità di correggere le 3 aree singolarmente senza andare a modificare l'intero codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5725,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5328,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5895,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6177,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6195,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 510,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "PerModel-View-Controller si intende  un pattern architetturale molto diffuso nello sviluppo di sistemi software, in particolare nell'ambito della programmazione orientata agli oggetti, in grado di separare la logica di presentazione dei dati dalla logica di business.\r\nQuesto pattern si posiziona nel livello di presentazione in una Architettura multi-tier.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5325,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5729,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5899,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6176,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6243,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 862,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Per MVC si intende un pattern di programmazione, in cui le varie funzionalità del software sono logicamente separate ovvero suddivise su più strati software differenti in comunicazione tra loro.\r\nMVC è composto da 3 livelli:\r\nModel - il core dell'applicazione, incapsula lo stato dell'applicazione definisce i dati e le operazioni che possono essere eseguite su questi. Definisce le regole per l'interazione con i dati, esponendo alla View ed al Controller rispettivamente le funzionalità per l'accesso e l'aggiornamento.\r\n\r\nView - La logica di presentazione dei dati,che rappresenta il mezzo mediante il quale gli utenti interagiscono con il sistema.\r\n\r\nController - riceve i comandi dell'utente (in genere attraverso il view) e li attua modificando lo stato degli altri due componenti.\r\n\r\nVantaggi:\r\n-Modularità-->La separazione tra Model e View permette a diverse GUI di utilizzare lo stesso Model.\r\n-Supporto più semplice per nuovi tipi di client(Model preesistente)\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6175,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5327,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5728,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5898,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6152,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 794,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Il Model-View-Controller è un pattern che prevede una divisione dei componenti del programma in base ai compiti che essi devono svolgere:\r\n- model (fornisce i metodi per accedere ai dati)\r\n- view (gestisce la rappresentazione dei contenuti, e l'interfaccia di interazione con l'utente)\r\n- controller (riceve i comandi dall'utente e li applica sui dati)\r\n\r\nIl vantaggio comportato dall'utilizzo di questo pattern consiste in una maggiore gestibilità dei vari elementi, che permette al programmatore di accedere facilmente ad ogni componente del programma in base all'aspetto su cui intende lavorare, grazie alla maggiore chiarezza e sistematicità del codice, dovuta appunto alla scelta del pattern MVC.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5896,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6172,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5726,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5326,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6212,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Il Model-View-Controller è un design pattern utile quanto ordinato per organizzare e dividere in modo pertinente il codice scritto. Il pattern è basato sulla separazione dei compiti fra i componenti software che interpretano tre ruoli principali:\r\n-il model fornisce i metodi per accedere ai dati utili;\r\n-il view visualizza i dati del model e \"comunica\" con l'utente\r\n-il controller riceve i comandi dell'utente e modifica lo stato dell'intero software.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6173,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5894,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5323,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5724,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6213,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 770,
                "courseId": 100,
                "courseFinalScore": 18
              },
              "answerText": "Il Model-View-Controller è un design pattern utile quanto ordinato per organizzare e dividere in modo pertinente il codice scritto. Il pattern è basato sulla separazione dei compiti fra i componenti software che interpretano tre ruoli principali:\r\n-il model fornisce i metodi per accedere ai dati utili;\r\n-il view visualizza i dati del model e \"comunica\" con l'utente\r\n-il controller riceve i comandi dell'utente e modifica lo stato dell'intero software.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5324,
                  "rater": {
                    "raterId": 747,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6174,
                  "rater": {
                    "raterId": 846,
                    "courseId": 100,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5897,
                  "rater": {
                    "raterId": 755,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5727,
                  "rater": {
                    "raterId": 910,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5880,
          "asker": {
            "courseId": 100,
            "askerId": 824,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè un Parent è un Nodo ed allo stesso tempo un nodo puó avere altri Parent? Che tipo di legame c'è?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Node"
            },
            {
              "keyword": " Parent"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5887,
          "asker": {
            "courseId": 100,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega come gestisce gli eventi JavaFX.",
          "totalDifficultyLevel": 10,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6201,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 863,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "JavaFX gestisce gli eventi tramite classi che implementano l'interfaccia EventHandler, dette Listener. I Listener devono implementare il metodo:\r\npublic void handle(Event e){...}\r\nin cui vengono definite le operazioni da effettuarsi al verificarsi di un evento.\r\n\r\nPossiamo collegare i Listener ad oggetti di altre classi di JavaFX(quelle che ereditano da Node), per es. Button o Shape tramite il metodo addEventHandler(EventType, EventHandler): il primo parametro è il tipo di evento che viene registrato; il secondo è un oggetto Listener il quale metodo handle viene eseguito al verificarsi dell'evento.\r\nPer tutti questi oggetti è possibile registrare più Listener per diversi eventi, utile per esempio per effettuare logging(scrivere messaggi di errore su stderr).\r\n\r\nÈ possibile creare anche metodi costruttori per le classi Listener, in modo da passare informazioni al metodo handle.\r\n\r\nPer velocizzare la scrittura, è possibile definire Listener anonimi e interni alla classe stessa.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5383,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6084,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5632,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6055,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5756,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6238,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 761,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Al fine di separare la logica degli eventi da quella di implementazione delle interfacce grafiche, in Java i gestori degli eventi sono istanze di una classe separata che implementa l'interfaccia eventHandler, assumendo l'obbligo di implementare il metodo void handle(event T), ovvero il protocollo di comunicazione che definisce il modo in cui tale evento deve essere gestito. Javafx inoltre permette l'introduzione di filtri come event.ANY, event.ACTION per rispondere alla molteplicità di eventi che possono verificarsi. A seconda delle situazioni si parla di:\r\nLISTENER ESTERNO: la gestione è esterna alla classe stessa (la comunicazione avviene attraverso il passaggio della referenza)\r\nLISTENER INTERNO: la gestione avviene in una classe interna (facilita la comunicazione) \r\nSELF LISTENER: è la classe stessa a gestire gli eventi\r\nLISTENER INTERNO ANONIMO: unione di definizione e istanziazione (favorisce la compattezza del codice)\r\nMULTI LISTENER: gli eventi vengono gestiti da più controller",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5633,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6057,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6086,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5758,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5384,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6171,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 864,
                "courseId": 100,
                "courseFinalScore": 25
              },
              "answerText": "In JavaFX un evento è rappresentato come un'istanza della classe javafx.event.Event. Esistono molti tipi di eventi (come KeyEvent, DragEvent, MouseEvent..), ed è possibile estendere la classe Event per poterne creare di nuovi. Un evento possiede tre proprietà: type, source e target. Per la gestione degli eventi, in JavaFX è possibile utilizzare la classe Listener.\r\nEsempio:\r\nListener a=new Listener();\r\nbtn.addEventHandler(Event.ANY, a);\r\nE' inoltre possibile implementare un Listener interno o esterno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5382,
                  "rater": {
                    "raterId": 758,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6085,
                  "rater": {
                    "raterId": 891,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5631,
                  "rater": {
                    "raterId": 916,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6056,
                  "rater": {
                    "raterId": 41,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5757,
                  "rater": {
                    "raterId": 773,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5846,
          "asker": {
            "courseId": 100,
            "askerId": 787,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos?è e a cosa serve un framework (es. JavaFX) in Java? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Framework"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5830,
          "asker": {
            "courseId": 100,
            "askerId": 904,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare il legame che collega : stage,scene,parent e nodo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stage"
            },
            {
              "keyword": "parent"
            },
            {
              "keyword": "scene"
            },
            {
              "keyword": "nodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5779,
          "asker": {
            "courseId": 100,
            "askerId": 806,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione della classe Stage in un'applicazione grafica? Qual è la differenza rispetto alla Scene? \r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " stage"
            },
            {
              "keyword": " scene"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5796,
          "asker": {
            "courseId": 100,
            "askerId": 803,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la particolarità della classe Parent? E quali sono e a cosa servono le sue sottoclassi piú \"importanti\"?",
          "totalDifficultyLevel": 15,
          "totalInterestingnessLevel": 12,
          "totalRelevanceLevel": 15,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " lezione 15"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6210,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 759,
                "courseId": 100,
                "courseFinalScore": 26
              },
              "answerText": "Parent è la classe di base per tutti i nodi che hanno i figli in scene graph.\r\nQuesta classe gestisce tutte le operazioni di scene graph gerarchici, inclusa l'aggiunta o rimozione di nodi figli.\r\n\r\nI sottoclassi più importanti del Parent sono:\r\n\r\n-Group: effetti e trasformazioni da applicare a una collezione di nodi figli.\r\n-Region: classe per i nodi, possono essere designati (styled) con CSS e con layout del children.\r\n-base Control: classe per i nodi di alto livello (che possono cambiano aspetto) destinati per l'interazione dell'utente. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5717,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5968,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5305,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5467,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5447,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6205,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 875,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "La particolarità di Parent è che oltre ad essere un Node ha come elementi dei Node, in questo modo si possono fare finestre che contengono dei Node (cerchio, quadrato, etc) e Parent in cui quest'ultimi contengono altri Node e Parent e così via.\r\nLa sottoclasse più importante di Parent è Group che, come si può capire dal nome, è un contenitore di oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5303,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5444,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5464,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5966,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5715,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6163,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 792,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "I parent sono dei nodi, quindi sottoclassi di Node, che possono contenere altri nodi così da poter collegare gli elementi tra loro. Le sottoclassi di parent sono molte, alcune delle quali sono Group, HBox, GridPane, che forniscono delle proprietà specifiche di layout",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5965,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5716,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5465,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5445,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5304,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6174,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 775,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "La classe Parent è una classe di tipo Node che al suo interno contiene dei Node; Alcune delle sue sottoclassi sono Group che è un contenitore di nodi, Region che è un'area che può contenere dei nodi, Control che a sua volta è una superclasse di vari widjet di utilità, WebView che lavora con materiale web. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5302,
                  "rater": {
                    "raterId": 784,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5466,
                  "rater": {
                    "raterId": 584,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5714,
                  "rater": {
                    "raterId": 803,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5967,
                  "rater": {
                    "raterId": 858,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5446,
                  "rater": {
                    "raterId": 921,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5802,
          "asker": {
            "courseId": 100,
            "askerId": 857,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il rapporto tra stage, scene parent e node ?",
          "totalDifficultyLevel": 3,
          "totalInterestingnessLevel": 5,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "stage"
            },
            {
              "keyword": " scene"
            },
            {
              "keyword": " parent"
            },
            {
              "keyword": " node"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6145,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 790,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Lo stage è la finestra e questa contiene una scene. Una scene ha un parent che è un node",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6124,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5588,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5969,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5418,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6182,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 494,
                "courseId": 100,
                "courseFinalScore": 16
              },
              "answerText": "Uno stage è una finestra.\r\n\r\nUna scene è il contenuto che verrà visualizzato all'interno dello stage, ed è un insieme di node.\r\n\r\nUn node è un widget, un elemento dell'interfaccia, come un bottone o una label.\r\n\r\nUn parent è un node che serve a raggruppare altri node. Un esempio di parent è una VBox, in quanto raccoglie vari node al suo interno, che possono essere a loro volta dei parent.\r\n\r\nRicapitolando: per realizzare una UI creo dei widget (node). Questi, generalmente, vengono raggruppati tramite dei node particolari che sono i parent. Questi node vengono aggiunti ad una scene, che per essere visualizzata nella finestra deve essere aggiunta al relativo stage.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5417,
                  "rater": {
                    "raterId": 857,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5587,
                  "rater": {
                    "raterId": 863,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 6125,
                  "rater": {
                    "raterId": 807,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5970,
                  "rater": {
                    "raterId": 797,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5833,
          "asker": {
            "courseId": 100,
            "askerId": 893,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere la relazione tra classi Node e Parent ed il loro ruolo in JavaFX. Fare un esempio di classi derivate ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Parent"
            },
            {
              "keyword": " Node"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5810,
          "asker": {
            "courseId": 100,
            "askerId": 865,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega in maniera esaustiva la struttura gerarchica di base di JavaFX.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " gerarchia"
            },
            {
              "keyword": " struttura"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5800,
          "asker": {
            "courseId": 100,
            "askerId": 793,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo e' possibile ottenere una modifica sullo stato dell'applicazione tramite la classe con funzione di EventHandler?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "linking"
            },
            {
              "keyword": " controller"
            },
            {
              "keyword": " handler"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5816,
          "asker": {
            "courseId": 100,
            "askerId": 773,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona la grafica in Java?\r\nEsistono librerie predefinite e metodi utilizzabili?\r\nCom'e' strutturata la finestra grafica e da chi e' gestita?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Grafica"
            },
            {
              "keyword": " Finestra"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5850,
          "asker": {
            "courseId": 100,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè la classe controller Listener è definita come classe esterna all'applicazione? In che modo si riesce a mantenere il collegamento con l'applicazione con cui si lavora a livello grafico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Controller"
            },
            {
              "keyword": " applicazione grafica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5847,
          "asker": {
            "courseId": 100,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché esiste un Listener interno ed uno esterno? A cosa servono e quali sono le principali differenze tra i due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener interno"
            },
            {
              "keyword": " Listener esterno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5797,
          "asker": {
            "courseId": 100,
            "askerId": 748,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che problema sorge quando tento di \"ascoltare\" più eventi?\r\nCome si può risolvere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event"
            },
            {
              "keyword": "listener"
            },
            {
              "keyword": "multilistener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5844,
          "asker": {
            "courseId": 100,
            "askerId": 845,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestito in java fx l'utilizzo di finestre multiple? Come è possibile terminare questo programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java fx"
            },
            {
              "keyword": " finestre multiple"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5856,
          "asker": {
            "courseId": 100,
            "askerId": 861,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Definisci la struttura di JavaFX e, se possibile, descrivine la gerarchia.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gerarchia"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5868,
          "asker": {
            "courseId": 100,
            "askerId": 864,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è Java FX? Come funziona? Come posso utilizzarlo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java fx"
            },
            {
              "keyword": " interfaccia"
            },
            {
              "keyword": "grafica"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5798,
          "asker": {
            "courseId": 100,
            "askerId": 825,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è possibile implementare un'applicazione che apra più di una finestra? Quali possono essere i problemi relativi alla terminazione del processo di tale applicazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "finestra"
            },
            {
              "keyword": " javaFX"
            },
            {
              "keyword": " più finestre"
            },
            {
              "keyword": " processo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5817,
          "asker": {
            "courseId": 100,
            "askerId": 771,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando per un oggetto come  ad esempio Button btn, come faccio ad accoppiare un handler ad un evento particolare come un click di mouse usando il metodo addEventHandler?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 17,
          "numEvaluators": 4,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Button"
            },
            {
              "keyword": " Handler"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6185,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 793,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Per accoppiare un handler ,per un evento E, ad un oggetto e' necessario chiamare su quest'ultimo il metodo addEventHandler il quale richiede due parametri. Essi sono:\r\n 1- il tipo di evento\r\n 2- il Listener\r\n\r\nIl tipo di evento identifica l'azione necessaria (es. il Click) che dev'essere eseguita sull'oggetto affinche' il Listener chiami il suo metodo Handle che prende come parametro l'evento E ed eseguira' il codice definito al suo interno.\r\n\r\nSi puo' avere diverse implementazioni del Listener. \r\nEsso puo' essere:\r\n\r\n-una classe esterna la quale puo' anche apportare modifiche sull'applicazione tramite meccanismi di riferimento ad essa.\r\n\r\n-self-listener: la classe stessa e' listener di se stessa ossia il listener e' implementato direttamente nel codice dell'applicazione;\r\n\r\n-listener anonimo: l'implementazione della sottoclasse di EventHandler viene istanziata al momento della chiamata del metodo \"addEventHandler\" ed una volta svolta la sua funzione verra distrutta.\r\n\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5334,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5845,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6046,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6148,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 769,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Per \"accoppiare\" un handler ad un evento particolare come il click di mouse abbiamo due possibilità.\r\nLa prima consiste nel creare una nuova classe che implementi l'interfaccia EventHandler (che da adesso chiamerò classe Listener). Il costruttore della classe Listener avrà come parametro un riferimento alla classe contenente il metodo start in modo da poter utilizzare le variabili ed i metodi in essa contenuti. Nella classe principale verrà inizializzato un oggetto della classe Listener che verrà inserito nella chiamata alla funzione addEventHandler. \r\nUn secondo metodo è quello di implementare l'interfaccia EventHandler direttamente sulla classe principale sovrascrivvendo quindi in essa il metodo handle. In questo modo non avremo bisogno di creare una nuova classe. Nella chiamata  alla funzione addEventHandler non avremmo un oggetto Listener da passare come parametro ma passeremo la stessa classe (attraverso il costrutto this).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6047,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5335,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5842,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6154,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 837,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Considerando gli elementi dati dal quesito, per accoppiare l'handler al click del mouse tramite il metodo addEventHandler è necessario specificare come primo parametro attuale del metodo il \"MouseEvent.\" e successivamente indicare l'azione tra quelle possibili come la \"ANY\" che considera qualsiasi evento della classe MouseEvent oppure la \"MOUSE_PRESSED\" o \"MOUSE_RELEASED\" per considerare rispettivamente la pressione o il rilascio del pulsante del mouse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6045,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5843,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5332,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6178,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 814,
                "courseId": 100,
                "courseFinalScore": 21
              },
              "answerText": "Per accoppiare un evento come la pressione di un tasto a un handler tramite un Bottone inanzitutto è necessario creare un oggetto bottone che chiameremo btn, successivamente bisogna applicare a btn il metodo addEventHandler il quale specificherà il tipo di evento in questione e quale ascoltatore si attiverà in risposta alla sua esecuzione(l'ascoltatore deve essere stato precedentemente dichiarato).\r\nQuindi se ad esempio scegliamo come evento la pressione del tasto del mouse una volta premuto il bottone l'ascoltatore ad esso associato si attiverà per produrre un effetto.\r\nTale effetto è definito in un altra classe ascoltatore che implementa l'interfaccia EventHandler tramite il metodo handle che verrà sovrascritto per ottenere l'effetto desiderato.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5844,
                  "rater": {
                    "raterId": 771,
                    "courseId": 100,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6044,
                  "rater": {
                    "raterId": 782,
                    "courseId": 100,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5333,
                  "rater": {
                    "raterId": 865,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5794,
          "asker": {
            "courseId": 100,
            "askerId": 912,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra le classi OListener ed EListener?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "OListener"
            },
            {
              "keyword": " EListener"
            },
            {
              "keyword": " differenza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5803,
          "asker": {
            "courseId": 100,
            "askerId": 795,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la gerarchia delle classi di java FX",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javaFX"
            },
            {
              "keyword": " gerarchia"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5849,
          "asker": {
            "courseId": 100,
            "askerId": 783,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono e come vengono relazionate le componenti in un'applicazione java FX? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "componenti"
            },
            {
              "keyword": " java FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5813,
          "asker": {
            "courseId": 100,
            "askerId": 802,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è gestita la gerarchia in Java FX delle Stage Scene Parent e Node?\t",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": " gerarchia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5818,
          "asker": {
            "courseId": 100,
            "askerId": 510,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è nua classe ? fai degli esempi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " classe "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5835,
          "asker": {
            "courseId": 100,
            "askerId": 763,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo inizialmente nello stage potevo disegnare solo un oggetto alla volta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stage"
            },
            {
              "keyword": " oggetti"
            },
            {
              "keyword": " display"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5867,
          "asker": {
            "courseId": 100,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Dare una descrizione dei seguenti termini e mostrare come sono relazionati tra loro: Stage, Scene, Parent, Node",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stage"
            },
            {
              "keyword": " scene"
            },
            {
              "keyword": " parent"
            },
            {
              "keyword": " node"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5782,
          "asker": {
            "courseId": 100,
            "askerId": 863,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Listener \"anonimo\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": "anonimo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5804,
          "asker": {
            "courseId": 100,
            "askerId": 823,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il ruolo del Listener nella gestione degli eventi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " eventi"
            },
            {
              "keyword": " listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5890,
          "asker": {
            "courseId": 100,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è definita la gerarchia stage-scene-parent-node in JavaFX? Illustarne il funzionamento facendo riferimento ad un opportuno programma generico. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javafx"
            },
            {
              "keyword": " gerarchia"
            },
            {
              "keyword": " esempio"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5863,
          "asker": {
            "courseId": 100,
            "askerId": 786,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la funzione dell' Event Handler? Che tipo di eventi può catturare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event handler"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5820,
          "asker": {
            "courseId": 100,
            "askerId": 890,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Listener a=new Listener(this); Si spieghi la funzione del this e cosa sta a significare.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " This"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5873,
          "asker": {
            "courseId": 100,
            "askerId": 894,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve e cosa e' un Listener? Quali tipi di Listener si possono avere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event handler"
            },
            {
              "keyword": " esterno"
            },
            {
              "keyword": " interno"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5879,
          "asker": {
            "courseId": 100,
            "askerId": 807,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è strutturata la gerarchia che lega le componenti chiave su cui si basa JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": "gerarchia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5795,
          "asker": {
            "courseId": 100,
            "askerId": 921,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene denominato il modello di programmazione che permette una miglior organizzazione di un programma? Descrivi anche le varie sezioni",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "porganizzazione"
            },
            {
              "keyword": " modello"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5809,
          "asker": {
            "courseId": 100,
            "askerId": 925,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità della classe Shape in JavaFX?",
          "totalDifficultyLevel": 13,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 16,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "shape"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6235,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 833,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "La classe (astratta) Shape fornisce alcune proprietà utilità per creare oggetti che rappresentano un qualche tipo di forma geometrica, che può spaziare da circonferenze, poligoni e curve semplici, ma anche del testo.\r\nOltre ai metodi ereditati da Node, di cui è sottoclasse, Shape consente di settare alcune proprietà elementari dell'oggetto geometrico quali colore interno, spessore e colore del bordo, più tante piccole proprietà che \"giocateci sopra per scoprirle\".\r\n\r\nUna osservazione opportuna è che sussiste una grossa differenza tra il disegnare oggetti geometrici e con Canvas e con Shape. Gli oggetti creati con Shape sono dotati di una serie di metodi propri, mentre gli oggetti creati con Canvas sono solamente un insieme di \"pixels colorati\", per cui se voglio aggiungere strumenti a questi oggetti, devo crearli da me.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5616,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5939,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5925,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6165,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 836,
                "courseId": 100,
                "courseFinalScore": 19
              },
              "answerText": "L' utilità della classe Shape è che fornisce all' utente una serie di forme predefinite e configurabili che rendono più o meno immediata la creazione di un' interfaccia grafica.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5617,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5923,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5938,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6170,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 842,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe Shape di JavaFX dispone di diverse forme geometriche in 2D che permetto di operare e generare oggetti di tale forme. L'utilità di questa classe è la predisposizione basilare di ogni forma geometrica da cui è possibile generare delle forme più complesse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5927,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5942,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5619,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6208,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 894,
                "courseId": 100,
                "courseFinalScore": 24
              },
              "answerText": "La classe Shape è utile per istanziare oggetti grafici (come cerchi, rettangoli, linee, polilinee....). La domanda non mi sembra particolarmente sensata, comunque la classe Shape è figlia della classe Node quindi può essere aggiunta a Pane vari. Inoltre l'utilità rispetto a una Canvas è che possono essere considerati gli oggetti di tipo Shape come singoli elementi facilitando la creazione di effetti grafici.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5924,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5941,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5620,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6246,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 787,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe Shape è una classe astratta che estende Node (che a sua volta estende Object) e fornisce le definizioni di proprietà per gli oggetti che rappresentano una generica forma geometrica. Le proprietà (es. Paint, StrokeType) possono essere relative al riempimento della forma, proprietà del tratto di contorno, degli stili e delle decorazioni del tratto e degli attributi di dashing. E? possibile definire poi delle classi concrete che implementano i metodi astratti di Shape (e quindi estendono Shape), come per esempio classi Circle oppure Rectangle.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5943,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5618,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5928,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6240,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 874,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La classe astratta Shape provvede alle definizioni delle proprietà comuni per gli oggetti che rappresentano forme geometriche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5621,
                  "rater": {
                    "raterId": 925,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5940,
                  "rater": {
                    "raterId": 822,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5926,
                  "rater": {
                    "raterId": 880,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 5783,
          "asker": {
            "courseId": 100,
            "askerId": 560,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega dettagliatamente le classi e sottoclassi contenute nella \"Parent hierarchy\", soffermandoti sul ciclo \"chiuso\" di PARENT e NODE.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " fx"
            },
            {
              "keyword": " parent"
            },
            {
              "keyword": " hierarchy"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5881,
          "asker": {
            "courseId": 100,
            "askerId": 847,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "qual'è la funzione del metodo .getChildren() ?",
          "totalDifficultyLevel": 19,
          "totalInterestingnessLevel": 19,
          "totalRelevanceLevel": 19,
          "numEvaluators": 6,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "javafx"
            },
            {
              "keyword": "eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6190,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 750,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "getChildren() è un metodo della classe astratta Parent, e ritorna la lista dei figli della classe Parent in cui viene chiamata. La funzione principale del metodo è quella di aggiungere altri figli (nodi) a questa lista (anche se al inizio sara vuota).Esempio : se creo un nodo di tipo Button(sottoclasse concreta della classe astratta Node) :  \r\nButton but = new Button();  e creo un parent di tipo Group (sottoclasse concreta della classe Parent): Group g = new Group(); per aggiungere (creare la relazione tra Node e Parent) a \"g\" il \"but\" :   g.getChildren().add(but); possiamo aggiungere anche più nodi scegliendo .addAll(Nodes ...).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5285,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5597,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6080,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6201,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6230,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 784,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo .getChildren serve a ottenere la lista dei figli di un nodo.\r\nAll'interno di una scena, i nodi sono organizati gerarchicamente in genitori e figli. Ad esempio, in una vbox (genitore) è possibile aggiungere tre bottoni, che saranno i suoi figli: in questo modo abbiamo creato una relazione di parentela e tramite il metodo .getChildren() potremo accedere ai bottoni, come figli della vbox.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5600,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 6198,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5282,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6077,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6211,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 880,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo .getChildren() ritorna il primo nodo figlio del nodo indicato spostandosi verticalmente lungo la linea gerarchica dove quest'ultimo si trova. Volendo non solo il primo nodo figlio, ma anche i successivi, si puo' impiegare un ciclo while con getNext.\r\nIn caso il nodo su cui viene chiamato il metodo non dovesse avere nodi figli .getChildren() ritornerà null.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5595,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5280,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6075,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6196,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6220,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 755,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Questo metodo ritorna un oggetto di tipo List che rappresenta una lista di tutti gli elementi che sono annidati all'interno dell'oggetto su cui viene chiamato il metodo .getChildren(). In caso non ci siano elementi, verrà ritornata una lista vuota. Ovviamente, la lista non contiene una copia degli elementi annidati nel blocco \"padre\", infatti, se noi andiamo a modificare un elemento della lista, le modifiche effettuate andranno a cambiare il contenuto effettivo dell'oggetto. Inoltre, questo metodo identifica solo gli elementi che sono ad un solo \"livello di profondità\" rispetto al blocco padre. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6076,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5281,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 6197,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5596,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6168,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 925,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "In Java FX il metodo getChildren() restituisce una lista dei nodi figlio che contiene un nodo padre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5284,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 6200,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6079,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5599,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6232,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 902,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo getChildren() restituisce una List contenente tutti i figli della classe Parent, ossia tutti i suoi nodi figli. La List che viene restituita è del tipo ObservableList.\r\n ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5598,
                  "rater": {
                    "raterId": 832,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6078,
                  "rater": {
                    "raterId": 847,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6199,
                  "rater": {
                    "raterId": 831,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5283,
                  "rater": {
                    "raterId": 864,
                    "courseId": 100,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5886,
          "asker": {
            "courseId": 100,
            "askerId": 922,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le particolarità del comando \"Launch\" che troviamo spesso nel Main in un codice JavaFx?",
          "totalDifficultyLevel": 17,
          "totalInterestingnessLevel": 16,
          "totalRelevanceLevel": 12,
          "numEvaluators": 5,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Javafx"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " Launch"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6147,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 826,
                "courseId": 100,
                "courseFinalScore": 29
              },
              "answerText": "serve alla JVM per eseguire la funzione start che viene implementata nella classe che estende application.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5741,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5790,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5936,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5686,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 5480,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6184,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "Launch è un comando stand-alone, che serve per richiamare la funzione a cui è abbinato. Infatti :\r\n\r\npublic class Evento extends Application{.....}\r\n\r\nindica l'esistenza di una class Application che in questo caso è stata estesa e con\r\n\r\npublic static void main(String[] args){\r\nApplication.launch(args); }\r\n\r\nrichiama la class Application.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5481,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5742,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5687,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5937,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5791,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6197,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 100,
                "courseFinalScore": 23
              },
              "answerText": "Launch lancia un'applicazione standalone e può essere chiamato al più una volta nel main, altrimenti ritorna un errore. Il metodo launch non ritorna nulla finché l'applicazione non è terminata; inoltre la classe che chiama il metodo launch deve essere una sottoclasse di Application, altrimenti anche in questo caso abbiamo un errore. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5479,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5738,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5683,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5787,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5933,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6237,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 835,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "launch è un metodo tipicamente chiamato nel Main che lancia un'applicazione standalone. E' usata tipicamente per lanciare l'applicazione creata nelle righe di codice sopra scritte. Non può essere chiamata più di una volta altrimenti ritorna un'eccezione. Il comando launch non da un return finchè l'applicazione non viene chiusa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5934,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5788,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5739,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5684,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 5478,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6158,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 840,
                "courseId": 100,
                "courseFinalScore": 22
              },
              "answerText": "Il metodo Launch() è spesso chiamato dal main della nostra applicazione e serve per lanciare la nostra applicazione a RunTime",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5789,
                  "rater": {
                    "raterId": 748,
                    "courseId": 100,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5482,
                  "rater": {
                    "raterId": 861,
                    "courseId": 100,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5740,
                  "rater": {
                    "raterId": 753,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5685,
                  "rater": {
                    "raterId": 759,
                    "courseId": 100,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5935,
                  "rater": {
                    "raterId": 922,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 5828,
          "asker": {
            "courseId": 100,
            "askerId": 761,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Si descriva lo schema minimo utilizzato per un'applicazione grafica in java",
          "totalDifficultyLevel": 12,
          "totalInterestingnessLevel": 14,
          "totalRelevanceLevel": 14,
          "numEvaluators": 3,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "grafica"
            },
            {
              "keyword": " schema"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6216,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 752,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "L'applicazione minima in JavaFX deve avere una \"Stage\" (= finestra)  che contiene una \"Scene\" (= contenitore). La Scene ha un Parent (= contenuto) e il contenuto è un Node.\r\nAl fine di mostrare effettivamente la grafica ed eventualmente arricchirla ci sono altre istruzioni di libreria che sono preposte per questo compito (.show(), .setScene(), .setTitle()...).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5297,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5719,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 5551,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5958,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6192,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 838,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "import .. //qui importo le varie classi\r\n//creo la mia classe che estende la classe astratta Application\r\npublic class MinimalApp extends Application { \r\n\r\n//implemento il metodo start, dal quale parte l'applicazione. Contiene il primaryStage, cioè la finestra //principale\r\n     public void start(Stage primaryStage) {\r\n\r\n//istanzio gli oggetti di cui ho bisogno, qui un cerchio. Questi nodi non possono avere nodi \"figli\"\r\nNode circ= new Circle(40, 40, 30);\r\n\r\n//istanzio il parent, cioè il nodo da cui gli oggetti istanziati (che sono altri nodi) discendono.\r\nParent root= new Group(circ);\r\n\r\n//istanzio la scene, cioè il contenitore dei nodi (parent e nodi , in cui gli oggetti vivono)\r\nScene scene= new Scene(root, 400, 300);\r\n\r\n//inserisco la scene nella finestra, lo Stage\r\nprimaryStage.setScene(scene);\r\n\r\n//mostro la finestra\r\nprimaryStage.show();}\r\n\r\npublic static void main(String[] args){\r\n\r\n//dal main tramite un metodo statico eseguo la mia application\r\nApplication.launch(args);\r\n}}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5960,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5295,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5720,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5552,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6188,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 896,
                "courseId": 100,
                "courseFinalScore": 0
              },
              "answerText": "La libreria JavaFX è pronta per creare applicazioni grafiche. Alla base è la classe Stage(palco), che rappresenta una o più finestre. Stage has a Scene, cioè contiene la classe scena, che rappresenta il contenuto della finestra. Scene ha un Parent, che ha uno o più Node di cui è anche sottoclasse. Parent e Node sono classi astratte, dove il Parent è il nodo principale di un albero o sottoalbero le cui foglie sono dei Node. Esempi di Parent sono le sottoclassi Control,Group,Region,Webview, ciascuna a sua volta superclasse di oggetti come forme geometriche, bottoni ecc.\r\nEcco un programma minimo: 1)Inizializziamo un' Application nel main, in essa uno Stage stage. 2)In stage istanziamo un bottone - Button btn, e gli assegnamo un testo e un EventHandler, una classe che permette azioni come stampare un messaggio nel terminale. 3)Istanziamo uno StackPane root, che è la superclasse di Button, e gli passiamo il figlio btn. 4)Istanziamo la Scene scene, gli diamo root. 5)Rendiamo visibile stage.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5718,
                  "rater": {
                    "raterId": 860,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 5959,
                  "rater": {
                    "raterId": 763,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5296,
                  "rater": {
                    "raterId": 761,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5550,
                  "rater": {
                    "raterId": 793,
                    "courseId": 100,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 5874,
          "asker": {
            "courseId": 100,
            "askerId": 884,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa è un \"action listener\"? A che cosa serve l'interfaccia EventHandler in JavaFX? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5872,
          "asker": {
            "courseId": 100,
            "askerId": 886,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile scrivere in un unico codice quello utilizzato per la parte grafica e quello dell'applicazione stessa, e semmai come?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Grafica"
            },
            {
              "keyword": " Applicazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5839,
          "asker": {
            "courseId": 100,
            "askerId": 896,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Si spieghi la relazione model-view-controller.",
          "totalDifficultyLevel": 4,
          "totalInterestingnessLevel": 7,
          "totalRelevanceLevel": 6,
          "numEvaluators": 2,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "model"
            },
            {
              "keyword": "view"
            },
            {
              "keyword": "controller"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6156,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 788,
                "courseId": 100,
                "courseFinalScore": 28
              },
              "answerText": "Model-view-controller è un design pattern(uno schema di risoluzione ben noto) utilizzato nelle applicazione con un'intefaccia utente (GUI). Ci sono tre entità (appunto model, view e controller) che dividono i vari compiti: model è la raccolta dei dati necessari (variabili, costanti, metodi che agiscono sui dati ecc), view contiene tutto quello che riguarda l'intefaccia grafica e i suoi oggetti da visualizzare, mentre controller contiene tutti gli oggetti che manipolano l'aspetto, la posizione e le caratteristiche degli oggetti grafici.\r\nUn requisito fondamentale è la visibilità dei componenti a cui devono accedere le tre diverse entità; altrimenti non è possibile effettuare questa suddivisione dei compiti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 5819,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5838,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6194,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5647,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6003,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5669,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6224,
              "task": {
                "taskId": 169,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 747,
                "courseId": 100,
                "courseFinalScore": 20
              },
              "answerText": "Il Model-View-Controller è uno schema(pattern) architetturale che ha il compito di organizzare e suddividere il codice/software in tre blocchi principali, tra cui:\r\n- Model: fornisce le funzioni(metodi) per accedere ai dati utili all'applicazione.\r\n- View: permette di visualizzare i dati contenuti nel Model, e si occupa anche dell'interazione con l'utente.\r\n- Controller: riceve in input i comandi dell'utente, li elabora e modifica lo stato delle altre due componenti.\r\nCi deve essere una interconnessione tra queste componenti. Ognuna di esse deve avere un Handle(legame) con le altre componenti.\r\nSi tratta quindi di un ciclo continuo all'interno del quale l'utente immette il proprio comando attraverso il Controller, il quale modifica(manipola) i dati presenti all'interno del Model, che a sua volta chiama View per aggiornare il risultato del comando.\r\nUTENTE -> utilizza -> CONTROLLER -> modifica -> MODEL -> aggiorna -> VIEW -> ritorna all'UTENTE e così via.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 6004,
                  "rater": {
                    "raterId": 899,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 6195,
                  "rater": {
                    "raterId": 886,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5646,
                  "rater": {
                    "raterId": 896,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5668,
                  "rater": {
                    "raterId": 786,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 5818,
                  "rater": {
                    "raterId": 594,
                    "courseId": 100,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 5837,
                  "rater": {
                    "raterId": 746,
                    "courseId": 100,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 169,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 5885,
          "asker": {
            "courseId": 100,
            "askerId": 883,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella seconda slide di \" java fx - events\" cosa significa la frase \"un parent è un node\"? Spiega perché questa uguaglianza è vera.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Parent"
            },
            {
              "keyword": " node"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 5784,
          "asker": {
            "courseId": 100,
            "askerId": 766,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 168,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la classe Listener? E quale è la differenza di avere un Listener esterno o un Listener interno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Auto documentante "
            },
            {
              "keyword": " comodo"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    }
  ]
}
