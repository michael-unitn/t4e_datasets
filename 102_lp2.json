{
  "courseId": 102,
  "version": 2,
  "courseName": "Linguaggi Programmazione 2",
  "lectures": [
    {
      "lectureId": 72,
      "lectureTitle": "Animation & Copy Contructor",
      "questions": [
        {
          "questionId": 6872,
          "asker": {
            "courseId": 102,
            "askerId": 1018,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che è possibile ottenere usando il Copy Constructor piuttosto che l'interfaccia Cloneable?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6893,
          "asker": {
            "courseId": 102,
            "askerId": 980,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli aspetti del metodo obj.clone di Java che possono dare problemi quando si crea un clone, e come si possono risolvere gli inconvenienti che ne derivano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": "clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7340,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1099,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo obj.clone inizializza ogni campo nell'oggetto creato come clone assegnandogli i valori presenti nei campi corrispondenti dell'oggetto clonato. É quindi necessario scrivere del codice specifico in modo da gestire tutti i campi per i quali copiare i valori risulti scorretto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11153,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11274,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11375,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11122,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7378,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 963,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Attraverso un'implementazione del metodo clone() con shallow copy, verrà copiato l'intero oggetto con le relative collezioni o istanze a oggett in esso. Per ottenere una deep copy è necessario modificare e implementare una copia per 'valore', ristanziando o chiamando (se disponibile) il metodo clone() di quegli oggetti che altrimenti sarebbero condivisi con l?istanza appena clonata. In caso di mancata implementazione infatti può avvenire che un oggetto e il suo clone risultino uguali ma che quando vengono apportate modifiche a collezioni, array o istanze di altre classi vengano modificate per entrambe anziché per solo quella voluta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11124,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11374,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11276,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11152,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7330,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1073,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I problemi possono sorgere dal fatto che è un metodo definito protected quindi può essere usato solo nello stesso package o nelle sottoclassi. Per risolvere questi problemi bisogna fare l'overloading del metodo dichiarandolo public o anche protected",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11151,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11275,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11121,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11376,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7417,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 940,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo clone() implementato da Object, si limita a generare un \"shallow copy\" del nostro oggetto, ovvero una copia bit a bit, o superficiale. Questo è sufficiente nel caso in cui i campi del nostro oggetto siano tutti dei tipi primitivi. Al contrario, se l'oggetto di cui si vuole eseguire una copia contiene a sua volta uno o più campi di tipo oggetto, ossia non primitvo, allora sarà necessario modificare il risultato di Object.clone(), andando a copiare manualmente i suddetti campi, per realizzare una \"deep copy\".\r\nSe non ci occupassimo di implementare una copia 'manuale' di tali campi, nella copia dell'oggetto essi risulterebbero come referenze per gli stessi oggetti appartenenti alla classe che intendiamo clonare, ovvero: l'oggetto di origine e la sua copia condividerebbero alcuni campi, che possiamo considerare riferimenti di una stessa locazione di memoria (sinonimi, dunque). In tal caso non potremmo considerare l'oggetto da clonare e la sua copia come entità indipendenti!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11123,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11154,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11373,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11277,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6914,
          "asker": {
            "courseId": 102,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando viene usato Timeline e quando Transition? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7359,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Transition e Timeline sono entrambi sottoclassi di Animation e servono entrambe a creare animazioni. La differenza sostanziale sta nel fatto che Timeline fornisce la possibilità di aggiornare i valori delle proprietà dell'animazione nel tempo.\r\nQuindi utilizzo Timeline, a dispetto di Transition, se la mia animazione non è composta da una serie di immagini mostrate a brevissimi intervalli di tempo l'una dall'altra, ma da un'unica figura che modifica le sue proprietà nel corso del tempo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11317,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11418,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11042,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11434,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11200,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11193,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7423,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 997,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si usano entrambe per le animazioni. La prima permette di poter interrompere, riprendere, ricominciare, rovesciare o ripetere il moviemento quando viene richiesto menre la seconda no.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11043,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11435,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11195,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11316,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11199,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11417,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7388,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1013,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Transition fornisce le funzionalità base definite in Animation.\r\nÈ infatti possibile impostare la durata dell'animazione tramite il metodo \"setCycleDuration(Duration value)\" , ed è possibile implementare il metodo  \"interpolate(double frac)\" , che viene chiamato durante l'esecuzione dell'animazione, dove deve essere specificato il codice per l'animazione desiderata.\r\nTimeline permette in aggiunta di suddividere l'animazione in più intervalli temporali, con la possibiltà di specificare l'animazione da eseguire in ogni singolo intervallo tramite appositi oggetti KeyFrame.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11194,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11416,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11041,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11433,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11201,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11315,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6917,
          "asker": {
            "courseId": 102,
            "askerId": 1079,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra copia superficiale(shallow copy) e copia in profondità di un oggetto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6919,
          "asker": {
            "courseId": 102,
            "askerId": 1068,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene utilizzata la timeline in JavaFX? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX animation "
            },
            {
              "keyword": "  JavaFX animation "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6891,
          "asker": {
            "courseId": 102,
            "askerId": 1080,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Transition e timeline",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Translation"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6853,
          "asker": {
            "courseId": 102,
            "askerId": 1025,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze fra shallow copy e deep copy?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7342,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1017,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sia A un oggetto.\r\nNella Shallow copy un nuovo oggetto B viene creato e i valori di A sono copiati in B. Se tali valori si riferiscono ad un oggetto allora saranno copiati i riferimenti condividendoli, quindi se avviene una modifica in A avviene anche in B.\r\n\r\nNella deep copy invece i campi sono dereferenziati, pertanto modificando in uno non avvengono modifiche nell'altro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11073,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11250,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11358,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10954,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11037,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10940,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7341,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1098,
                "courseId": 102,
                "courseFinalScore": 14
              },
              "answerText": "La shallow copy viene effettuata con il metodo clone di object e effettua una copia bit a abit dell'oggetto, ovvero crea un alias di un oggetto, quindi modificandone uno viene modificato anche l'altro. Per creare invece una vera e propria copia indipendente dall'oggetto copiato, cioè una deep copy, bisogna implementare il metodo clone.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11076,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11033,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11254,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10937,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10955,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11357,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7362,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 979,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una shallow copy consiste nella duplicazione del minimo necessario a rappresentare un'entità. Tra due collezioni, ad esempio, una shallow copy genererà la copia del puntatore ai valori della collezione originale.\r\nUna deep copy, invece, consiste nella duplicazione di tutto il contenuto di un'entità. Tra due collezioni, una deep copy generà una nuova entità i quali elementi sono copie degli elementi della collezione originale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10939,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11075,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10957,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11252,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11036,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11359,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7366,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 996,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Shallow copy duplica il meno possibile di un oggetto. Una copia superficiale di una collezione infatti è una copia della struttura ma non degli elementi. Tramite shallow copy due collezioni quindi condividono i singoli elementi.\r\n\r\nDeep copy invece duplica tutto. Una deep copy di un oggetto è un altro oggetto identico al primo con tutti gli elementi dell'originale duplicati (ad es. puntatori a due indirizzi diversi contenenti instanze differenti ma di uguali valori).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11035,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11074,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10956,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11360,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11251,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10938,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7393,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La Deep Copy consiste nel duplicare l'oggetto, con questo metodo modificando una delle due variabili non ci modifica anche l'altra.\r\nLa Shallow Copy (Copia per indirizzo) viene creato un'altro oggetto che punta allo stesso blocco di memoria della variabile iniziale, con questo metodo se si modifica una variabile viene modificata anche l;altra.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11034,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11072,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10958,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10941,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11253,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11356,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6911,
          "asker": {
            "courseId": 102,
            "askerId": 955,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si crea un'animazione di sparizione e poi riapparizione di un oggetto ad esempio cliccandoci sopra? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX animation"
            },
            {
              "keyword": " JavaFX animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6867,
          "asker": {
            "courseId": 102,
            "askerId": 1013,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è possibile creare una finestra di pop-up in un'applicazione JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6938,
          "asker": {
            "courseId": 102,
            "askerId": 1044,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi può essere necessaria la clonazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6848,
          "asker": {
            "courseId": 102,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "La classe animation di cosa differisce da una classe layout?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFxAnimation"
            },
            {
              "keyword": " JavaFxAnimation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6954,
          "asker": {
            "courseId": 102,
            "askerId": 1029,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una animazione in Java? In quali modi si può rappresentare",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6855,
          "asker": {
            "courseId": 102,
            "askerId": 992,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la Clone e che problemi può dare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLONE"
            },
            {
              "keyword": "CLONE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6890,
          "asker": {
            "courseId": 102,
            "askerId": 1034,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il comportamento di default quando non implementiamo il metodo clone in una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "copy constructor"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7360,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 983,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Se non si implementa il metodo clone tale metodo non può essere chiamato nel main in quanto metodo protetto della classe oggetto.\r\nSe invece si implementa, implementando l'interfaccia cloneable e creando un metodo clone che richiama il metodo clone di object, si otterrà una copia bit a bit, quindi se l'oggetto da clonare conteneva riferimenti ad altri oggetti anche il clone avrà gli stessi riferimenti e quindi non sarà un vero oggetto a se stante.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11231,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10905,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11331,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11003,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11039,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11138,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11343,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7357,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 949,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Il metodo clone arriva già definito dalla classe Object ma è segnato come protected, va quindi obbligatoriamente esteso per poter essere usato da classi che non siano estensione della classe stessa. Di default effettua una copia bit a bit di tutte le variabili di tipo primitivo, come int e double (Shallow Copy), mentre mantiene i riferimenti per gli oggetti mappati in memoria (come array e oggetti complessi).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10903,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11038,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11137,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11002,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11233,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11344,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11332,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7343,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 975,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "Di default clone fa una copia bit a bit dell'oggetto. Generalmente si tratta di una shallow copy.\r\nIl metodo clone di default si trova nella classe Object.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11136,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11330,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11040,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11345,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11232,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10904,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11004,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6861,
          "asker": {
            "courseId": 102,
            "askerId": 1017,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra l'utilizzo di Copy constructor e clone ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7404,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 944,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il Copy constructor, costrutto caratteristico del C++, dev'essere implementato da zero dal programmatore ed è invocato implicitamente durante un passaggio di parametri per valore, in modo tale da generare una copia dell'oggetto passato come parametro ad un metodo. Il metodo clone, invece, fornito dalla classe Object di Java, dev'essere sovrascritto estendendone la visibilità a public (in quanto protected) e non è utilizzato per passaggio di parametri, ma per generare copie di oggetti necessarie al programmatore (N.B. la classe data deve implementare l'interfaccia Clonable).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10972,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10975,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10920,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11049,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7347,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1040,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "In Java non esiste il copy constructor quindi siamo obbligati a riscrivere il metodo clone(). La differenza è che clone fa una copia bit a bit mentre copy constructor istanzia un nuovo oggetto e poi gli setta tutte le variabili come erano quelle dell'oggetto da copiare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10919,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11050,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10971,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10976,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7401,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Il Copy constructor è un costruttore di una classe che prende come parametro un'istanza della classe stessa, e istanzia un oggetto che ne è la copia.\r\nInvece clone() è un metodo. Il metodo clone() non ha un comportamento garantito, dipende cioè dalla classe dell'oggetto. In generale è desiderabile, ma non garantito, che  \r\n\"x.clone().equals(x)\" \r\nvenga valutato a true.\r\nPer definire il metodo clone() è inoltre necessario implementare l'interfaccia Cloneable. Se non viene implementato il metodo clone(), il comportamento di default è quello di fare una copia bit a bit dell'oggetto, quindi solitamente non viene fatta una Deep Copy, ma piuttosto una Shallow Copy.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11051,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10922,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10977,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10973,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7422,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1065,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Non è possibile chiamare il metodo clone direttamente su alcuno oggetto. Per utilizzarlo dobbiamo fare un override pubblico e provvedere ad una implementazione nella classe in ordine che che essa possa accedervi. In generale l'implementazione di clone è molto più articolata rispetto ad una copy; quindi è meglio utilizzare una copy constructor assicurandoci che gli oggetti non abbiano una gerarchia di ereditarietà.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10921,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10970,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11052,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10974,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6903,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste il Copy constructor in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6953,
          "asker": {
            "courseId": 102,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando utilizzo TimeLine a cosa serve esattamente la KeyFrame e perchè devo utilizzarla?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": " JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7428,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "KeyFrame serve per indicare come avviene un'animazione. Devo utilizzarla per determinare i valori che TimeLine deve interpolare per definire la posizione e la direzione in cui avviene l'animazione ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11166,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11281,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11349,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10902,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10930,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7427,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1081,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'utilizzo delle KeyFrame risulta essenziale durante l'utilizzo di TimeLine, in quanto sono le stesse KeyFrame a definire queste ultime, per poi essere processate individualmente nell'ordine specificato dal programmatore. Le Keyframe sono inoltre essenziali in quanto contengono determinate proprietà delle animazioni specificate durante la scrittura del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10931,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11350,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11164,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11279,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10901,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7391,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1018,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Quando realizzo un'animazione, essa avrà un momento di inizio e una durata: questo lasso temporale sarà rappresentato dalla TimeLine.\r\n\r\nDato che sarebbe impossibile rappresentare ogni minimo spostamento di un oggetto (figure, immagini, bottoni, label etc..) durante tutta la durata dell'animazione, per permetterne l'implementazione sono stati introdotti i KeyFrame.\r\n\r\nE' possibile pensare ai KeyFrame come fossero delle fotografie del nostro oggetto animato, scattate a intervalli regolari dall'inizio dell'animazione: tramite queste singole fotografie, java riesce a interpolare i movimenti che l'oggetto deve compiere per spostarsi dalla posizione assunta in un determinato KeyFrame alla posizione assunta nel KeyFrame immediatamente successivo (ad es: in una traslazione,gli unici KeyFrame possono essere la posizione iniziale e finale).\r\n\r\nL'interpolazione è definita dal programmatore tramite regole che assegnano la posizione successiva dell'oggetto a partire da quella attuale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11165,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10900,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11351,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11278,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10932,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7358,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 984,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Serve per stabilire quando iniziano e finiscono le varie animazioni, devi utilizzarle perchè se no non puoi stabilire l'ordine di succesione/ sovrapposizione delle animazioni",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10899,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11167,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11348,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10929,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11280,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6883,
          "asker": {
            "courseId": 102,
            "askerId": 963,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra la Shallow copy e la Deep copy? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": "clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7395,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Nel primo caso, Shallow copy, \"allego\" B allo stesso indirizzo di A (copia per indirizzo) e di conseguenza alla modifica di uno viene modificato anche l'altro.\r\nDeep copy, o copia in profondità, consiste invece in una reale copia dei valori di A in B. Così facendo si ottiene l'indipendenza tra essi a costo di un maggiore \"costo\" in termini di velocità  di esecuzione rispetto a shallow copy.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11264,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11135,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11179,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11227,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11244,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11294,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7369,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1023,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "la Shallow copy è la copia già implementata da java e fa una copia bit a bit degli oggetti , la Deep copy la definiamo noi e facciamo si che quando un oggetto venga copiato rispetti dei parametri da noi definiti, la Deep copy è utile tutte quelle volte che ho delle new all'interno degli oggetti che altrimenti con la Shallow copy diventerebbero sinonimi e non copie vere e proprie",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11290,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11239,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11182,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11131,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11228,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11267,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7386,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1054,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La \"Shallow copy\" crea una nuova istanza della stessa classe e copia tutti gli attributi nella nuova istanza. Mentre il \"Deep copy\" consiste nella copia dell'oggetto e dei suoi eventuali riferimenti ad altri oggetti copiati anch'essi (esempio: serializzazione di un oggetto).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11265,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11178,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11242,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11226,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11292,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11133,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7402,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 987,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con shallow copy faccio la copia esatta di tutti i valori dell'oggetto, mentre con la deep copy faccio la copia della allocazione dinamica della memoria che ha fatto l'oggetto",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11183,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11241,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11230,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11130,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11291,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11268,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7424,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1074,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando un oggetto A copia un oggetto B tramite shallow copy, ne prende l'indirizzo facendo si che punti alla stessa cella di memoria. Con questo metodo se viene modificato uno dei due oggetti anche l'altro subirà le stesse modifiche, il vantaggio è la velocità di esecuzione dell'oggetto. La Deep Copy, invece, consiste in una reale copia dell'oggetto. Il vantaggio è che A e B non dipendono fra di loro ma c'è un alto costo in termini di velocità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11225,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11240,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11269,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11293,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11181,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11134,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7421,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 960,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Si può parlare di questa differenza fra modalità di copia fra due oggetti solo in alcuni linguaggi come C++. Il problema nasce allorquando si vogliano utilizzare oggetti allocati staticamente nello stack e non nello heap quindi non si utilizzano puntatori a tali oggetti.\r\nNel caso in cui si passi un oggetto come parametro il linguaggio attua una Shallow copy ovvero una copia bit a bit; l'oggetto creato condivide però una parte della memoria con l'oggetto passato quindi quando la copia esce dallo scope viene deallocata insieme all'oggetto originale, non rendendolo più disponibile. Per ovviare a questo tipo di problema si introduce il concetto di Deep copy: viene creato un oggetto separato da quello passato per parametro ma uguale, in modo tale che se dovesse essere cancellato non inficerebbe nient'altro. Per implementare ciò bisogna definire un nuovo costruttore Line( const Line &obj);  // copy constructor  e implementarlo facendo la copia di ogni singola variabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11180,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11132,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11266,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11229,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11243,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11289,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6847,
          "asker": {
            "courseId": 102,
            "askerId": 1019,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos' è un copy costructor e perché è così importante nella programmazione ad oggetti? (Dare dei riferimenti sia per Java sia per C++)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6894,
          "asker": {
            "courseId": 102,
            "askerId": 1015,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si, spiegare come è possibile iniziare su uno stesso oggetto due animazioni diverse, di cui la seconda inizi a metà della durata della prima, entrambe terminanti contemporaneamente.\r\n\r\n(es: translazione con riduzione dell'opacità da metà percorso, e consenguente completa sparizione al termine)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6845,
          "asker": {
            "courseId": 102,
            "askerId": 942,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il ruolo del tipo Timeline nelle animazioni javafx? Fare un esempio di utilizzo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": " JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6849,
          "asker": {
            "courseId": 102,
            "askerId": 997,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Il metodo clone di Object restituisce una copia dell'oggetto passato. Il significato della \"copia\" è univoco?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLONE"
            },
            {
              "keyword": " CLONE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6915,
          "asker": {
            "courseId": 102,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo clone?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "copy constructor"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6944,
          "asker": {
            "courseId": 102,
            "askerId": 995,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'implementazione di una classe è una buona regola quella di definire (o almeno dichiarare) il \"copy constructor\". Perchè è utile e perchè viene creata una copia dell'istanza? Non possiamo considerarla solo uno spreco di spazio?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": "Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6899,
          "asker": {
            "courseId": 102,
            "askerId": 961,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è stato implementato il \"Copy Constructor\" anche in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy Constructor"
            },
            {
              "keyword": "Java"
            },
            {
              "keyword": "Motivo"
            },
            {
              "keyword": "Implementazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6955,
          "asker": {
            "courseId": 102,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "All'interno di una animation, a cosa serve una Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "animation"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6878,
          "asker": {
            "courseId": 102,
            "askerId": 944,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i passi necessari per poter utilizzare il metodo clone fornito da Object su di una data classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": "clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6898,
          "asker": {
            "courseId": 102,
            "askerId": 964,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale modo si può implementare un eventHandler su un oggetto che estende un elemento di JavaFx e poi catturare tale evento nella classe principale? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "subclassing JavaFX components"
            },
            {
              "keyword": " subclassing JavaFX components"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6850,
          "asker": {
            "courseId": 102,
            "askerId": 996,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si spostano gli oggetti all'interno della finestra?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6858,
          "asker": {
            "courseId": 102,
            "askerId": 1085,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "in che modo si crea un'animazione gestita da dei pulsanti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java FX"
            },
            {
              "keyword": " animazioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6959,
          "asker": {
            "courseId": 102,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come abbiamo visto fin'ora, quando utilizziamo un Pane, l'oggetto inserito viene posizionato in automatico in base alla logica del Pane utilizzato. Se questa posizione non ci andasse bene, in che modo possiamo modificare la sua posizione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFx Layout positioning"
            },
            {
              "keyword": " translate"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7356,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1031,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Possiamo modificare la posizione del Node in maniera relativa alla posizione definita dalla logica del pane attraverso l'uso dei metodi .setTranslateX e .setTranslateY",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11272,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11026,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11096,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11190,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7344,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1046,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Usando i metodi setLayoutX e setLayoutY, che regolano rispettivamente la distanza da sinistra e la distanza dall'alto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11027,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11093,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11189,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11270,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7338,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1002,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Utilizzando le funzioni setX() e setY(), che specificano la posizione assoluta rispetto agli assi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11192,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11095,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11273,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11028,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7379,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 985,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per decidere la posizione si usa principalmente .alignment e .margin. Inoltre Borderpane divide l'area in 5 parti (top, bottom, left, center, right) e invece di usare getChildren si può usare borderpane.setCenter (o left, right, ...) per aggiungere l'elemento nell'area desiderata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11025,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11094,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11271,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11191,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6960,
          "asker": {
            "courseId": 102,
            "askerId": 1086,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve una transition? In quanti modi si può implementare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "transition"
            },
            {
              "keyword": "animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6909,
          "asker": {
            "courseId": 102,
            "askerId": 1033,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali tipologie di transition utilizzeresti per far translare un cerchio mentre si dissolve? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX AnimationJavaFX Animation"
            },
            {
              "keyword": "Transitions"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6881,
          "asker": {
            "courseId": 102,
            "askerId": 1065,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi le due principali sottoclassi di Animation viste a lezione",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java FX Animation"
            },
            {
              "keyword": " subclasses"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7383,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1033,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Le due principali sottoclassi di Animation viste a lezione sono la classe Transition e la classe Timeline.\r\n\r\n       La classe Transition (esempio \"The horse in motion\" di Muybridge) offre un semplice framework per definire l'animazione e implementa le funzionalità base della classe Animation (N.B. Animation è una classe abstract); per definire una transition bisogna necessariamente implementare il metodo interpolate(double) e impostare la durata del ciclo con cui vogliamo venga calcolata.\r\n\r\n       La classe Timeline, sebbene più difficile da utilizzare rispetto alla classe Transition, è anche molto più potente; il programmatore ha la possibilità di creare animazioni su qualsiasi proprietà di JavaFX(tutti gli oggetti rappresentabili, le loro proprietà...), definendo una serie di frame (detti KeyFrame) e decidendo la logica di interpolazione per ogni frame; la Timeline non è altro che l'interpolazione dei KeyFrame sequendo le modalità (di interpolazione) specificate dal programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11395,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11370,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11082,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11105,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11299,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7364,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1003,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Le due principali sottoclassi di Animation viste sono Transition e Timeline.\r\nLa prima offre un framework che alla creazione di ogni frame chiama il metodo interpolate(double time) dove time è un numero reale (compreso tra 0 e 1) che indica lo stato dell'animazione (0 = inizio, 1 = fine), in base a questo numero specifichiamo cosa deve essere mostrato a schermo.\r\nUna Timeline invece è un oggetto più complesso, a cui dobbiamo aggiungere vari KeyFrame, questi possiamo vederli come uno \"stato\" ovvero un insieme di \"target value\" cioè dei valori di proprietà (dimensione di figure, colore eccetera) che devono essere raggiunti ad un determinato tempo. Eseguendo il metodo play() per ogni istante di tempo verranno calcolati (interpolati) i valori delle proprietà in maniera automatica in base alla distanza (tempo) tra i KeyFrame e i target value di ogni KeyFrame. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11372,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11301,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11107,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11083,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11397,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7398,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1079,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le principali sottoclassi di Animation sono Transition e Timeline. La prima ha la funzionalità di eseguire il metodo interpolate() ad ogni frame, la durata del quale è stabilito dalla setCycleDuration(javafx.util.Duration). La Timeline permette di creare animazioni più complesse; il suo funzionamento consiste nel processare in modo sequenziale singoli keyframes, ciascuno dei quali è associato ad un istante preciso e anche in questo caso definito dal programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11300,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11106,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11084,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11371,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11396,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6880,
          "asker": {
            "courseId": 102,
            "askerId": 1028,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa permettono di fare la classe Transition e Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6927,
          "asker": {
            "courseId": 102,
            "askerId": 1007,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo non sempre è sufficiente invocare super.clone(); per fare la copia di un oggetto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": "clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7408,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 999,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè nella classe deve essere implementata la \"Cloneable\" e il downcast. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11333,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11118,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10928,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11143,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10913,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7412,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 980,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza sta nel tipo di copia: richiamando semplicemente il metodo clone di object si crea una shallow copy, ossia una copia bit a bit dell'oggetto su cui viene invocato clone; altrimenti se si fa l'override del metodo clone sovrascrivendo le reference del costruttore originale si può ottenere una deep copy, che fa sì che i cambiamenti su una delle due copie non si rifletta anche sull'altra, separando così i due oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10915,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11142,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10926,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11337,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11115,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7415,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1066,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "perché la sottoclasse avrà sicuramente dati che non la superclasse non ha e che quindi non verrebbero copiati",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10917,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11146,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11338,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10924,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11120,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7365,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1042,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Perché se una delle variabili dell'oggetto è un riferimento, super.clone() creerà una copia del riferimento e non creerà una copia dell'oggetto a cui punta il riferimento. (Non copierà neanche gli array perché anch'essi sono riferimenti)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11117,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11145,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10925,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10916,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11336,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7406,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 952,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "In alcuni casi è possibile che alcuni oggetti (di una qualche classe) contengano una lista (collection) o un normale array e in questi casi la shadow copy non è il massimo. Perchè questo ? Perchè nell'oggetto non è memorizzata la lista vera e propria, ma una sorta di riferimento all'area (aree) di memoria che contiene la lista ! Facendo una shadow copy, viene copiato il riferimento e quindi tutti gli oggetti \"clonati\" avranno la stessa lista in comune. Per questo motivo è bene implementarsi una propria deep copy e lasciare da parte la super.clone();",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10918,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11119,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11144,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11335,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10927,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7396,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1015,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "In molti casi gli oggetti contengono puntatori (nascosti ma pur sempre puntatori sono), e la funzione clone() di default fa una copia bit a bit. Il che significa che ad esempio un oggetto contenente una lista (ovvero un puntatore a lista) se clonato creerebbe un'altra istanza di sé che però conterrà sempre la stessa lista. Quindi è necessario ridefinire la funzione clone() per correggere errori simili, sempre che non sia una situazione voluta ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11334,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10923,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10914,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11116,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11141,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6923,
          "asker": {
            "courseId": 102,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il metodo clone() risulta essere un metodo protected? Quali sono le limitazioni che esso impone e in quali casi risultano essere troppo strette? Si possono modificare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7433,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 932,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Questo metodo è definito protected poichè è un metodo della classe Object; effettua una copia \"superficiale\" dell'oggetto sul quale viene chiamato:ogni campo dell'oggetto in questione viene copiato nel nuovo oggetto tramite una semplice assegnazione. Essendo un metodo definito protected, una sottoclasse non può accedere ai membri protected degli oggetti della sua superclasse.\r\nE generalmente, perchè una classe sia effettivamente clonabile, essa deve ridefinire il metodo clone() rendendolo public, creando così una \"copia profonda\".\r\nTale operazione non è sufficiente, e quindi occorre specificare che l'oggetto implementi l'interfaccia Cloneable, che non contiene nessun metodo e serve solamente come etichetta. Se la classe non implementasse questa interfaccia, il metodo clone() di Object potrebbe lanciare un'eccezione: CloneNontSupportedException().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11169,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11421,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11249,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11202,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11236,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11313,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10960,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7349,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Il metodo clone è protected perchè dev'essere effettuato l'override del metodo, per poterlo usare. Le limitazioni riguardano gli oggetti da clonare, che devono essere Cloneable, e inoltre solo la classe A può clonare oggetti della classe A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11247,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11420,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11168,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11237,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11311,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11205,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10959,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7411,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 58,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo clone() è protected perchè è stato deciso di limitarlo in modo da controllare potenziali errori. Dato che clonare non garantisce il successo dell'azione è meglio implementarlo esplicitamente in modo da gestirene le eccezioni. Queste limitazioni vengono evitate facendone l'override come metodo pubblico.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11234,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11314,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11246,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11170,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10962,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11419,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11203,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7328,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 956,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Ovvio che sì.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11312,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11422,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11238,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11248,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10963,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11206,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11171,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7336,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 966,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "(3 domande??) Il metodo clone() è protected perché non dovrebbe essere chiamato su qualsiasi oggetto, ma deve essere effettuato l'override per avere più controllo sul metodo stesso. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11204,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11235,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11245,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11423,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11172,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11310,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10961,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6913,
          "asker": {
            "courseId": 102,
            "askerId": 994,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve e cosa richiede una transition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Subclassing JavaFx componente"
            },
            {
              "keyword": " JavaFx Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6910,
          "asker": {
            "courseId": 102,
            "askerId": 1049,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è caldamente consigliato costruire una funzione copia nel proprio programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6940,
          "asker": {
            "courseId": 102,
            "askerId": 940,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi è necessario implementare un copy constructor, in C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6851,
          "asker": {
            "courseId": 102,
            "askerId": 1053,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché può risultare necessario usare il metodo clone() in Java?\r\nPorre inoltre un esempio ove l'uso sia richiesto.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLONE"
            },
            {
              "keyword": " CLONE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6876,
          "asker": {
            "courseId": 102,
            "askerId": 985,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In javafx che tipi di layout ci sono e come si differenziano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": " JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6860,
          "asker": {
            "courseId": 102,
            "askerId": 981,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa si differenziano transition e timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6961,
          "asker": {
            "courseId": 102,
            "askerId": 1032,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": " Qual è il trucco per avere degli aggiustamenti dinamici della posizione ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": " Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6904,
          "asker": {
            "courseId": 102,
            "askerId": 957,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra shallow copy e deep copy?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": " Clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6956,
          "asker": {
            "courseId": 102,
            "askerId": 1067,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando uso la StrokeTransition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX animation"
            },
            {
              "keyword": " JavaFX animation "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7351,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 972,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando serve, senza mai abbondare né deficere. Il giusto ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11098,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11329,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10999,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11307,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11304,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7345,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1091,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "\"StrokeTransition\" è una sottoclasse della classe \"Transition\" (a sua volta sottoclasse di \"Animation\").\r\nIn particolare Stroketransition permette di cambiare gradualmente il colore di un'immagine in un determinato tempo.\r\nSi utilizza scrivendo:\r\nStrokeTransition \"nome oggetto\" = new StrokeTransition(\"Durata intervallo\", \"oggetto su cui applicare la transition\", \"colore iniziale\", \"colore finale\");",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11001,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11097,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11302,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11309,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11327,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7363,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1027,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La StrokeTransitition è un'animazione che permette di ottenere la modifica del colore di un'entità (forma, bottone, ecc.. ) ad intervelli regolari, specificati dalla varibaile Stroke. L'animazione parte da un colore specificato nellla chiamata e termina al raggiungimento del nuovo colore, anch'esso specificato nella chiamata.\r\nStrokeTransition st = new StrokeTransition(Duration.millis(5000), rectangle, Color.RED, Color.GREEN);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11328,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11000,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11308,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11099,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11303,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6936,
          "asker": {
            "courseId": 102,
            "askerId": 1021,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra una Timeline e una Transition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6963,
          "asker": {
            "courseId": 102,
            "askerId": 1005,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il Copy Constructor?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "COPY CONSTRUCTOR"
            },
            {
              "keyword": " COPY CONSTRUCTOR"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6922,
          "asker": {
            "courseId": 102,
            "askerId": 1008,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la maggiore criticità in cui potremmo incorrere nella copia (o clonazione) di oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": "clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6924,
          "asker": {
            "courseId": 102,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra la subclasses Transition e Timeline? E come funzionano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": "JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6884,
          "asker": {
            "courseId": 102,
            "askerId": 952,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è e quando è utile il Copy Constructor ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7409,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1096,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il copy constructor come si intuisce dal nome è un costruttore, lo si chiama passandogli un puntatore ad un' altra istanza, solitamente della stessa classe dell'istanza appena creata.\r\nQuesto costruttore non fa altro che settare i propri parametri uguali a quelli ricevuti in argomento.\r\nÈ utile quando le istanze contengono puntatori, perchè grazie al costruttore posso settarli in maniera specifica invece che copiarli, cosa che potrebbe creare gravi effetti collaterali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11424,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11020,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11298,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11149,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11323,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11353,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7373,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "ll Copy Constructor è un metodo che serve ad effettuare una deep copy dell'oggetto su cui lo si chiama, ovvero restituisce una copia con la stessa struttura e le stesse caratteristiche di quella di partenza allocata in uno spazio di memoria differente. Questa ultima caratteristica lo differenzia il metodo da \"clone\" che invece implementa una shallow copy dell'oggetto cioè una copia bit a bit dell'oggetto. In particolare in C++ questo metodo è necessario qualora si voglia copiare un puntatore per evitare che la modifica dell'oggetto copiato si ripercuota su quello originale (o viceversa).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11355,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11325,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11019,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11297,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11425,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11148,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7403,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1007,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Un Copy Constructor è un particolare costruttore utilizzato per effettuare una copia di un oggetto: riceve come parametro di ingresso un oggetto della stessa classe e ne ritorna una copia. L'implementazione di un Copy Constructor risulta particolarmente utile quando la classe ha come parametri di istanza altri oggetti: in questo caso non è sufficiente effettuare una shallow copy (copia bit a bit effettuata di default dal metodo object.clone) ma è necessario istanziare nuove classi in modo da rendere l'oggetto creato uguale ma indipendente dall'oggetto che viene passato per parametro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11295,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11352,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11326,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11426,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11017,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11150,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7407,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Il Copy Constructor è una funzionalità offerta dal C++ per costruire un nuovo oggetto completamente uguale all'oggetto di partenza. Questa funzionalità risulta quindi utile quando abbiamo bisogno di creare una copia esatta di un oggetto. In particolar modo, essa è fondamentale quando viene utilizzato il passaggio di parametri per copia. Infatti senza il copy constructor, la mia copia sarebbe una Shallow Copy, ovvero una copia bit a bit dell'oggetto, compresi i valori dei puntatori. Questo tipo di copia crea enormi problemi. Infatti una volta terminata la funzione, la variabile, uscendo dallo scope, verrà deallocata dal distruttore, deallocando anche eventuali variabili allocate dinamicamente. La deallocazione dell'oggetto copia però porta alla perdità delle variabili dinamiche dell'oggetto originario, provocando gravi errori. Il copy constructor serve ad evitare questo problema; esso si occupa di allocare nuovamente le zone di memoria delle variabili dinamiche e copiandone il valore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11427,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11354,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11324,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11018,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11147,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11296,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6965,
          "asker": {
            "courseId": 102,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa fa il metodo \"clone\"? Che cosa è necessario fare per utilizzarlo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6889,
          "asker": {
            "courseId": 102,
            "askerId": 945,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il copy-constructor?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": "Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6897,
          "asker": {
            "courseId": 102,
            "askerId": 1012,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In JavaFX qual è la differenza tra le coordinate restituite dai metodi getLayoutX/getLayoutY rispetto a quelle ottenute con getTraslateX/getTraslateY?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": " JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6931,
          "asker": {
            "courseId": 102,
            "askerId": 1055,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Che associazione lega il KeyFrame ad un Interpolatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": "JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6864,
          "asker": {
            "courseId": 102,
            "askerId": 988,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra animation e timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JAVAFX ANIMATION"
            },
            {
              "keyword": " JAVAFX ANIMATION"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6905,
          "asker": {
            "courseId": 102,
            "askerId": 970,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve la proprietà Translate di Node?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": " JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6885,
          "asker": {
            "courseId": 102,
            "askerId": 1043,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile ovviare al problema dello spostamento degli oggetti in un interfaccia imposto dal tipo di contenitore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": "  JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7425,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 939,
                "courseId": 102,
                "courseFinalScore": 30
              },
              "answerText": "Per poter ottenere l'animazione di spostamento di un oggetto nel quale le coordinate di Layout sono imposte dal tipo di contenitore risulta particolarmente utile richiamare i metodi getTranslateX() e setTranslateX() (applicabili anche per le coordinate Y). Ogni Nodo di per sé è dotato di coordinate di LayoutX e LayoutY, che stabiliscono una posizione STABILE e NON MUTABILE del nodo in questione. Se però associamo ad esse i valori ottenuti dalle funzioni TranslateX e TranslateY (che viceversa permettono delle modifiche dinamiche riguardo la posizione dell'oggetto) e li sommiamo è possibile creare l'effetto di spostamento nonostante il contenitore principale imponga determinate coordinate iniziali all'oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11101,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11431,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11220,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7346,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1022,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Partiamo dal presupposto che ogni contenitore ha un layout manager che stabilisce in che modo gli oggetti sono dislocati al suo interno. Per ovviare a questo problema, cioè se si volesse forzare la posizione degli oggetti si dovrebbe lavorare senza un layout manager. Si dovrebbe dunque fornire la posizione assoluta di ogni componente all'interno del contenitore, ed si avrebbero però problemi quando il contenitore viene redimensionato dall'utente.\r\n\r\nPer forzare la posizione degli oggetti si potrebbe utilizzare sull'oggetto le trasformazioni contenute nella classe javafx.scene.Node, che è una classe base per la scena. Per esempio mediante una traslazione, facendo dunque un setting delle proprietà translateX/translateY.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11221,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11429,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11103,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7431,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 955,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Settando gli alignment degli oggetti su center per esempio, anche ridimensionando la finestra, questi rimarranno al centro. Non settando quel parametro gli oggetti rimarranno nella posizione decisa x loro dal layout",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11430,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11102,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11224,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7432,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Esistono funzioni che permettono di decidere esattamente la posizione di un nodo, ad esempio setLayout(), e funzioni della classe Translate che permettono di posizionare un oggetto a partire dalla posizione di origine. Per evitare invece che un nodo venga modificato in dimensioni si può impostare con una funzione la dimensione minima e massima. Se invece si vuole permettere uno spostamento del nodo a seconda del ridimensionamento della scene, si può usare una funzione setAlignament(), specificando la posizione che deve mantenere il nodo, ad esempio Pos.CENTER",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11432,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11100,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11222,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7370,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1028,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Con il metodo setTranslateX (analogamente per Y) posso spostare un oggetto rendendolo libero dalla propria posizione in cui era stato settato. Infatti con getTranslateX posso accedere al valore dello spostamento effettuato dal punto iniziale, mentre con getLayoutX dell'oggetto alla posizione fissata nel layout.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11104,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11223,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11428,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6879,
          "asker": {
            "courseId": 102,
            "askerId": 979,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa restituisce l'istruzione x.clone() != x e perché?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6950,
          "asker": {
            "courseId": 102,
            "askerId": 1045,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i diversi usi di Timeline e Transition di Java FX animation?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6895,
          "asker": {
            "courseId": 102,
            "askerId": 991,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Utilizzando una timeline sarebbe utile poter spostare un widget con le frecce direzionali; tuttavia i listener implementati fino ad ora non permettono di catturare gli eventi connessi a piu tasti contemporaneamente, come si puó ovviare a questo problema?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": " JavaFX Animation"
            },
            {
              "keyword": " Listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6874,
          "asker": {
            "courseId": 102,
            "askerId": 975,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo in Java non dobbiamo necessariamente implementare i copy constructor contrariamente a C++? In altre parole: per quale motivo in c++ è consigliabile creare un copy constractor quando creiamo una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Copy costructor"
            },
            {
              "keyword": " Copy costructor"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7394,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "in Java e in c++ il copy constructor viene definito dal sistema se non è stato definito dal programmatore. Nel primo caso non è sempre necessario, mentre nel secondo si perche in c++ si fa uso dei puntatori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11347,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11108,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11283,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11059,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10935,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10969,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11339,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7385,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1043,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "l' uso di copy constructor è consigliato quando si usa allocazione dinamica della memoria, in c++ se non creiamo un copy constructor il compilatore provvede a crearne uno che consiste nella copia bit per bit (quindi copia pari pari anche di eventuali puntatori e non degli oggetti associati). In java è possibile è possibile implementare l' interfaccia cloneable di object per rendere pubblico il metodo clone ed implementarlo a piacere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11282,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11109,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11058,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11346,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10968,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10936,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11340,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6859,
          "asker": {
            "courseId": 102,
            "askerId": 983,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa differenzia una Transition da una Timeline ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": "JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7361,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1034,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "La transition permette di realizzare delle animazioni specificando istante per istante i valori che animiamo. La timeline invece permette di specificare dei keyframe ed il resto dell'animazione viene calcolata automaticamente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11413,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10978,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10998,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11198,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11085,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7348,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe astratta che contiene le funzionalità di base richieste da tutte le animazioni di transizione basato , come PathTransition e RotateTransition. Questa classe offre un quadro semplice per definire l'animazione . Fornisce tutte le funzionalità di base definite in animazione . Transizione richiede l'attuazione di un metodo interpolate ( doppia ) che è la chiamata in ciascun frame , mentre la transizione è in funzione. Inoltre una classe estende deve impostare la durata di un singolo ciclo con Animation.setCycleDuration (javafx.util.Duration ) . Tale durata è normalmente impostato dall'utente tramite una proprietà duration ( come in FadeTransition.duration ) per esempio. Ma può anche essere calcolata con la classe che estende come si fa in ParallelTransition e FadeTransition. Un Timeline può essere utilizzato per definire una forma di animazione priva di qualsiasi WritableValue, ad esempio, Tutte le proprietà JavaFX.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10997,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11196,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11415,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11087,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10980,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7418,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1012,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Transition e Timeline, due sottoclassi di Animation, si differenziano per implementazione e complessità:\r\n- Transition fornisce un framework semplice per definire un'animazione, implementa tutte le funzionalità base definite in Animation e richiede l'implementazione del metodo interpolate, responsabile dell'aggiornamento dell'animazione.\r\n- Timeline, invece, è una classe più complessa che permette di animare qualsiasi WritableValue (ad es. le proprietà di JavaFX), e non solo, tramite interpolazione di uno o più KeyFrame attraverso i quali si definiscono i valori delle proprietà animate ad un determinato tempo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10979,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11086,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11197,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11414,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10996,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6846,
          "asker": {
            "courseId": 102,
            "askerId": 1058,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra lo shallow binding ed il deep binding? In quali casi è consigliabile utilizzare l'uno o l'altro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6887,
          "asker": {
            "courseId": 102,
            "askerId": 1066,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "come viene definita la posizione di un oggetto in video?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning "
            },
            {
              "keyword": " JavaFX Layout positioning "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6951,
          "asker": {
            "courseId": 102,
            "askerId": 939,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra una Shallow Copy ed una Deep Copy? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6958,
          "asker": {
            "courseId": 102,
            "askerId": 1081,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali elementi si possono 'clonare' in JavaFx?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6908,
          "asker": {
            "courseId": 102,
            "askerId": 984,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra layoutX e translateX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": " JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7390,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 961,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Ci sono dei layout manager , come ad esempio i Group , che non definiscono di default la posizione dei suoi elementi , per questo motivo il programmatore deve decidere la loro posizione tramite delle funzioni(setLayoutX() e setLayoutY()).Altri layout manager come BorderPane,StackPane ecc. definiscono un posizione all'oggetto nel momento in cui viene inserito , per questo motivo nel caso in cui si voglia modificarne la posizione si dovrà per cui utilizzare metodi come setTranslateX() ed setTranslateY() per spostare l'oggetto rispettivamente in modo orizzontale e verticale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10912,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11008,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10948,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11064,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10986,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7387,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1036,
                "courseId": 102,
                "courseFinalScore": 31
              },
              "answerText": "LayoutX è una property di un node che indica la coordinata assoluta x del node all'interno del Layout, mentre translateX è un property di un node che indica un differenziale rispetto alla coordinata LayoutX. LayoutX viene usato per indicare la posizione stabile di un Node, mentre poi la quantità translateX viene aggiunta per spostarlo per esempio all'interno di una animazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10985,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10906,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11007,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10949,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11060,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7413,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 982,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Modificando layoutX modifico principalmente le impostazioni della schermata su cui sto operando con translate x opero sull'oggetto nella schermata",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11065,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10987,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10910,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11010,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10950,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7354,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1080,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In pratica il primo col get da la posizione impostata a tempo di compilazione ( se lo metti nell'handle credo ti dia invece la posizione attuale , da verificare) ; mentre il secondo da lo spostamento effettuato a prescindere dalla posizione di partenza es. Se  faccio setlayoutX (50) ; set translateX(60) si troverà in posizione 110(50 iniziale+60 translati) ma col gettranslate otterrai 60 , ovvero lo spostamento effettuato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10908,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10952,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10991,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11005,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11063,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7420,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1021,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "LayoutX e translateX sono due variabili della classe Node che definiscono il posizionamento del nodo.\r\nLayoutX è una variabile che generalmente viene settata automaticamente dal Pane che utilizziamo e non va modificata a meno che non stiamo posizionando noi stessi ogni nodo. TranslateX, al contrario, è una variabile che definisce il posizionamento del nodo rispetto al valore contenuto in layoutX ed è attraverso questa variabile che il layout ci permette di riposizionare al meglio i nodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11066,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10988,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10911,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11006,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10953,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7335,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 957,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "layoutX indica la coordinata x della posizione di un oggetto grafico nel ambiente in cui si trova (borderPane, stackPane, etc) e solitamente viene gestita dal gruppo, mentre con translateX è possibile \"muovere\" l'oggetto senza realmente alterare la posizione originale, a cui si può accedere tramite layoutX (e layoutY)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10947,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11061,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10989,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11009,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10909,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7329,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 981,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "LayoutX è la posizione assoluta dell'oggetto rispetto al punto 0 dell'applicazione \r\n\r\nTranslateX è la posizione relativa dell'oggetto all'interno del contenitore in cui è collocato ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10951,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10990,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10907,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11062,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11011,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6929,
          "asker": {
            "courseId": 102,
            "askerId": 948,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A proposito della clonazione, qual è la differenza tra shallow copy e deep copy?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6947,
          "asker": {
            "courseId": 102,
            "askerId": 1001,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile usare due o più animazioni sullo stesso oggetto contemporaneamente oppure sequenzialmente in JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6863,
          "asker": {
            "courseId": 102,
            "askerId": 527,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le due sottoclassi di Animation e qual è la differenza tra le due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6943,
          "asker": {
            "courseId": 102,
            "askerId": 967,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in C++, rispetto a Java, è necessario dichiarare e definire un Copy Constructor all'interno di ogni singola classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "copy constructor"
            },
            {
              "keyword": " copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6907,
          "asker": {
            "courseId": 102,
            "askerId": 969,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare le classi giá presenti per fare un' animazione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javafx animation"
            },
            {
              "keyword": " javafx animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6873,
          "asker": {
            "courseId": 102,
            "askerId": 1037,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual' è la differenza fra Transition e Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": "JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6886,
          "asker": {
            "courseId": 102,
            "askerId": 1023,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "perché dovremmo implementare il copy constructor e non usare quello standard?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor "
            },
            {
              "keyword": "Copy constructor "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6964,
          "asker": {
            "courseId": 102,
            "askerId": 1075,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa offrono le classi Transition e Timeline in più rispetto alla classe Animation?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7352,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1029,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le transizioni in JavaFX forniscono i mezzi per integrare le animazioni in una timeline interna. Le transizioni possono essere composti per creare animazioni multiple che vengono eseguite in parallelo o in sequenza. È questa la principale differenza!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11029,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11021,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11260,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10966,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10982,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11393,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7377,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1032,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Non si istanzia mai un'animation ma sue due sottoclassi:Transition e Timeline.\r\nLa classe Transition ci da un framework semplice per definire un' animazione e le funzionalità di base per l'animazione stessa.\r\nTimeline può essere usata per definire una forma libera di animazione di un qualunque writablevalue cioè di tutte le proprietà di javaFx ossia i valori e le proprietà delle componenti.Se nell'animazione avevamo il concetto di frames ma erano sostanzialmente impliciti, cioè avevamo un parametro che scorreva tra 0 e 1 e sulla base di quello costruiamo dinamicamente le immagini, la timeline invece, ha un concetto di keyframes esplicito; è una classe che permette di rappresentare l'asse del tempo e su questo asse possiamo decidere che a un certo istante ci sono dei frames. Attraverso un metodo di interpolazione il sistema calcola come passare dall'uno all'altro. Anche la transition richiede l'implementazione di un metodo di interpolazione per definire i singoli frames.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10964,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11392,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10984,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11262,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11032,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11024,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7419,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 986,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Per creare un'animazione vengono sempre istanziate le sottoclassi di Animation: Transition e Timeline.\r\nLa classe Transition offre un framework semplice per definire l?animazione e dà le funzionalità di base della stessa.\r\nMentre Timeline è una classe che permette di rappresentare l?asse del tempo e su di essa \r\nsi può decidere dove collocare il frame.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11391,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11031,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11261,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11022,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10967,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10983,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7430,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 995,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Premessa: è naturale che le due classi, Transition e Timeline, offrano vantaggi maggiori rispetto alla classe Animation, in quanto esse ne sono sottoclassi.\r\n\r\nDetto questo possiamo analizzarle, Transition è un semplice framework che agevola l'uso di metodi già implementati in Animation, principalmente tramite il metodo Interpolate, che viene chiamato per ogni frame (deve essere obbligatoriamente overridato).\r\n\r\nTimeline invece permette di definire più liberamente delle animazioni, applicabili poi a tutte le \"JAVAFX Properties\". Qui l'elemento principale dell'animazione è chiamato KeyFrame, con il quale si puo' liberamente scegliere di far procedere delle animazioni mentre altre rimangono \"in pausa\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10965,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11030,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11263,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10981,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11394,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11023,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6856,
          "asker": {
            "courseId": 102,
            "askerId": 1036,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in c++ è importante implementare un metodo copy constructor, oltre al costruttore e distruttore, e quali potrebbero essere le conseguenze se non lo si fa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "copy constructor"
            },
            {
              "keyword": " copy constructor"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7331,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1078,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché senza copy constructor la copia, se contenente oggetti, punterebbe allo stesso indirizzo e quindi non sarebbe indipendente. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10942,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11128,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11368,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11388,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7368,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1009,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il copy constructor permette di fare una copia di un'istanza esistente.\r\nE' importante implementare un metodo copy constructor qualora la classe abbia variabili puntatori e allocazioni dinamiche della memoria,in quanto altrimenti, l'operazione di clonazione della classe non restituirebbe il risultato voluto e ci si limiterebbe solo a una \"shallow copy\".\r\n\r\nSolitamente se il copy constructor non è definito nella classe, il compilatore stesso ne definisce uno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11386,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10943,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11125,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11365,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7384,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 991,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "In C++ è fondamentale implementare un metodo copy constructor (che consiste nel fare overloading del metodo costruttore) perchè altrimenti è impossibile fare una copia dell'oggetto bit a bit (se non lo implemento anzichè una copia ho un aliasing fra gli identificatori dello stesso oggetto). Inoltre con un copy constructor posso fare delle \"deep copy\" dell'oggetto che sono indispensabili nel caso volessi passare per valore l'oggetto ad una sub-routine (se così non fosse rischierei di generare errori per deallocazione multipla delle variabili di istanza dell'oggetto). In generale è buona norma definire sempre il metodo anche se poi non andrà poi implementato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10944,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11366,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11387,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11126,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7389,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1072,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Crea un nuovo oggetto a partire da uno già esistente,  e viene creato un copy constructor per ogni classe in automatico a meno che non venga specificato manualmente dal programmatore. Il cc viene richiesto da puntatori ad allocazioni dinamiche.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11389,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11367,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11127,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10946,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7367,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1030,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "E' importante implementare un metodo copy constructor perché, altrimenti, ogni volta che tale metodo viene chiamato per fare una copia di una classe, questo andrà ad effettuare una copia bit a bit con la conseguenza che se la classe contiene dei puntatori che puntano ad una locazione all'interno della heap allora la classe ottenuta dalla copia avrà al suo interno un puntatore che punterà allo stesso indirizzo di memoria. Il problema si presenta dunque nel processo di distruzione della classe perché, in questo modo, ci saranno più classi contenenti un puntatore che punta allo stesso indirizzo di memoria e quindi avremo problemi di dangling pointer. Un ulteriore problema è che in questo modo avremmo un'entità condivisa, quindi, se attraverso il puntatore si va a modificare un campo della locazione di memoria da esso puntata, tale modifica si ripercuoterebbe anche sulla classe ottenuta mediante la copia, con conseguente comportamento non desiderato da parte del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11369,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11129,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10945,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11390,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6925,
          "asker": {
            "courseId": 102,
            "askerId": 965,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa succede se setto il cycleCount a \"INDEFINITE\" e attivo anche il flag autoReverse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6946,
          "asker": {
            "courseId": 102,
            "askerId": 974,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa fa il metodo clone() ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6852,
          "asker": {
            "courseId": 102,
            "askerId": 1035,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Data una componente in un Layout, è possibile modificare le sue coordinate? se si come?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": "JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6934,
          "asker": {
            "courseId": 102,
            "askerId": 958,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un copy constructor?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6900,
          "asker": {
            "courseId": 102,
            "askerId": 949,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Com'è possibile combinare 2 o più animazioni sullo stesso componente JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6896,
          "asker": {
            "courseId": 102,
            "askerId": 951,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e come si usa il copy constructor?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "copy constructor"
            },
            {
              "keyword": " copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6901,
          "asker": {
            "courseId": 102,
            "askerId": 1014,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo clone()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6902,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste il Copy constructor in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6928,
          "asker": {
            "courseId": 102,
            "askerId": 1096,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega i metovi per cui il metodo clone() di object è protetto invece di essere pubblico.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7355,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1019,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo clone()  è stato deciso di renderlo protected dai creatori di Java poichè tutti gli oggetti sono sottoclassi di Object. Per poterlo utilizzare bisognerà fare l'override di clonable e renderlo public. Il motivo è perchè è buona norma scrivere un metodo di copia per ogni classe che facciamo per evitare che la copia avvenga in modo non voluto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11215,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11385,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11219,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10993,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11156,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11363,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7405,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo clone è protetto perché non ogni oggetto è clonabile (un oggetto può avere ad esempio delle risorse che non sono duplicabili). Per evitare che casi di questo tipo si verifichino e per mettere in guardia il programmatore, Object mette a disposizione Clone ma lo propone come Protected. In questo modo è richiesto che il metodo clone sia sovrascritto dalla classe come pubblico, per essere così richiamabile al di fuori della classe stessa. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11364,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11214,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11217,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11384,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11157,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10995,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7392,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 990,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "In Java in genere non e' sempre necessario fornire un mezzo per effettuare una copia di una certa classe.\r\nIl modo in cui i progettisti di Java hanno scelto di rendere disponibile questa funzionalita' alle classi che invece la richiedono e' attraverso un metodo protected di Object che una certa sottoclasse e' libera di scegliere se rendere disponibile o meno all'esterno effettuandone l'override e cambiando la sua visibilita' in public segnalando poi questa \"modifica\" attraverso l'implementazione dell'interfaccia vuota Cloneable.\r\nIl motivo fondamentale per cui clone non e' pubblico (a differenza di altri metodi di Object come hashCode o equals) e' proprio per permettere al programmatore di scegliere se rendere la propria classe clonabile oppure no. Se il metodo fosse stato pubblico il programmatore sarebbe stato obbligato a fornire per ogni classe un'implementazione di clone.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11212,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11158,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11361,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11383,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10992,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11216,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7380,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1008,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Il metodo clone() in Object ha visibilità di tipo protected per due motivi principali:\r\n1) In questo modo, ci viene comunicato implicitamente che tale metodo è \"chiuso\" e non sempre applicabile, in quanto potremmo avere degli oggetti non clonabili.\r\n2) Se davvero vogliamo usare clone(), saremo obbligati a fare override su di esso per renderlo public. L'override è quindi fortemente incoraggiato, anche perché altrimenti non potremmo fare deep copy (due cloni tra loro indipendenti), in quanto il metodo originale in Object si limita alla shallow copy.\r\n\r\nQuindi, la ragione per cui clone() è protected è che tale metodo deve essere utilizzato correttamente, sapendo esattamente cosa vogliamo fare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11213,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11218,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11155,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11382,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11362,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10994,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6962,
          "asker": {
            "courseId": 102,
            "askerId": 986,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il copy constructor?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6906,
          "asker": {
            "courseId": 102,
            "askerId": 941,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra SHALLOW COPY e DEEP COPY?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6935,
          "asker": {
            "courseId": 102,
            "askerId": 1030,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché, in alcuni casi, è bene non affidarsi al metodo clone() della classe Object?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": " Clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6868,
          "asker": {
            "courseId": 102,
            "askerId": 946,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve, nello specifico, il metodo Object.Clone()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6967,
          "asker": {
            "courseId": 102,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa avviene specificando INDEFINITE su CycleCount? Com'è possibile, inoltre, far andare un'animazione avanti ed indietro ripetutamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6916,
          "asker": {
            "courseId": 102,
            "askerId": 1042,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In JavaFX, che cos'è una Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6948,
          "asker": {
            "courseId": 102,
            "askerId": 1054,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le sottoclassi di Transition? e a cosa servono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6957,
          "asker": {
            "courseId": 102,
            "askerId": 1002,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa differisce la funzione setLayoutX dalla funzione SetX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": "JavaFX Layout positioning "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6877,
          "asker": {
            "courseId": 102,
            "askerId": 1099,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché é utile usare un metodo clone() in java FX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": " method"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6921,
          "asker": {
            "courseId": 102,
            "askerId": 1078,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è molto sconsigliato l uso di posizionamento statico di oggetti all interno dell interfaccia grafica? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": " JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7400,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1014,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Posizionare in modo statico i componenti all'interno dell'interfaccia grafica è sconsigliato perchè ad esempio essi potrebbero non essere visibili nel caso in cui la finestra viene ridimensionata.\r\nOggigiorno infatti è sempre più diffuso il posizionamento relativo degli oggetti all'interno dell'interfaccia per far si che essi si \"adattino\" il più possibile ai cambiamenti in maniera automatica; prendiamo l'esempio di una finestra con una label e un textfield collegato, spesso usate per l'inserimento di una credenziale; nel caso di posizionamento relativo, se la label viene spostata, di conseguenza anche il textfield verrà spostato. Nel caso di posizionamento statico invece, devo andare a modificare la posizione di entrambi i componenti.\r\nUsare quindi il posizionamento relativo invece di quello statico ritorna molto utile quando ho molti oggetti, in quanto, cambiando la posizione di uno, gli altri si \"muovono\" di conseguenza",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11012,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11069,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10893,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11285,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11404,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7334,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 978,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè javaFX posiziona dinamicamente gli oggetti per garantire una compatibilità maggiore su monitor diversi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10890,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11015,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11406,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11071,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11284,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7353,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 992,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Poiché nel caso in cui la finestra venga ridimensionata, si potrebbe andare a nascondere delle componenti. Se ad esempio il menù fosse in basso e se ridimensionasse la finestra si potrebbe perdere la possibilità di utilizzarlo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11070,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11016,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11286,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11403,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10891,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7397,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 962,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché altrimenti poi non si possono più spostare. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11287,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11014,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11068,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11405,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10889,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7399,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1044,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Oggetti posizionati staticamente all'interno di un'interfaccia rimangono ancorati alla posizione prefissata anche durante il ridimensionamento della finestra.\r\nQuesto può causare una pessima distribuzione o la scomparsa di alcuni elementi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11013,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10892,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11067,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11288,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11407,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6949,
          "asker": {
            "courseId": 102,
            "askerId": 1089,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile far cambiare il layout delle animazioni all'utente? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6952,
          "asker": {
            "courseId": 102,
            "askerId": 1098,
            "courseFinalScore": 14
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra i due metodi di clonazione in JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6892,
          "asker": {
            "courseId": 102,
            "askerId": 1047,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in C++ si rende spesso necessario definire un metodo per clonare un oggetto di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Clone "
            },
            {
              "keyword": " Clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6871,
          "asker": {
            "courseId": 102,
            "askerId": 953,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una timeline?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "timeline"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6854,
          "asker": {
            "courseId": 102,
            "askerId": 962,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si implementa il metodo clone?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6932,
          "asker": {
            "courseId": 102,
            "askerId": 1052,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si ottiene la posizione precisa all'interno della finestra di un qualsiasi oggetto javafx contenuto in uno dei tanti layout predefiniti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Layout positioning"
            },
            {
              "keyword": " JavaFX Layout positioning"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6939,
          "asker": {
            "courseId": 102,
            "askerId": 977,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "some si sottoclassano delle componenti in JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "subclassing JavaFX components"
            },
            {
              "keyword": "subclassing JavaFX components"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6912,
          "asker": {
            "courseId": 102,
            "askerId": 1027,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile far adattare automaticamente le componenti di una finestra dopo un resizing in esecuzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java FX Animation"
            },
            {
              "keyword": " Java FX Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7332,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 951,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Usando layout predefiniti (come i Pane) esse si adattano automaticamente al resizing (questa funzionalità è gestita dal layout senza che il programmatore debba fare niente), mentre se le componenti sono posizionate con posizionamento assoluto esse rimangono nei punti di coordinate (X,Y) definiti dal programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11342,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11306,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11140,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10934,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7375,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1070,
                "courseId": 102,
                "courseFinalScore": 10
              },
              "answerText": "Poichè è il layout a gestire la disposizione delle componenti grafiche all'interno della finestra, se si evita di utilizzare il posizionamento assoluto di queste (usando il metodo set, in generale sempre sconsigliato) l'adattamento è automatico. \r\nSe non si ricorre al posizionamento assoluto, la posizione di una componente sullo schermo è data dalla posizione di base decisa dal layout; su questa noi possiamo imporre delle condizioni utilizzando il metodo Translate che ci permette di spostare la nostra componenente rispetto a quella data dal layout.\r\nIn una animazione tipicamente lavoreremo con il translate ed il layout delle cordinate rimarrà fisso; è questo il modo per ottenere cambiamenti dinamici della posizione delle componenti, anche in relazione alla taglia delle finestre.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11305,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10933,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11341,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11139,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6882,
          "asker": {
            "courseId": 102,
            "askerId": 1000,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è  una fade transition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": "JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6930,
          "asker": {
            "courseId": 102,
            "askerId": 1074,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si possono cambiare le coordinate di un oggetto posizionato da un Pane? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "posizione"
            },
            {
              "keyword": " Pane"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6933,
          "asker": {
            "courseId": 102,
            "askerId": 1064,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa comporta l'utilizzo diretto di una classe Animation, senza il passaggio per le sue sottoclassi Timeline e Transition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7416,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1047,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "Animation è abstract e fornisce le funzionalità base di una animazione. Bisogna usare una sua sottoclasse concreta per realizzare un' animazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11056,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11114,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11173,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11045,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11399,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7381,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1052,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Nella norma bisognerebbe creare una classe anonima o una sottoclasse che implementi tutti i metodi astratti, tuttavia in questo caso ci sono metodi da implementare che non possono essere implementati a meno che non si creino delle particolari classi delle quali necessita l'eventuale sottoclasse di Animation.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11055,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11176,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11044,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11398,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11113,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7429,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 974,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Essendo Animation e Transition abstract non possono essere istanziate, ma devono essere estese o sottoclassate. Se si utilizza Animation non si può accedere alle funzioni di Timeline o Transition mentre se si utilizzano le sottoclasse si può accedere alle funzioni di Animation.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11057,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11048,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11111,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11400,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11174,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7337,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 969,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L utilizzo appunto della classe Animation invece che delle sottoclassi Timeline e Transition",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11402,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11110,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11046,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11175,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11054,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7374,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1005,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'utilizzo diretto della classe Animation, senza che essa venga sottoclassata, comporta la perdita tutti i metodi per la creazione di animazioni. In quanto classe astratta, essa non può essere istanziata, ed è quindi inutilizzabile per la creazione delle animazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11047,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11112,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11177,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11053,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 11401,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6869,
          "asker": {
            "courseId": 102,
            "askerId": 1070,
            "courseFinalScore": 10
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In C++ è possibile scegliere tra due modi per la allocazione della memoria, quali sono?\r\nSpecifica le differenze tra i due e spiega come questa possibilità di scelta influenzi la struttura delle classi in C++.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "costruttore"
            },
            {
              "keyword": " distruttore"
            },
            {
              "keyword": " copy-constuctor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6966,
          "asker": {
            "courseId": 102,
            "askerId": 960,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Come faccio a clonare un oggetto di tipo A?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor "
            },
            {
              "keyword": "Copy constructor - "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6945,
          "asker": {
            "courseId": 102,
            "askerId": 993,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega come funziona l'interpolazione nelle animazioni in JavaFX",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6865,
          "asker": {
            "courseId": 102,
            "askerId": 1022,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i diversi tipi di cloning in Java e come vengono usati? Rispondere evidenziando le principali differenze",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLONE"
            },
            {
              "keyword": " CLONE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6942,
          "asker": {
            "courseId": 102,
            "askerId": 972,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un copy constructor? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " copy constructor "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6918,
          "asker": {
            "courseId": 102,
            "askerId": 978,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega in breve a cosa serve il copy constructor di C.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Copy constructor"
            },
            {
              "keyword": " Copy constructor"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6875,
          "asker": {
            "courseId": 102,
            "askerId": 982,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale può essere un esempio di JavaFX Animation? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6870,
          "asker": {
            "courseId": 102,
            "askerId": 990,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali situazioni puo' essere comodo usare una PauseTransition?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7339,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 941,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Una PauseTransition può essere utilizzata in una SequentialTransition per creare una pausa tra Transition.\r\n\r\nÈ comodo usarla quando si hanno già degli oggetti Transition (Path, Rotate...) e non si vuole utilizzare una Timeline.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11092,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11162,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11081,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11379,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7333,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1001,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Quando devi mettere in pausa l'animazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11091,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11381,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11080,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11161,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7350,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 946,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il PauseTransition viene usato per fermare una transazione nel momento in cui ne abbiamo bisogno. Questo può tornarci utile nel caso dovessimo fare dei controlli particolari tra un momento ed un altro della transazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11088,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11160,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11380,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11079,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7426,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1038,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "PauseTransition serve per avere un intervallo: è una transizione che mi dice di aspettare. E' utile soprattutto nelle composizioni sequenziali, se tra due transizioni differenti voglio inserire un momento di stacco in cui non succede nulla.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11378,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11089,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11159,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11078,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7410,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1035,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La PauseTransition può essere comoda quando si creano delle composizioni sequenziali di transizioni; per esempio si volere che tra due transizioni in sequenza ci sia un momento \"di pausa\" in cui la componente non fa niente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11163,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11077,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11377,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11090,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6866,
          "asker": {
            "courseId": 102,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le sottoclassi di JavaFX Animation e qual è la differenza tra le due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6888,
          "asker": {
            "courseId": 102,
            "askerId": 999,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quanti fps deve avere un \"video\" per essere \"fluido\" ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6941,
          "asker": {
            "courseId": 102,
            "askerId": 932,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l' Animazione ? Quali sono i metodi e le sottoclassi da utilizzare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animazione"
            },
            {
              "keyword": " transizione"
            },
            {
              "keyword": " timeline"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6862,
          "asker": {
            "courseId": 102,
            "askerId": 954,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali tipologie di JavaFX Animation?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX components"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6857,
          "asker": {
            "courseId": 102,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "E` possibile animare due oggetti contemporaneamente? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": "JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7371,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si è possibile animare 2 oggetti contemporaneamente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11207,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11321,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11255,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10894,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11186,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7382,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 970,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si certamente. Quando si va a definire una animazione (Animation, Transition, Timeline,... Qualsiasi cosa) si deve fare l'override di determinati metodi che verranno poi eseguiti durante l'animazione. All'interno di questi metodi (ad esempio \"interpolate\" per Animation) si decide cosa l'animazione va a fare: è quindi possibile coinvolgere quanti oggetti si vogliono.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11209,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10896,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 11259,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 11320,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11184,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7372,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 958,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10895,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11208,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11322,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11185,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11256,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7376,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1025,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si, perchè l'animazione è una proprietà di un oggetto che non dipende dagli altri oggetti. E' quindi possibile applicare ad un oggetto anche più di un'animazione (che vengono eseguite in sequenza oppure contemporaneamente), le quali possono apparire in parallelo con altre animazioni di altri oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11187,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11258,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11319,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 11211,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10897,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7414,
              "task": {
                "taskId": 202,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1067,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Si",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 11210,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11257,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 11318,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10898,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 11188,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 202,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6926,
          "asker": {
            "courseId": 102,
            "askerId": 998,
            "courseFinalScore": 11
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Riguardo la clonazione, qual è la differenza tra shallow copy e deep copy?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "clone"
            },
            {
              "keyword": " clone"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6920,
          "asker": {
            "courseId": 102,
            "askerId": 1031,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra le classi Transition e Timeline?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX Animation"
            },
            {
              "keyword": " JavaFX Animation"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6937,
          "asker": {
            "courseId": 102,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 201,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere brevemente la sottoclasse Transition di Animation",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Animation"
            },
            {
              "keyword": " animation"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 67,
      "lectureTitle": "Classi ed ereditarietà",
      "questions": [
        {
          "questionId": 6270,
          "asker": {
            "courseId": 102,
            "askerId": 1023,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Con il sistema di distruzione automatica degli oggetti (garbage collection) quali sono i pro e i contro che il programmatore ha da questa gestione della memoria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": "Classi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6672,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1050,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I pro della presenza di questa procedura automatica sono, senza dubbio, la semplificazione delle operazioni di allocazione dinamica (che non richiede più attenzione per la deallocazione esplicita da parte del programmatore) e una migliore gestione della memoria (che, potenzialmente, non viene più sprecata in oggetti non più utilizzabili). Lo svantaggio è il minor controllo di questa gestione della memoria, che a volte può non funzionare come aspettato, poichè la procedura di garbage collection potrebbe non attivarsi in particolari casi di conflitto in memoria (può comunque essere forzata all'esecuzione dal programmatore).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8073,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8414,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8592,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6621,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1045,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con il sistema del garbage collector non è più necessario che il programmatore deallochi  la memoria occupata dal programma in heap dopo l'utilizzo, in questo modo si diminuiscono le probabilità di errori come puntatori a celle di memoria deallocate oppure alcuni memory leaks. Per contro il programmatore non ha controllo diretto sulla deallocazione, infarti anche se viene chiamato manualmente il garbage collector, il sistema puó decidere di non avviarlo per motivi di ottimizzazione. inoltre la garbage collection utilizza risorse calcolo e in momenti imprevedibili, il che rende difficile utilizzare un linguaggio con un simile sistema di memory management in sistemi in real-time.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8072,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8591,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8413,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6678,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 956,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "La garbage collection ha la funzione di gestire la memoria al posto del programmatore, eliminando quindi tutte quelle possibilità di errori legati alla cattiva gestione dei puntatori e a tutti i relativi memory leaks. Il programmatore quindi non si deve più occupare della gestione della memoria, questo però è sia un pro che un contro, dato che il programmatore ha sempre meno cose sotto il suo controllo e la GC può gestire in modo diverso la memoria da come la gestirebbe il programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8589,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8071,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8412,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6728,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1071,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "PRO:\r\n- Non è necessario deallocare ciò che è stato precedentemente allocato\r\n- E' meno probabile avere memory leak\r\n\r\nCONTRO:\r\n- E' possibile che in determinate situazioni, il programma deallochi degli oggetti che in realtà servono ancora.\r\n- Poichè il sistema deve continuamente controllare la memoria (ed eventualmente liberarla), è possibile che il programma risponda in maniera piu lenta e non prevedibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8415,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8590,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8074,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6282,
          "asker": {
            "courseId": 102,
            "askerId": 1008,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve nelle classi di Java la keyword \"extends\" e quali vantaggi porta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6388,
          "asker": {
            "courseId": 102,
            "askerId": 1044,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il compito dei modificatori di visibilità (public e private) all'interno delle classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": "Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6322,
          "asker": {
            "courseId": 102,
            "askerId": 964,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra 'implements' e 'extends'?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6289,
          "asker": {
            "courseId": 102,
            "askerId": 981,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa vuol dire che una classe ne eredita un'altra? Con quali istruzioni si eredita una classe e  con quali si accede ai dati della classe padre? Fare un esempio (a parole) di ereditarietà spiegando brevemente il perchè della scelta.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6256,
          "asker": {
            "courseId": 102,
            "askerId": 1020,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "spiegare cosa si intende per eridatarietà e come viene applicata nelle sue 3 forme, spiegare poi la differenza tra aggregazione (has-a) e composizione (part-of) utilizzando degli esempi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6269,
          "asker": {
            "courseId": 102,
            "askerId": 944,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quanto concerne l'ereditarietà, il file .java relativo ad una classe derivata deve essere inserito nello stesso package (e dunque nella stessa cartella) della classe padre?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6318,
          "asker": {
            "courseId": 102,
            "askerId": 967,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, una qualsiasi classe non derivante da un'altra classe da noi precedentemente definita (per esempio \"Pila\"), da cosa deriva?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6378,
          "asker": {
            "courseId": 102,
            "askerId": 1082,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono overriding e overloading ? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " overriding/overloading "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6345,
          "asker": {
            "courseId": 102,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Elenca e spiega cosa sono i modificatori di visibilità.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            },
            {
              "keyword": " modificatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6382,
          "asker": {
            "courseId": 102,
            "askerId": 1085,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa differisce una pila da una coda? E come si può trasformare la prima in una coda?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Coda"
            },
            {
              "keyword": " pila"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6373,
          "asker": {
            "courseId": 102,
            "askerId": 1042,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'UML?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6763,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1082,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L' UML (Unified Modeling Language) è un linguaggio utilizzato per la progettazione di software object oriented.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8520,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8651,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8287,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8383,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6710,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 997,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L' UML é un diagramma che rappresenta le classi e gli oggetti che compongono il sistema, i relativi attributi ed operazioni. Specifica i vincoli che legano tra loro delle classi mediante le associazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8650,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8384,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8284,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8522,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6715,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1044,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'UML è un diagramma il cui compito è descrivere la struttura e la funzionalità del software.\r\nIn particolare il diagramma delle classi rappresenta le differenti classi utilizzate nel software, le variabili e i metodi delle classi stesse e i loro legami.\r\nCome visto sulle slides il diagramma cambia i propri collegamenti grafici in base al collegamento tra le classi che intercorre (estensione, aggregazione, composizione).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8286,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8519,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8382,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8652,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6733,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 945,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "L'UML è un linguaggio di modelizzazione con cui è possibile rappresentare classi e oggetti che costituiscono un determinato programma/sistema insieme a variabili e metodi a loro associati.\r\nInoltre permette di specificare le relazioni che ci sono tra le varie classi come ereditarietà ,composizione, associazione e gerarchia(super/sub classe).\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8653,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8285,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8381,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8521,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6391,
          "asker": {
            "courseId": 102,
            "askerId": 1043,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare l' utilitá del comando super () in java, proporre un breve esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6365,
          "asker": {
            "courseId": 102,
            "askerId": 1018,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile creare una classe che contiene altre classi? Se si, in quale contesto questo approccio può risultarci utile? Se si, inoltre, sarebbe possibile instanziare un oggetto delle classi da essa contenute senza instanziare un suo oggetto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6626,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 972,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si, in java è possibile. E' utile quando bisogna fare oggetti complessi formati da più elementi. Si, è possibile instanziare un oggetto senza istanziare quello da esso contenuto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8322,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8154,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8326,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6774,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 934,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "E' possibile creare una classe che contiene altre classi. Può essere utilizzata quando abbiamo necessità di modellare un'entità ed una sua componente (ad esempio Università e Persona). E' inoltre possibile stanziare un oggetto delle classi senza istanziare un suo oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8152,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8320,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8328,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6637,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1080,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se ti riferisci al c++  credo di sì come esistono gli struct di struct, cosi fanno le classi. In Java no, si tratta invece di creare una classe (principale), dove all'interno della sua definizione, si creano oggetti delle altre,\r\nEs. Aplications o= new aplications; e in questo caso ci torna molto utile perché possiamo creare un programma \"multitasking\". Infine se ho capito bene l'ultima domanda, quando tu crei il main , non crei un oggetto della classe, ma esegui la sua definizione e se all'interno di questa vi è un'istanza di un oggetto la fa(creandone uno non della classe del main, ma di quella chiamata), altrimenti niente ed è \"simile\" ad un programma in c. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8153,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8319,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8327,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6698,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1007,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Java permette la creazione di classi annidate. Con classi annidate si intende la creazione di una classe all'interno di un'altra classe. es:\r\nPublic class ester{\r\n..\r\n   public class inter{\r\n..\r\n   }\r\n..\r\n}\r\nUn primo vantaggio lo si può riscontrare nella maggiore chiarezza del codice in quanto si capisce facilmente che \"inter\" è parte integrante di \"ester\". In secondo luogo si può notare come questo approccio può risultare utile nel caso in cui si abbia a che fare con ereditarietà multipla: nell'esempio precedente se si eredita ester si eredita, in automatico, anche inter. \r\nIn linea generale, se la classe interna non è definita come \"static\", per istanziare la classe interna è necessario avere anche l'istanza della classe esterna es: ester.inter a = new ester().inter();. Nel caso invece in cui \"inter\" sia definita come static, questa può essere considerata come una classe autonoma e non necessita, di conseguenza, dell'istanza della classe esterna es: ester.inter b= new ester.inter();.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8329,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8151,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8321,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6251,
          "asker": {
            "courseId": 102,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Una classe può avere più costruttori? se si come vengono gestiti da java.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Costruttori"
            },
            {
              "keyword": "Costruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6748,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1002,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si, una classe può avere più costruttori,però devono avere tutti tipo e numero di argomenti diversi. \r\nUn costruttore ha lo scopo di istanziare gli elementi della relativa classe in cui viene dichiarato.\r\nIn caso di estensione di una classe è possibilie utilizzare la keyword super per potersi riferire alla costruttore della classe padre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8148,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8567,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8113,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6662,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 990,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Java e' un linguaggio che supporta il cosiddetto overloading dei metodi. Cio' significa che in generale una classe puo' dichiarare piu' metodi aventi lo stesso nome ma che differiscono per numero o tipo dei parametri.\r\nUn costruttore non e' altro che un particolare metodo avente il nome della classe, dunque, grazie all'overloading, e' possibile dichiarare piu' costruttori che differiscono tra loro per numero o tipo dei parametri.\r\nAl momento dell'invocazione del costruttore viene selezionato il costruttore i cui parametri meglio corrispondono ai parametri attuali passati al momento dell'invocazione. In caso esistano due costruttori giudicati ugualmente \"buoni\" la chiamata e' ambigua e viene generato un errore che andra' risolto dal programmatore specificando esplicitamente tramite opportune conversioni il tipo dei parametri attuali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8147,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8569,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8114,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6735,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 989,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe può avere più costruttori che si differenziano tra loro per il numero e/o tipo di parametri con cui possono essere chiamati. Al momento della creazione di un oggetto di questa classe, viene chiamato il costruttore che accetta i parametri indicati dall'utente, mentre gli altri metodi di costruzione implementati vengono ignorati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8111,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8149,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8570,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6737,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 984,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sì, ma ogni costruttore deve avere diversi parametri d'ingresso, ad esempio se il primo costruttore ha come parametro d'ingresso un numero intero, un differente costruttore della stessa classe non può avere come parametri d'ingresso un intero (ma un intero e un float o 2 interi si). Un costruttore in java può chiamare un altro attraverso\r\n\" this (parametri del costruttore voluto); \"\r\nall'interno del costruttore attuale",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8112,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8150,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8568,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6313,
          "asker": {
            "courseId": 102,
            "askerId": 1014,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende quando si parla di overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6361,
          "asker": {
            "courseId": 102,
            "askerId": 947,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa significa costruttori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "COSTRUTTORI"
            },
            {
              "keyword": " COSTRUTTORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6311,
          "asker": {
            "courseId": 102,
            "askerId": 1012,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Prendendo come riferimento il linguaggio di modellizzazione UML (Unified Modelling Language) che cosa rappresenta una relazione ISA tra due classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6381,
          "asker": {
            "courseId": 102,
            "askerId": 1068,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si utilizzano più classi, quest'ultime vanno scritte in file sorgenti differenti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6393,
          "asker": {
            "courseId": 102,
            "askerId": 1053,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con overloading di metodi? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "OVERLOADING"
            },
            {
              "keyword": " OVERLOADING"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6327,
          "asker": {
            "courseId": 102,
            "askerId": 1073,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che conseguenze può avere non chiamare il metodo \"distruttore\" finalize()? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Distruttori"
            },
            {
              "keyword": " Distruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6651,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1000,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Può portare a dei memory leack.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8237,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8233,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8238,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8512,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8136,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6722,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il mancato utilizzo del metodo finalize() potrebbe per esempio portare a problemi nelle operazioni di finalizzazione (per esempio la chiusura di una risorsa di sistema utilizzata) prima che l'oggetto venga distrutto dal Garbage Collector.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8234,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8235,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8239,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8511,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8137,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6747,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1036,
                "courseId": 102,
                "courseFinalScore": 31
              },
              "answerText": "I soli casi in cui non chiamare il metodo finalize() causa delle conseguenze è se all'interno del nostro programma è stata allocata della memoria in maniera particolare, ad esempio se è stato aperto un programma in non java che ha allocato della memoria. Questa memoria potrebbe non venir liberata dal garbage collection, ed è quindi preferibile riscrivere il metodo finalize (che di default esiste ma non fa nulla) e chiamarlo esplicitamente attraverso System.runFinalization() subito dopo aver chiamato garbage collection con System.gc(). All'interno di questo metodo finalize() bisognerà scrivere quindi, ad esempio, come liberare aree di memoria allocata da un sottoprogramma scritto in C con la funzione malloc(), che non è possibile disallocare se non chiamando la funzione free().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8236,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8510,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8232,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8135,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8240,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6302,
          "asker": {
            "courseId": 102,
            "askerId": 960,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In java, quali sono le caratteristiche identificative, che permettono quindi l'overloading, di una funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " overloading "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6308,
          "asker": {
            "courseId": 102,
            "askerId": 1080,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "La funzione super() può tornare utile non solo nella costruzione di un oggetto ma anche per la sua stampa, ad esempio se si vuole stampare sottoclassi e si usa come nell'esempio dei punti e dei punti col nome del prof, ovvero nel toString  return name+super.toString (); non c'e' problema perché il risultato sarà qualcosa del tipo Punto (1,2). Ma se si vuole fare Punto3d(con la z), non si può fare return super.toString()+z; altrimenti verrebbe qualcosa del tipo (1,2),3 per via della definizione del toString del punto(che comprende le parentesi dopo la y). Allora qual è il modo più efficiente per ovviare il problema?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": " toString"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6266,
          "asker": {
            "courseId": 102,
            "askerId": 1028,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando scriviamo un metodo \"toString()\" all'interno della nostra classe, viene eseguita un'operazione di \"OVERRIDE\". In cosa consiste l'overriding e perché si verifica quando implemento il metodo sopra citato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6366,
          "asker": {
            "courseId": 102,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'e la differenza tra overloading e overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "OVERLOADING"
            },
            {
              "keyword": " OVERRIDING"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6298,
          "asker": {
            "courseId": 102,
            "askerId": 1049,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le possibilità che ci offre la programmazione ad oggetti con l'implementazione dell'ereditarietà?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6300,
          "asker": {
            "courseId": 102,
            "askerId": 978,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Indica a cosa serve e quando è utile utilizzare l'istruzione super().",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Classi"
            },
            {
              "keyword": " Costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6263,
          "asker": {
            "courseId": 102,
            "askerId": 970,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa succede se eredito da una superclasse che non prevede un costruttore senza parametri e nella classe figlio non richiamo il super(lista parametri)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6340,
          "asker": {
            "courseId": 102,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il \"garbage collector\" e qual'è un caso in cui questo meccanismo fallisce?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6350,
          "asker": {
            "courseId": 102,
            "askerId": 1033,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa avviene effettivamente quando definisco un nuovo oggetto? \r\n\r\nesempi:\r\nObject objectName = new Object()\r\nPila p = new pila ();\r\n\r\nIllustra brevemente il compito dell'operatore  new e dei vari elementi che compongo la dichiarazione di un oggetto (usando come riferimento uno o più degli esempi sopra citati).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Costruttori"
            },
            {
              "keyword": "Costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6356,
          "asker": {
            "courseId": 102,
            "askerId": 1062,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché i membri dato all'interno di una classe per convenzione sono dichiarati privati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Visibilità"
            },
            {
              "keyword": " Variabili"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6658,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 969,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè di default si suppone che tali membri, che siano attributi o metodi, debbano essere utilizzati solamente dalla classe stessa e quindi non accessibili dall'esterno sotto il principio dell'information hiding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8594,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8564,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8343,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6660,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una variabile privata è visibile solo all'interno della classe in cui è dichiarato,la dichiarazione privata viene effettuata per impedire che una classe ci possa accedere direttamente(classe.variabile).\r\nDi consuetudine per permettere ad una classe di modificarle vengono implementati i metodi set/get() per la modifica e la lettura della variabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8595,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8561,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8340,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6727,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1034,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Perché secondo il principio di Parna (information hiding) ogni elemento del software deve accedere solamente alle informazioni necessarie per l'esecuzione del suo compito. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8596,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8342,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8560,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6767,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 966,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I membri all'interno di una classe vengono generalmente dichiarati privati. Questo permette l'accesso al membro privato solo all'interno della classe in cui si trova.\r\nSolitamente si utilizza il modificatore più \"severo\", che permette un accesso limitato al membro, al metodo o alla classe: questa pratica rende il codice più comprensibile, in quanto stabilisce chiaramente quale classe o pacchetto può accedere al membro. Ad esempio, se si riscontra un bug nel codice, grazie ai modificatori è possibile stabilire velocemente se il problema si trova in una classe o in un altra, e questo è molto importante quando bisogna lavorare con migliaia di righe di codice.\r\nInoltre il modificatore di accesso privato permette l'information hiding, una tecnica che consiste nel nascondere il funzionamento interno di una parte di un programma, in modo da proteggere le altre parti del programma dai cambiamenti che si produrrebbero in esse nel caso che questo funzionamento fosse difettoso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8562,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8593,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8339,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6657,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1068,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nella programmazione ad oggetti per evitare l'utilizzo di variabili istanziate pubblicamente, dato che sono visibili da tutti i punti del programma, possono influenzare in modo incontrollato l'esecuzione del programma rendondo difficile la gestione del codice, la sua manutenzione e il suo sviluppo quindi vengono dichiarate private. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8597,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8341,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8563,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6352,
          "asker": {
            "courseId": 102,
            "askerId": 1058,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Il garbage collector viene automaticamente utilizzato da Java, evitando quindi possibili memory leaks. Tuttavia, è possibile invocarlo durante la compilazione di un file manualmente da parte del programmator : quali sono i possibili casi in cui il programmatore necessiti di usufruire del garbage collector diretta",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6339,
          "asker": {
            "courseId": 102,
            "askerId": 959,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra classe dichiarata \"abstract\" e non? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6346,
          "asker": {
            "courseId": 102,
            "askerId": 1002,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Non ho capito l'utilizzo del modificatore abstract",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": "Overriding/overloading "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6338,
          "asker": {
            "courseId": 102,
            "askerId": 1021,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le regole standard per denominare i metodi di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            },
            {
              "keyword": " Costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6351,
          "asker": {
            "courseId": 102,
            "askerId": 1030,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze per quanto riguarda la gestione della memoria tra C++ e Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Gestione della memoria"
            },
            {
              "keyword": " Gestione della memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6262,
          "asker": {
            "courseId": 102,
            "askerId": 948,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In che cosa consiste l'ereditarietà degli oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6374,
          "asker": {
            "courseId": 102,
            "askerId": 1051,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Se viene definita una variabile con visibilità \"public\" all'interno di una classe, essa potrà comunque essere visibile al di fuori della classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6325,
          "asker": {
            "courseId": 102,
            "askerId": 932,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "La classe 'padre' e la classe 'derivata' devono essere definite nello stesso file?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "classe padre"
            },
            {
              "keyword": " classe derivata"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6754,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1097,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Non necessariamente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8501,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8488,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6681,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1035,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, non necessariamente. \r\nNel caso siano entrambe public è obbligatorio avere due file separati, uno col nome della classe 'padre' e l'altro col nome della classe 'figlio', in quanto in un file ci può essere al più una classe pubblica.\r\nSe invece sono entrambe private, o lo è una sola delle due, possono essere definite anche nello stesso file.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8500,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8489,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6402,
          "asker": {
            "courseId": 102,
            "askerId": 971,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Dare una definizione esaustiva di OVERLOADING delineando le differenze e i differenti contesti di utilizzo con l'OVERRIDING e farne un esempio esplicativo (anche non mediante l'utilizzo di codice).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overloading"
            },
            {
              "keyword": " overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6326,
          "asker": {
            "courseId": 102,
            "askerId": 1031,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Dopo aver descritto brevemente il concetto di ereditarietà, spiegare come l'estensione di un classe tramite questo processo possa risultare strutturale e/o comportamentale, spiegandone le differenze. Completare le spiegazioni con un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6347,
          "asker": {
            "courseId": 102,
            "askerId": 1059,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende esattamente per costruttore di una pila/coda?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "COSTRUTTORI"
            },
            {
              "keyword": "COSTRUTTOR"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6376,
          "asker": {
            "courseId": 102,
            "askerId": 965,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e quali sono i modificatori in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": "  Classi"
            },
            {
              "keyword": "  Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6383,
          "asker": {
            "courseId": 102,
            "askerId": 1075,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una classe astratta e qual è la sua utilità nella programmazione ad oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6306,
          "asker": {
            "courseId": 102,
            "askerId": 1098,
            "courseFinalScore": 14
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Illustra i concetti di overriding e overloading (spiegando anche in cosa consiste la firma di una funzione).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6706,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'overloading consente di definire in una stessa classe più metodi aventi lo stesso nome, ma che differiscano nella firma, cioè nella sequenza dei tipi dei parametri formali. È il compilatore che determina quale dei metodi verrà invocato, in base al numero e al tipo dei parametri attuali. L'overriding, invece, consente di ridefinire un metodo in una sottoclasse: il metodo originale e quello che lo ridefinisce hanno necessariamente la stessa firma, e solo a tempo di esecuzione si determina quale dei due deve essere eseguito.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8066,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8100,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8400,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6644,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1055,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Ci si trova in presenza di overridding nel momento in cui si ereditano dei metodi da altre classi. Quando ad esempio mi trovo in presenza di una classe \"punto 3d\" che eredita i metodi da \"punto 2d\", si parlerà di overriding nel momento in cui potrò definire in \"punto 3d\" semplicemente come una estensione di \"punto 2d\". Sarà fondamentale richiamare subito con \"super\" i valori assegnati alla classe dalla quale eredito.\r\nL'overloading è il fenomeno che si presenta quando esistono una serie di funzioni con lo stesso nome ma con la possibilità di accettare un numero di argomenti diversi, ad esempio: ciao(int x, int y) e ciao(int x, int y, int z).\r\nLa firma rappresenta il numero minimo di informazioni utili per utilizzare un metodo e alla definizione univoca di questo. Solitamente la firma è costituita dal nome del metodo, i tipi e i valori che si danno in input (identificati in modo generico) e il tipo di output.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8396,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8070,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8102,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6756,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 982,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il concetto di overriding è un operazione molto importante e utile nella programmazione ad oggetti. Consiste nel partire da una classe già esistente per crearne una nuova con dei metodi ereditati da quella di partenza e riutilizzati per nuove necessità. Un problema in cui si può incorrere è che se in una sottoclasse si definiscono i metodi creati nella classe, in modo sbagliato (es. Dimenticarsi una maiuscola), il compilatore non darà errore in quanto non intuisce da solo che si sta utilizzando l'override. \r\n\r\nIl concetto di overloading definisce l'operazione di creare una famiglia di subroutine aventi lo stosso nome che però possono accettare diverse signature (argomenti, firme). La famiglia può caricare diverse funzioni, operatori e funzioni. Il problema in cui si può incorrere è quello di creare diverse funzioni con gli stessi parametri allo scopo di restituire risultati diversi. Per quanto riguarda le funzioni ricorsive, l'oveloading non influisce sull'esecuzio",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8397,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8069,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8101,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6674,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 941,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "La firma di una funzione è l'insieme di: NOME metodo-NUMERO e TIPO parametri-TIPO valore restituito.\r\n\r\nOVERLOADING: (cit. slide)\r\nFunzioni con uguale nome e diversa firma possono coesistere.\r\nEs:\r\nmove(int dx, int dy)\r\nmove(int dx, int dy, int dz)\r\n\r\n\r\nOVERRIDING: (cit. slide)\r\nRidefinizione di una funzione in una sottoclasse (mantenendo immutata la firma).\r\nEs:\r\nCLASSE Point\r\npublic String toString() { return \"(\"+x+\",\"+y+\")\";  }\r\n\r\nCLASSE NamedPoint (eredita variabili e funzioni da Point)\r\npublic String toString() { return name + super.toString(); } \r\n/* Richiama il metodo \"toString()\" della classe Point modificando le istruzioni del metodo. Da notare che la firma rimane uguale al metodo della classe Point. */",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8398,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8068,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8104,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6656,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1070,
                "courseId": 102,
                "courseFinalScore": 10
              },
              "answerText": "Il concetto di overriding di un metodo è legato alla gerarchia ereditaria delle classi. Quando si definisce una nuova classe è possibile definirla come estensione di una classe precedentemente definita (superclasse o padre), tramite la parola chiave extends. Dire che una classe ne estende un'altra significa che la sottoclasse in questione eredita tutte le proprietà che definivano il padre eccetto quelle esplicitamente ridefinite. L'overriding è la definizione di una funzione nella sottoclasse che ha la stessa firma di una funzione presente nella superclasse che risulta quindi sovrascritta. \r\nIl meccanismo di overloading consente che funzioni con uguale nome e diversa firma coesistano. \r\nLa firma di una funzione è data dal nome della funzione e dall'insieme dei parametri tipizzati che prende in input. In java due funzioni sono uguali (e non possono coesistere) se hanno la stessa firma. In C++,  per esempio, funzioni con uguale nome sono considerate uguali (non esiste overloading).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8399,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8103,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8067,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6334,
          "asker": {
            "courseId": 102,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "I metodi di quale classe vengono ereditati da una nuova classe definita senza dichiarare esplicitamente la classe di cui è estensione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " ereditarietà"
            },
            {
              "keyword": " classe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6363,
          "asker": {
            "courseId": 102,
            "askerId": 946,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In C abbiamo visto che non è necessario eseguire alcun \"return\" in una funzione che utilizza e modifica i valori contenuti in un array in quanto quest'ultimo viene già passato per riferimento. In Java, di conseguenza, siamo costretti ad usare sempre il \"return\". Ma se si necessita di un ritorno di più valori, non potendo usare variabili di supporto passate come puntatori, come posso fare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Gestione della memoria"
            },
            {
              "keyword": " Gestione della memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6333,
          "asker": {
            "courseId": 102,
            "askerId": 985,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "E' obbligatorio svolgere l'attività di garbage collection in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "garbage collection"
            },
            {
              "keyword": " garbage collection"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6680,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1101,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il meccanismo di \"garbage collection\" è un'attività automatica necessaria per liberare porzioni di memoria (nell'heap) durante l'esecuzione di un programma. Questo meccanismo ci permette di non preoccuparci dell'eliminazione degli oggetti creati e non più utilizzati dal programma come accade invece in altri linguaggi di programmazione (per esempio C++).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8604,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8618,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8164,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8461,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8266,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6636,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 970,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, la virtual machine di java si occupa della gestione della memoria, andando ad eliminare gli elementi presenti nel garbage collector in caso di necessità di spazio, ovvero gli elementi che non sono più \"puntati\" all'interno del programma, che quindi non servono più.\r\né comunque possibile andare a \"forzare\" questa operazione con il comando \"System.gc()\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8462,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8616,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8605,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8165,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8265,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6751,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 954,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Gli oggetti allocati dinamicamente su uno heap in Java vengono distrutti attraverso un meccanismo automatico di garbage collection.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8263,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8617,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8602,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8458,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8168,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6623,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 949,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Il garbage collection in Java è necessario per evitare memory leaks, in quanto non è previsto nessun comando per deallocare la memoria non più necessaria.\r\nJava prevede in automatico un meccanismo di garbage collection invocato automaticamente ma, volendo, è possibile forzare il garbage collector invocando System.gc().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8166,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8603,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8262,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8460,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8614,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6649,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1019,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, perché in Java c' è già un garbate collection che lavora automaticamente. Si può comunque utilizzarlo manualmente all' interno del programma e quindi renderlo più efficiente nei punti che vogliamo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8459,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8615,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8606,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8167,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8264,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6254,
          "asker": {
            "courseId": 102,
            "askerId": 1001,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando una classe eredita il metodo main dalla superclasse, si ottengono due classi, ognuna con un main che può essere soggetto ad override. Quindi, quando si esegue il programma, da quale dei due main inizia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6310,
          "asker": {
            "courseId": 102,
            "askerId": 962,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra overriding e overloading?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6359,
          "asker": {
            "courseId": 102,
            "askerId": 942,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il ruolo dei metodi distruttori e costruttori e in che modo semplificano il codice rispetto all'uso di normali funzioni ad hoc?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Costruttori"
            },
            {
              "keyword": " Costruttori"
            },
            {
              "keyword": " Distruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6281,
          "asker": {
            "courseId": 102,
            "askerId": 983,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste e a cosa serve l'overloading di un metodo ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6257,
          "asker": {
            "courseId": 102,
            "askerId": 1064,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come deve essere organizzato il codice ed i files quando andiamo a sfruttare il concetto di ereditarieta' ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6392,
          "asker": {
            "courseId": 102,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando utilizziamo l'Overloading e per quale motivo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "OVERLOADING"
            },
            {
              "keyword": "OVERLOADING"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6287,
          "asker": {
            "courseId": 102,
            "askerId": 1034,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "class Point {\r\n  int x, y;\r\n\r\n Point(int x, int y) {\r\n    this.x = x;\r\n    this.y = y;\r\n }\r\n}\r\n\r\nclass NamedPoint extends Point {\r\n  public String name;\r\n\r\n  NamedPoint(int x, int y, String name) {\r\n     super(x,y);\r\n     this.name = name;\r\n  }\r\n}\r\n\r\nConsiderando il codice qui sopra cosa esegue il codice qui sotto? E' corretto?\r\n\r\nNamedPoint np = new NamedPoint(5, 3, \"Pluto\");\r\nPoint p = (Point)np;\r\nSystem.out.println(p.name);\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Costruttori"
            },
            {
              "keyword": " Cast"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6329,
          "asker": {
            "courseId": 102,
            "askerId": 1054,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il principale vantaggio nell'utilizzo dell'ereditarietà nella programmazione OOP?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6342,
          "asker": {
            "courseId": 102,
            "askerId": 949,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il comando super()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6275,
          "asker": {
            "courseId": 102,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra overloading e overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": "Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6344,
          "asker": {
            "courseId": 102,
            "askerId": 1071,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo l'ereditarietà permette di avere codice piu mantenibile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6669,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1106,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché permette di creare all'interno del codice una gerarchia delle classi per la quale non si ha più un insieme di classi distinte, ma classi che ereditano parametri da altre, rendendo così i vari pezzi di codice più ordinati essendo collegati tra loro. Questo meccanismo permette di avere un codice più user-friendly quindi più facile da mantenere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8244,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8172,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8684,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8105,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6730,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 993,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Grazie all'ereditarietà si possono correggere in maniera più agevole i bug. Infatti, la correzione di un bug in una sottoclasse produce automaticamente la stessa correzione anche nella sua superclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8683,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8106,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8174,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8245,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6762,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1089,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Poiché, insieme al polimorfismo, una sottoclasse eredita il codice della superclasse e garantisce anche che tutto il codice precedentemente scritto sia in grado, in modo implicito,  di manipolare oggetti della sottoclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8173,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8107,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8246,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8682,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6278,
          "asker": {
            "courseId": 102,
            "askerId": 953,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Si hanno una classe Padre e una classe Figlio. Nella classe Padre è definito il costruttore Padre() mentre nella classe Figlio è definito il costruttore Figlio(). Cosa succede se nella sottoclasse Figlio ometto l'istruzione super()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "super"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6337,
          "asker": {
            "courseId": 102,
            "askerId": 1038,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Correggere e spiegare  gli errori del codice seguente:\r\npublic class NamedPoint extends Point {\r\n   String name;\r\n\r\n   public NamedPoint(x, y, name) {\r\n   name=name;\r\n   super(x,y);\r\n}\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6711,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1031,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il codice descrive una nuova classe NamedPoint derivata dalla classe Point (inclusa nelle librerie standard di Java) aggiungendo ad essa una stringa contenente il nome da associare al punto.\r\n\r\nIl costruttore così definito è errato per tre motivi:\r\n- Non è stato definito il tipo dei parametri\r\n- C'è un errore nell'assegnazione di name: sarebbe da correggere in this.name = name\r\n- Il costruttore della classe padre dev'essere invocato come prima istruzione nel costruttore della classe figlia. Di conseguenza super(x,y); deve esser richiamato prima di this.name=name;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8270,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8572,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8096,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8307,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6641,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1010,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "1)Nel costruttore vanno dichiarati i tipi delle variabili int x,int y,String name.\r\n\r\n2)Il costruttore della classe superiore \"super(x,y);\" va richiamato prima di fare qualsiasi altra istruzione.\r\n\r\n3)Sempre all'interno del costruttore va distinta la variabile \"name\" di ingresso da quella locale della classe che viene identificata con \"this.name\" dove this indica la classe stessa.\r\n\r\nSOLUZIONE:\r\n\r\npublic class NamedPoint extends Point{\r\n   String name;\r\n\r\n   public NamedPoint(int x,int y,String name){\r\n      super(x,y);\r\n      this.name=name;\r\n   }\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8269,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8574,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8308,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8095,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6743,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1052,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "L'istruzione super(x,y) deve essere la prima all'interno del costruttore, perchè il compilatore deve essere sicuro che non vengano chiamati metodi della classe madre che richiedono variabili non ancora settate.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8306,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8099,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8268,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8571,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6716,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1020,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "errori:\r\n1)il costruttore richiede 3 elementi di cui però non viene indicato il tipo, questo porta a 3 errori in fase di compilazione, correzzione: tipizzare le variabili\r\n2)errore sintattico name=name; non va a modificare la variabile interna alla classe che resta nulla.\r\ncorrezzione: utilizzare this.name=name; in questo modo il contenuto della variabile name passata come paramentro deve viene posto all'interno della variabile name della classe\r\n3)errore in fase di compilazione è porre il super come seconda istruzzione del costruttore,deve essere la prima perchè altrimenti viene richiamato il costruttore a 0 parametri della superclasse.\r\nabbiamo questi tre errori se prendiamo come ipotesi il fatto di avere una classe nella stessa cartella chiamata Point correttamente compilata.\r\nnel caso in cui non la avessimo (nel testo del problema non viene menzionata) avrem un'altro errore in fase di compilazione, il compilatore non troverà nessuna classe Point da cui estendere quella attuale",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8304,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8097,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8267,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8575,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6724,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 943,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": ".Nel codice sono presenti i seguenti errori:\r\n1)Nel costruttore di NamedPoint mancano i tipi dei parametri, 'x', 'y' e 'name' potrebbero essere qualsiasi cosa, quindi è necessario specificare di che tipo essi sono.\r\n2)La chiamata del super() deve essere sempre la prima istruzione in un costruttore quando si estende una classe, quindi non può essere messa per seconda come in questo caso.\r\n3)E' necessario specificare di quale 'name' si sta parlando, dato che non si sa quale sia la variabile di istanza e quale invece è la variabile locale, parametro del costruttore. Si può risolvere semplicemente mettendo un 'this.' prima della variabile di istanza, in modo da distinguerla dall'altra (this.name=name;).\r\n\r\nIl codice corretto risulta quindi: \r\n\r\npublic class NamedPoint extends Point {\r\n   String name;\r\n\r\n   public NamedPoint(int x, int y, String name) {\r\n   super(x,y);\r\n   this.name=name;\r\n}\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8305,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8573,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8271,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8098,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6377,
          "asker": {
            "courseId": 102,
            "askerId": 1089,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "L'ereditarietà ha come scopo l'aggiunta di variabili e/o nuovi metodi e/o modifiche o semplifica anche la lettura del codice da parte del compilatore/programmatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6299,
          "asker": {
            "courseId": 102,
            "askerId": 939,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare quali sono gli effetti delle seguenti istruzioni in un programma Java e sottolinearne le differenze:\r\n\r\n- System.gc();\r\n- System.runFinalization();",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            },
            {
              "keyword": " Distruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6369,
          "asker": {
            "courseId": 102,
            "askerId": 1067,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'override e quale sintassi richiede?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6264,
          "asker": {
            "courseId": 102,
            "askerId": 1079,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che il meccanismo dell'ereditarietà porta ai programmatori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6272,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è la Garbage Collection e perché non è stata implementata nel C/C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6317,
          "asker": {
            "courseId": 102,
            "askerId": 1025,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di creare una sottoclasse che eredita le variabili di istanza e i metodi da una superclasse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6295,
          "asker": {
            "courseId": 102,
            "askerId": 1013,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi la differenza fra \"overloading\" e \"overriding\" dei metodi di una classe.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6761,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La funzione di overloading dà la possibilità di creare due o più metodi con lo stesso nome, ma devono avere parametri diversi. Questo è utile per adeguare un metodo a contesti di utilizzo differenti. Al momento dell'invocazione viene scelta la funzione in base al parametro attuale. Due metodi con lo stesso nome possono infatti coesistere in una classe se restituiscono lo stesso tipo e hanno firme differenti. L'overriding invece è la possibilità di avere metodi con la stessa firma (firma = nome + parametri), ma con un'implementazione diversa. Questo permette la ridefinizione di una funzione in una sottoclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8619,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8443,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8206,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8358,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6766,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'Overloading si ha quando ci sono due o più metodi nella stessa classe con lo stesso nome ma argomenti diversi.\r\nOverriding significa avere due metodi con gli stessi argomenti ma differenti implementazioni, un metodo sta nella Parent class mentre l'altro sta in un \"child\" o classe derivata.\r\nL'Overloading avviene a compile-time mentre l'Overriding a run-time;\r\nSi può fare Overloading su metodi statici, ma non Overriding.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8357,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8442,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8205,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8622,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6661,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1098,
                "courseId": 102,
                "courseFinalScore": 14
              },
              "answerText": "In entrambi i casi si parla di polimorfismo della programmazione ad oggetti. \r\nUn metodo è caratterizzato dal nome e dai parametri e si parla di overloading quando in una classe si hanno due metodi con lo stesso nome ma con numero e/o tipo di parametri differenti i quali infatti vengono riconosciuti come diversi dal programma. Invece si parla di overriding quando all'interno di una sottoclasse si ha la ridefinizione di una funzione, la quale \"copre\" la definizione fatta precedentemente nella classe padre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8204,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8441,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8621,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8355,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6659,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 965,
                "courseId": 102,
                "courseFinalScore": 17
              },
              "answerText": "Per overloading si intende la coesistenza di funzioni che hanno un nome identico ma una firma diversa, (i parametri di ingresso); ad esempio:\r\n- riempiSecchio(int litri, int fluido);\r\n- riempiSecchio(int litri, int fluido, int tempFluid);\r\nPer overriding si intende la \"sovrascrittura\" di un metodo della Classe Madre in una sua sottoclasse, dove per sovrascrittura si intende una vera e propria redifinizione. Un esempio tipico è la sovrascrittura del metodo toString(), (che è circa uno standard di molte classi).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8356,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8207,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8444,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8620,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6331,
          "asker": {
            "courseId": 102,
            "askerId": 1050,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando di classi in Java, che differenza c'è tra estensioni Strutturali e Comportamentali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6309,
          "asker": {
            "courseId": 102,
            "askerId": 1096,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo nel linguaggio java esiste un padre universale (che in c++ non esiste), chiamato object, assegnato di default ad ogni classe pubblica senza genitore, quali sono i vantaggi della sua esistenza?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà "
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6380,
          "asker": {
            "courseId": 102,
            "askerId": 1055,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè si dichiara \"final\" un metodo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6328,
          "asker": {
            "courseId": 102,
            "askerId": 1037,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si caratterizza una classe dichiarata \"abstract\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": "Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6280,
          "asker": {
            "courseId": 102,
            "askerId": 1027,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Oggetti e classi hanno la medesima definizione?\r\nIndicare in modo completo le loro somiglianze e/o differenze.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6646,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 961,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza che c'è fra oggetto e classe e uguale a quella che c'è fra tipo di dato e dato . \r\nLa classe definisce le caratteristiche (metodi e variabili) che un oggetto possiede, mentre l'oggetto è un istanza di una classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8344,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8640,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8473,
                  "rater": {
                    "raterId": 971,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8487,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8479,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6622,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1038,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, non hanno la medesima definizione, in quanto gli oggetti sono istanze delle classi: mentre la classe definisce un tipo di dato ed è composta da attributi e metodi, un oggetto è una variabile del tipo di dato definito dalla classe. Ad esempio se dichiaro una classe \"Persona\", un possibile oggetto potrebbe essere \"Mario\" oppure \"Giovanni\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8476,
                  "rater": {
                    "raterId": 971,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8347,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8477,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8638,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8484,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6689,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 790,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "la differenza fra classe ed oggetto è la stessa che c'è fra il tipo di dato ed il dato stesso. La classe è la descrizione di un tipo di dato cioè specifica i metodi e le variabili che quel tipo di dato possiede. L'oggetto è invece un'istanza della classe: quando istanziamo una variabile definendola di una certa classe, creiamo un oggetto di quella classe rappresentato dal nome della variabile che abbiamo istanziato.\r\n\r\nes: Oggetto -> System.out.println(\"ciao\"); utilizza il metodo println proprio dell'oggetto System.out\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8637,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8485,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8478,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8345,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8474,
                  "rater": {
                    "raterId": 971,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6639,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1065,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe è la descrizione astratta di un tipo di dato: specifica i metodi e le variabili che quel tipo di dato possiede. Un oggetto invece è un'istanza della classe: eredita dalla classe tutti gli attributi definiti in essa ed è modificabile tramite i metodi definiti sempre all'interno della classe. Classi ed oggetti si somigliano perchè hanno gli stessi attributi e gli stessi metodi ma l'oggetto è l'entità realmente modificabile ed utilizzabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8639,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8346,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8480,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8486,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8475,
                  "rater": {
                    "raterId": 971,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6371,
          "asker": {
            "courseId": 102,
            "askerId": 984,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "All'interno di una sottoclasse, come si chiama il metodo costruttore di una superclasse? Dove va chiamato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6394,
          "asker": {
            "courseId": 102,
            "askerId": 940,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché per essere certi che vengano chiamati i metodi finalize() di una classe, occorre\r\nchiamare System.runFinalization() subito DOPO System.gc()? Non sarebbe sufficiente chiamare solamente System.gc(), il quale, in caso di assenza di referenze per un istanza di oggetto, provvederebbe a deallocarlo (chiamando prima della deallocazione eventuali metodi final() della classe)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6749,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1047,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "Non è sufficiente invocare System.gc() perchè il garbage collector, per una questione di efficienza, potrebbe non deallocare immediatamente un oggetto senza referenza, ma agire in un secondo momento. Quindi per essere sicuri che un oggetto senza referenza venga deallocato in un momento preciso del programma, bisogna prima invocare il garbage collector (che individua gli oggetti da deallocare, senza magari deallocarli subito) e subito dopo System.runFinalization() che fa in modo che vengano eseguiti subito i finalize() per gli oggetti da deallocare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8360,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8613,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8677,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8417,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6654,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1027,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per attivare il garbage collector è sufficiente ma non necessario chiamare System.gc().  Nin è necessario perché java chiama automaticamente questo metodo. Nel caso in cui il programmatore ritenga necessaria la chiamata di System.gc() allora è bene utilizzare anche System.runFinalization() per essere sicuri che il metodo finalize() venga chiamato. Se System.runFinalization() non viene chiamato si corre il rischio che il metodo finalize() non venga chiamato dal sistema, magari a causa della terminazione del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8676,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8359,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8416,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8611,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6757,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1094,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando il GC incontra degli oggetti che non sono più referenziati ma che contengono un \"finalizer\" non li dealloca immediatamente, ma li inserisce in una lista di oggetti che attendono di essere finalizzati. In ogni caso, non è detto che il \"finalizer\" venga chiamato. Il metodo System.runFinalization() SUGGERISCE al sistema di chiamare i \"finalizer\" degli oggetti che ancora attendono di essere finalizzati. Ho evidenziato la parola \"suggerisce\" in quanto non è certo che i metodi vengano chiamati, così come non è certo che il GC parta quando chiamiamo il metodo System.gc(). L'unico modo per essere sicuri che essi vengano chiamati è chiamarli manualmente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8418,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8361,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8612,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8678,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6305,
          "asker": {
            "courseId": 102,
            "askerId": 986,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali tipi di estensioni di ereditarietà ci sono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6679,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1029,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I tipi di estensioni di ereditarietà sono due: strutturali, consistenti nell'aggiunta di variabili di istanza, e/o comportamentali, caratterizzati dall'aggiunta di nuovi metodi e/o dalla modifica di metodi esistenti",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8524,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8565,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8258,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8435,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6704,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1063,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le estensioni di ereditarietà possono essere di tipo strutturale oppure di tipo comportamentale: strutturale quando aggiungo variabili di istanza, comportamentale quando aggiungo dei nuovi comportamenti, cioè aggiungo dei nuovi metodi o modifico i metodi esistenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8434,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8566,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8523,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8259,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6330,
          "asker": {
            "courseId": 102,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare brevemente la differenza fra overriding e overloading con l'aiuto di un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6303,
          "asker": {
            "courseId": 102,
            "askerId": 1072,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qule regola governa le relazioni tra superclasse e classe figlia per quanto riguarda i livelli di accesso? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "superclasse"
            },
            {
              "keyword": " accesso"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6362,
          "asker": {
            "courseId": 102,
            "askerId": 988,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa accade se non si trova il metodo toString nel blocco di una classe? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "OVERRDING"
            },
            {
              "keyword": " OVERRIDING"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6638,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 963,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Ogni classe estende implicitamente la classe Object. Nel caso in cui venga chiamato il metodo toString() di una classe che non implementa esplicitamente tale metodo, verrà chiamato il metodo della classe padre da cui essa è estesa. Se la classe in questione non deriva da nessun'altra verrà invocato il metodo toString() della classe Object. Di default il metodo restituisce una variabile di tipo String contenente la testuale rappresentazione della classe. La stringa rappresentativa è formata dal nome della classe, il carattere '@' e la rappresentazione esadecimale dell'hash code dell'oggetto.\r\n\r\nAd ogni modo, è possibile sovrascrivere il metodo toString() e usare una propria implementazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8122,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8163,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8180,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8279,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8081,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6694,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 958,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se in una classe, non è stato dichiarato il metodo toString, quando quest'ultimo viene richiamato, il programma utilizzerà il metodo toString di default in java.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8183,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8082,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8283,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8124,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8162,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6718,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 944,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo toString(), eseguito implicitamente con il comando \"System.out.println(p);\", dove p è un'istanza della classe considerata, contiene le istruzioni necessarie alla rappresentazione in output dell'oggetto p. Se non presente nel blocco della classe in questione sarà ricercato nella classe padre, quindi, se assente ancora una volta, nella superclasse della classe padre e così via, sino ad arrivare eventualmente alla superclasse comune a tutte le classi in Java, cioè la classe Object. Quest'ultima infatti comprende un metodo standard toString() che implica la stampa del package, della classe e di un identificatore relativi all'oggetto in questione. In conclusione, dunque, sarà eseguito il primo metodo toString() individuato nella catena di relazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8282,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8079,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8121,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8159,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8179,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6655,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 999,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Accade che ad esempio dell'oggetto non si possono stampare i valori delle variabili d'istanza, e l'intestazione. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8160,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8280,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8182,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8083,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8123,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6688,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1040,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Viene chiamato il metodo toString superclasse. Se quella classe non estende nessuna classe allora verrà chiamato il metodo toString della classe Object (che è la superclasse di tutte le classi).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8181,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8281,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8080,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8120,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8161,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6370,
          "asker": {
            "courseId": 102,
            "askerId": 1095,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "perchè l'input in java è così complicato, non c'è un modo di renderlo più semplice?\r\ne cosa si intende per subclassing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "input "
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6368,
          "asker": {
            "courseId": 102,
            "askerId": 1029,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quante volte viene chiamato il metodo \"Costruttore\" durante la creazione dell'oggetto ad esso legato? E quando? Quali sono le differenze rispetto ad un altro metodo della classe? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Costruttori"
            },
            {
              "keyword": " Costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6283,
          "asker": {
            "courseId": 102,
            "askerId": 952,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra overriding ed overloading ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6294,
          "asker": {
            "courseId": 102,
            "askerId": 977,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "in cosa consiste l'ereditarietà?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6307,
          "asker": {
            "courseId": 102,
            "askerId": 1083,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi dell' uso da parte di un linguaggio del \"garbadge collection\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Gardbadge Collection"
            },
            {
              "keyword": " Garbadge Collection "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6690,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 942,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "La \"garbage collection\" ha il ruolo di rilevare quali aree di memoria allocate dal programma non vengono più utilizzate e possono essere dunque liberate per fare spazio ad nuove allocazioni. Ha il vantaggio di essere quasi completamente automatica e di evitare quindi i cosiddetti \"memory leak\" che si hanno comunemente in altri linguaggi per la mancata o scorretta deallocazione della memoria. Essendo tuttavia automatica, il programmatore ha poco controllo su di essa, ad esempio qualora si volesse forzare l'avvio della \"garbage collection\" essa si riserverebbe ugualmente la scelta di effettuare il suo ciclo di pulizia o meno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8669,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8448,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8490,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8090,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6687,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 939,
                "courseId": 102,
                "courseFinalScore": 30
              },
              "answerText": "Il principale vantaggio della \"garbage collection\" consiste nel fatto che la deallocazione viene eseguita automaticamente dal computer e non è più quindi priorità del programmatore occuparsi della suddetta attività manualmente; molti degli errori tipici di allocazione/deallocazione di memoria vengono così eliminati (in particolare alcuni problemi di \"memory leaks\" e il problema dei \"dangling pointers\" cessano di esistere).\r\nTra gli svantaggi invece si ha, prima di tutto, che non si può prevedere il momento in cui avverrà la \"garbage collection\" (si ricordi sotto questo punto di vista che l'istruzione \"System.gc()\" semplicemente SUGGERISCE ma non obbliga il PC ad effettuare l'attività di deallocazione) quindi il programmatore non ha il pieno controllo del programma. Inoltre essa consuma grandi risorse di calcolo, quindi potrebbe generare diminuzioni delle prestazioni durante l'esecuzione del programma.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8091,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8492,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8670,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8449,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6726,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1104,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Come vantaggio evita possibili errori come i memory leak ed evita al programmatore la gestione manuale della memoria, come svantaggio ha una diminuzione delle prestazioni correlata al lavoro in più che deve svolgere la cpu",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8491,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8671,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8089,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8450,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6274,
          "asker": {
            "courseId": 102,
            "askerId": 998,
            "courseFinalScore": 11
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "C'è un caso in cui, anche se Garbage Collection viene richiesta esplicitamente tramite System.gc(), questa non viene eseguita?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage Collection"
            },
            {
              "keyword": " Garbage Collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6349,
          "asker": {
            "courseId": 102,
            "askerId": 1061,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono i costruttori?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Costruttori "
            },
            {
              "keyword": "Costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6397,
          "asker": {
            "courseId": 102,
            "askerId": 1035,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Con l'ereditarietà una classe figlio eredita dalla classe padre tutti i metodi e le variabili, ma supponiamo che nella classe figlio non ci sia bisogno di un metodo o di una variabile, c'è un modo per evitare che venga ereditata e/o disabilitata oppure semplicemente la si ignora?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6643,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 980,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per evitare che la sottoclasse utilizzi metodi o variabili della classe padre è sufficiente che questi vengano impostati come privati nella classe da cui vengono ereditati, in questo modo la classe derivata non può visualizzarli. Questo ovviamente però può creare problemi se dalla stessa superclasse derivano più classi diverse, ed in alcune di queste si fa uso di alcuni metodi e parametri che altre invece non usano, in tal caso può quindi essere preferibile semplicemente ignorarle nelle sottoclassi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8406,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8216,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8138,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8497,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8532,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6721,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 977,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "si ignora semplicemente la possibilità di utilizzare il dato metodo o variabile",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8139,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8498,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8533,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8215,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8407,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6697,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1011,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nell'uso dell'ereditarietà in un linguaggio Object Oriented, NON è possibile che una classe figlia elimini o disabiliti i metodi e le variabili della classe madre. Questo andrebbe infatti a scontrarsi con quel principio dell'OOP che afferma che ogni volta che si faccia uso di un oggetto di una classe madre, esso debba poter essere sostituito con un oggetto di una delle classi figlie.\r\n Esiste comunque la possibilità (sto parlando ora in maniera assolutamente qualitativa) di \"adattare\" i metodi della classe  madre alle esigenze della classe figlia.\r\n Dunque, una classe figlia potrà avere solo \"qualcosa in più\" o \"qualcosa di riadattato\" rispetto alla classe madre, ma MAI \"qualcosa in meno\".\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8140,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8499,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8405,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8213,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8534,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6676,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1028,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Se nella classe figlio non ho bisogno di ereditare un metodo o una proprietà posso cambiare la visibilità del medesimo in \"private\". Così facendo il metodo o la proprietà è attiva solo nella classe dove è definita.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8531,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8408,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8496,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8141,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8214,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6277,
          "asker": {
            "courseId": 102,
            "askerId": 527,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Overloading e Overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6357,
          "asker": {
            "courseId": 102,
            "askerId": 989,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali compiti svolti dal garbage collector di Java devono essere implementati manualmente in linguaggio C++ ad oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            },
            {
              "keyword": " Java"
            },
            {
              "keyword": " C++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6395,
          "asker": {
            "courseId": 102,
            "askerId": 1101,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa si riferiscono i termini \"abstract\" e \"final\"? Cosa comporta il loro utilizzo? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " final"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6286,
          "asker": {
            "courseId": 102,
            "askerId": 1040,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza fra overriding e overloading? Sono obbligato ad estendere una classe per fare overriding? E per fare overloading?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6745,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1030,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il fenomeno di overriding si verifica quando in una sottoclasse andiamo a sovrascrivere un metodo ereditato da una superclasse, cambiandone il corpo. In questo caso, quando si applica tale metodo a un oggetto della sottoclasse, viene eseguita la nuova realizzazione del metodo e non quella originale della superclasse. Inoltre quando si vuole ridefinire un metodo in una sottoclasse è necessario prestare attenzione al fatto che il nome del metodo e i tipi dei parametri siano esattamente gli stessi di quelli del metodo della superclasse. Il fenomeno di overloading invece ci permette di avere all'interno di uno stesso programma più metodi con lo stesso nome ma con parametri diversi, ciascuno con il proprio codice. Per fare un overriding è necessario estendere una classe a meno che non vogliamo ridefinire dei metodi che sono contenuti all'interno della superclasse Object, in tal caso non occorre estendere la classe. Per fare overloading invece non è necessario estendere una classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8314,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8419,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8261,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8472,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8582,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6703,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 998,
                "courseId": 102,
                "courseFinalScore": 11
              },
              "answerText": "All' interno dl programma si ha overloading quando si hanno delle funzioni che, pur avendo lo stesso nome, restano distinte tra di loro poichè hanno firma diversa. Ad esempio: f(int n) {...} ha firma diversa rispetto a f(int n, int s) {...} anche se hanno lo stesso identico nome. Si ha overriding invece quando una funzione viene semplicemente ridefinita in una sottoclasse, mantenendo invariata la firma. Per fare overriding occorre estendere la classe, mentre per fare overloading i diversi metodi possono essere definiti all' interno della stessa classe. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8581,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8420,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8315,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8471,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8260,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6390,
          "asker": {
            "courseId": 102,
            "askerId": 1011,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cos'è la cosiddetta \"garbage collection\", specificando quale potrebbe essere un problema del suo uso in linguaggi di programmazione che abbiano applicazione industriale.\r\nSpiegare inoltre come funziona la \"garbage collection\" in Java, specificando almeno un comando ad essa collegato. Dire infine per quale ragione un linguaggio come C++ non utilizza l'espediente della \"garbage collection\".",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GARBAGE COLLECTION"
            },
            {
              "keyword": " GARBAGE COLLECTION"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6396,
          "asker": {
            "courseId": 102,
            "askerId": 951,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come posso sapere, in un programma Java, quando (o con che frequenza) il Garbage collection mi dealloca la memoria allocata ma non utilizzata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": "Garbage collection"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6647,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 974,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La zona di memoria che contiene i dati allocati dinamicamente si chiama heap. Per costruzione Java non offre la possibilità di deallocare in modo esplicito (come avviene invece in altri linguaggi come in C++) ciò che è stato allocato nella heap, riempiendo molto velocemente la memoria. Il compito del Garbage collection (Gc) è quello di liberare la memoria occupata dagli oggetti non più referenziati e di combattere la seguente frammentazione della memoria.\r\nSpesso il Gc viene effettuato quando la memoria sta finendo. La JVM però non garantisce quando il Gc entrerà in esecuzione per questo motivo esiste il comando System.gc(). Da notare che anche con questo comando non è detto che verrà effettuato un Gc, dipende dalla JVM e da come è ottimizzato.\r\nE' da ricordare che alla fine di un programma la memoria viene autmaticamente liberata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8454,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8425,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8586,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8289,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6769,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1042,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Non puoi saperlo. In java la deallocazione della memoria è gestita dalla Java Virtual Machine, che implementa una propria tecnica di garbage collection (e differenti JVM possono utilizzare differenti algoritmi o differenti implementazioni della garbage collection).\r\nGli unici strumenti disponibili al programmatore sono i metodi statici System.gc() e Runtime.gc() che consentono di eseguire il garbage collector in un preciso istante scelto dal programmatore. Tuttavia il sistema può decidere di eseguire il garbage collector anche in un altro momento, che è imprevedibile dal programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8428,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8453,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8291,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8584,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6717,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 988,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il garbage collector dealloca la memoria, appunto, una volta che non viene più utilizzata. Ergo quando si esce da un blocco e non vi sono parametri da passare, allora le sue variaibli vengono deallocate. In caso contrario prima vengono passati i parametri e poi vengono deallocate anche quelle variabili. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8452,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8288,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8583,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8426,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6753,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 946,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Di default in Java il garbage collector viene invocato alla fine di ogni esecuzione di un programma per deallocare la memoria non più necessaria. Nel caso io volessi invocarlo a mio comando in modo da gestire personalmente la sua esecuzione posso farlo ogni qual volta lo desideri utilizzando il comando System.gc(); il quale, per l'appunto, viene usato per invocare il GC a mio scelta nel caso ne avessi bisogno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8427,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8290,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8451,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8585,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6399,
          "asker": {
            "courseId": 102,
            "askerId": 58,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa implica per il programmatore la presenza del garbage collector in java? Quali sono i vantaggi e gli svantaggi introdotti da tale automazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6252,
          "asker": {
            "courseId": 102,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la classe da cui ereditano tutte le classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6273,
          "asker": {
            "courseId": 102,
            "askerId": 994,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In termini di memoria, qual è il guadagno che si ottiene con l'uso dell'ereditarietà piuttosto che con le dichiarazioni di variabili classe per classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6731,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1049,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con l'uso dell'ereditarietà, più che un guadagno di memoria si ottiene un guadagno a livello pratico. Non ci sarà più bisogno, ad esempio, a reinserire tutte le variabili nella classe figlio, ma basterà inserire quelle nuove. Inoltre, come costruttore potrà essere utilizzato lo stesso della classe padre. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8558,
                  "rater": {
                    "raterId": 1084,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8386,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8188,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8544,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8641,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6707,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 962,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Non serve che le funzioni vengano ricostruite ogni volta, perché vengono utilizzate quelle già presenti nell'altra classe. Per questo motivo viene occupata memoria in più soltanto per le nuove classi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8643,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8559,
                  "rater": {
                    "raterId": 1084,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8191,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8387,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8546,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6668,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Questa domanda è mal posta, non esiste nessun vantaggio esplicito a livello di memoria. Lo scenario della domanda prevede una duplicazione di variabili che non dipende dall'applicazione dell'ereditarietà.\r\nL'ereditarietà permette di creare una versione 'specializzata', ovvero con funzionalità e parametri aggiuntivi, di una classe già esistente. Questo migliora l'organizzazione del codice rendendo chiara la relazione fra una classe ed un'altra. Riduce la ridondanza del codice, e quindi si risparmia tempo a non dover riscrivere del codice che è già stato scritto. \r\nInoltre, la manutenzione del software diventa molto più facile. Se ci dovesse essere un errore nel codice, con l'ereditarietà si ha il vantaggio di dover cambiare il codice solo una volta, cosa che magari ci si dimenticherebbe di fare trattando un codice molto ampio senza l'estensione di una classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8388,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8642,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8547,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8190,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8557,
                  "rater": {
                    "raterId": 1084,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6685,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Il guadagno di memoria nell'utilizzare l'ereditarietà piuttosto che due classi distinte è molto piccolo e sta solo nella scrittura di meno codice e quindi nelle dimensioni del file finale. \r\nPerò è possibile vedere un guadagno nell'uso di una sottoclasse specializzante al posto di una sola classe già specializzata, prendiamo ad esempio la classe \"Persona\" con gli attributi \"nome\", \"cognome\" e \"data di nascita\" e la sottoclasse di \"Persona\", \"Studente\" con un attributo in più (\"matricola\") utilizzando una sottoclasse invece che una sola classe \"Persona\" contenente anche l'attributo \"matricola\", viene salvata una variabile ogni volta che non è necessario l'attributo \"matricola\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8556,
                  "rater": {
                    "raterId": 1084,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8644,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8385,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8189,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8545,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6284,
          "asker": {
            "courseId": 102,
            "askerId": 941,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java per eliminare un oggetto si può utilizzare il metodo \"finalize()\".\r\n\r\nTuttavia \"il metodo finalize POTREBBE NON ESSERE CHIAMATO DAL SISTEMA (es. se il programma finisce prima?)\" (cit. slide).\r\n\r\nIn questo caso la memoria rimane occupata o interviene il garbage collector?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Distruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6760,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1043,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In caso di chiusura dell' intero programma il sistema operativo interviene rendendo disponibile la memoria precedentemente allocata per l' esecuzione.\r\nil metodo finalize() viene chiamato quando l' oggetto è prossimo ad essere deallocato dal garbage collector. Java non garantisce l' efficacia dell' utilizzo di metodi di tipo \"finalize()\". vengono spesso sconsigliati in quanto sono eseguiti a discrezione del garbage collector. Può succedere che non venga mai invocato ad esempio in  programmi che terminano rapidamente o dove l' oggetto è reperibile durante tutta la durata del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8142,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8587,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8252,
                  "rater": {
                    "raterId": 790,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8256,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8193,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6693,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1009,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il metodo \"finalize()\" può essere utilizzato per consentire al programmatore di implementare meccanismi di gestione esplicita della memoria.Tuttavia non è detto che questo venga chiamato dal sistema, poichè funge quasi da suggerimento , ma non da comando.Il sistema infatti, valuterà se si necessità davvero di richiamare finalize() e darà priorità a processi più importanti. Per forzare la chiamata di \"finalize()\" bisogna chiamare la \"System.gc\" e subito dopo la \"System.runFinalization().\r\nComunque anche se finalize() non venisse chiamato, la memoria non resterà occupata, ma interverrà il garbage collector che troverà il momento opportuno (es. quando il programma è in pausa) per liberarla e restituirla al sistema.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8251,
                  "rater": {
                    "raterId": 790,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8588,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8143,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8257,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8192,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6320,
          "asker": {
            "courseId": 102,
            "askerId": 999,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come opera il metodo distruttore in un normale programma java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "DISTRUTTORI"
            },
            {
              "keyword": " DISTRUTTORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6314,
          "asker": {
            "courseId": 102,
            "askerId": 1019,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un Garbage collection e come funziona? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6279,
          "asker": {
            "courseId": 102,
            "askerId": 979,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In termini di scrittura del codice, qual è il vantaggio principale nell'avere una serie di sotto-classi che ereditano le caratteristiche della stessa super-classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6684,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 995,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "- Piu leggibile\r\n- Piu breve\r\n- Facilita' nel fix (evita duplicati)\r\n- Astrattamente piu' corretta",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8433,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8199,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8130,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8115,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8211,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6699,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1013,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Tramite l'Ereditarietà, le sotto-classi ereditano tutte le caratteristiche della super-classe.\r\nIn questo senso dunque, grazie all'Ereditarietà, viene evitata la ridondanza nella scrittura del codice: infatti, la sotto-classe \"eredita\" tutte le caratteristiche (cioè \"eredita\" tutto il codice) della super-classe.\r\nViene dunque favorito il riutilizzo del codice nella scrittura di nuove sotto-classi.\r\nQuindi, una volta definita la super-classe, si potranno poi implementare nuove sotto-classi senza dover riscrivere tutto il codice già scritto nella super-classe: sarà necessario implementare solo le caratteristiche aggiuntive.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8119,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8133,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8430,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8201,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8210,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6714,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1054,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il principale vantaggio è il riuso del codice, cioè le classi derivate mantengono i metodi e gli attributi  della classe da cui deriva. Questo permette un risparmio di tempo dal punto di vista di scrittura e testing. Inoltre è possibile ridefinire il codice di alcuni dei metodi ereditati tramite il meccanismo di overriding (riscrittura di un metodo ereditato).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8132,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8118,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8202,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8431,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8208,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6712,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1037,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se delle varie classi hanno dei metodi in comune che fanno le stesse cose conviene fare una super-classe che contenga quei metodi dalla quale far discendere le altre classi, in questo modo le varie classi contengono i metodi ereditati e non c'è bisogno di riscriverli in ogni classe ripetendo lo stesso codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8200,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8212,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8432,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8116,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8131,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6665,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1091,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il vantaggio principale delle sotto-classi è che permettono di evitare eventuale duplicazione del codice, permettono il riuso di certe funzionalità, semplificano la costruzione di nuove classi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8429,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8209,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8117,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8203,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8134,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6301,
          "asker": {
            "courseId": 102,
            "askerId": 1036,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in c++ non esiste garbage collection?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6772,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1046,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In c++ il garbage collection esiste ma deve essere incluso con una libreria o implementato dal programmatore, mentre in Java e altri linguaggi é una caratteristica del linguaggio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8623,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8323,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8495,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8503,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6701,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1014,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "In C++ non esiste il garbage collector perchè chi ha definito gli standard del linguaggio ha deciso che la gestione della memoria è responsabilità del programmatore mentre in Java è stato introdotto il garbage collector per occuparsi di ciò.\r\nAd esempio se in C++ viene creato un oggetto, ci sarà un puntatore \"p\" alla zona di memoria riservata ad esso; se ad un certo punto del programma, il programmatore decide di usare quel puntatore per un altro oggetto della stessa classe, diventa fondamentale fare un \"delete p;\" per deallocare la memoria che avevo precedentemente riservato al fine di evitare memory leak. In Java invece, grazie al garbage collector, questa pulizia avviene automaticamente in background.\r\nSi tratta di due filosofie di gestione della memoria diverse, una che responsabilizza il programmatore, permettendo così maggior velocità ma anche più rischi, mentre l'altra, lascia il compito al GC, perdendo leggermente in prestazioni ma aumentando la sicurezza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8625,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8325,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8494,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8504,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6625,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1003,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "La garbage collection non è stata implementata in C++ per questioni di efficienza, infatti in Java viene effettuata periodicamente in maniera automatica (anche se è possibile richiamarla manualmente), questo comporta un costo in termini di tempo e risorse, il C++ punta invece a massimizzare l'efficienza. Inoltre in C++ è presente l'aritmetica dei puntatori, che permette di accedere ad un'area di memoria anche senza avere un suo riferimento, in Java il numero di riferimenti ad un'area di memoria è proprio il parametro che permette di decidere se un'area di memoria non è più necessaria (0 riferimenti ad un'area di memoria implicano che essa non è più raggiungibile, quindi non ci interessa cosa contiene ed è possibile deallocarla).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8502,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8493,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8624,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8324,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6265,
          "asker": {
            "courseId": 102,
            "askerId": 1022,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare cosa si intende per superclasse e sottoclasse, ponendo particolare enfasi sul legame esistente tra i costruttori di una classe e quelli della superclasse. Come si chiama la superclasse universale?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            },
            {
              "keyword": " EREDITARIETA'"
            },
            {
              "keyword": " EREDITARIETA'"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6683,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 950,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "In programmazione orientata gli oggetti per il principio di ereditarietà viene a formarsi un'albero gerarchico di classi (o come in c++ un insieme di alberi). Definiamo sottoclasse la classe che \"estende\" il concetto di un'altra, definita superclasse, aggiungendo, modificando e/o conpletandone il significato. In java per completare il concetto di polimorfismo (possiamo dire quasi universale) viene creata la classe Object come madre di tutte le classi nella quale vengono concentrate tutte le funzionalità comuni a tutti gli oggetti (L'estensione avviene implicitamente). Per istanziare un oggetto occorre creare un costruttore che permette si inizializzare gli attributi della classe e in particolare l'inizializzazione della superclasse (occorre specificare il costruttore mediante il reference super). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8514,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8409,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8681,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8446,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8094,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6642,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 996,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Supponiamo di aver appena creato una nuova classe (es. Cane). E' detta superclasse la classe che è ereditata dalla nostra classe (es. class Cane extends Animale {}).\r\nNel nostro caso quindi 'Animale' è la superclasse.\r\nLa classe 'Cane' diventa sottoclasse (o \"child class\") in quanto eredita i metodi e attibuti dalla superclasse 'Animale'.\r\nI costruttori di una sottoclasse hanno la priorità su quelli della superclasse in quanto più specifici.\r\nTutte le classi definite dal programmatore in Java sono sottoclassi della superclasse universale 'Object' la quale è l'unica a non essere sottoclasse di nessuna.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8092,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8445,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8513,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8411,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8680,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6713,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1072,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I costruttori di una superclasse vengono ereditati e possono essere utilizzati nella classe. Non vale viceversa.  La superclasse universale si chiama Object.  Nasce tutto da lì,  infatti, dal definire la classe più generica possibile,  ovvero quella di oggetto.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8515,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8410,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8679,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8447,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8093,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6336,
          "asker": {
            "courseId": 102,
            "askerId": 982,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può esaminare un sistema tramite linguaggio UML? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6267,
          "asker": {
            "courseId": 102,
            "askerId": 1065,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa differisce la distruzione degli oggetti tra \"C++\" e \"Java\"? Spiega in particolare il meccanismo di \"Garbage collection\" in java (come funziona? Quando agisce? Può essere chiamato?).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6343,
          "asker": {
            "courseId": 102,
            "askerId": 958,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è la \"Garbage collection\" e come funziona?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6358,
          "asker": {
            "courseId": 102,
            "askerId": 955,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Dopo aver eseguito la garbage collection, come si processano gli errori trovati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6323,
          "asker": {
            "courseId": 102,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è la firma di una funzione? In che modo entra in gioco quando si parla di Overloadind e Overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overriding/Overloading"
            },
            {
              "keyword": " firma"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6739,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1103,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La firma di una funzione è costituita dal nome di tale funzione e dai parametri che essa riceve in ingresso.  L'overloading si verifica quando sono presenti due funzioni con uguale nome e diversa firma. L' overriding consiste nella ridefinizione in una sottoclasse di una funzione con la stessa firma .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8633,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8338,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8468,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6663,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "In Java la firma di una funzione è formata dal nome della funzione stessa (identificatore) e dai tipi dei parametri in entrata. Il tipo di ritorno NON viene considerato.\r\nCon overloading si intende una situazione in cui in una stessa classe ci siano più funzioni con lo stesso nome ma con firma diversa; variano il numero e/o il tipo dei parametri in entrata.\r\nSi ha overriding quando, in caso di ereditarietà, nella sottoclasse viene modificato il corpo di un metodo ereditato dalla superclasse; la firma rimane la stessa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8467,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8336,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8630,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6768,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1053,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "La firma identifica univocamente la funzione; essa include il nome, il tipo di dato ritornato e il tipo ed il nome dei parametri, quando presenti.\r\nNel caso di overloading, vengono definite diverse funzioni con lo stesso nome ma con una diversa implementazione. Possono quindi essere aggiunti parametri e rivedere la logica della funzione stessa.\r\nInvece, l'overriding permette di riscrivere la logica di una funzione definita dalla classe padre; questa funzione deve mantenere la stessa firma usata nella classe padre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8632,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8337,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8470,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6750,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1048,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La firma di una funzione descrive il nome, il tipo dei parametri e il tipo del valore tornato da una funzione. Nell'Overriding il metodo ridefinito in una sottoclasse ha la stessa firma del metodo originale della superclasse; Overloading invece significa «sovraccaricare» ovvero definire più versioni di un metodo, utilizzando lo stesso nome ma una firma diversa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8469,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8631,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8335,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6379,
          "asker": {
            "courseId": 102,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "come avviene la gestione della memoria all'interno del compilatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "gestione della memoria"
            },
            {
              "keyword": " gestione della memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6290,
          "asker": {
            "courseId": 102,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Una classe può solamente estendere UNA superclasse? Perché? Cos'è l'ereditarietà multipla e che problemi può causare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EREDITARIETA'"
            },
            {
              "keyword": " EREDITARIETA'"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6367,
          "asker": {
            "courseId": 102,
            "askerId": 1047,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono deallocati gli oggetti in java? Qual è la differenza rispetto a C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Garbage collection"
            },
            {
              "keyword": " Garbage collection"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6652,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1096,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Java è un linguaggio che punta a semplificare la vita al programmatore per questo motivo esistono solo i tipi di dati dinamici contrariamente al c++ dove esistono anche quelli statici. Grazie a questo motivo e all'impossibilità del programmatore di lavorare con gli indirizzi dei dati (aritmetica dei puntatori), è il linguaggio stesso che si occupa di deallocare i dati dinamici attraverso delle scansioni periodiche dell' area heap, chiamate garbage collection, questa scansione può essere chiamata anche dal programmatore attraverso il comando: Sistem.gc();\r\nCompletamente diverso è in c++ in cui la deallocazione dei dati dinamici è affidata completamente al programmatore (con l'operatore delete ...; o delete [] ...; ), se questa operazione non avviene si incappa nel grave problema del memory leak.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8313,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8366,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8656,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8220,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8353,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6719,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 991,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "In Java non mi devo preoccupare di deallocare gli oggetti poichè, una volta finito di utilizzarli, potrà entrare in azione su di essi il \"garbage collector\" (un 'meccanismo' di deallocazione automatica).\r\nIn Java viene assegnato all'oggetto contatore del numero di \"puntatori\" a quell'oggetto; quando il contatore è a 0 significa che nulla stà puntando a quell'oggetto e quindi quest'ultimo può essere deallocato. Questo implica un vantaggio in quanto, a differenza del C++, non spetta al programmatore ricordarsi di deallocare gli oggetti (quindi non si rischia di incorrere in memory leaks) ma anche uno svantaggio poichè non ho il pieno controllo sul grarbage collector. Quindi se, ad esempio, dovessi deallocare un oggetto in una precisa posizione del codice non avrei problemi in C++ ma sarebbe più complicato in Java (esistono  comandi come System.gc() che richiamano esplicitamente l'azione del grabage collector ma ciò non implica necessariamente che quest'ultimo entri in azione).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8217,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8350,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8363,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8309,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8657,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6635,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 952,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "In Java vengono deallocati attraverso un sistema automatico detto Garbage Collection. Questo sistema si basa su un contatore che registra il numero di riferimenti ad una certa area di memoria e quando il contatore raggiunge lo 0 l'area di memoria viene considerata garbage (non più utilizzata) e quindi il sistema la libera.\r\nIn C++, invece, è il programmatore che deve occuparsi della deallocazione di ogni oggetto/variabile allocata in heap con l'apposito comando delete dopo ogni suo uso.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8654,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8310,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8221,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8354,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8362,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6736,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 978,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In java gli oggetti vengono deallocati automaticamente dal Garbage Collector.\r\nOgni oggetto oltre ad avere una classe costruttore ha anche una classe distruttore (finalize()) che può essere persino scritta dall'utente, ma di norma non è necessario farlo.\r\nIl Garbage Collector si occupa di scandagliare la memoria e liberare gli oggetti che non vengono più referenziati tramite il loro apposito metodo finalize.\r\nIl GC può essere chiamato manualmente dal programmatore tramite System.gc().\r\nVolendo si può chiamare anche un metodo finalize specifico eseguendo System.runFinalization() immediatamente dopo System.gc().\r\nLa differenza principale rispetto al C++ è che il processo è completamente automatico, mentre in C++ sta al programmatore preoccuparsi di deallocare gli oggetti dove è necessario.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8312,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8365,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8658,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8351,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8218,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6705,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1001,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Java non permette al programmatore di deallocare gli oggetti in modo esplicito. Quando un oggetto non è più referenziato, ovvero quando non ci sono più oggetti che lo utilizzano, deve essere distrutto e ciò avviene tramite il garbage collector, una speciale routine di sistema che scandisce lo Heap liberando la memoria occupata dagli oggetti non più referenziati. Il processo di garbage collection avviene automaticamente quando il sistema ha poca memoria libera, la memoria occupata da oggetti allocati sullo heap supera una certa soglia oppure viene chiamato il metodo GC.Collect(). Nell'ultimo caso non si ha comunque la certezza che venga eseguita la garbage collection.\r\nA differenza di Java, in cui il programmatore non può accedere direttamente alle aree di memoria, in C++ è possibile usare dei puntatori per l'allocazione degli oggetti ed è compito del programmatore assicurarsi che ogni oggetto venga deallocato tramite l'operatore \"delete\" quando non viene più usato, non essendoci il gc.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8352,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8655,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8364,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8219,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8311,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6353,
          "asker": {
            "courseId": 102,
            "askerId": 1094,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra aggregazione e composizione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "aggregazione"
            },
            {
              "keyword": "composizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6291,
          "asker": {
            "courseId": 102,
            "askerId": 957,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando scrivo un programma in java formato da più classi le quali presentano caratteristiche comuni tra loro, in che modo posso organizzarle?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6292,
          "asker": {
            "courseId": 102,
            "askerId": 972,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi derivanti dall'ereditarietà? Come si implementa in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6401,
          "asker": {
            "courseId": 102,
            "askerId": 1070,
            "courseFinalScore": 10
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Due principali differenze sono emerse tra Java e C++. La prima riguarda la struttura della gerarchia ereditaria delle classi, mentre la seconda l'elasticità di definizione delle funzioni. Descrivere queste due differenze nel dettaglio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Object"
            },
            {
              "keyword": " albero"
            },
            {
              "keyword": " overloading"
            },
            {
              "keyword": " firma"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6384,
          "asker": {
            "courseId": 102,
            "askerId": 956,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'UML e quali possono essere le sue funzioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": "UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6387,
          "asker": {
            "courseId": 102,
            "askerId": 980,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Avendo una classe R ed una classe RS che estende la prima, se nella prima ci fosse una qualsiasi variabile (o un qualsiasi metodo) che non viene mai utilizzata nella sua sottoclasse, questa variabile (o metodo) può in qualche modo essere eliminata dalla classe derivata o dovrà essere mantenuta come un'appendice inutile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6633,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 957,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, ogni attributo o metodo della classe padre viene \"trasferito\" alla classe che la estende. I metodi della classe padre possono essere modificati (tramite overriding) ed è possibile aggiungerne di nuovi, ma quelli esistenti non possono essere eliminati, così come le variabili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8600,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8627,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8157,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8249,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8370,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6627,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 940,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "In Java, non esiste un modo che permetta di prevenire esplicitamente l'ereditarietà di metodi/attributi appartenenti alla superclass, quando questa viene subclassata con 'extends'.\r\nAlcuni esempi su come aggirare il 'problema': http://stackoverflow.com/questions/5486402/disabling-inherited-method-on-derived-class.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8250,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8371,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8601,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8626,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8158,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6708,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1015,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "No, deve essere mantenuta anche se inutilizzata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8247,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8598,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8156,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8372,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8628,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6640,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 955,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, dovranno essere mantenuti se si utilizza il metodo extends.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8248,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8373,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8599,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8629,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8155,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6285,
          "asker": {
            "courseId": 102,
            "askerId": 1024,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Utilizzando l'ereditarietà in un programma più volte, e quindi riutilizzando un tratto di codice da noi scritto in precedenza, non c'è il rischio di aumentare gli errori? Per questo motivo non è meglio evitare quando possibile l'ereditarietà? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Errori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6335,
          "asker": {
            "courseId": 102,
            "askerId": 1063,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra la classe e la struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6738,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "le struct non sono supportate da Java, le classi sono simili alle struct ma hanno piu funzionalità come la subclassing",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8634,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8144,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8169,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6666,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1017,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe è un tipo di riferimento, quando viene creato un oggetto della classe la variabile alla quale è assegnato l'oggetto contiene solo un riferimento a quella memoria.\r\n\r\nUna struttura è un tipo di valore, quando viene creata una struttura la variabile alla quale è assegnata contiene di dati effettivi della struttura.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8171,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8146,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8636,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6677,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La class è un tipo di riferimento, quando viene creato un oggetto della classe, la variabile a cui è assegnato l'oggetto contiene solo un riferimento alla memoria. Quando il riferimento all'oggetto viene assegnato a una nuova variabile, la nuova variabile fa riferimento all'oggetto originale. \r\nLa struct invece è un tipo di valore, quando viene creata, la variabile a cui è assegnata la struct contiene dati effettivi della struttura. Essa è assegnata a una nuova variabile, viene quindi copiata. La nuova variabile e la variabile originale pertanto contengono due copie separate degli stessi dati. Le modifiche apportate a una copia non influiscono sull'altra copia, al contrario della class.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8145,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8170,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8635,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6276,
          "asker": {
            "courseId": 102,
            "askerId": 1104,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa si intende nei termini di ereditarietà tra classi e come la parola \"extends\" mette in relazione due classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6389,
          "asker": {
            "courseId": 102,
            "askerId": 943,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le estensioni di tipo strutturale?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6755,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1083,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'estensione strutturale di una classe è un particolare tipo di ereditarietà in cui la sottoclasse oltre a possedere tutte le variabili di istanza della classe padre ne aggiunge di nuove. Per una implementazione di tale sotto classe si usa la parola chiave \"Extends\". Un esempio di estensione strutturale può essere quello visto a lezione, cioè la classe NamedPoint che, oltre alle coordinate x e y, aggiunge il parametro \"name\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8254,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8110,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8527,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8455,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6630,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 992,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Le estensioni di tipo strutturale in java consistono nella possibilità di ereditare delle funzioni, dei metodi e della variabili, da una classe (padre) ad un'altra (figlio).\r\nLa possibilità di usare funzioni già definite, rende più veloce la creazione di classi \"figlie\" e, inoltre, semplifica la manutenzione del codice.\r\nLe estensioni permettono, anche, di sovrascrivere una funzione, un metodo o una variabile dichiarata nella classe \"padre\". Questa proprietà è detta overriding e permette di adattare, il codice, al comportamento della classe figlio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8457,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8253,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8109,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8525,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6752,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1058,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sottoclassi che possiedono struttura e oggetti uguali a quelli della classe \"Padre\", le quali tuttavia differiscono da quest'ultima per l'aggiunta di nuove variabili di istanza",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8108,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8456,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8526,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8255,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6386,
          "asker": {
            "courseId": 102,
            "askerId": 1000,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si possono classificare le estensioni di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6732,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1085,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "è impossibile classificare le estensioni di una classe dato che non hanno classificazione.\r\nDall'estensione di una classe padre si genera una classe figlio avente di base gli stessi attributi e metodi, tutto ciò tramite la keyword 'extends'.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8303,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8075,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8403,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6771,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 58,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le estensioni possono essere strutturali, ovvero comportare l'aggiunta di variabili di istanza e dunque una maggiore informazione riguardo l'oggetto, oppure comportamentali, ovvero riguardare l'aggiunta di nuovi metodi o la modifica dei metodi esistenti per overloading (funzioni con nome uguale ma firma diversa) o per overriding (funzione ridefinita in una sottoclasse mantenendo immutata la firma).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8300,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8404,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8077,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6696,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1073,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le estensioni di una classe possono essere di tipo strutturale nel caso vengano aggiunte variabili di istanza o comportamentali quando si ha un'aggiunta di nuovi metodi o la modifica di metodi già esistenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8402,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8076,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8302,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6653,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 983,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Le estensioni di una classe possono essere :\r\n- Strutturali se la nuova classe ha come unica aggiunta dei campi(variabili), questo tipicamente accade quando si passa da una classe generica(mammiferi) ad una classe più specifica(gatti).\r\n- Comportamentali se la nuova classe subisce delle modifiche ai metodi esistenti o se vengono aggiunti nuovi metodi, questo tipicamente accade quando si passa da una classe ad una sua \"evoluzione\", ad esempio il passaggio da gatto a gatto domestico.\r\n- Entrambe se vengono effettuate delle modifiche sia ai campi che ai metodi, come ad esempio il passaggio da mammifero a gatto domestico.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8301,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8078,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8401,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6296,
          "asker": {
            "courseId": 102,
            "askerId": 963,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella programmazione ad oggetti in Java perchè il distruttore e il relativo metodo 'finalize()' sono opzionali e non strettamente necessari per evitare il memory leak?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Distruttori"
            },
            {
              "keyword": "Distruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6671,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1022,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nella programmazione ad oggetti in Java il distruttore e il metodo finalize() risultano spesso inutili in quanto Java mette a disposizione una modalità automatica di gestione della memoria, chiamata \"garbage collector\", che tiene traccia delle locazioni di memoria utilizzate e libera automaticamente le porzioni di memoria che non dovranno più essere utilizzate successivamente o nel momento in cui non c'è più riferimento all'oggetto stesso, evitando così il memory leak. In poche parole il garbage collector deve: \r\n-determinare l'oggetto da eliminare (garbage detector)\r\n-liberare e rendere disponibile la relativa zona di memoria\r\n-evitare la frammentazione dello heap.\r\nIn Java è comunque possibile avere lo stesso effetto utilizzando o definendo un distruttore (mediante il metodo finalize) utile nei casi in cui il garbage collector potrebbe risultare troppo inefficiente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8278,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8349,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8084,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8227,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6670,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1008,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "In Java la gestione della memoria è automatica: nello specifico, un garbage collector si occupa di rendere nuovamente disponibile la memoria non più utilizzata dal programma. Ciò risolve il problema di eventuali memory leak e rende perciò opzionale l'uso del costruttore e del metodo \"finalize()\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8348,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8277,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8228,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8085,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6398,
          "asker": {
            "courseId": 102,
            "askerId": 1005,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": " Qual è la differenza tra il distruttore \"~\" del C++ e \"finalize()\" di java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "DISTRUTTORI"
            },
            {
              "keyword": " DISTRUTTORI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6764,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1081,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il distruttore \"~\" ha la funzione di liberare lo spazio in memoria utilizzato da un determinato oggetto o quello occupato dai suoi eventuali metodi. L'utilità di questo metodo è l'evitare eventuali fenomeni di memory leak, consentendo la corretta liberazione della memoria utilizzata durante l'esecuzione del programma. Il distruttore \"~\" risulta superfluo in Java in quanto il linguaggio, a differenza del C++, prevede un sistema di garbage collection, che rende implicita l'eliminazione degli oggetti. Il metodo \"finalize()\", non dovendo dunque eliminare esplicitamente gli oggetti, consente un utilizzo corretto delle risorse \"non Java\" non gestibili implicitamente in fase di garbage collection, quali il recupero di file aperti, garantendo un minore spreco di risorse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8509,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8659,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8539,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8577,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8299,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6650,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo finalize() non è la stessa cosa di un distruttore. La finalize() richiama il metodo finalize() per un oggetto che deve essere eliminatoin quanto non è piu utilizzato.\r\nNon si può mai sapere quando verrà richiamata finalize() poiché non si trova sotto il controllo del programmatore.\r\n\r\nIn C++ il distruttore è una funzione che viene eseguita automaticamente quando stiamo per rilasciare un oggetto, tramite l'operatore \"delete\" ad un puntatore dell'oggetto, il programma esce dal campo di visibilità di un oggetto della classe.\r\n\r\n1) il distruttore, come il costruttore, ha sempre lo stesso nome della classe nella quale è definito ma preceduto dal carattere \"(~)\".\r\n\r\n2) i distruttori a differenza dei costruttori, non possono accettare argomenti e non possono essere modificati tramite overloading.\r\n\r\n3) anche i distruttori quando vengono definiti esplicitamente, bengono creati automaticamente dal compilatore(distruttore di default).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8537,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8508,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8578,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8663,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8296,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6725,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 968,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando in C++, distruggiamo un oggetto con \"delete\", siamo sicuri che il distruttore viene chiamato in quel momento. Quando invece un oggetto viene marcato come garbage, non è possibile determinare a priori quando il collector verrà attivato e verrà quindi chiamato il metodo \"finalize()\" dell?oggetto. Nel caso peggiore, se il codice del programma non lascia alla CPU un momento di pausa, il collector potrebbe non essere mai attivato, se non alla fine dell'esecuzione. Questo può comportare problemi, quindi in caso di necessita, o per sicurezza sull'esecuzione immediata, si può invocare esplicitamente il garbage collector mediante l?istruzione \"System.gc();\". ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8295,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8507,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8579,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8660,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8535,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6673,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 986,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Il distruttore ha il compito opposto del costruttore, ovvero liberare la memoria da un oggetto allocato dinamicamente.\r\nIn java esiste il metodo dichiarato come \"public void finalize()\", il quale viene richiamato dal garbage collector quando non vi sono più riferimenti all'oggetto da eliminare, questo implica che l'oggetto non viene eliminato subito(a discrezione del garbage collector).\r\nMentre, in C++ il distruttore viene invocato manualmente e la zona di memoria viene liberata immediatamente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8505,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8536,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8662,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8297,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8580,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6723,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il distruttore \"finalize()\" di java è un particolare metodo che viene invocato automaticamente quando l'oggetto viene distrutto, il distruttore \"~\" di C++ invece è una funzione con lo stesso nome della classe che si vuole distruggere. Mentre in java il distruttore è attivato automaticamente dal garbage collector in C++ deve essere utilizzato solo in alcuni casi particolari come ad esempio con un'oggetto allocato dinamicamente o quando la durata di un'elemento temporaneo termina.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8661,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8506,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8538,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8298,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8576,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6324,
          "asker": {
            "courseId": 102,
            "askerId": 1078,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si possono descrivere un insieme di classi che ereditano le une dalle altre? Che differenza strutturale c'é tra java e c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6255,
          "asker": {
            "courseId": 102,
            "askerId": 1041,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'overreading? Quando è possibile (che condizioni vanno rispettate)? Fornire un esempio semplice.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overreading"
            },
            {
              "keyword": " overreading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6360,
          "asker": {
            "courseId": 102,
            "askerId": 995,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Perche' in Java, anche se in una classe non e' stato dichiarato (e definito) il metodo \"toString\", quando questo viene chiamato da un'istanza della classe il programma non restituisce nessun errore, anzi l'output del metodo e' coerente (fornisce valide informazioni sull'istanza chimante)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "EREDITARIETÁ"
            },
            {
              "keyword": " EREDITARIETÁ"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6759,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 953,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": ".Ogni classe, in Java, possiede un unica superclasse \"Object\" la quale definisce lo stato ed il comportamento base che ciascun oggetto deve avere. Il metodo \"toString\" è presente in questa classe e ritorna una rappresentazione testuale dell'oggetto. La funzione viene invocata automaticamente ogni volta che è necessaria una conversione in forma di stringa\r\nes. System.out.println(oggetto);\r\nSe il metodo è stato ridefinito in una superclasse o nella classe stessa cui viene invocato, tramite l'operazione di override, non verrà eseguito il metodo della classe Object ma il metodo ridefinito in precedenza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8423,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8543,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6675,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1099,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La definizione di sottoclassi può essere iterata a piacere: si possono definire delle gerarchie di classi arbitrariamente complesse.\r\nIn Java ogni classe è una classe derivata, in modo diretto o indiretto, dalla classe Object. Infatti, ciascuna classe che non estende un'altra classe estende automaticamente la classe Object (la quale contiene il metodo toString)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8542,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8424,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6765,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 951,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Se in una classe in Java non viene definito il metodo \"toString\" ma si tenta comunque di stampare un'istanza di suddetta classe, il compilatore andrà a cercare il metodo toString nella classe padre. Nel caso in cui la classe considerata non sia figlia di nessun'altra classe allora il metodo toString verrà preso in una macro classe chiamata Object di cui tutte le classi sono figlie (e in questo caso apparirà a video il nome della classe a cui appartiene l'istanza che si cerca di stampare e altri simboli che possono essere interpretati come un puntatore a quella classe). Purtroppo però questi output non stampano a video le informazione volute sull'istanza, per questo è buona norma di programmazione definire per ogni classe il metodo toString.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8422,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8541,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6720,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1095,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La classe object è la superclasse che fa parte di ciascuna classe in Java, grazie all' ereditarietà, i suoi metodi possono essere invocati su tutti gli oggetti, per esempio il metodo toString fa parte di essi e permette di rappresentare testualmente l'oggetto in forma String.\r\nPer riassumere: ogni classe estende la classe object che a sua volta definisce il metodo toString, quindi il metodo toString non deve essere dichiarato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8540,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8421,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6355,
          "asker": {
            "courseId": 102,
            "askerId": 1052,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa succede se si modifica un metodo già esistente di una classe?\r\nCome viene chiamata questa pratica?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6648,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1023,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La modifica di un metodo già esistente di una classe permette di personalizzare quel metodo e adattarlo al meglio alla sottoclasse su cui si sta lavorando, in questo modo quando lo useremo verrà utilizzato il proprio metodo e non quello della classe padre. Questa pratica è chiamata overriding. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8088,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8316,
                  "rater": {
                    "raterId": 764,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8231,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8528,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6667,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1025,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Modificando un metodo già esistente di una classe si modifica il comportamento della classe stessa dovuto a tale metodo. Le variabili di istanza vengono ereditate dalla superclasse insieme agli altri metodi, che rimangono immutati. Questa pratica si chiama overriding e sfrutta il concetto di ereditarietà. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8086,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8529,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8317,
                  "rater": {
                    "raterId": 764,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8230,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6758,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1075,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nella programmazione ad oggetti è possibile modificare un metodo ereditato da un'altra classe, questa tecnica è detta Overriding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8229,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8318,
                  "rater": {
                    "raterId": 764,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8530,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8087,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6271,
          "asker": {
            "courseId": 102,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per \"overriding\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding"
            },
            {
              "keyword": " overriding "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6348,
          "asker": {
            "courseId": 102,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consistono le funzioni di overloading e overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6319,
          "asker": {
            "courseId": 102,
            "askerId": 1046,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Overloading e Overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6261,
          "asker": {
            "courseId": 102,
            "askerId": 1007,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo, all'interno di un metodo di una classe, a volte è possibile omettere il riferimento this (es: this.x =z;) mentre altre è strettamente necessario il suo utilizzo? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            },
            {
              "keyword": " this"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6709,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 975,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "È possibile omettere il riferimento this quando non ci sono ambiguità rispetto al nome della variabile a cui si fa riferimenato per le regole di scope delle variabili.\r\nQuindi è strettamente necessario usare this quando sono presenti altre variabili all interno del metodo con lo stesso nome, così da poter accedere alla variabili dichiarate nella classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8646,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8127,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8552,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8668,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6770,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1018,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "La parola chiave this può essere usata quando si ha bisogno di usare il nome di una variabile globale di classe in un costruttore/metodo. Ad esempio:\r\n\r\npublic class esempio{\r\nString nome;\r\npublic void Name(String nome){\r\nthis.nome = nome;\r\n}}\r\n\r\nIn questo caso l'utilizzo di this è necessario in quanto la variabile name è sia una variabile globale di classe sia una variabile del costruttore/metodo: usando il this posso assegnare il valore globale name allaa variabile name Dell metodo senza ambiguità. \r\n\r\nQuando i nomi di variabile presenti negli assegnamenti dei costruttori/metodi sono diversi dalle variabili globali di classe, il this, invece, può essere omesso. Ad esempio:\r\n\r\npublic class esempio{\r\nString nome;\r\npublic void Name(String nome_costruttore){\r\nnome_costruttore = nome;\r\n}}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8664,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8555,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8649,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8126,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6628,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1064,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il riferimento \"this\" è necessario metterlo solamente laddove è richiesto specificare lo scope della variabile: se in un metodo di una classe non abbiamo ambiguita nella chiamata di una variabile (quindi hanno tutte un nome diverso) non vi sarà il bisogno di usare \"this\" per riferirsi alla variabile della classe. Se, invece, il metodo adotta una variabile il cui nome è stato già utilizzato per definire una variabile globale della classe, allora ci sarà la necessità di usare this.nomevariabile affinchè il compilatorie possa risolvere l'ambiguità e capire che la variabile che stiamo richiamando non è quella dichiarata nel metodo bensì quella dichiarata nella classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8128,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8551,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8648,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8666,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6645,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "This viene utilizzato per fare riferimento all'oggetto corrente, il suo utilizzo è necessario tipicamente nel caso del costruttore di una classe, in cui utilizziamo gli stessi nomi per le variabili di istanza e quelle che noi passiamo al costruttore; per esempio:\r\n\r\npublic class Automobile{\r\n  private int targa;\r\n\r\n  public Automobile(int targa){\r\n    this.targa = targa;\r\n  }\r\n}\r\n\r\nin questo modo possiamo distinguere le due variabili targa, una di istanza appartenente alla classe, e una appartenente al costruttore (questa situazione può presentarsi anche in altri metodi che non siano il costruttore).\r\nSe le variabili hanno nomi diversi, usare this non è necessario; come nel seguente esempio:\r\n\r\npublic class Automobile{\r\n  private int targa;\r\n\r\n  public Automobile(int licensePlate){\r\n    targa = licensePlate;\r\n  }\r\n}\r\n\r\nIn più this si può utilizzare per chiamare un altro costruttore nella stessa classe (vedi explicit constructor invocation).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8125,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8667,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8647,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8554,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6632,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 979,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La keyword \"this\" è necessaria quando, all'interno di un metodo, si vuole richiamare un campo che è stato nascosto da un parametro con lo stesso nome.\r\nCiò significa che è possibile omettere la keyword \"this\" se i campi di un metodo hanno nomi univoci.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8665,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8645,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8553,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8129,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6385,
          "asker": {
            "courseId": 102,
            "askerId": 997,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una superclasse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6742,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1005,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per superclasse si intende una classe che può essere estesa e che offre le sue funzionalità alle sottoclassi. Viene chiamata classe padre di una sottoclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8463,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8608,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6744,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1061,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una superclasse è una classe \"genitore\" che vengono estese e offrono la loro funzionalità . Le sottoclassi ereditanto tali funzionalità che appunto estendono le superclassi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8464,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8609,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6686,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per \"superclasse\" si intende una classe gerarchicamente sovraordinata ad un'altra classe, definita \"sottoclasse\", che la estende e ne eredita i metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8607,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8465,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6629,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "una superclasse, con la relativa sottoclasse, sono due classi che rappresentano due concetti in relazione tra loro e che quindi dichiarano campi in comune. \r\nPerciò una Superclasse può essere vista come un concetto generale (Animali, Libri, Strade, ...), che può essere \"esteso\" in concetti più specifici nella relativa sottoclasse (Cane, LibroFantascienza, Autostrada, ...).\r\nesse vengono messe in relazione attraverso il concetto di Ereditarietà e alla sintassi \"extends\" in Java.\r\n\r\nfacciamo un esempio:\r\n\r\npublic class Libro {\r\n  public String titolo;\r\n  public String autore;\r\n  public int numeroPagine;\r\n  //...\r\n}\r\n\r\npublic class LibroFantascienza extends Libro {\r\n// questa classe eredita tutti i campi pubblici della classe Libro\r\npublic final String argomentoTrattato = \"Fantascienza\";\r\n}\r\n  \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8610,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8466,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6297,
          "asker": {
            "courseId": 102,
            "askerId": 1066,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quante overriding/overloading di funzioni possono coesistere nello stesso file?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding/overloading"
            },
            {
              "keyword": " Overriding/overloading "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6315,
          "asker": {
            "courseId": 102,
            "askerId": 991,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile che una sotto-classe abbia più di una classe padre? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6341,
          "asker": {
            "courseId": 102,
            "askerId": 1048,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo l'Ereditarietà è vantaggiosa per il riutilizzo del codice sorgente?   ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6740,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "L'ereditarietà è vantaggiosa per il riutilizzo del codice grazie alla possibilità di ereditare appunto da una classe tutta la sua struttura e i suoi metodi, andando a sovrascrivere solo i metodi necessari apportando. La classe figlia sarà in tutto e per tutto uguale al padre, tranne che per i nuovi metodi scritti e le eventuali nuove variabili. Questo porta a creare una struttura gerarchica molto forte e che semplifica la manutenzione del codice. Inoltre attraverso l'ereditarietà il codice non sarà copiato nella nuova classe: questo semplifica la risoluzione di eventuali 'bachi', consentendo di applicare la correzione una volta soltanto e non in tutte le parti di codice dove viene utilizzato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8483,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8242,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6631,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 981,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'ereditarietà è vantaggiosa poiché è possibile creare un oggetto base e, successivamente, altri oggetti che ne ereditano le caratteristiche e aggiungono funzioni e dati, senza reimplementare quelli della classe base.\r\nIn questo modo si hanno tre vantaggi: \r\n1) il codice viene riutilizzato con un conseguente risparmio di tempo e minore possibilità di errori\r\n2) se viene modificato l'oggetto base, le modifiche si ripercuotono anche su quelli che lo ereditano\r\n3) ereditando, si ha una naturale stratificazione degli oggetti rendendo l'eredità coerente anche a livello logico dando quindi la possibilità di definire una gerarchia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8243,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8482,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6746,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 987,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Supponiamo che in un programma si usi una classe Animale contenente dati per specificare, ad esempio, se l'animale è vivo, il luogo in cui si trova, quante zampe ha, ecc.; in aggiunta a questi dati la classe potrebbe contenere anche metodi per descrivere come l'animale mangia, beve, si muove, si accoppia, ecc. Se si volesse creare una classe Mammifero molte di queste caratteristiche rimarrebbero esattamente le stesse di quelle dei generici animali, ma alcune sarebbero diverse. La cosa importante da notare è che nel definire la nuova classe non è necessario specificare nuovamente che un mammifero ha le normali caratteristiche di un animale ma basta aggiungere le caratteristiche peculiari che contraddistinguono i mammiferi rispetto agli altri animali Per usare parole semplici si potrebbe dire che questo metodo dice di \"fare prima tutto quello che la classe base farebbe\" seguito poi dal codice che indica quali sono le \"cose in più\" che deve fare la nuova classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8481,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8241,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6288,
          "asker": {
            "courseId": 102,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Diagrammi UML in cosa consistono e possono essere usati per definire gli l'ereditarieta' o gli oggetti di cui è composto un programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6259,
          "asker": {
            "courseId": 102,
            "askerId": 992,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'utilizzare l'ereditarietà tra classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": "Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6364,
          "asker": {
            "courseId": 102,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega la differenza tra overriding e overloading, facendo qualche piccolo esempio",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overriding/Overloading"
            },
            {
              "keyword": " Overriding/Overloading"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6682,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Ho Overloading quando ho due (o più) funzioni che condividono lo stesso nome, ma hanno firma diversa (cioè fondamentalmente prendono in input variabili con tipi diversi o in diverso numero), ad esempio:\r\nlenght(int start, int end)\r\nlenght(int start, int middle, int end)\r\nSi parla, invece, di Overriding quando ridefinisco una funzione in una sottoclasse, mantenendo la firma identica a quella della superclasse, ad esempio nella Coda che abbiamo visto a lezione veniva fatto un Overriding della funzione Estrai(), rispetto alla Estrai() della Pila.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8367,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8393,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8516,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8380,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8550,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6773,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1012,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "L'overriding consiste nella ridefinizione, in una classe derivata, di un metodo già presente nella classe padre, consentendo quindi di \"sovrascriverlo\" mantenendo però inalterata la firma: stesso nome, parametri e valore di ritorno. Solo a tempo di esecuzione si determina quale metodo deve essere eseguito (runtime polymorphism).\r\n\r\nEs:\r\nclass Cerchio {\r\n\tdouble r;\r\n\tdouble area() { return Math.PI * r * r }\r\n}\r\n\r\nclass Ellisse extends Cerchio {\r\n\tdouble r2;\r\n\t// Overriding di area()\r\n\tdouble area() { return Math.PI * r * r2; }\r\n}\r\n\r\nPer overloading, invece, si intende la presenza, in una stessa classe, di una famiglia di metodi (ma anche costruttori e operatori) con lo stesso nome ma diversa firma (parametri diversi per tipo e/o numero).A differenza dell'overriding è il compilatore che determina quale dei metodi verrà invocato (compile time polymorphism).\r\n\r\nEs:\r\nint somma(int a, int b)\r\nint somma(int a, int b, int c)\r\nfloat somma(float a, float b)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8548,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8379,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8395,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8517,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8368,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6741,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1021,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "In java l'overloading è una tecnica che permette la scrittura di più metodi con lo stesso nome ma con una lista parametri diversa.\r\nPer esempio in una classe OperazioniElementari possiamo definire il metodo dividi(int a, int b) e il metodo dividi(float a, float b) i quali, avendo firme diverse, saranno chiamati a seconda del tipo di parametri che riceveranno in ingresso.\r\nL'overriding si utilizza per ridefinire un metodo di una nuova classe derivata da un'altra precedemente definita. Per fare ciò è necessario che la firma (il nome e la lista parametri) del nuovo metodo sia esattamente la stessa di quello della classe padre che andremo a sovrascrivere.\r\nSe dalla classe OperazioniElementari deriviamo la classe OperazioniScientifiche possiamo andare a riscrivere il metodo dividi(int a, int b). Quando chiameremo il metodo dividi per un oggetto di tipo OperazioniScientifiche il compilatore andrà a chiamare il metodo appena descritto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8518,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8549,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8369,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8394,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8378,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6372,
          "asker": {
            "courseId": 102,
            "askerId": 974,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega e fai un esempio del metodo toString().",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            },
            {
              "keyword": " Metodo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6400,
          "asker": {
            "courseId": 102,
            "askerId": 987,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono rispettivamente i concetti di Overloading e Overriding? Forniscine un esempio",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding"
            },
            {
              "keyword": "overloading "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6253,
          "asker": {
            "courseId": 102,
            "askerId": 1009,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Abbiamo visto che, nel metodo costruttore di una classe,è stata utilizzata la parola chiave \"this\". Qual'è la sua funzione? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6260,
          "asker": {
            "courseId": 102,
            "askerId": 990,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai e' comune trovare nel costruttore di una classe derivata una chiamata del tipo:\r\n\r\nsuper();\r\n\r\ncon un'eventuale lista di parametri inserita tra le parentesi tonde?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Costruttori"
            },
            {
              "keyword": " Costruttori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6624,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 948,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "Ciò è comune perché super() fa sì che il costruttore della classe derivata erediti tutte le istruzioni presenti nel costruttore della superclasse da cui essa è derivata. Inoltre super(), se presente, deve obbligatoriamente essere la prima istruzione del costruttore della sottoclasse.",
              "notes": "-",
              "rating": 0,
              "coins": []
            }
          ]
        },
        {
          "questionId": 6354,
          "asker": {
            "courseId": 102,
            "askerId": 996,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi in massimo 3 righe cosa significa EREDITARIETA'(nell'Object-Oriented Programming)",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6258,
          "asker": {
            "courseId": 102,
            "askerId": 882,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi brevemente il concetto di Ereditarietà e l'uso della relazione \"is a\".\r\nÈ giusto \"estendere\" le seguenti classi rispetto alla relazione \"is a\"? perchè?\r\n\r\npublic class Triangolo {\r\npublic final int NUMERO_LATI = 3;\r\npublic float lunghezzaLatoUno;\r\npublic float lunghezzaLatoDue;\r\npublic float lunghezzaLatoTre;\r\n//...\r\n}\r\n\r\npublic class Rettangolo extends Triangolo {\r\npublic final int NUMERO_LATI = 4;\r\npublic float lunghezzaLatoQuattro;\r\n//...\r\n}\r\n\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6734,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1066,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sia la classe 2 estesa alla classe 1, la classe 2 eredita i metodi della classe 1; questo semplifica il codice senza ripetere parti di programma identici.\r\nSi  perché i dati estesi sono in comune",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8197,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8222,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8440,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8331,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8273,
                  "rater": {
                    "raterId": 1051,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6702,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 967,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe è definita estensione (extends) di un'altra se essa eredita tutte le caratteristiche della classe \"Padre\". Nell'esempio in classe riportato abbiamo definito la \"Coda\" come classe figlia della \"Pila\" (Coda extends Pila). In altre parole abbiamo scritto la \"Coda\" come una \"Pila\" da cui vengono ereditati i metodi e le variabili. Infatti si parla di \"Coda is a Pila\", ovvero \"la coda è una pila\".\r\nNel caso sopra riportato è possibile definire Rettangolo come classe figlia di Triangolo. Infatti Rettangolo eredita le caratteristiche di Triangolo (ovvero avere 3 lati) con l'aggiunta di uno. In \"informatichese\" questa cosa ha senso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8194,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8334,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8438,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8223,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8275,
                  "rater": {
                    "raterId": 1051,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6691,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 994,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per Ereditarietà si intende un meccanismo che permette di definire una struttura tra classi in cui da una classe generale vengono derivate classi sempre più specifiche che ereditano le proprietà ed i metodi delle classi genitore. \r\nL'uso della relazione \"is a\" (relazione di generalizzazione) serve a far capire in che direzione va il flusso di dati dalle classi genitore alle varie figlie (la classe figlia sarà quindi un'istanza della classe padre).\r\n\r\nNo, non è corretto estendere le classi tramite is-a in quanto, oltre ad essere un grosso errore di logica, si esegue l'override di una variabile final. Ciò è logicamente sbagliato in quanto, quando viene dichiarata una variabile con il modificatore final si intende una variabile finita, che non necessita di ulteriori specializzazioni o modifiche ed è dunque logico che non sia possibile farne l'override. \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8436,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8276,
                  "rater": {
                    "raterId": 1051,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8226,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8195,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8333,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6692,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 964,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "L'ereditarietà in un linguaggio ad oggetti permette di estendere una classe ad una classe già esistente. Tale classe appunto eredità i metodi, le variabili e permette di creare oggetti dichiarati nelle classi estese (aggregazione). In generale permette di caraterizzare un classe già esistente estendendo e ridefinendo i metodi stessi, creando così overloading nel caso in cui vengano ridefiniti metodi con parametri diversi, o di overriding nel caso in cui venga proprio ridefinito il metodo. \r\n\r\nL'esempio di ereditarietà rispetta il concetto is-a in quanto non viene instanziato un oggetto che si riferisce alla classe estesa ma vengono semplicemente implementate delle nuove funzionalità alla classe Triangolo. \r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8274,
                  "rater": {
                    "raterId": 1051,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8330,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8196,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8437,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8225,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6664,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1039,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe dichiarata extends, eredita tutti i metodi compresi i costruttori e le variabili dalla sua superclasse, cioè is-a, tranne quelli esplicitamente dichiarati.Serve a non riscrivere del codice ridondante, ma eventualmente ampliarlo.Tutte le classi comunque ereditano dalla superclasse Object.Per cui is-a significa, prende da.\r\nNon è corretto estendere una classe per cambiare una variabile, mentre per aggiungere una variabile si.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8224,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8332,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8272,
                  "rater": {
                    "raterId": 1051,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8198,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8439,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6293,
          "asker": {
            "courseId": 102,
            "askerId": 945,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è UML e per cosa può essere usato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "UML"
            },
            {
              "keyword": " UML"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6700,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 960,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "l'UML, come si può carpire dal significato (Unified Modeling language), è un linguaggio prettamente grafico che permette di rappresentare modelli orientati ad oggetti e quindi la struttura ereditaria delle diverse classe all'interno di un programma. L'UML prescinde dal linguaggio di programmazione quindi può essere utilizzato in qualsiasi applicazione che faccia utilizzio di classi ed oggetti. Dal punto di vista pratico può svolgere il ruolo da tramite fra il programmatore di librerie e l'usufruitore in modo da rendere chiaro a quest'ultimo come dovrà utilizzare il codice scritto. L'UML trova la sua massima applicazione in programmi di medie-grosse dimensioni dove la complessità del codice e dei diversi gradi di eredetarietà, overriding e overloading cresce esponenzialmente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8184,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8178,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8391,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8377,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8674,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6729,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1074,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "UML (unified modeling language, \"linguaggio di modellizzazione unificato\"), è un linguaggio di modellizzazione e specifica basato sul paradigma orientato agli oggetti. Viene utilizzato soprattutto nella progettazione di progetti basati su paradigma object-oriented. E permette di specificare le classi, relazioni, gli attributi e i metodi di una classe, etc.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8176,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8185,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8375,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8675,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8392,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6695,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1033,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "L'UML (unified modeling language) è un linguaggio di modellizzazione basato sul paradigma della programmazione ad oggetti. Con esso si possono rappresentare le strutture di software e applicazioni mediante l'utilizzo di tabelle e collegamenti fra le varie tabelle, specificando con le tabelle le caratteristiche delle varie classi e oggetti che compongono il progetto, con collegamenti le varie associazioni che intercorrono fra essi. In conclusione, esso viene ampiamente utilizzato in fase di analisi e/o di realizzazione di software nel campo della programmazione ad oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8187,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8376,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8673,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8175,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8390,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6634,
              "task": {
                "taskId": 184,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1079,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "UML è un linguaggio di modellazione particolarmente adatto per la programmazione object-oriented. Esso consiste in una serie di diagrammi utili per rappresentare in modo efficiente i vari aspetti di una realtà che si vuole costruire o analizzare. Per esempio, il class diagram, che fa parte di UML, permette di descrivere le diverse entità, o classi, i loro attributi(variabili di istanza), le loro funzionalità(metodi), nonchè il tipo di relazioni eventualmente presenti tra tali entità.  UML è un linguaggio che opera a livello molto alto, per cui solitamente si ricorre ad esso prima della scrittura di codice. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8177,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8389,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8672,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8374,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8186,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 184,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6304,
          "asker": {
            "courseId": 102,
            "askerId": 976,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Data una classe B che estende la classe A, è necessario ridefinire il costruttore della classe B?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6312,
          "asker": {
            "courseId": 102,
            "askerId": 1017,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Ci sono differenze nel comportamento di heap e stack se si usa una coda piuttosto che una pila?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GESTIONEDELLAMEMORIA"
            },
            {
              "keyword": " GESTIONEDELLAMEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6375,
          "asker": {
            "courseId": 102,
            "askerId": 1081,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi della ridefinizione (overriding) di una funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6316,
          "asker": {
            "courseId": 102,
            "askerId": 961,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo è fondamentale il concetto di ereditarietà nel paradigma di programmazione orientata agli oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": "riutilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6332,
          "asker": {
            "courseId": 102,
            "askerId": 993,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali metodi/variabili vengono ereditati in una sottoclasse dalla sua classe madre?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6268,
          "asker": {
            "courseId": 102,
            "askerId": 975,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Attraverso quale keyword posso far riferimento senza ambiguità a i metodi e alle variabili di una classe padre ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6321,
          "asker": {
            "courseId": 102,
            "askerId": 954,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 183,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la relazione tra classi e superclassi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Ereditarietà"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 69,
      "lectureTitle": "Collections+Equals",
      "questions": [
        {
          "questionId": 6552,
          "asker": {
            "courseId": 102,
            "askerId": 1009,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Elenca e descrivi brevemente le proprietà richieste al metodo equals().",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "EQUALS"
            },
            {
              "keyword": "EQUALS"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7025,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 996,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "1) Riflessiva : Object deve essere uguale a se stesso.\r\n\r\n2) Simmetrica : se a.equals(b) è vera allora b.equals(a) deve essere vera.\r\n\r\n3) Transitiva : se a.equals(b) è vera e b.equals(c) è vera allora c.equals(a) deve essere vera.\r\n\r\n4) Non Contraddizione : chiamate muliple di equals() devono ritornare lo stesso risultato finché nessuna proprietà viene modificata.\r\n\r\n5) Comparazione a NULL: la comparazione a NULL deve restituire false e deve risultare NullPointerException.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9586,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9269,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9346,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9454,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7062,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1076,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo equals() deve essere definito per confrontare due oggetti di un certo tipo facendo in modo che venga confrontato il contenuto dell'oggetto e non il suo indirizzo di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9584,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9452,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9271,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9345,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6962,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 982,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In java richiede che il metodo equals rispetti determinate proprietà per poter effettuare l'equivalenza \r\n\r\nRiflessività: per ogni oggetto x, avremo che x.equals(x) è vero\r\n\r\nSimmetria: dati due oggetti x ed y, avremo che se x.equals(y) è vero , allora y.equals(x) è vero\r\n\r\nTransitività: dati tre oggetti x, y e z, se x.equals(y) è vero e y.equals(z) è vero, allora x.equals(z) è vero\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9270,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9453,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9585,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9347,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6484,
          "asker": {
            "courseId": 102,
            "askerId": 1065,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un hashcode e quali vantaggi comporta il suo utilizzo? Illustra con un esempio il suo funzionamento.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6556,
          "asker": {
            "courseId": 102,
            "askerId": 991,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "L'hashCode sembra essere un metodo \"pericoloso\" in quanto non è univoco (ci possono essere delle \"collisioni\"); dato che ogni volta che si fa l'overriding di equals è necessario ri-implementare anche hashCode, sarebbe possibile implementare quest'ultimo in modo tale da renderlo univoco per ogni oggetto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6597,
          "asker": {
            "courseId": 102,
            "askerId": 1001,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le interfacce e come possono essere usate? Quale la differenza tra un'interfaccia e una classe abstract?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6589,
          "asker": {
            "courseId": 102,
            "askerId": 943,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve un hashcode e come funziona?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6587,
          "asker": {
            "courseId": 102,
            "askerId": 944,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è un tipico pattern impiegato per sfruttare un oggetto di tipo Iterator?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": "Iterator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6941,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1053,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Un oggetto di tipo Iterator, utilizzato per scorrere tutti i singoli elementi di una Collection, viene solitamente utilizzato seguendo questi passi:\r\n- viene ottenuto l'oggetto mediante il metodo iterator() della Collection\r\n- si implementa un ciclo basato sul valore di verità del metodo hasNext() dell'oggetto Iterator\r\n- all'interno del ciclo, si ottiene il prossimo elemento mediante il metodo next()",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9543,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9414,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9755,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9752,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7020,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1030,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'idea chiave del pattern Iterator consiste nel trasferire la responsabilità dell'accesso o della navigazione attraverso gli elementi di una struttura dati contenitrice, a una classe separata dal contenitore che è l'iteratore . L'iteratore rappresenta il concetto di posizione in un qualsiasi punto all'interno della struttura e può essere visto come qualcosa che punta tra due elementi. L'iteratore inizialmente punta alla posizione che precede il primo elemento, poi lo si può spostare invocando il suo metodo next: iterator.next();\r\nPrima di utilizzare il metodo next è buona prassi di programmazione invocare il metodo hasNext il quale restituisce true se c'è un elemento successivo. Quindi per scorrere gli elementi di una struttura è possibile utilizzare il seguente codice:\r\n\r\nwhile (iter.hasNext()) { \r\n  Object obj = iter.next();\r\n}\r\n\r\nIl metodo next restituisce l'elemento sopra cui transita l'iteratore durante il suo avanzamento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9415,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9544,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9749,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9754,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7051,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1091,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Iterator sfrutta 3 metodi principali: hasNext, next e remove.\r\nIl primo è booleano e restituisce \"true\" se ci sono ancora elementi da visitare.\r\nNext restituisce Object e in particolare restituisce il prossimo oggetto all'interno della collezione.\r\nMentre Remove rimuove dalla collezione gli oggetti appena visitati da next.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9753,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9751,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9412,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9545,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6943,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1053,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "sdfgh",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9413,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9750,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9756,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9542,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6567,
          "asker": {
            "courseId": 102,
            "askerId": 945,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra instanceof e getClass? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "EQUALS"
            },
            {
              "keyword": " EQUALS"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7027,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 987,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Differiscono per sintassi:\r\nPer esempio la sintassi di instanceOf è: class instanceOf a; mentre quella di getClass è: a.getClass ().\r\nSono anche due istruzioni diverse, in quanto instanceOf restituisce o true o false se le classi a confronto sono dello stesso tipo, mentre getClass restituisce una stringa con il nome della classe",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9510,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9670,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9354,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9648,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6984,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Instanceof permette di determinare se l'oggetto appartiene alla classe o ad una sottoclasse della classe con cui viene messo a confronto. Nel caso di interfacce ritorna \"true\" se la classe dell'oggetto implementa questa interfaccia.\r\n\r\nSe invece si vuole determinare esattamente la classe di un oggetto bisogna utilizzare getClass (ad esempio quando si implementa il metodo \"equals\" in una classe che dovrebbe confrontare elementi solo di quella classe, escludendo le sottoclassi) ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9511,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9355,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9671,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9649,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7019,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 983,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Istanceof restituisce vero se la classe dell'oggetto preso in considerazione corrisponde a quella a cui la stiamo confrontando e  falso altrimenti.\r\nGetclass restituisce la classe dell'oggetto preso in considerazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9353,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9650,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9672,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9512,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6536,
          "asker": {
            "courseId": 102,
            "askerId": 1068,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali operazioni possono essere effettuate su un oggetto di tipo Iterator?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Iterator "
            },
            {
              "keyword": " Iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6606,
          "asker": {
            "courseId": 102,
            "askerId": 1005,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le implementazioni concrete delle collections?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "COLLECTIONS"
            },
            {
              "keyword": " COLLECTIONS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6550,
          "asker": {
            "courseId": 102,
            "askerId": 1044,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "A quale scopo il metodo equals della classe Object è implementato semplicemente verificando gli indirizzi delle due classi passate (X==Y) ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6601,
          "asker": {
            "courseId": 102,
            "askerId": 995,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo e' una buona norma implementare le \"interfaces\"? In sostanza sono solo delle raccolte di firme e (raramente) variabili aggiuntive.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6573,
          "asker": {
            "courseId": 102,
            "askerId": 998,
            "courseFinalScore": 11
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste la differenza tra l' uso del metodo equals e l' uso del metodo hashCode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " HashCode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6554,
          "asker": {
            "courseId": 102,
            "askerId": 1043,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "spiegare l'importanza di una propria implementazione del metodo equals",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6496,
          "asker": {
            "courseId": 102,
            "askerId": 1013,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando il metodo equals() viene re-implementato in una classe, siamo in presenza di Overloading o di Overriding del metodo equals() ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6968,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1025,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se nella re-implementazione viene modificata la firma, ad esempio cambiando il tipo del parametro formale, allora siamo in presenza di Overloading. Se invece il metodo equals() mantiene la stessa firma di quello nella classe Object e viene dunque sovrascritto siamo allora in presenza di Overriding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9566,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9488,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9403,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9574,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7060,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1075,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se si usa equals(Object) siamo in presenza di Overriding mentre se usa equals(qualcos'altro) è Overloading.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9489,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9568,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9571,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9401,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7005,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1066,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "overriding in quanto la firma di equals rimane invariata",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9569,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9487,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9572,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9402,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6974,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1026,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nel caso del metodo equals si tratta di Overriding dato che non stiamo aggiungendo parametri e non stiamo cambiando il tipo dei parametri e del return. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9567,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9490,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9575,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9405,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7002,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1078,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si tratta di overloading essendo equals() giá dichiarata nella classe object con parametro generico object. Quando si reimplementa si cambia la firma di tale funzione mettendo un parametro di tipo opportuno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9404,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9573,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9570,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9491,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6525,
          "asker": {
            "courseId": 102,
            "askerId": 997,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il metodo Equals della classe Object?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "EQUALS"
            },
            {
              "keyword": "EQUALS"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6940,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1046,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nella classe Object il metodo Equals è quel metodo che confronta questo oggetto con quello passato come parametro. \r\nL'implementazione è fatta con == quindi restituirà true se e solo se gli oggetti sono lo stesso oggetto, poichè controlla che il riferimento in memoria sia uguale. \r\nÈ un metodo che può essere sovrascritto e ereditato da tutte le sottoclassi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9597,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9533,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9669,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9556,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7001,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "il metodo equals() è destinato a confrontare due reference (sul primo viene chiamato il metodo e il secondo viene passato come parametro) e restituisce il valore booleano true se e solo se i due reference puntano ad uno stesso oggetto, quindi se hanno lo stesso indirizzo di puntamento.\r\nnella classe Object è definito come segue:\r\n\r\npublic boolean equals(Object obj) {\r\n  return (this == obj); \r\n}\r\n\r\nin alcune sottoclassi di Object, come String, il metodo equals() è riscritto in modo tale da restituire true anche nel caso di confronto tra due reference che puntano ad oggetti diversi, ma con gli stessi contenuti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9557,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9598,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9532,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9668,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6539,
          "asker": {
            "courseId": 102,
            "askerId": 1096,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché la fuzione java che confronta se due classi sono uguali restituisce true unicamente se sono la stessa istanza di una data classe, quali sono i vantaggi, svantaggi e le conseguenze di questa decisione del linguaggio java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6551,
          "asker": {
            "courseId": 102,
            "askerId": 1099,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "che Cos'è dynamic binding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Dynamic"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6935,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per dynamic binding si intende che il legame tra i metodi avviene a run time, cioè durante la fase di esecuzione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9451,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9539,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9747,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9426,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7037,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 953,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": ".il dynamic binding è la possibilità di scegliere a runtime il metodo di quale classe utilizzare. Ad esempio, abbiamo due classi derivate (A, B), una casse padre(C) e lo stesso metodo (f()) dichiarato nella classe C e implementato in due modi diversi nelle classi A e B.\r\nC c:\r\nc=new A();\r\nc.f();\r\nIn questo modo f() si riferisce al metodo della classe A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9449,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9427,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9540,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9746,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6994,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 974,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nella programmazione a oggetti, la decisione su quale attributo o metodo richiamare in un punto dell'esecuzione del programma viene eseguita tramite il binding.\r\n\r\nQuesta decisione può essere stabilita in anticipo in maniera fissa, (binding statico o early binding), oppure essere presa a tempo di esecuzione, in maniera dinamica, (binding dinamico o late binding).\r\nBinding dinamico, o late binding, è il binding stabilito a tempo di esecuzione.\r\n\r\nNel secondo caso il compilatore non genera una volta per tutte, all'atto della compilazione, il codice per l'assegnazione dei valori delle variabili o per calcolare quale metodo chiamare - come nel binding statico - ma genera un codice che verrà utilizzato per calcolare quale metodo richiamare di volta in volta.\r\n\r\nNel binding dinamico, quindi, l'identità delle variabili è determinata a seconda del flusso di esecuzione, e non può essere stabilita a priori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9448,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9538,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9748,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9424,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6931,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Un binding é il legame tra il nome di una variabile e la variabile stessa, talvolta non é possibile definire questo legame a compile time (ad esempio nel caso il tipo di una variabile sia definito da utente) ed è in queste circostanze che entra in gioco il dynamic binding, che non è altro che la creazione di un binding a run time. In java il dynamic binding viene effettuato dalla jvm.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9541,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9450,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9425,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9745,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6495,
          "asker": {
            "courseId": 102,
            "askerId": 1014,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali funzioni ci fornisce un iterator?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " Iterator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6986,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un iterator fornisce un metodo listIterator() che crea l'iteratore, un metodo next() che lo fa avanzare ed un metodo hasNext() che verifica l'esistenza del nodo successivo e, in modo del tutto opzionale un metodo remove()",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9685,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9646,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9537,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7058,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1002,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Gli iteratori permettono di scorrere su un contenitore, accedendo a ogni elemento singolarmente. Un iteratore astrae e generalizza il concetto di puntatore a una sequenza di oggetti e può essere implementato in tanti modi diversi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9536,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9688,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9644,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7052,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1073,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un iterator è in grado di darci la possibilità di muoverci tra gli elementi di una collezione grazie al metodo next(), effettuare un controllo sull'esistenza di un eventuale elemento successivo grazie al metodo hasnext() e di eliminare l'ultimo elemento visitato attraverso il metodo remove().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9686,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9535,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9647,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6938,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 981,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "un iterator è un oggetto che fornisce dei metodi per accedere con facilità a una collezione di dati. creato l'iterator, è sufficiente chiamare la funzione next per far muovere il cursore in avanti di una componente e ottenere la componente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9534,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9687,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9645,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6514,
          "asker": {
            "courseId": 102,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa cambia se faccio il controllo di due oggetti con equals, oppure con un semplice eguaglianza tra loro due a livello di memoria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6534,
          "asker": {
            "courseId": 102,
            "askerId": 976,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che accorgimenti è necessario prendere quando si implementa il metodo equals di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7063,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1032,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La prima cosa che devo controllare è se l'oggetto che mi è stato passato sia null; in questo caso so già che è diverso dall'oggetto che ho, quindi la condizione da imporre è che se l'oggetto passato è null allora l'output è false. Nella definizione di equals posso fare un overloading o un overriding. In questo secondo caso la condizione da imporre è che \r\nse il parametro che mi è stato dato non è compatibile con quello che voglio comparare l'output deve essere false. Devo effettuare dunque dei cast. Inoltre devo applicare equals solo le volte che la funzione hashcode mi da lo stesso codice altrimenti sono certo di avere oggetti diversi.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9744,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9601,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9768,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9436,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9732,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6999,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 977,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "bisogna fare in modo che il metodo controlli solo le corrispondenze dei valori delle classi comparate, senza controllare se anche i nomi delle stesse siano uguali (nel qual caso, presumibilmente restituirebbe che due classi contenenti gli stessi parametri ma con nomi differenti sono diverse tra loro",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9438,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9600,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9730,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9766,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9741,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7064,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Al fine di implementare il metodo equals di una classe (ovvero di estendere il metodo equals di object), è necessario stabilire quali siano i criteri di uguaglianza rilevanti nella classe. In generale, le relazioni di uguaglianza devono rispettare le proprietà transitiva, simmetrica e riflessiva. Equals deve  essere \"consistente\", vale a dire che invocando più volte la equals sugli stessi operandi debbo ottenere sempre lo stesso risultato. E' inoltre necessario controllare che x.equals(null) restituisca sempre falso.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9599,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9731,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9765,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9743,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9437,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6933,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 962,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per ottenere risultati significativi, il metodo equals deve essere ridefinito in ogni classe in cui è necessario effettuare confronti. Altrimenti, se nella classe in questione il metodo non è stato sovrascritto, verrà eseguito il metodo ereditato da Object, con risultati che potrebbero essere inattesi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9435,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9767,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9729,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9602,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9742,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6489,
          "asker": {
            "courseId": 102,
            "askerId": 948,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega che cos'è e a cosa serve un hashcode.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6592,
          "asker": {
            "courseId": 102,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare le funzioni svolte dai metodi add e remove all'interno delle Collections.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6595,
          "asker": {
            "courseId": 102,
            "askerId": 1070,
            "courseFinalScore": 10
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java, quale è la differenza tra il concetto di identità e quello di uguaglianza ? Quali sono, nello specifico, le proprietà che richiediamo al metodo equals() ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "=="
            },
            {
              "keyword": " equals()"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6579,
          "asker": {
            "courseId": 102,
            "askerId": 978,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega se l'uguaglianza degli hashcode di due oggetti implica anche l'uguaglianza degli oggetti stessi e dimostralo con un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6506,
          "asker": {
            "courseId": 102,
            "askerId": 992,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un'interfaccia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": "interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6561,
          "asker": {
            "courseId": 102,
            "askerId": 1018,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra una classe astratta e un'interfaccia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "INTERFACCE"
            },
            {
              "keyword": " INTERFACCE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6545,
          "asker": {
            "courseId": 102,
            "askerId": 979,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra instanceOf e getClass()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6993,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 961,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "InstanceOf è un metodo che ritorna un valore booleano.Se l'operatore sinistro è un istanza della classe fra parentesi , verrà ritornato un valore positivo altrimenti negativo.esempio utilizzo : Pippo.instanceof (classe).\r\nGetclass() è un metodo che ritorna la classe del oggetto chiamato.\r\nEs:\r\n Pippo.getclass(); // ritorna la classe di pippo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9587,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9515,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9339,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9563,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6952,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 960,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Per prima cosa si può notare come differisca la sintassi fra i due costrutti.\r\nIl primo è un operatore infisso (A instanceOf punto) e la sua funzione è quella di ritornare il valore booleano True nel caso A sia COMPATIBILE con la classe punto quindi tornerà true anche nel caso A sia un oggetto di una classe derivata da A.\r\ngetClass utilizza la seguente sintassi (A.getClass()) con la funzione di ritornare una String composta dal nome della classe di A. Questo ci permette nel caso si voglia fare una funzione di confronto fra due oggetti di stabilire se appartengono alla stessa classe o a classe ereditate.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9338,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9589,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9565,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9514,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7068,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1081,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza sta prevalentemente nel fatto che instanceOf è un operatore mentre getClass() è un metodo. instanceOf restituirà infatti un valore booleano e nello specifico 'true' se l'oggetto è un'istanza della classe di confronto o di una sua superclasse, 'false' in caso contrario. getClass(), essendo un metodo e non un operatore, restituirà al posto del valore booleano un'istanza di tipo Class, diversificandone gli utilizzi rispetto all'operatore instanceOf.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9337,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9588,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9513,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9564,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6499,
          "asker": {
            "courseId": 102,
            "askerId": 967,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la differenza tra \"uguaglianza\" e \"identità\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "identità"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6544,
          "asker": {
            "courseId": 102,
            "askerId": 1035,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'hashcode e a cosa serve? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Hashcode"
            },
            {
              "keyword": "Hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6575,
          "asker": {
            "courseId": 102,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Come può essere usata una classe astratta in combinazione con un'interfaccia? Può una classe astratta implementare un'interfaccia? Può un'interfaccia estendere una classe astratta? Può un'interfaccia essere dichiarata astratta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6549,
          "asker": {
            "courseId": 102,
            "askerId": 1023,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "cos'è l'hashCode e in che modo permette di velocizzare il controllo di determinati oggetti senza usare il metodo equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": "hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6995,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 986,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "L'hashcode è metodo che restituisce un valore che viene associato ad un oggetto e questa funzione viene utilizzata quando vi sono tanti attributi. \r\nL'hashcode è un metodo più veloce della funzione equals, ma è meno preciso, poichè non controlla attributo per attributo. Dunque l'hashcode permette di fare controlli veloci: se due oggetti hanno valori differenti, si sa gia in partenza che questi sono diversi, non è detto che se hanno lo stesso numero siano uguali, di conseguenza si applica il metodo equals. Quindi il metodo hashcode, permette di utilizzare il meno possibile la funzione equals.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9443,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9723,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9499,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9509,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9612,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7048,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1085,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "l'hashCode è un metodo per velocizzare il confronto tra funzioni differenti in sostanza è una verifica grossolana per fallire il test, difatti se il test risulta negativo si sa per certo che le funzioni sono differenti. in caso di un test positivo però bisogna utilizzate per forza il metodo equals per confrontarli ed avere la certezza del fatto che le funzioni siano identiche.\r\nesempio:\r\nabbiamo le funzioni \"ABBA\" e \"ABBB\" a confronto, un metodo di confronto può essere la differenza delle somme dei valore acsii delle lettere del testo, in questo caso si ha che la prima vale 262 e la seconda vale 263 quindi si può determinare con la massima certezza che le funzioni sono differenti.\r\ninvece confrontando con lo stesso metodo le funzioni \"ABAB\" e \"ABBA\" si ha che la somma dei valore acsii delle lettere del testo è di 262 per entrambe le funzioni quindi apparentemente identiche, in questo caso per avere la certezza che le funzioni siano identiche bisogna per forza usare il metodo equals.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9725,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9614,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9500,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9444,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9508,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7004,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1049,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'hashCode è un metodo utilizzato nella programmazione ad oggetti in Java che permette un controllo veloce sul definire se due oggetti sono uguali. Viene utilizzato spesso a braccetto con il metodo equals. L'utilizzo del metodo hashCode permette di restituire velocemente l'equazione di uguaglianza fra due oggetti in quanto non ha bisogno di controllare l'intero oggetto, ma soltanto i parametri da noi definiti all'interno del metodo. Per sapere se essi sono identità, verrà eseguito un controllo ulteriore in seguito con il metodo equals. Riassumendo, il metodo hashCode permette di definire se due oggetti sono simili per determinati valori impostati, se si vuole, invece, conoscere se sono identità si passerà all'utilizzo del metodo equals.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9498,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9442,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9507,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9613,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9724,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6591,
          "asker": {
            "courseId": 102,
            "askerId": 965,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Si faccia un esempio concreto di utilizzo delle Collections di Java.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6485,
          "asker": {
            "courseId": 102,
            "askerId": 1022,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponiamo di avere due oggetti con lo stesso hashcode e gli inseriamo all'interno di una HashMap.\r\nMap.put(x,x); Map.put(y,y);\r\ndove x.hashcode()==y.hashcode().\r\nQuanti oggetti ci sono in questa HashMap (almeno)? Motivare accuratamente la risposta usando le proprietà degli hashcode.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "HASHCODE"
            },
            {
              "keyword": " HASHCODE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6498,
          "asker": {
            "courseId": 102,
            "askerId": 1085,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "cos'è l'uguaglianza di classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " istanze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6518,
          "asker": {
            "courseId": 102,
            "askerId": 1091,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è nel confrontare due classi usando l'operatore \"==\" e il metodo \"equals\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6973,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1071,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Nel confrontare due OGGETTI (o istanze di una classe), se viene utilizzato l'operatore == vengono confrontati gli indirizzi di memoria degli oggetti in questione. Questo implica che anche se due oggetti sono stati creati nello stesso modo (ovvero i valori di tutte le variabili di quell'oggetto sono uguali), l'operatore restituirà false.\r\nSe viene invece utilizzato il metodo equals, ci sono due casi:\r\n- Se passo un object e non è stato fatto overriding del metodo, vengono confrontati gli indirizzi degli oggetti in questione (come nel caso dell'operatore ==)\r\n- Se invece passo un oggetto di tipo MyClass, verrà utilizzato il metodo scritto dal programmatore, che determinerà se i due oggetti sono uguali o meno, basandosi sui requisiti determinati nel metodo stesso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9467,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9678,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9696,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6927,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 976,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"==\" confronta esclusivamente l'etichetta della classe, mentre il metodo \"equals\" può essere scritto in modo che confronti tutti gli attributi delle classi confrontate.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9674,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9698,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9466,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6956,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 957,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"==\" esegue il confronto tra gli identificatori (indirizzi in stack) delle 2 istanze; il metodo equals, se non ridefinito, esegue la stessa operazione, quindi di default non ci sono differenze nel risultato. E' possibile (e consigliabile) però ridefinire il metodo equals in modo da fare un confronto secondo criteri che abbiano più senso, come ad esempio tra alcuni, o tutti, gli attributi dei 2 oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9469,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9699,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9677,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7034,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 967,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"==\" confronta le due classi ritornando il valore booleano \"true\" se e solo se le due classi sono identiche, ovvero se o solo se sono la stessa classe (quindi sono allocate nello stesso spazio in memoria). Il metodo equals invece restituisce il valore booleano \"true\" non solo se le due classi sono identiche, ma se anche sono uguali, ovvero se ogni parametro della prima istanza della classe è uguale al rispettivo parametro della seconda istanza della classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9465,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9676,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9697,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6951,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1098,
                "courseId": 102,
                "courseFinalScore": 14
              },
              "answerText": "L'operatore \"==\" confronta il valore effettivo nel caso di variabili di tipo primitivo, mentre per quanto riguarda gli oggetti, confronta gli indirizzi dove sono stati memorizzati che non sono mai uguali a meno di assegnazione di uno stesso oggetto a due variabili diverse. Per questo si usa il metodo \"equals\" per confrontare due oggetti, infatti, con questo, viene comparato il contenuto dei due oggetti così da vedere effettivamente se sono uguali. L'intoppo è che, chiamando il metodo \"equals\" senza implementarlo, gli oggetti verranno confrontati alla stessa maniera del \"==\" , perché il metodo viene ereditato dalla classe Object dove è implementato con questo operatore. E' quindi necessaria un'implementazione perché sia efficace. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9673,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9701,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9464,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6963,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1013,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Supponiamo di avere due oggetti di tipo Persona già istanziati, \"p1\" e \"p2\".\r\nUsando l'operatore \"==\" , viene confrontato il valore contenuto nella variabile \"p1\" con il valore contenuto nella variabile \"p2\". Ma \"p1\" e \"p2\" contengono l'indirizzo di memoria (memoria heap) dove sono stati allocati i due oggetti di tipo Persona: infatti, possiamo considerare \"p1\" e \"p2\" come dei veri e propri puntatori. Dunque, questo tipo di confronto restituirà true se \"p1\" e \"p2\" contengono lo stesso indirizzo di memoria (cioè si riferiscono allo stesso oggetto in memoria: fenomeno di Aliasing); false altrimenti.\r\nUtilizzando il metodo \"equals\" invece, possiamo spingerci oltre, e definire noi i parametri secondo cui due oggetti possono essere considerati uguali. Ad esempio, due Persone potrebbero essere considerate uguali perchè hanno lo stesso Codice Fiscale. Basterà dunque re-implementare a dovere il metodo \"equals\" già definito nella classe Object, e utilizzarlo per confrontare due oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9700,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9675,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9468,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6583,
          "asker": {
            "courseId": 102,
            "askerId": 980,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra una classe astratta e un'interfaccia? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "INTERFACCE"
            },
            {
              "keyword": "INTERFACCE "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6527,
          "asker": {
            "courseId": 102,
            "askerId": 928,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi comporta l'utilizzo delle Collections?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "vantaggi"
            },
            {
              "keyword": " collections"
            },
            {
              "keyword": " utilizzo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6563,
          "asker": {
            "courseId": 102,
            "askerId": 1040,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Per confrontare due oggetti in java perchè si deve utilizzare il metodo equals() invece dell'operatore '=='?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6991,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1031,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore == confronta l'effettivo valore contenuto nella variabile. E' sicuramente efficace nei casi in cui il confronto avviene tra tipi primitivi (quali per esempio int, float, char, ...) in quanto il valore contenuto nella variabile è prettamente il valore stesso assegnato.\r\nIn caso di oggetti (derivati dalla classe Object), però, il contenuto effettivo della variabile altro non è che un puntatore all'oggetto stesso. Di conseguenza l'operatore == andrebbe a confrontare gli indirizzi e, anche se due oggetti son stati dichiarati con gli stessi identici attributi e son effettivamente \"uguali\", se non condividono la stessa area di memoria vengono visti come diversi da questo operatore.\r\nEcco quindi che nella classe Object viene definito il metodo equals(), che eventualmente con l'overriding verrà ridefinito dalle classi sottostanti, che permette di confrontare due oggetti per le loro effettive caratteristiche similari (generalmente in base ai loro attributi)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9283,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6957,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L?operatore ?==? mette a confronto la reference dei due oggetti e restituisce true se i due oggetti si riferiscono alla stesso riferimento, stesso oggetto in memoria. Non fa quindi il confronto tra gli stati dell?oggetto. Equals() invece può verificare se due oggetti sono uguali (ad esempio se gli oggetti in questione contengono lo stesso valore). Il metodo equals() di default fa lo stesso confronto dell?operatore ?==? (confronta puntatori), è bene quindi fare l?overriding del metodo riscrivendolo secondo le nostre esigenze. E? pertanto preferibile usare il metodo equals() poichè lo si può reimplementare a seconda delle nostre necessità. Importante è ricordare che equals() deve sempre comparare due Object. Proprietà utili di questo metodo sono: riflessione (un oggetto è uguale a se stesso), simmetria, transitività. Inoltre per qualsiasi riferimento x non nullo, x.equals(null) deve restituire false.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9286,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6928,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1058,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché l'operatore di uguaglianza da risultato  true solo nel caso in cui i due oggetti siano totalmente identici, ovvero i due oggetti sono allocati nello stesso spazio di memoria. Quindi per un vero e proprio confronto si necessita del metodo equals() implementato a seconda dei criteri del programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9284,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6929,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 979,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"==\" non è adatto a confrontare oggetti in Java in quanto agisce a livello di variabile. Infatti, un oggetto è rappresentato come un puntatore a zona di memoria che contiene variabili e metodi. Ciò significa che con \"==\" otterremmo un confronto tra indirizzi che non è l'informazione cercata. Esiste dunque il metodo equals() che permette di implementare la modalità di confronto voluta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9285,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6517,
          "asker": {
            "courseId": 102,
            "askerId": 1031,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "E' corretto basare la funzione equals sulla corrispondenza dell'hashcode degli oggetti da confrontare? Motivare la risposta.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6535,
          "asker": {
            "courseId": 102,
            "askerId": 1007,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo quando si implementa una collection di tipo \"Set\" sarebbe opportuno definire il metodo hashCode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6492,
          "asker": {
            "courseId": 102,
            "askerId": 964,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare brevemente le differenti proprietà di una classe astratta e di un interfaccia e della loro implementazione. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": "Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6509,
          "asker": {
            "courseId": 102,
            "askerId": 939,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra le strutture dati \"Set\" e le strutture dati \"List\" derivanti dalla classe Collection?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6562,
          "asker": {
            "courseId": 102,
            "askerId": 1046,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa contiene il Java Collection Framework? (spiega brevemente).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6598,
          "asker": {
            "courseId": 102,
            "askerId": 1036,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Se nell'implementazione di equals andiamo ad utilizzare \r\nif (!(var instanceof P)) return false; \r\nanzichè  if (o.getClass() != this.getClass()) \r\nreturn false;  \r\nnon rischiamo di violare la simmetria richiesta al metodo equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7050,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1089,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, poiché le due classi sono uguali, cambia solamente la scrittura ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9367,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9447,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9595,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7006,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1047,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "Si, utilizzando istanceof, la simmetria di equals() ( che prevede a.equals(b) <==> b.equals(a)) viene  in alcuni casi violata. Per esempio, siano date le classi A e B con B che eredita da A:\r\nclass A{                                                    \r\n  int x;\r\n  ...costruttore\r\n  ...equals(Object obj) usando istanceof (due oggetti sono uguali se hanno stesso campo x)\r\n}\r\nclass B extends A{\r\n  ...costruttore\r\n  ...equals(Object obj) usando istanceof (due oggetti sono uguali se hanno stesso campo x)\r\n}\r\nsia poi A a= new A(1);     B b= new B(1);\r\nricordando il seguente:\r\n\r\na istanceof A -->true\r\na istanceof B -->false\r\nb istanceof A -->true\r\nb istanceof B -->true\r\n\r\nho che a.equals(b) -->true (viene usato equals di A e a.x==b.x)\r\nma b.equals(a) -->FALSE! (viene usato equals di B, a.x==b.x, ma a instanceof B FALSE)\r\n\r\ne quindi la simmetria viene meno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9446,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9368,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9594,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7036,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 998,
                "courseId": 102,
                "courseFinalScore": 11
              },
              "answerText": "Se nell' implementazione di equals utilizziamo:\r\nif (!(var instanceof P)) return false; \r\nal posto di if (o.getClass() != this.getClass()) return false;\r\nnon violiamo la simmetria che viene richiesta al metodo equals. Infatti le due soluzioni possono considerarsi equivalenti e scegliere l' una piuttosto che l' altra dipende dal modo in cui si vuole implementare il metodo equals.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9369,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9596,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9445,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6558,
          "asker": {
            "courseId": 102,
            "askerId": 955,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Abbiamo visto le collection list e set, in cui gli elementi possono essere ripetuti o no. Invece le map che tipi di oggetti sono?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6543,
          "asker": {
            "courseId": 102,
            "askerId": 1080,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Ma quando si fa l'assegnazione tra oggetti del tipo p1=p2; con entrambi oggetti della classe P, si da l'indirizzo di p2 in p1 o si fa un'assegnazione a ciascun campo di p1?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Assegnazione"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6959,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1014,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "In un'assegnazione fra oggetti come questa (p1 = p2), viene copiato l'indirizzo a cui fa riferimento p2 in p1; questo fenomeno è detto aliasing e accade quando utilizziamo due identificatori diversi che fanno riferimento allo stesso oggetto in memoria (p1 e p2 in questo caso).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9527,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9683,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9531,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9659,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7010,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 940,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Di fatto, ciò che viene copiato in p1 è l'indirizzo di memoria contenuto nella variabile p2. In fin dei conti, p1 e p2 sono delle *referenze* (puntatori \"mascherati\") per gli oggetti di tipo P,  i quali sono in realtà memorizzati nello heap.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9528,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9682,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9660,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9530,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6947,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 941,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Quando hai due oggetti p1,p2 entrambi della classe P e fai un'assegnazione come \"p1=p2\", l'indirizzo di p2 viene assegnato anche a p1.\r\nIn questo modo i due oggetti puntano alla stessa area di memoria; questo significa che se viene modificato un valore di p1, la modifica avverrà anche su p2 (e viceversa).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9526,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9684,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9529,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9661,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6508,
          "asker": {
            "courseId": 102,
            "askerId": 1039,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Se voglio creare una collection di oggetti eterogenei, tipo studenti docenti staff, è meglio creare per ognuno una lista oppure un unica lista con associati degli indici?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "collection"
            },
            {
              "keyword": "liste"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7067,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 956,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Un'unica lista con associati gli indici, a differenza dei set a cui non possiamo associare degli indici. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9654,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9519,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9291,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6967,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1079,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Dipende da che tipo di realtà si vuole modellare e quale è lo scopo del programma che si vuole costruire. Se per esempio si vuole creare un programma che calcola quante persone ci sono in media all'interno dell'Università allora conviene ovviamente trattare tutte le entità come eguali creando un'unica lista. Un programma per la gestione degli stipendi invece dovrà utilizzare una lista diversa per ognuna delle tre classi.    ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9516,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9289,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9657,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7057,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1101,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se voglio creare una collection di oggetti eterogenei posso utilizzare entrambe le \"strategie\":\r\n\r\n1.se creo un'unica lista con gli indici associati posso trovare il tipo necessario al mio impiego grazie al polimorfismo utilizzando l'operatore instanceof (if (oggetto[indice] instanceof Studente) {...});\r\n\r\n2.se creo più liste per ogni oggetto troverò con più facilità l'oggetto necessario (Studente[50], Docente[10],...);\r\n\r\nPertanto la prima soluzione mi dà più flessibilità, ma la seconda soluzione è più veloce ed è più vicina alla realtà. Pertanto la seconda opzione è preferibile alla prima.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9287,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9517,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9655,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6964,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1044,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Dipende dallo scopo del programma.\r\nSe la collection è destinata a contenere pochi elementi o elementi nuovi (esempio viene aggiunto un nuovo tipo di persona: Ricercatore) allora può essere conveniente inserire tutti gli oggetti in un unica lista.\r\nAl contrario, se si prevede che gli oggetti della lista rimangano sempre gli stessi (es: non verranno creati nuovi tipi di persone) allora può essere conveniente utilizzare più liste.\r\nInoltre il sistema a più liste è computazionalmente più semplice perché per esempio, nella ricerca per cognome dello studente, non è necessario verificare tutte le volte, all'atto di estrazione, che l'oggetto sia studente visto che direttamente mi sposterò all'inizio della ricerca sulla lista studenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9290,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9520,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9656,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6971,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "È meglio creare per ognuno una lista poiché vi potrebbero essere metodi che non possono corrispondere a determinati oggetti e quindi si possono causare problemi ereditarietà.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9658,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9288,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9518,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6553,
          "asker": {
            "courseId": 102,
            "askerId": 1095,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "non ho capito perchè nelle slaid System.out.println(p1.equals(p2)); ritorna false \r\ne poi in un altra slaid con tutto definito uguale nel main il comando System.out.println(p1.equals(p2)); ritorna true.\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "metodo "
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6487,
          "asker": {
            "courseId": 102,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi e` preferibile utilizzare una collection al posto di un array?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": "Collections"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6934,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1003,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "I casi possono essere svariati casi in cui le collections sono preferibili agli array. Se vogliamo ad esempio memorizzare oggetti di tipo diverso non possiamo certamente utilizzare un array, inoltre le collections forniscono metodi per ordinare (sorting) la collection stessa in modo da poter utilizzare diversi algoritmi di ricerca più efficienti. Peraltro, in molti casi, utilizzare una collection risulta essere più semplice e rispetta maggiormente il principio dell'astrazione, infatti anche non sapendo come è implementata ci viene fornita un'interfaccia che ci permette di utilizzarla.\r\nL'utilizzo degli array è quindi consigliato solamente nei casi in cui vogliamo memorizzare un singolo tipo di dato specialmente se esso è un tipo primitivo (INT, DOUBLE, BOOL).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9762,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9390,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9348,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7056,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 943,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una collection è generalmente più conveniente da usare di un array, dato che contiene tanti metodi già testati (praticamente a prova di errore) che ci permettono di lavorare facilmente sugli elementi contenuti al suo interno risparmiando tempo e fatica. Può risultare utile utilizzare un array nel caso in cui voglia fare qualcosa di più semplice e banale, magari utilizzando solo dei tipi primitivi al suo interno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9351,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9763,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9391,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6985,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1080,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando si vuole lavorare su classi diverse, tuttavia bisogna tener conto che la collection è un concetto è non un comando, per poterne avere una bisogna creare list,set o quant'altro, tuttavia esiste pure l'arraylist che  è una collection ma allo stesso tempo un array",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9352,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9760,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9392,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6989,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1017,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Gli elementi dell'array devono essere tutti dello stesso tipo con le collections invece è possibile costruire delle gererchie (eventualmente si avrà bisogno di un casting).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9350,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9761,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9388,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6945,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1034,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Un array è una struttura dati molto semplice per cui alcune volte ha senso aggiungere un livello di astrazione in più introducendo strutture dati più complesse (e i loro algoritmi). E' altamente consigliabile quindi conformarla all'interfaccia Collection cosicché la nostra struttura dati sia compatibile con una serie di librerie di Java stesso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9349,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9389,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9764,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6572,
          "asker": {
            "courseId": 102,
            "askerId": 1064,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quand'e' che due oggetti sono considerati uguali nel linguaggio Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "identita'"
            },
            {
              "keyword": " identita'"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6500,
          "asker": {
            "courseId": 102,
            "askerId": 963,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali caratteristiche delle Collection di tipo Set?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": "Collections"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7054,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 993,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'interfaccia di tipo Set è una sottointerfaccia di Collection. Un set è un insieme non ordinato (e quindi non indicizzato) di elementi. In esso non sono previsti duplicati di uno stesso oggetto, al contrario di quanto accade nella interfaccia di tipo List.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9313,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9359,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9381,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9579,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6948,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1064,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La collection di tipo set e' caratterizzata dall'unicita' dei suoi elementi, i quali non si possono ripetere, al contrario delle List. Un'altra importante caratteristica e' che gli elementi non sono indicizzabili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9360,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9581,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9382,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9315,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7059,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1015,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Una collection di tipo set non può avere elementi duplicati al suo interno. Inoltre non si può accedere agli elementi tramite un indice e non è garantito che gli elementi si trovino nello stesso ordine in cui sono stati inseriti",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9383,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9580,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9314,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9361,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6533,
          "asker": {
            "courseId": 102,
            "askerId": 962,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per interfaccia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7061,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 966,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un interfaccia rappresenta una sorta di ?promessa? che una classe si impegna a mantenere. La promessa è quella di implementare determinati metodi di cui viene resa nota soltanto la definizione (un po? come si è già visto per le classi ed i metodi astratti). In Java un'interfaccia non può essere instanziata e può contenere SOLO metodi d'istanza astratti e costanti.",
              "notes": "-",
              "rating": 0,
              "coins": []
            }
          ]
        },
        {
          "questionId": 6569,
          "asker": {
            "courseId": 102,
            "askerId": 1028,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché conviene implementare un override del metodo \"equals()\" piuttosto che un overload?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6541,
          "asker": {
            "courseId": 102,
            "askerId": 1066,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "descrivere l'utilità delle interfacce ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": " interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6578,
          "asker": {
            "courseId": 102,
            "askerId": 1089,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è lo scopo delle interfacce?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6570,
          "asker": {
            "courseId": 102,
            "askerId": 985,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che funzione ha l'hashcode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6596,
          "asker": {
            "courseId": 102,
            "askerId": 1075,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa determinano rispettivamente l'uguaglianza di HashCode() e la non uguaglianza?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7017,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 988,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se due hashcode sono diversi allora i due oggetti a cui si riferiscono gli hashcode sono diversi. L'uguglianza degli hashcode invece non implica l'uguaglianza degli oggetti in quanto oggetti diversi possono avere lo stesso hashcode. Per questo motivo equals() e hashCode() vengono spesso usati insieme (il legame è molto stretto, tanto che la documentazione della classe object prevede che nel caso di overriding di uno dei due debba essere fatto anche l'overriding dell'altro metodo).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9470,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9694,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9397,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6992,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 958,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'uguaglianza di due hashcode sta a significare l'uguaglianza degli oggetti confrontati, al contrario la non uguaglianza sta a significare una differenza tra i due oggetti, che può essere rilevata attraverso l'uso del metodo equals.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9695,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9396,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9471,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6605,
          "asker": {
            "courseId": 102,
            "askerId": 1082,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'hashcode? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Hashcode"
            },
            {
              "keyword": " Hashcode "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6486,
          "asker": {
            "courseId": 102,
            "askerId": 1008,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando due oggetti della stessa classe si dicono \"identici\" e quando sono invece \"uguali\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "identità"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7003,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 928,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Due oggetti della stessa classe si dicono:\r\nIdentici - quando sono lo stesso oggetto e quindi puntano alla stessa parte di memoria\r\nUguali - quando sono uguali tra loro ma allo stesso tempo puntano a due parti di memoria distinte",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9275,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9705,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9628,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7009,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1086,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Due oggetti della stessa classe si dicono identici se, confrontandoli utilizzando l'operatore ==, fanno riferimento alla stessa area di memoria. Se cambio uno dei due, cambia anche l'altro.\r\nDue oggetti della stessa classe si dicono uguali se, confrontandoli utilizzando il metodo equals (), in un dato istante hanno lo stesso aspetto, tuttavia non fanno riferimento alla stessa area di memoria e, se cambio uno, non cambio automaticamente anche l'altro.\r\nEsiste un metodo equals () presente nella classe Object (nel quale viene utilizzato semplicemente l'operatore ==) che è la base per definire il proprio metodo. La ridefinizione va fatta rispettando la proprietà riflessiva, simmetrica, transitiva, tipiche di una relazione d'equivalenza e inoltre, bisogna far in modo che sia consistente ovvero, invocando più volte la equals () sugli stessi operandi, c'è sempre lo stesso risultato; infine x.equals(null) deve ritornare false.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9629,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9704,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9276,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7030,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 968,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Due oggetti di una classe si dicono identici, se non hanno nulla di diverso. Sono uguali se hanno per esempio stesso valore ma nomi diversi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9702,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9277,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9630,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6955,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 952,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Due oggetti che sono istanza di una stessa classe si dicono identici quando sono proprio lo stesso oggetto, ovverro quando entrambi si riferiscono ad una sola area di memoria ! Questo confronto si fa con l'operatore == !\r\n\r\nEs: MyClass a = new MyClass();\r\n     MyClass b = a;\r\n     a == b;\r\n  -> Qui a e b sono identici perchè sia a, sia b identificano la stessa area/la stessa entità !\r\n\r\nL'ugualianza tra due oggetti, che sono istanza di una stessa classe, è un po' più complicata perchè dipende dall'implementazione. \r\nSolitamente c'è ugualianza quando tutti gli attributi di un certo oggetto sono uguali a tutti gli attributi dell'altro ! Questo confronto si fa con il metodo equals()\r\n\r\nEs: MyClass a = new MyClass();\r\n     MyClass b = new MyClass();\r\n     a.equals(b);\r\n  -> Qui a e b sono uguali se gli attributi di a sono uguali agli attributi di b !\r\n  \r\nLa differenza tra uguaglianza e identità è una cosa molto sottile e in alcuni casi può anche essere la stessa cosa ! Es: classe Object !",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9278,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9627,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9703,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6557,
          "asker": {
            "courseId": 102,
            "askerId": 1098,
            "courseFinalScore": 14
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i problemi che possono sorgere utilizzando l'operatore \"equals\" e come possono essere risolti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals "
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6530,
          "asker": {
            "courseId": 102,
            "askerId": 1071,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Se definisco la funzione \"bool equals(MyClass obj)\", ma al momento di richiamarla al posto di passare un oggetto di tipo MyClass passo un oggetto di tipo String, cosa succede?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6586,
          "asker": {
            "courseId": 102,
            "askerId": 1015,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità del poter ridefinire la funzione equals(...)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6521,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Avendo 2 classi A e B tali che B is an A, e avendo\r\nA a = new B();\r\nB b = new B();\r\n\r\nesistono differenze nell'usare\r\na.getClass() == b.getClass()\r\ne\r\na instanceOf b\r\n\r\nsono equivalenti le 2 funzioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "identità"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6600,
          "asker": {
            "courseId": 102,
            "askerId": 1081,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'utilità dell'utilizzo delle collections?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6515,
          "asker": {
            "courseId": 102,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa succede se provo a utilizzare equals() su un istanza di una classe, all'interno della quale il metodo non è implementato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " identità"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6983,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1096,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Come per ogni metodo che non è implementato nella classe di appartenenza, java ricerca il metodo che si intende applicare nella classe genitore risalendo se necessario fino al padre universale object.\r\nNel caso di equals() la funzione è definita in object quindi il programma prenderà questa se non ha subito l'overriding in classi sottostanti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9457,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9714,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9295,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9547,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7012,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 999,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Ottengo un errore in compilazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9298,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9716,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9548,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9455,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6997,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 963,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Il metodo equals() permette di controllare se due oggetti sono uguali, ritornando true in caso affermativo. Il controllo viene eseguito sull'istanza della classe da cui il metodo è chiamato e il parametro di tipo Object.\r\nQualsiasi classe estende implicitamente la classe Object che contiene una sua implementazione del metodo equals(). Nel caso in cui si tenti di chiamare equals() da un'istanza che non lo implementa verrà chiamato il metodo della classe da cui è estesa e così via. Se nessuna classe padre implementa tale metodo verrà richiamato quello della classe Object che difatti è paragonabile ad un operatore di confronto '=='. In questo caso verranno comparati gli indirizzi di memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9458,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9297,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9715,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9549,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6953,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 985,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Normalmente equals() confronta due valori, mentre \"==\" confronta le locazioni di memoria.\r\nSe il metodo non è implementato equals() diventa uguale \"==\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9456,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9546,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9717,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9296,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6594,
          "asker": {
            "courseId": 102,
            "askerId": 989,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Nelle Collections di Java viene fatto largo uso di interfacce, che sono poi estese alle classi che ne derivano. Che vantaggi porta l'utilizzo di interfacce ben definite?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6524,
          "asker": {
            "courseId": 102,
            "askerId": 1055,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un interfaccia e qual'è l'utilità dell'interfaccia \"iterator\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Iterator"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6526,
          "asker": {
            "courseId": 102,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le collections e come si implementano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "collections"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6540,
          "asker": {
            "courseId": 102,
            "askerId": 954,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste il concetto di uguaglianza in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "uguaglianza"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6491,
          "asker": {
            "courseId": 102,
            "askerId": 970,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve un Iterator?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6987,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 951,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Un Iterator serve per scandire gli elementi di un contenitore (che può anche essere una Collection, una pila, una coda, ecc..) uno alla volta ed eventualmente eliminarli grazie a tre metodi definiti: next(), hasNext() e remove().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9273,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9356,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9501,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9577,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6982,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 939,
                "courseId": 102,
                "courseFinalScore": 30
              },
              "answerText": "L'Iterator in Java è un oggetto che permette di visitare tutti gli elementi contenuti all'interno di una Collection; può essere quindi assimilato al concetto di \"cursore\". In particolare alcuni dei metodi fondamentali di cui sono dotati gli Iterator e che li rendono particolamente utili nella programmazione sono:\r\n\r\n- Il metodo boolean hasNext(), che permette di verificare se successivamente all'elemento indicato in quel momento dall'iteratore se ne trova un altro (esso ha fondamentale importanza poiché viene usato spesso come condizione per verificare se si è effettuato lo scorrimento di tutti gli elementi all'interno di una Collection).\r\n-Il metodo Object next(), che fa avanzare l'iteratore di un posto ritornando l'oggetto da esso puntato.\r\n-Il metodo void remove(), che permette di rimuovere dalla Collection l'oggetto puntato dall'Iterator.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9502,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9358,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9578,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9272,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7031,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 964,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Un iterator (iteratore) permette di gestire gli elementi di una Collection attraverso dei metodi già definiti. Next() restituisce l'oggetto seguente nella Collection. Hasnext() restituisce un booleano, true se esiste l'elemento seguente. remove() che rimuove l'ultimo oggetto ritornato da next().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9357,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9274,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9503,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9576,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6602,
          "asker": {
            "courseId": 102,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "come sono correlati metodi equals() e hashCode()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6547,
          "asker": {
            "courseId": 102,
            "askerId": 990,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Secondo te quali vantaggi porta il fatto che tutte le strutture dati definite nel Collection Framework (ad eccezione delle mappe) implementino un'interfaccia comune \"Collection\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6936,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1022,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Implementare l'interfaccia Collection utilizzando le strutture definite nel Collection Framework portano, a mio avviso, i seguenti vantaggi:\r\n-sforzo di sviluppo ridotto utilizzando classi di insiemi piuttosto che attuare le nostre classi di raccolta;\r\n-qualità del codice migliorate dato che le classi che producono collezioni son ben ottimizzate e collaudate;\r\n-sforzo di manutenzione del codice ridotto utilizzando le classi fornite con il JDK;\r\n-possibilità di modificare l'implementazione di una collezione senza modificare i clienti;\r\n-interoperabilità tra API non correlati, cioè possibilità di utilizzare (e farsi utilizzare da) codice realizzato indipendente dal nostro;\r\n-favorisce il riuso del software, fornendo un'interfaccia standard per le collezioni e gli algoritmi.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9459,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9625,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6978,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il vantaggio è che appunto hanno tutte una sottostruttura comune, quindi per implementare due strutture simili che magari inseriscono o estraggono i dati in modo differente, ma operano sui dati in maniera simile (come ad esempio la pila e la coda), basta implementare solo le funzioni effettivamente differenti, senza dover riscrivere anche le funzioni uguali. \r\nAllo stesso modo se voglio personalizzare una struttura \"di base\", mi basta modificare solo il necessario.\r\nInoltre così viene definita una sorta di scheletro minimo di metodi che tutte queste strutture hanno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9622,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9462,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6980,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1008,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Alcuni vantaggi dell'utilizzo del Collection Framework per l'implementazione di strutture dati sono:\r\n1) Modularità (l'interfaccia \"Collection\" raggruppa tutte le collezioni di elementi);\r\n2) Riutilizzo del codice (abbiamo alcuni parametri/metodi in comune ad ogni collezione);\r\n3) Algoritmi predefiniti (esistono metodi specifici alle varie collezioni, già implementati e immediatamente utilizzabili);\r\n4) Polimorfismo (i metodi agiscono su Object, permettendoci così di sfruttare la relazione \"is a\" delle nostre classi).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9626,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9463,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7000,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 944,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il vantaggio principale consiste nel fatto che, in questo modo, divengono evidenti i metodi comuni alle strutture dati in questione, magari apparentemente molto diverse tra loro. Si tratta, per la precisione, di metodi che devono essere implementati necessariamente, in qualunque classe concreta (cioè istanziabile, non astratta) appartenente al Collection Framework, dunque di proprietà indispensabili ad una struttura dati per essere definita \"collection\". Ciò al tempo stesso riduce notevolmente i margini di errore nella scrittura di nuovo codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9461,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9623,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7070,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 989,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "E' possibile utilizzare gli stessi metodi per le varie classi che implementano la stessa interfaccia, senza preoccuparsi di come funzionano i metodi. In questo modo strutture dati molto diverse, come ad esempio List e Set, possono condividere la firma di alcuni metodi il cui codice è differente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9624,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9460,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6555,
          "asker": {
            "courseId": 102,
            "askerId": 1025,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve il metodo equals() e che differenza c'è con l'operatore \"==\" ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6548,
          "asker": {
            "courseId": 102,
            "askerId": 975,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "In un interfaccia è possibile dichiarare anche variabili o solo metodi che poi dovranno essere implementati nella classe che implementa l'interfaccia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7047,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 995,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Tecnicamente entrambe le opzioni sono errate. Questo perche' in un interfaccia non e' possibile dichiarare una variabile (la interfaccia non verra' mai istanziata, quindi non e' utile un attributo che puo' essere modificato), ma nemmeno la dichiarazione delle firme (la semplice dichiarazione di metodi con i parametri formali specificati) e' l'unica operazione possibile.\r\n\r\nInfatti esiste la possibilita' di dichiarare costanti, che poi verranno \"ereditate\" dalle classi che implementano l'interfaccia stessa. Quindi in realta' si puo' dichiarare delle variabili, ma solo tramite la keyword \"final\", che le rende costanti (percio' avere una variabile che sia concettualmente tale non e' possibile).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9484,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9494,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9395,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6979,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1023,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In un interfaccia non è possibile dichiarare variabili tuttavia si possono dichiarare delle costanti oltre alle firme dei metodi che poi dovranno essere implementati dalle classi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9493,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9394,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9485,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6960,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1070,
                "courseId": 102,
                "courseFinalScore": 10
              },
              "answerText": "No, una interfaccia non può avere variabili di istanza né metodi concreti (implementati) ma solo dichiarazioni di metodi astratti. \r\nUna interfaccia può essere pensata come una particolare classe astratta che contiene, in modo simile ai file .h del C, la firma di alcuni metodi che vogliamo che le classi che soddisfano l'interfaccia posseggano. Le interfacce servono per definire proprietà che sono comuni a varie classi, anche eterogenee e ad imporre, a compile time, vincoli a queste stesse. Per dichiarare che una classe soddisfa una certa interfaccia si usa la parola chiave 'implements'.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9393,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9486,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9492,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6513,
          "asker": {
            "courseId": 102,
            "askerId": 527,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è buona norma, quando si fa un override della equals() di Object, di sovrascrivere anche la funzione hashCode()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6998,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 990,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Eseguire un override di hashCode() dopo un override di equals() non solo e' buona norma, e' *obbligatorio*.\r\nLa libreria standard di Java infatti fa affidamento sul rispetto da parte dello sviluppatore del \"contratto\" che i progettisti Java hanno imposto sul metodo hashCode che prevede in particolare che se due oggetti sono uguali (cioe' obj1.equals(obj2) == true) allora  anche il valore restituito da hashCode sui due oggetti deve essere uguale (cioe' obj1.hashCode() == obj2.hashCode()). Se noi modifichiamo equals quindi non sarebbe piu' corretto utilizzare la versione generata automaticamente di hashCode perche' non rispetterebbe questa clausola.\r\nIl non rispetto di questa clausola infatti rendera' gli oggetti della classe in questione malfunzionanti se usati in classi hash-based come HashMap, HashSet o HashTable perche' queste classi basano il loro funzionamento proprio sull'assunzione che lo sviluppatore abbia rispettato il contratto di hashCode.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9551,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9311,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9441,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9759,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7018,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 945,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "Facendo l'override della funzione equals cambiamo i campi che vengono utilizzati nel confronto e il metodo che usiamo per confrontarli. Visto che java prima di usare la funzione equals confronta i valori ritornati dalla funzione hashCode per fare un confronto più veloce è buona norma sovrascrivere anche la funzione hashCode in modo che il valore ritornato rispecchi i campi che andiamo a confrontare nella funzione equals. È comunque possibile far ritornare alla funzione hashCode un valore costante forzando java ad usare sempre equals ma questo vanifica i vantaggi dati dall'utilizzo delle hash. È invece più opportuno cambiare la funzione in modo che tenga conto dei parametri che andiamo a confrontare e li \"unisca\" in un unico valore che deve essere più spesso possibile diverso dal valore ottenuto facendo l'hashCode di un oggetto diverso. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9440,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9310,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9757,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9550,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6946,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 969,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè la funzione hashCode genera un codice univoco dell'oggetto che si sta confrontando e quindi confrontando i codici ottenuti da questa funzione sovrascrivendola si sa di per certo se i i due oggetti sono uguali o meno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9552,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9758,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9439,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9312,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6522,
          "asker": {
            "courseId": 102,
            "askerId": 999,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e come viene utilizzato l'hashcode? (:",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "HASHCODE"
            },
            {
              "keyword": " HASHCODE"
            },
            {
              "keyword": " HASCHCODE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6584,
          "asker": {
            "courseId": 102,
            "askerId": 949,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè se creiamo all'interno di una nostra classe C un metodo\r\npublic boolean equals(C var){...}\r\ne lo invochiamo passandogli un Integer o una String non genera un errore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6531,
          "asker": {
            "courseId": 102,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra un interfaccia e una classe normale? Fai un esempio di utilizzo tipico di un interfaccia.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6585,
          "asker": {
            "courseId": 102,
            "askerId": 951,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Data questa classe:\r\nclass P {\r\n int x; int y;\r\n String parola;\r\n int vettore[100];\r\n }\r\n\r\ndefinire un metodo equals per questa classe.\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6511,
          "asker": {
            "courseId": 102,
            "askerId": 969,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'ereditarietá?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietá"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6582,
          "asker": {
            "courseId": 102,
            "askerId": 1045,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il metodo equals della classe Object viene implementato con l'operatore \"==\", rendendolo equivalente alla funzione dello stesso operatore \"==\" tra oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6576,
          "asker": {
            "courseId": 102,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è e a cosa serve un Iteratore? In che modo può essere utilizzato??",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Iterator"
            },
            {
              "keyword": " Iterator"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6972,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 970,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un Iteratore é un oggetto che implementa l'interfaccia Iterator, utilizzato in tipologie di oggetti come le collections, che contengono una serie di oggetti sui quali può essere utile eseguire un'iterazione. L'iteratore fornisce i metodi necessari per eseguire questa operazione:\r\nhasNext(), che restituisce un booleano (true se l'oggetto al quale siamo arrivati non é l'ultimo contenuto nella collection, false altrimenti);\r\nnext(), che restituisce l'oggetto successivo nella collection;\r\nremove(), che rimuove dalla collection l'ultimo elemento restituito da next().\r\nUn Iteratore può funzionare su qualsiasi collection che implementa metodi per rimuovere elementi da essa contenuti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9329,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9582,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9304,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7032,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 942,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Un iteratore è un'interfaccia che può essere associata ad una collection, la quale può essere gestita con tre metodi: hasNext(),next() e remove(). \r\nIl primo metodo, di tipo bool, ritorna true se è presente un elemento di tipo T che può essere ritornato dal secondo (che è di tipo T), mentre remove(), di tipo void, permette di cancellare l'ultimo elemento ritornato dall'iteratore dalla collection .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9305,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9328,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9583,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6494,
          "asker": {
            "courseId": 102,
            "askerId": 1053,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Considerando la funzione hashCode(), come questa permette di confrontare due oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "identità"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6537,
          "asker": {
            "courseId": 102,
            "askerId": 983,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona il metodo equals relativo alla classe object ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6604,
          "asker": {
            "courseId": 102,
            "askerId": 993,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa è una interfaccia?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6566,
          "asker": {
            "courseId": 102,
            "askerId": 1033,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali collections messe a disposizione dal linguaggio Java in java.util.* e in cosa differiscono fra loro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "COLLECTIONS"
            },
            {
              "keyword": "COLLECTIONS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6520,
          "asker": {
            "courseId": 102,
            "askerId": 974,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le collections? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6490,
          "asker": {
            "courseId": 102,
            "askerId": 988,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un hashcode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "HASHCODE"
            },
            {
              "keyword": " HASHCODE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6519,
          "asker": {
            "courseId": 102,
            "askerId": 952,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cosa sono le Collections e come vengono utilizzate ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6559,
          "asker": {
            "courseId": 102,
            "askerId": 957,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo, definendo una classe in java, è necessario definire esplicitamente anche un'implementazione (specifica per la classe) del metodo .Equals()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6949,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perche questa implementazione è la base per comparare due oggetti della nostra classe. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9619,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9633,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7038,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1050,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "E' necessario per permettere in futuro, nel codice implementato del programma, di eseguire a buon fine dei confronti tra diversi elementi (che siano dello stesso tipo o meno) utilizzando tale metodo per confrontare un oggetto con l'oggetto del tipo definito (che contiene il metodo \"equals\"). Questo poichè non sempre il semplice confronto tramite \"==\" risulta corretto se si stratta di tipi di dato complessi e strutturati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9620,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9632,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6965,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Non è per forza necessario definire un'implementazione per il metodo equals(), in quanto, se non viene esplicitato, viene ereditato il metodo della classe Object che è implementato con la stessa semantica dell'==, ovvero valuta a True se e solo se i due oggetti si riferiscono allo stesso indirizzo di memoria. \r\nE' consigliato fare l'override del metodo equals() per permettere il confronto di due oggetti secondo i criteri più adatti alla classe, ovvero in grado di testare se due oggetti sono equivalenti (ad esempio se contengono le stesse informazioni).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9621,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9631,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7066,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 994,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo equals di una classe viene scritto in modo che l'invocazione <obj1>.equals(<obj2>) restituisce true quando gli oggetti <obj1> e <obj2> sono istanze della stessa classe e hanno uguale contenuto, cioè valori equivalenti per ogni variabile d'istanza.\r\nPoichè tutte le classi ereditano da Object, il metodo equals può essere invocato su una istanza di una qualunque classe. Se però nella classe in questione il metodo non è stato sovrascritto, verrà eseguito il metodo ereditato da Object, con risultati che potrebbero essere inattesi.\r\n\r\nQuindi il metodo equals deve essere ridefinito in tutte le classi in cui è necessario effettuare confronti, per ottenere risultati significativi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9634,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9618,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6588,
          "asker": {
            "courseId": 102,
            "askerId": 940,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la risposta all'esercizio proposto nelle slide riguardante gli hashCode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6501,
          "asker": {
            "courseId": 102,
            "askerId": 1079,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra interfaccia e classe abstract? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " Interfacce"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6970,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 992,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Una classe si dice abstract se presenta, in essa, almeno un metodo o funzione, la cui implementazione è definita da un'altra classe. Inoltre le classi abstract si riconoscono dalla presenza della parola chiave \"abstract\", che precede la loro dichiarazione e quella dei suoi metodi.\r\nUn interfaccia è una collezione di metodi senza la loro definizione.Il suo scopo è quello di definire un protocollo del comportamento che deve essere fornito ad una classe. La classe dovrà implementare tutti i metodi richiesti dall'interfaccia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9387,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7016,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1029,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Direi che le classi astratte pure definiscono un contratto di tipo verticale (dedicato) con le instanze delle classi figlie, mentre le interfacce rappresentano di più un contratto di tipo orizzontale (generico) con gli oggetti che le implementeranno.\r\nLe classi astratte pure definiscono un legame più forte con la classe derivata poichè ne rappresentano il tipo base definendone il comportamento comune. Mentre le interfacce possono essere usate per definire un modello generico, che implementa un comportamento comune a classi di vario genere e natura.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9385,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7024,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1038,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'interfaccia è un tipo paragonabile alla classe, ma soggetto a restrizioni ulteriori: risulta composta esclusivamente di metodi astratti ed eventualmente da un insieme di campi visibili all'esterno di essa.\r\nUna classe astratta è una classe che definisce una interfaccia senza implementarla completamente. Questo serve come base di partenza per generare una o più classi specializzate aventi tutte la stessa interfaccia di base. La classe astratta da sola non può essere istanziata, viene progettata soltanto per svolgere la funzione di classe base e da cui le classi derivate possono ereditare i metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9384,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7053,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1045,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un interfaccia contiene una serie di firme di metodi e costanti, per cui, a differenza delle classi abstract, non contiene campi e implementazioni dei metodi definiti. Una classe abstract puó invece contenere metodi NON abstract con relativa implementazione. In più, più classi possono implementare una stessa interfaccia (anche in modi radicalmente diversi) e più interfacce possono essere implementate dalla stessa classe permettendo una sorta di multi-ereditarietà. In più le parole chiavi utilizzate sono differenti (implements per le interfacce e extends per le classi)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9386,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6488,
          "asker": {
            "courseId": 102,
            "askerId": 961,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è fra le interfacce e le classi astratte?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "interfacce"
            },
            {
              "keyword": "classi astratte"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6988,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1039,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe dichiarata astratta non può essere istanziata, e deve avere delle sottoclassi.\r\nUna classe non astratta non può contenere metodi astratti.\r\nUna interfaccia è una collezione di firme di metodi senza implementazione, ma può contenere costanti. Le interfacce si possono usare come tipi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9640,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9721,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9341,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9712,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6954,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 946,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sia le classi astratte che le interfacce non possono essere instanziate poichè al loro interno definiscono soltanto i metodi e le proprietà che dovranno essere implementate dalle classi che deriveranno da esse, rappresentano pertanto un \"template\" per le classi che una volta derivate da esse ed instanziate ne implementeranno il comportamento.\r\nUna classe astratta, quindi, è una classe che serve solo per essere derivata, definendo al suo interno metodi e proprietà tutti o in parte anch'essi astratti. Una classe astratta che implementa solo ed esclusivamente metodi e proprietà astratte viene detta classe astratta pura.\r\nNelle interfacce invece, pur essendo molto simili alle classi astratte in quanto anch'esse definiscono metodi e proprietà astratte, non troveremo l'implemetazione di alcun metodo o proprietà.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9710,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9340,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9719,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9641,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7043,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 980,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le interfacce sono un'ulteriore generalizzazione rispetto alle classi astratte, definiscono infatti quali devono essere i metodi che una classe deve assolutamente possedere per non essere considerata astratta.\r\nÈ praticamente una classe che contiene le dichiarazioni dei metodi e le variabili che tutte le classi che derivano da essa devono necessariamente contenere per essere implementabili.Una classe può implementare più interfacce, non avendo queste dei metodi dichiarati infatti non si verranno a creare problemi di overriding o overloading.\r\nLe principali differenze con la classe astratta sono proprio queste quindi:nella classe astratta i metodi sono scritti totalmente mentre nelle interfacce vengono solo dichiarati, e mentre una classe può derivare da una sola classe astratta può invece implementare infinite interfacce.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9639,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9709,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9720,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9343,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7007,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1074,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe astratta è una classe che viene de&#64257;nita solo per stabilire una interfaccia comune per tutte le sue sottoclassi. Ongni sottoclasse dovrà definire tutti i metodi astratti, una classe astratta può contenere dati e metodi non astratti, e non può essere istanziata.\r\nUn?interfaccia è una struttura che definisce un protocollo di comportamento, che può essere implementato da una qualunque classe. Un interfaccia definisce un insieme di metodi ma non li implementa, all'interno di essa non si possono definire variabili ma solo costanti e anch'essa non può essere istanziata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9713,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9722,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9342,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9642,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7040,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 997,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le interfacce appaiono simili alle classi astratte ma hanno significative differenze:\r\n- Un interfaccia non può avere metodi con implementazione,mentre una classe astratta può fornire una implementazione parziale\r\n- Una classe può implementare molte interfacce ma puo? essere derivata da una sola superclasse\r\n- Le interfacce non fanno parte della gerarchia delle classi, quindi classi non discendenti l?una dall?altra possono implementare la stessa interfaccia\r\n- se occorre fornire ereditarietà multipla, si usano le interfacce\r\n- se si deve fornire una parte (comune) dell?implementazione, si usano le classi astratte\r\n- se tuttavia ci si trova a scrivere una classe astratta senza alcuna implementazione, di fatto è un?interfaccia",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9643,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9718,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9711,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9344,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6493,
          "asker": {
            "courseId": 102,
            "askerId": 987,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare perchè le seguenti istruzioni danno risultati diversi a run time:\r\n\r\n1) public class Test { \r\npublic static void main(String[] a){new Test();}  Test() { \r\nP p1=new P(); \r\n     p1.x=1; p1.y=2; \r\nP p2 = new P(); \r\n     p2.x=1; p2.y=2; \r\nSystem.out.println(p1 == p2);\r\n}\r\n}\r\n\r\n2) public class Test { \r\npublic static void main(String[] a){new Test();} Test() { \r\nP p1=new P(); \r\n     p1.x=1; p1.y=2; \r\nP p2= p1; \r\nSystem.out.println(p1 == p2);\r\n}\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6571,
          "asker": {
            "courseId": 102,
            "askerId": 1047,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai si rende utile la definizione del concetto di hashcode per quanto riguarda il confronto di oggetti in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6939,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1028,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Quando abbiamo a che fare con un set, inseriamo un nuovo elemento solo se non è già presente. Per verificare se l'oggetto candidato ad entrare nel set è ?uguale? ad uno già presente si usa il metodo equals. La cosa è assai costosa, perché bisognerebbe confrontare tutti gli elementi del set. Perciò esiste il metodo hash che si presenta come una scorciatoia. Questa funzione genera uno hashcode, ovvero un numero che rappresenta l?oggetto valutando alcune delle sue caratteristiche. Se la hash mi dà risultati (numeri) diversi sono sicuro che i due dati sono diversi; è un modo per velocizzare il calcolo di confronto. È utile dunque implementare un metodo hashCode() che ?trita? l?oggetto e restituisce un numeretto identificativo della forma dell?oggetto. Alla fine controllerò solo l?uguaglianza degli oggetti che hanno lo stesso ?hash code?. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9737,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9363,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9693,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9525,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9321,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6969,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1054,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché permette di scartare velocemente e a priori gli oggetti (dello stesso tipo) aventi hashcode differenti, però non è una condizione sufficiente per stabilirne l'uguaglianza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9522,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9691,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9736,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9323,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9365,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7044,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Poichè, nel confrontare oggetti in java, è utile sapere che è necessario usare equals e hashcode. Tuttavia se due oggetti sono uguali hanno lo stesso hashcode, ma non è necessariamente vero il contrario.\r\nInoltre, tramite hashcode, si può calcolare la chiave di un qualsiasi oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9320,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9362,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9739,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9521,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9690,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6981,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1035,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè quando bisogna definire se due oggetti in Java sono uguali solitamente si confrontano i valori contenuti nei campi dei due oggetti. Ma un oggetto può avere molti campi e dunque confrontarli tutti richiede tempo.\r\nPer ottimizzare questo processo si usa l'hashcode che permette di confrontare velocemente due oggetti per capire se sono diversi. Infatti se il confronto con l'hashcode restituisce falso si è sicuri che i due oggetti sono diversi, mentre se restituisce vero si procede al confronto con l'Equals. \r\nIn ogni caso con un hashcode \"fatto bene\" si riescono ad ottimizzare di molto le prestazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9524,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9364,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9738,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9322,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9689,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6976,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 972,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per avere un confronto con brevi tempi di esecuzione e calcolo. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9324,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9692,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9523,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9366,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9740,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6504,
          "asker": {
            "courseId": 102,
            "askerId": 972,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un hashcode e come si implementa in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6560,
          "asker": {
            "courseId": 102,
            "askerId": 958,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una List? Come funziona?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6564,
          "asker": {
            "courseId": 102,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Effettuando l'overriding del metodo equals é obbligatorio fare l'overriding anche del metodo hash? Perché?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7046,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1007,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Qualsiasi classe che effettua overriding del metodo equals deve necessariamente farlo anche del metodo hashCode. Il metodo equals viene utilizzato per verificare se due oggetti sono uguali; questo può risultare molto dispendioso nel caso in cui si abbia a che fare con svariati confronti e con oggetti di grande dimensione. Il metodo hashCode permette di ottimizzare, almeno in parte, il confronto tra oggetti: questo metodo restituisce un valore numerico dato dalla valutazione del valore delle variabili che compongono l'oggetto. Ad esempio, data la classe \"Data\" formata da: int giorno,mese,anno; un possibile valore di ritorno del metodo hashCode è la somma delle tre variabili. Due oggetti con hashCode diversi hanno sicuramente almeno una variabile diversa. Viceversa, in presenza di hashCode uguali non si è certi della loro uguaglianza (es: 2/3/15 e 3/5/12) ed è quindi necessario invocare il metodo equals. Quindi grazie al metodo hashCode equals viene chiamato un ristretto numero di volte.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9325,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9506,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9708,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9400,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6966,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1009,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Sì,se una classe esegue l'override del metodo equals(), deve farlo anche del metodo hashCode(), così da soddisfare il contratto del metodo Object.hashcode.\r\nI due metodi sono strettamente correlati e in particolare \"uguaglianza implica hashcode uguali\" e \"diversità di hashcode implica non uguaglianza\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9398,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9327,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9505,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9706,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7041,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1043,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "no, fare l' overriding del metodo equals ha l' utilità di definire quali sono gli attributi a cui diamo importanza nel confronto tra due oggetti. Nel caso in cui la procedura di conronto possa occupare molte risorse è fortemente consigliato l' uso di metodi che restituiscano un hashcode secondo una chiave conosciuta.\r\nCon questo tipo di implementazione prima di eseguire il confronto al metodo equals si fa confrontare gli hashcode degli oggetti e solo nel caso in cui risultino identici allora procede al conronto vero e proprio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9399,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9326,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9504,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9707,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6590,
          "asker": {
            "courseId": 102,
            "askerId": 1038,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Scrivere l'output di questo codice e motivare il perché del risultato.\r\n\r\npublic class Test {\r\n public static void main(String[] a){new Test();}\r\n Test() {\r\n     P p1=new P();\r\n     p1.x=1; p1.y=2;\r\n     P p2=new P();\r\n     p2.x=1; p2.y=2;\r\n     System.out.println(p1.equals(p2));  }   }",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Identità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6546,
          "asker": {
            "courseId": 102,
            "askerId": 1012,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra l'operatore \"==\" e il metodo \"equals\" nel linguaggio di programmazione Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EQUALS"
            },
            {
              "keyword": " EQUALS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6538,
          "asker": {
            "courseId": 102,
            "askerId": 1017,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Facendo riferimento alla slide 40 dell'ultima lezione cosa succede se P estende Q (invece che Q estende P) ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EQUALS"
            },
            {
              "keyword": " IDENTITA'"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6483,
          "asker": {
            "courseId": 102,
            "askerId": 981,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché la classe object implementa il metodo equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " Equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7015,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La classe object implementa il metodo equals per verificare se c'è qualche altro object uguale ad esso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9299,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9562,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9608,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9376,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7042,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 955,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Lo implementa perché 2 oggetti potrebbero essere completamente uguali (compresa l'allocazione di memoria) o uguali in tutto tranne nell'allocazione di memoria. Quindi il metodo equals verifica questa differenza restituendo true solo se sono in uno di questi 2 casi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9301,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9561,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9374,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9611,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6996,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1040,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Poiché per confrontare due oggetti non si può utilizzare l'operatore '==' quindi è stato creato un metodo chiamato 'equals' che (se necessario) deve essere sovrascritto (Overriding) nella classe dell'oggetto che intendiamo confrontare. Ad esempio se abbiamo una classe A e vogliamo confrontare due istanze di essa a1 e a2, nella classe A sarà implementato il metodo: public boolean equals(A a); e per confrontare i due oggetti sarà invocato così: a1.equals(a2);.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9300,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9375,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9559,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9609,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7008,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1000,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per poter confrontare due oggetti,anche di tipo diverso, e vedere se sono uguali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9303,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9560,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9610,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9373,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6950,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 949,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "La classe object implementa il metodo equals, così come tutti i metodi standard (tostring, compareto, clone,...) in modo da poterli usare all'interno di una collezione di oggetti qualsiasi. Ogni classe, infatti, estende implicitamente la classe object ed eredita i vari metodi, che possono poi essere sovrascritti con il principio dell'overriding.\r\nInoltre grazie all'equals \"implementato\" a livello di classe Object è possibile confrontare anche istanze di classi diverse, essendo un metodo polimorfo (prende in ingresso un parametro di tipo Object). Il metodo equals, di default restituisce lo stesso risultato dell'operatore == tra l'oggetto passato e l'oggetto sul quale è invocato(this).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9302,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9558,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9377,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9607,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6523,
          "asker": {
            "courseId": 102,
            "askerId": 1037,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo il metodo \"equals()\" fa il confronto fra due oggetti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6599,
          "asker": {
            "courseId": 102,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando utilizzare un'interfaccia e perchè?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "INTERFACCE"
            },
            {
              "keyword": "INTERFACCE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6503,
          "asker": {
            "courseId": 102,
            "askerId": 966,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra \"Set\" e \"List\" e quando è più conveniente usare la prima piuttosto che la seconda?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7029,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1037,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "\"Set\" è una collection non ordinata che non ammette duplicati, \"List\" invece è una collection ordinata che ammette duplicati i cui dati sono accessibili tramite indice e mantengono l' ordine in cui vengono inseriti.\r\nÈ piú conveniente utilizzare una List nel caso in cui si debbano utilizzare dei dati da mantenere in un certo ordine o che debbano essere ripetuti, nel caso in cui si debbano utilizzare dei dati tutti diversi e senza un preciso ordine conviene utilizzare una Set.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9379,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9728,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9555,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6937,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1065,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La principale differenza tra set e list è che la prima non contiene dati ordinati mentre la seconda permette l'ordinamento (inoltre questi dati nella list sono accessibili tramite un indice). E' più conveniente usare list quando si devono fare duplicati di qualche oggetto, mentre è più conveniente usare set quando non si ha bisogno di questa funzione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9727,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9554,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9380,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7014,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 58,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sia List che Set derivano dall'interface Collection. La differenza principale è che List è una Collection ordinata che permette duplicati mentre Set è una Collection non ordinata che non permette duplicati.\r\nDunque se hai bisogno di mantenere l'ordine di inserimento e la collezione può contenere duplicati allora usi List. Se invece si vogliono evitare duplicati bisogna usare Set.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9378,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9726,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9553,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6542,
          "asker": {
            "courseId": 102,
            "askerId": 946,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Dal punto di vista pratico quando è meglio usare il metodo equals() piuttosto che hashCode() piuttosto che == ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6944,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 991,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Innanzitutto è bene premettere che non posso usare hashCode() senza equals() in quanto non è univoco (salvo re-implementazioni) quindi anche se relativamente \"rari\" non si possono escludere casi di \"collisioni\" (oggetti diversi che presentano lo stesso hashCode).\r\nUserò l'operatore ==  (o equals() non ri-implementato) nel caso voglia comparare due variabili di tipo primitivo o verificare che due oggetti siano in realtà puntatori allo stesso indirizzo di un oggetto allocato in heap. Mentre posso fare un overriding del metodo equals() (e del metodo hashCode()) per verificare se due oggetti dello stesso tipo, allocati in diverse aree di memoria, hanno gli stessi valori delle stesse variabili di istanza (sono due copie). Naturalmente si possono fornire varie implementazioni di equals() che portebbero, ad esempio, prendere in esame solo alcune variabili di istanza più significative tralasciando le altre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9317,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9306,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9432,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9474,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9637,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7069,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1005,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Dal punto di vista pratico è sempre meglio usare il metodo equals() al posto dell'operatore booleano == e della funzione hashCode(), in quanto il metodo equals() da noi implementato ci dà la possibilità di decidere su quali parametri possiamo testare l?uguaglianza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9475,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9433,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9309,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9636,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9319,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6930,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 975,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "È bene usare equals o hashcode se gli oggetti che dobbiamo confrontare sono distinti. In particolare equals è piu pesante dal punto di vista computazionale rispetto ad hashcode. Per questo se si deve usare molte volte \r\nequals è bene invece implementare un proprio metodo hashcode così da rendere più snello il programma.\r\n Invece al contrario si usa == per vedere se i due oggetti sono uno la copia identica dell'altro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9316,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9308,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9472,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9431,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9635,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7039,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 959,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "\"==\" viene utilizzato quando dobbiamo confrontare 2 oggetti di tipo primitivo;\r\nequals() indica se due oggetti sono uguali, nel caso di classi è vero solo se puntano allo stesso oggetto\r\nhashCode() viene usato per confrontare i singoli oggetti di una classe;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9318,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9638,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9434,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9307,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9473,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6528,
          "asker": {
            "courseId": 102,
            "askerId": 764,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste un modo per testare l'uguaglianza? Se si quale?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "testare"
            },
            {
              "keyword": " uguaglianza"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6565,
          "asker": {
            "courseId": 102,
            "askerId": 1030,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è e qual è la funzionalità dell'hashcode?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6505,
          "asker": {
            "courseId": 102,
            "askerId": 996,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione che permette di confrontare luguaglianza tra due classi e come si comporta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EQUALS "
            },
            {
              "keyword": "EQUALS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6502,
          "asker": {
            "courseId": 102,
            "askerId": 941,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo delle collection \"boolean retainAll(Collection c);\" (Slide Collection - p.29)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6507,
          "asker": {
            "courseId": 102,
            "askerId": 1027,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare in modo esaustivo le funzionalità del metodo equals.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EQUALS"
            },
            {
              "keyword": " EQUALS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6580,
          "asker": {
            "courseId": 102,
            "askerId": 1034,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è hash code? A cosa serve?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "hashcode"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7021,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1099,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo hashCode di Object ritorna l?indirizzo interno di un oggetto convertito in un intero",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9292,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9652,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9370,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6932,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo hashCode() restituisce un valore hash per un oggetto.\r\nLe sue caratteristiche sono: \r\n-Una volta istanziato l?oggetto, il valore restituito da questo metodo deve essere consistente (non deve cambiare) se non cambiano i campi con cui viene calcolato.\r\n-Istanze dello stesso oggetto su diverse esecuzioni dell?applicazioni devono invece restituire valori diversi.\r\n-Se due oggetti sono dichiarati uguali dal metodo equals() allora la funzione hash deve restituire lo stesso valore.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9371,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9651,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9293,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7011,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "hashCode è un metodo della classe Object ed essendo tale viene ereditato da tutte le classi. Il metodo hashCode prende in input un oggetto e restituisce un intero sotto le seguenti condizioni:\r\n- nell'esecuzione di una stessa applicazione Java, se invocato più volte più volte sullo stesso oggetto istanziato, hashCode restituisce sempre lo stesso intero (a meno che non vengano modificati i campi con cui viene calcolato); in esecuzioni distinte, invece, non è necessario che l'intero ritornato sia lo stesso.\r\n- se due oggetti sono uguali secondo il metodo equals, allora il metodo hashCode applicato ai due oggetti ritornerà lo stesso intero; non è detto il contrario, cioè due oggetti con lo stesso intero ritornato da hashCode potrebbero non essere uguali secondo equals.\r\nIl metodo hashCode è utile nel caso si tratti con tabelle hash, per esempio si può utilizzare per confrontare chiavi di ricerca.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9294,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9653,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9372,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6497,
          "asker": {
            "courseId": 102,
            "askerId": 977,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "due oggetti O1 e O2 i cui valori sono stati inizializzati uguali, sono essi stessi uguali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6977,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1019,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, due oggetti O1 e O2 anche se inizializzati uguali sono due oggetti distinti allocati in due spazi di memoria distinti ma con i campi che hanno gli stessi valori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9662,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9406,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7049,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1018,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "In Java i tipi primitivi (int, float, string..) e gli oggetti vengono gestiti in memoria in modo differente: nella locazione di memoria corrispondente a un tipo primitivo è presente il suo valore (se dichiaro un \"int i = 5\", viene memorizzato il valore \"5\"), mentre in quella di un oggetto è presente il puntatore all?area di memoria che contiene l?oggetto.\r\n\r\nDunque quando si confrontano, nel caso di tipi primitivi, viene confrontato il valore vero corrispondente ad essi, mentre nel caso di oggetti, viene confrontato l?indirizzo di memoria a cui i puntatori fanno riferimento. \r\n\r\nPer questo motivo due oggetti distinti O1 e O2, seppur inizializzati con gli stessi valori, essendo rappresentati in memoria da due puntatori distinti non possono essere considerati, in questo senso, uguali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9408,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9664,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7028,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 954,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sono due oggetti distinti memorizzati in locazioni di memoria distinte.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9407,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9663,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6529,
          "asker": {
            "courseId": 102,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste e come viene utilizzato il metodo equals()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": "equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6593,
          "asker": {
            "courseId": 102,
            "askerId": 942,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra un interfaccia e una classe abstract? Fare un esempio di utilizzo di interfacce. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Interfaccia"
            },
            {
              "keyword": " interfaccia "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6532,
          "asker": {
            "courseId": 102,
            "askerId": 58,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenze ci sono tra l'operatore == ed il metodo equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7035,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 984,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "l'operatore == verifica se gli oggetti sono la stessa istanza di un oggetto, mentre il metodo equals verifica se gli oggetti hanno (all'interno delle variabili della classe) gli stessi valori e/o oggetti contenenti variabili con gli stessi valori",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9430,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9680,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9332,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9733,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6990,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "La principale differenza tra l'operatore '==' e il metodo equals è il tipo di utilizzo; ovvero il primo operatore serve per testare l'identicità dei due 'termini' che si mettono a confronto mentre il metodo equals serve a testare l'uguaglianza di un oggetto con un altro. In particolare l'operatore '==' è implementato nel linguaggio mentre il metodo è implementato nella classe object e può essere sovrascritto nelle sue sottoclassi, dando la possibilità al programmatore di specificare quando due oggetti sono uguali. Infatti usando l'operatore '==' tra due oggetti, questo ritornerebbe true solo nel caso in cui i due identificatori siano due alias dello stesso oggetto. Sovrascrivendo il metodo equals invece siamo noi a decidere quando due oggetti sono uguali, ma non identici.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9734,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9679,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9331,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9429,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7022,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1068,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L?operatore == permette, invocando questo costrutto, il confronto di valori contenuti nelle variabili. Nel caso di tipi primitivi viene confrontato il valore vero, mentre nel caso di oggetti viene confrontato l?indirizzo di memoria a cui i puntatori fanno riferimento, questo può creare dei casi di ambiguità che come si è visto a lezione si può verificare che l'esito del confronto sia positivo se l'allocazione di memoria avviene nel stesso punto grazie l'utilizzo di un puntatore.\r\nPer ovviare a questo problema è necessario usare il metodo equals che, a differenza dell?operatore ==, confronta gli oggetti puntati entrando quindi in merito al contenuto dell?oggetto. Il metodo equals è definito nella classe Object quindi è disponibile su tutti gli oggetti (ma non sui tipi primitivi).\r\nNella classe Object di default non è possibile sapere come confrontare qualunque oggetto, quindi implementando equals possiamo confrontare tutti i campi della classe grazie a ==.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9428,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9735,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9330,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9681,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6603,
          "asker": {
            "courseId": 102,
            "askerId": 1042,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è una collection in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6577,
          "asker": {
            "courseId": 102,
            "askerId": 1032,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è un'interfaccia e fai un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "interfaccia"
            },
            {
              "keyword": " interfaccia"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6581,
          "asker": {
            "courseId": 102,
            "askerId": 986,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Tramite quale metodo si possono confrontare due oggetti dello stesso tipo, ma con identificatori diversi?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "equals"
            },
            {
              "keyword": " equals"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6568,
          "asker": {
            "courseId": 102,
            "askerId": 959,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un identità in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "IDENTITA"
            },
            {
              "keyword": " IDENTITA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6510,
          "asker": {
            "courseId": 102,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra una Interfaccia ed una classe abstract?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Interfacce"
            },
            {
              "keyword": " interfacce"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6961,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un'interfaccia è una collezione di firme di metodi (senza implementazione). Una interfaccia può dichiarare costanti. Contiene solo dichiarazioni dei metodi (no impl.).\r\nUna classe dichiarata abstract invece non può essere istanziata, e deve essere subclassata. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9333,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9604,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6975,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1059,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "le differenze a livello teorico sono poche mentre a livello pratico è meglio preferire le interfacce quando si ha un programma abbastanza complesso dove ci sono molti metodi simili cosi da evitare duplicazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9335,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9605,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7055,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1055,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sia le classi astratte che le interfacce non possono essere instanziate poichè al loro interno definiscono soltanto i metodi e le proprietà.\r\nUna classe astratta è una classe che viene de&#64257;nita solo per stabilire una interfaccia comune per tutte le sue sottoclassi.\r\nUn?interfaccia è una struttura che definisce un protocollo di comportamento, che può essere implementato da una qualunque classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9606,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9334,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7045,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1021,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Le classi di tipo abstract presentano innumerevoli differenze rispetto alle interfacce, prima fra tutte la possibilità di implementare i metodi dichiarati all'interno della classe stessa quando invece l'interfaccia si presenta solo come \"collezione\" di firme. L'interfaccia permette l'ereditarietà multipla, al contrario della classe astratta, ma allo stesso tempo non può contenere metodi costruttori o di tipo static, metodi che possono essere presenti in una classe astratta. Inoltre una classe di tipo abstract può contenere metodi che non sono astratti e può contenere al suo interno qualsiasi tipo di variabile. In un'interfaccia i metodi sono automaticamente classificati come abstract e le variabili d'istanza possono essere solo di tipo static e final.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9336,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9603,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6574,
          "asker": {
            "courseId": 102,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che porta l'uso di una libreria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Collections"
            },
            {
              "keyword": " Collections"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6512,
          "asker": {
            "courseId": 102,
            "askerId": 1078,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra equals e == nel confronto tra due oggetti? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " equals "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7033,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 965,
                "courseId": 102,
                "courseFinalScore": 17
              },
              "answerText": "L'operatore  \" == \" si occupa di vedere se gli oggetti confrontati sono la STESSA istanza. L'operatore equals() invece si occupa di confrontare lo stato degli oggetti; cioè, per esempio, se tutti gli attributi sono uguali. Il vantaggio di usare equals() è che puoi fare un overriding di questo metodo e decidere tu cosa rende due oggetti uguali!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9423,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9478,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9482,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9416,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9590,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7013,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1072,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "== confronta il contenuto delle variabili  primitive e in caso di oggetti confronta gli oggetti.  Può essere causa di errori, perché il contenuto può essere diverso. Equals invece confront direttamente ciò che contengono gli oggetti. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9419,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9420,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9592,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9480,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9479,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7026,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1027,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore == restituisce vero se e solo se due oggetti sono alloccati nella stessa parte di memoria e quindi fanno riferimento alla stessa cosa. Il metodo equals può essere implementato in modo che restisca vero se due oggetti allocati in zone della memoria diverse hanno determinati parametri in comune. L'operatore == restituisce vero se e solo se anche equals restituisce vero, ma non necessariamente vale anche il contrario.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9418,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9593,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9477,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9481,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9421,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6942,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 948,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "Sia equals che == confrontano due oggetti/variabili con la differenza che equals è un metodo della classe object, mentre == è un operatore. Il metodo equals della classe object e == danno lo stesso risultato, però tramite overloading è possibile ridefinire equals in ogni classe. Un esempio può essere per una classe Pt che contiene le variabili x e y, si può ridefinire equals facendo in modo che invece che dirci se due referenze sono referenze dello stesso oggetto, ci dica se il valore delle variabili x e y di due istanze della classe Pt sono uguali o no.\r\nEs.:\r\npublic class Pt{\r\n  int x,y;\r\n  public boolean equals(Pt p){\r\n    return(this.x==p.x && this.y==p.y);\r\n  }\r\n}\r\npublic class Main{\r\n  public static void main(String args){\r\n    Pt p1=new Pt();\r\n    Pt p2=new Pt();\r\n    p1.x=2;\r\n    p2.x=2;\r\n    p1.y=1;\r\n    p2.y=1;\r\n    System.out.println(p1.equals(p2));\r\n  }\r\n}\r\nSe equals fosse quello della classe object restituirebbe false (come farebbe ==), mentre qui restituisce true.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9483,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9417,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9422,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9591,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9476,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6516,
          "asker": {
            "courseId": 102,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 192,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'hashcode? E che relazione ha con il metodo equals?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Equals"
            },
            {
              "keyword": " hashcode"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7065,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1001,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Con il termine hashcode si intende l'intero, associato ad ogni oggetto, che viene ritornato nel momento in cui si chiama il metodo omonimo hashcode(). Tale metodo è definito nella classe Object, insieme al metodo equals(), ma spesso è necessario effettuare un ovveride per ottenere un metodo nuovo che sia adatto alla classe che si sta implementando. Ogni volta che viene effettuato un override sul metodo equals() è necessario effettuarlo anche sul metodo hashcode(). \r\nLe caratteristiche principali dell'hashcode sono le seguenti:\r\n-se viene chiamato più volte il metodo hashcode() sullo stesso oggetto durante l'esecuzione di un'applicazione Java, il valore ritornato deve essere lo stesso (se non sono stati cambiati i valori dell'oggetto)\r\n-se due oggetti risultano uguali dal metodo equals() allora hanno anche lo stesso hashcode; ma non vale il contrario, ovvero due oggetti con lo stesso hashcode non devono essere necessariamente uguali se confrontati con il metodo equals()\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9497,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9411,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9667,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9616,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6958,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1033,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Con hashcode si intende un valore intero che rappresenta un oggetto (un'istanza di una classe); quando chiamo la funzione Object.hashcode() su un oggetto A il metodo mi restituisce un \"codice identificativo\" dell'oggetto che mi facilita alcune operazioni come il confronto e l'ordinamento di oggetti (es. in una collection).\r\nOggetti diversi hanno hashcode diversi, oggetti uguali hashcode uguali. Se due oggetti hanno hascode identici non è però detto che i due oggetti siano uguali: entra qui in gioco lo stretto legame con il metodo equals(): se due oggetti hanno uguale hashcode allora si chiama il metodo equals per vedere se sono veramente uguali (oggetti diversi POSSONO avere hashcode uguali). \r\nE' importante anche notare che il legame fra i due metodi è così stretto che qualsiasi classe che fa override del metodo Object.equals deve obbligatoriamente fare override anche del metodo  Object.hashcode() .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9496,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9665,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9409,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9617,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7023,
              "task": {
                "taskId": 193,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1012,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "In Java \"public int hashCode()\" è un metodo che trova una sua prima e generica implementazione già nella superclasse Object e ritorna un intero che rappresenta un codice hash.\r\nClassi come HashMap, HashTable o HashSet organizzano i dati che contengono in gruppi (\"buckets\") basandosi su questo valore.\r\nLe specifiche Java richiedono che tra \"hashCode\" e il metodo \"equals\" rimanga sempre soddisfatta la seguente implicazione:\r\n\"objA.equals(objB)==true\" => \"objA.hashCode() == objB.hashCode()\", mentre non è necessario che sia vero il contrario. E' importante assicurarsi, quindi, che questa relazione venga rispettata quando si effettua l'override di questi metodi.\r\nSe non si è sicuri di come definire \"hashCode\" in relazione ad \"equals\" è buona norma farlo semplicemente restituire 0.\r\nQuando oggetti diversi hanno lo stesso codice hash si parla di \"collisione\". Questo evento non è fonte di errori, tuttavia un numero elevato di collisioni potrebbe degradare la performance del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9666,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9410,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9615,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9495,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 193,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "lectureId": 71,
      "lectureTitle": "JavaFX",
      "questions": [
        {
          "questionId": 6838,
          "asker": {
            "courseId": 102,
            "askerId": 1042,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java cos'è una classe interna anonima?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6739,
          "asker": {
            "courseId": 102,
            "askerId": 1033,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i casi in cui è opportuno avere una classe listener definita esternamente alla classe che implementa application? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "LISTENER"
            },
            {
              "keyword": "LISTENER"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6791,
          "asker": {
            "courseId": 102,
            "askerId": 1025,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come avviene la propagazione di un evento per un bottone quando quest'ultimo viene premuto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6766,
          "asker": {
            "courseId": 102,
            "askerId": 942,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo si può utilizzare la definizione di una classe interna anonima? Presentare un esempio pratico con del codice java.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi interne anonime"
            },
            {
              "keyword": "classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6816,
          "asker": {
            "courseId": 102,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè viene utilizzata una classe interna anonima? Come viene definita in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6756,
          "asker": {
            "courseId": 102,
            "askerId": 1032,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale strategia conviene scegliere tra classe esterna, classe interna anonima e autoimplementazione, quando si ha un codice molto semplice?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6781,
          "asker": {
            "courseId": 102,
            "askerId": 965,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità del paradigma Parent Node in JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6815,
          "asker": {
            "courseId": 102,
            "askerId": 974,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono getTarget() e getSource() e quai sono le differenze tra i due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7306,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1089,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le due istruzioni getTaget() e getSource() sono entrambe delle istruzioni che ritornano delle caratteristiche. GetTarget() ritorna l'istanza dell'oggetto puntato, mentre getSource() ritorna l'oggetto su cui si è svolto inizialmente l'evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10755,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10386,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10507,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10647,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7303,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1053,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "getTarget() e getSource() permettono di ottenere informazioni relative ad eventi. \r\nIl primo permette di ottenere l'oggetto \"bersaglio\" dell'evento. \r\nIl secondo restituisce l'oggetto su cui è stato generato inizialmente l'evento. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10754,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10509,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10382,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10646,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7272,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1040,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "getTarget() è un metodo che ritorna la destinazione dell'evento. getSource() ritorna invece l'oggetto che ha generato l'evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10649,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10510,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10384,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10757,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7222,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 985,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "getTarget() ritorna l'evento target dell'evento, mentre getSource() ritorna la classe sorgente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10383,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10756,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10508,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10648,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7209,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1068,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "get source oggetto\r\nget target ...",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10753,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10385,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10506,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10645,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6807,
          "asker": {
            "courseId": 102,
            "askerId": 1001,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Se si usano i keyEvent, cosa potrebbe impedire il funzionamento corretto del programma, quando ci sono più nodi nella stessa scena?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7301,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Poichè, a causa del concetto di fuoco, è necessario aggiungere entrambi i key event all'interno della funzione start.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10739,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10792,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7245,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1008,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Supponiamo di associare un EventHandler per il KeyEvent al singolo nodo.\r\nIl programma potrebbe non funzionare correttamente perché, se tale nodo non avesse il \"fuoco\" (non fosse cioè attivo) al verificarsi del KeyEvent, il suo EventHandler non potrebbe registrare quanto accaduto.\r\nÈ quindi buona prassi associare l'EventHandler all'intero contenitore (se vogliamo l'intero Stage), in modo che l'evento venga sempre catturato, non importa quale nodo sia attivo in quel momento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10740,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10791,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6754,
          "asker": {
            "courseId": 102,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra un Listener Interno e uno Esterno e quale dei due e` preferibile usare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": "Listeners "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7269,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1049,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un Listener Interno si differenzia da un Listener Esterno per la sua implementazione. Il primo viene creato al momento del suo utilizzo all'interno della classe in cui viene utilizzato, il secondo, invece, viene richiamato come oggetto all'interno della classe, in quanto ha una classe Listener creata appositamente. Il motivo per cui a volte è meglio implemmentare un Listener Interno al posto di uno Esterno o viceversa sta, oltre che nel modo di programmare dell'utente, nella quantità di eventi di cui c'è bisogno di tenere conto. In caso in cui ci sia un solo evento, non ci sarà bisogno di creare una classe apposita e quindi verrà utilizzato un Listener Interno, al contrario se ci fossero stati più eventi, un Listener Esterno avrebbe avuto un effetto più vantaggioso, sia a livello di lettura di codice, sia a livello di implementazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10470,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10656,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10887,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10872,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7288,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 976,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza tra un listener interno ed uno esterno è la posizione della dichiarazione.\r\nUn listener interno viene dichiarato al interno della classe che ha bisogno di gestire gli eventi (come la classe Application di JavaFX che abbiamo sempre visto in laboratorio). Mentre un listener esterno viene dichiarato su un'altro file a parte per poi essere istanziato al interno della classe che lo necessità.\r\nGeneralmente i listener esterni vengono utilizzati quando è necessario riutilizzare il loro codice per diversi contesti differenti al interno del applicazione. In caso invece l'evento è circoscritto ad un'unico caso di necessità è più conveniente utilizzare un listener interno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10871,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10888,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10471,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10655,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6728,
          "asker": {
            "courseId": 102,
            "askerId": 1068,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modi può essere posizionato un layout all'interno di una scena?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout "
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6768,
          "asker": {
            "courseId": 102,
            "askerId": 957,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "come è possibile e quali sono i vantaggi dell'invocare un evento attraverso il \"fuoco\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6788,
          "asker": {
            "courseId": 102,
            "askerId": 1082,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i listeners? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6823,
          "asker": {
            "courseId": 102,
            "askerId": 997,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come possiamo evitare la \"propagazione\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JAVA FX EVENT CHAIN"
            },
            {
              "keyword": "JAVA FX EVENT CHAIN"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6834,
          "asker": {
            "courseId": 102,
            "askerId": 1067,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il parent WebView?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6806,
          "asker": {
            "courseId": 102,
            "askerId": 1027,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile utilizzare due bottoni come ascoltatori di eventi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JAVA FX"
            },
            {
              "keyword": " JAVA FX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6840,
          "asker": {
            "courseId": 102,
            "askerId": 1058,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Si possono assegnare più Listeners ad un unico solo evento?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": "Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6832,
          "asker": {
            "courseId": 102,
            "askerId": 932,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è il concetto di fuoco?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Fuoco"
            },
            {
              "keyword": " tastiera "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7323,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1005,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per concetto di fuoco in Java si intende il campo di definizione della variabile, anche chiamato scooping di una variabile.\r\n\r\nIl compilatore é l'agente che si occupa di risolvere lo scooping delle variabili.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10681,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10559,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10433,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10628,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7281,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 999,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il fuoco è ciò che consente ai widget del GUI di vedere gli eventi di tastiera. Solamente un widget alla volta può essere a fuoco. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10627,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10431,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10558,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10683,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7229,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il fuoco è quel meccanismo grazie al quale un elemento della finestra creata dal nostro codice JavaFX, appare evidenziato rispetto agli altri oggetti presenti nella finestra stessa. È possibile impostare un elemento che ha il fuoco di default, oppure modificare quale elemento ha il fuoco in seguito ad un qualsiasi tipo di evento (di mouse, di tastiera..)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10682,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10626,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10432,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10556,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10421,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7320,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1078,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il fuoco indica l oggetto a cui sono rivolti gli eventi in un determinato momento",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10684,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10434,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10557,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10629,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6762,
          "asker": {
            "courseId": 102,
            "askerId": 954,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per classi interne anonime?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6782,
          "asker": {
            "courseId": 102,
            "askerId": 1052,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Se aggiungo un evento ad un bottone e lo stesso evento lo aggiungo al gruppo che lo contiene, l'evento viene ripetuto due volte?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6819,
          "asker": {
            "courseId": 102,
            "askerId": 1074,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega lo schema Stage/Scene/Parent/Node di un programma javafx.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stage"
            },
            {
              "keyword": "Scene"
            },
            {
              "keyword": "Parent"
            },
            {
              "keyword": "Node    "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6723,
          "asker": {
            "courseId": 102,
            "askerId": 981,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è lo scopo delle catene di eventi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7213,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 970,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Permettere che l'evento venga \"passato\" agli oggetti successivi nella catena. In questo modo chi deve (e sa) occuparsi dell'evento se ne prende cura; tutti gli altri oggetti semplicemente non fanno nulla",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10593,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10415,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10577,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10672,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7264,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1072,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Principalmente serve per rendere effettivo il principio basilare della programmazione per cui ogni componente del programma deve conoscere tutto ciò di cui ha bisogno e niente di più. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10578,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10673,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10595,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10414,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7243,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 963,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Attraverso un Event Chain è possibile propagare la chiamata di un evento generando una catena di invocazioni. EventFilter e EventHandler differiscono per l'ordine con cui generano la catena, il primo inzia dal contenitore più grande (es. Stage) propagandosi fino ai figli. L' EventHandler invece percorre la catena in senso inverso.\r\nPrincipalmente la catena di eventi viene usata per decidere quale nodo deve intercettare per primo un determinato evento.\r\nEs: Se genero una catena su un bottone e un HBox attraverso un EventFilter, la propagazione partirà dall'HBox",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10674,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10594,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10579,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10416,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6829,
          "asker": {
            "courseId": 102,
            "askerId": 964,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa restituisce la funzione getChildren() che viene chiamata ogni volta che si vuole aggiungere un elemento ad un Parent?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6747,
          "asker": {
            "courseId": 102,
            "askerId": 1022,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le classi interne anonime e quali vantaggi comporta il loro uso?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI_INTERNE_ANONIME"
            },
            {
              "keyword": " CLASSI_INTERNE_ANONIME"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6749,
          "asker": {
            "courseId": 102,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "quali sono i vantaggi di usare le librerie di javafx layout??",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javafx layout"
            },
            {
              "keyword": " javafx layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6770,
          "asker": {
            "courseId": 102,
            "askerId": 952,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono/Quando si utilizzano le classi interne anonime ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7215,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Le classi interne anonime sono classi  che sovrappongono qualche metodo di una superclasse o implementano qualche metodo di un?interfaccia, senza dover costruire una classe vera e propria che lo faccia. Sono utili nei casi in cui non sia possibile lavorare sulle interfacce ma sia necessario operare con le implementazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10519,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10512,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10745,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10731,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10472,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10634,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10704,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7280,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 941,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Le classi interne anonime sono delle classi che vengono istanziate all'interno di un metodo. Si dicono anonime perché non viene associato un nome alla classe.\r\n\r\nSono utilizzate per evitare di dover creare una classe esterna e poter vedere subito che cosa permette di fare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10473,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10520,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10747,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10513,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10637,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10733,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10705,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7261,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1023,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi interne anonime sono delle classi interne ad altre classi, sono generalmente utilizzate per svolgere dei servizi basilari , spesso le utilizziamo per settare degli ascoltatori che poi utilizzeremo in determinate circostanze",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10636,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10732,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10707,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10475,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10517,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10514,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10746,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7315,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 997,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi anonime sono un particolare tipo di classe interna di java che possono essere definite nel corpo di un metodo. A differenza delle classi locali, le classi anonime sono delle espressioni che possono essere incluse come parte di un'espressione più ampia senza la necessità di dichiararle con un nome e la loro visibilità è limitata alla classe o al metodo nel quale sono state definite. Le classi anonime non possono fare uso di membri statici (come proprietà, metodi o ulteriori classi interne) e non possono nemmeno definire interfacce interne, considerate anch'esse statiche. Le classi anonime possono usare variabili esterne alla loro visibilità solo se queste vengono dichiarate di tipo final. Generalmente viene utilizzata quando c'è la necessità di creare una classe locale soltanto una volta. Le classi anonime forniscono la possibilità di sovrapporre i metodi di una superclasse, o di implementare i metodi di un'interfaccia, senza dover costruire una classe vera e propria. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10511,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10635,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10474,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10706,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10748,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10734,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10518,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6797,
          "asker": {
            "courseId": 102,
            "askerId": 1030,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di utilizzare classi interne come ricevitori di eventi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6839,
          "asker": {
            "courseId": 102,
            "askerId": 1035,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "cos'è il fuoco?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": "JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6771,
          "asker": {
            "courseId": 102,
            "askerId": 986,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Elencare e descrivere i diversi tipi di layout di JavaFX.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": " JavaFX layout"
            },
            {
              "keyword": "  JavaFX layout "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6804,
          "asker": {
            "courseId": 102,
            "askerId": 998,
            "courseFinalScore": 11
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le classi interne anonime e perché può essere conveniente utilizzarle?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6835,
          "asker": {
            "courseId": 102,
            "askerId": 1080,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra handle e filter?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "EventHandler"
            },
            {
              "keyword": " Filter"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6746,
          "asker": {
            "courseId": 102,
            "askerId": 1013,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza fra un EventHandler e un EventFilter?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6796,
          "asker": {
            "courseId": 102,
            "askerId": 1054,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra l'event Handler e l'event Filter?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "event chain"
            },
            {
              "keyword": " event chain"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7216,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "l'handler viene eseguito durante la fase di bubbling di un evento, mentre il filter viene eseguito durante la cattura dell'evento stesso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10407,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10561,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10717,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10494,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10680,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7284,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 972,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'event handler gestisce un evento in generale, il filter permette di filtrare uno specifico ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10560,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10495,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10409,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10679,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10719,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7250,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 948,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "La funzione dell'event Handler e quella dell'event Filter è la stessa con la differenza che l'event Filter agisce prima sul nodo più esterno della catena degli eventi e poi segue la catena fino al nodo più interno, mentre l'event Handler funziona al contrario.\r\nAd esempio se abbiamo una catena di questo tipo \"Stage-Scene-Pane-Button\" l'event Filter agirà nell'ordine Stage, Scene, Pane, Button mentre l'event Handler nell'ordine Button, Pane, Scene, Stage.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10718,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10408,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10562,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10678,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10493,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6774,
          "asker": {
            "courseId": 102,
            "askerId": 1031,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere la differenza tra listener esterno, interno e interno anonimo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6805,
          "asker": {
            "courseId": 102,
            "askerId": 951,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le varie possibilità di implementazione di Listeners e che vantaggi portano ciascuna?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listeners"
            },
            {
              "keyword": "listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6742,
          "asker": {
            "courseId": 102,
            "askerId": 1066,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "è possibile che diversi pulsanti ricevano gli stessi eventi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javaFX eventi"
            },
            {
              "keyword": " javaFx eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6744,
          "asker": {
            "courseId": 102,
            "askerId": 1104,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "le classi interne possono essere considerate una soluzione di java per l'eredità multipla? come mai?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6812,
          "asker": {
            "courseId": 102,
            "askerId": 967,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi conviene inserire un listener esterno alla classe rispetto a un listener interno anonimo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7246,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un listener è un oggetto che aspetta che si verifichi un evento e quando ciò accade compie un azione in risposta. Per gestire un evento occorre:creare un oggetto listener per l?evento che \r\ninteressa e aggiungere il listener al componente che può generare l?evento. Gli oggetti listener sono istanze di classi che implementano interfacce ?listener? della libreria standard di Java. Nei casi in cui devi gestire una grande quantità di dati conviene avere un listener esterno alla classe in modo tale da sapere dove esso viene gestito e quindi avere un codice più organizzato e pulito. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10563,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10866,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10516,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10576,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10405,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10477,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7263,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1033,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Uno dei casi più importanti è quello in cui abbiamo più oggetti che hanno bisogno di un listener (o eventhandler) con le stesse funzionalità! Se ad esempio abbiamo 3 bottoni che devono gestire l'evento \"bottone premuto\" allora avere una classe listener esterna mi permetterà di aggiungere facilmente i tre gestori di eventi ai bottoni creando 3 istanze dello stesso listener e senza duplicare codice(come avverrebbe invece se dovessi dichiarare per ogni bottone una classe interna anonima). \r\nAltro caso è quando ho bisogno che il listener possa essere istanziato anche da altre classi(per questioni di visibilità).\r\nIn conclusione, ogni volta che avrò bisogno di istanziare una classe una sola volta utilizzerò le classi interne anonime, ogni volta che invece dovrò istanziare più oggetti uguali utilizzerò una classe esterna!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10515,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10867,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10476,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10564,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10406,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10575,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6795,
          "asker": {
            "courseId": 102,
            "askerId": 987,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono gli strumenti più utili per ordinare in maniera semplice e corretta i vari bottoni in Javafx?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6811,
          "asker": {
            "courseId": 102,
            "askerId": 978,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si può evitare la propagazione in una eventi chain?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6745,
          "asker": {
            "courseId": 102,
            "askerId": 992,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono i Listener",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Listener "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6817,
          "asker": {
            "courseId": 102,
            "askerId": 953,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono i layout?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javaFX"
            },
            {
              "keyword": " layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6836,
          "asker": {
            "courseId": 102,
            "askerId": 1081,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i più importanti eventi di JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "-JavaFXeventi"
            },
            {
              "keyword": " -JavaFXeventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6732,
          "asker": {
            "courseId": 102,
            "askerId": 972,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le classi interne anonime?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6767,
          "asker": {
            "courseId": 102,
            "askerId": 1099,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Che funzione hanno i listeners?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Event"
            },
            {
              "keyword": " listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6776,
          "asker": {
            "courseId": 102,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la funzione di un listener?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6784,
          "asker": {
            "courseId": 102,
            "askerId": 1070,
            "courseFinalScore": 10
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la relazione che sussiste tra la class Node e la class Parent.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ricorsione"
            },
            {
              "keyword": " contenimento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6792,
          "asker": {
            "courseId": 102,
            "askerId": 944,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche principali di un border pane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": "JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6778,
          "asker": {
            "courseId": 102,
            "askerId": 1091,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si catturano gli eventi da tastiera?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " event"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6721,
          "asker": {
            "courseId": 102,
            "askerId": 1017,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale è la gerarchia dei tipi di eventi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6777,
          "asker": {
            "courseId": 102,
            "askerId": 1002,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilizzo della classe Scene?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": " JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6740,
          "asker": {
            "courseId": 102,
            "askerId": 1008,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi un listener esterno è più comodo di uno interno/interno anonimo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": "Listeners"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7212,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 969,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando il listener viene utilizzato da più oggetti esterni.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10521,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10527,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10478,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10788,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10535,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7211,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 957,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando è necessario utilizzarlo più di una volta (anche in classi diverse).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10525,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10480,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10789,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10533,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10524,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7292,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 974,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un listener esterno viene utilizzato quando deve essere richiamato più volte (per esempio l'EventHandler di più bottoni) invece uno interno o interno anonimo viene utilizzato quando serve una sola volta (per esempio quando in un programma con un bottone che quando viene cliccato stampa una stringa a video)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10479,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10523,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10790,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10536,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10526,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7256,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1074,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando ci sono più elementi che richiedono un listener.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10528,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10522,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10787,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10534,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10481,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6793,
          "asker": {
            "courseId": 102,
            "askerId": 990,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega quale e' il principale motivo per cui e' utile estendere un EventHandler nel seguente modo\r\n\r\nclass MyHandler extends EventHandler<MouseEvent>() {\r\n    public void handle(MouseEvent event) {...}\r\n};\r\n\r\npiuttosto che senza specificare nessun parametro di tipo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6841,
          "asker": {
            "courseId": 102,
            "askerId": 966,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra i vari tipi di \"listener\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6761,
          "asker": {
            "courseId": 102,
            "askerId": 958,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i Listeners e come funzionano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners "
            },
            {
              "keyword": " Listeners "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6729,
          "asker": {
            "courseId": 102,
            "askerId": 1019,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono gestiti gli eventi con JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6780,
          "asker": {
            "courseId": 102,
            "askerId": 1007,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel codice \"layout.getChildren().add(cerchio);\" qual è la funzione del metodo getChildren()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7318,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 995,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "il getChildren() e' un metodo della classe \"javafx.scene.Parent\", dichiarato \"protected\" e ritornante una collection (una ObservableList, per la precisione), che contiene tutti i figli dell'oggetto chiamante.\r\n\r\nPerciò codice sopracitato, getChildren() ritorna una collection di tutti i figli di \"layout\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10828,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10532,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10800,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7262,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1036,
                "courseId": 102,
                "courseFinalScore": 31
              },
              "answerText": "La funzione del metodo getChildren() è quella di restituire la lista dei Children di un Parent, in questo caso layout. Il significato del codice riportato è \"aggiungi il Children cerchio alla lista dei Children di layout\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10531,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10801,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10826,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7321,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1021,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Un oggetto di tipo Parent non è altro che una collezione di nodi che verranno visualizzati.\r\nIl metodo getChildren() permette di ottenere la lista degli elementi contenuta nel parent che può venire modificata aggiungendo o rimuovendo elementi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10799,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10829,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10529,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7230,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1027,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo getChildren() permette la comunicazione fra parent e child. In questo caso particolare, la comunicazione con il parent layout permette l'aggiunta di un cerchio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10798,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10530,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10827,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6826,
          "asker": {
            "courseId": 102,
            "askerId": 1009,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le classi interne anonime?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": "Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6833,
          "asker": {
            "courseId": 102,
            "askerId": 1043,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "spiegare qual' è la flessibilità che si ha in javaFX nell' utilizzo degli event handler e event filter e cosa serve il metodo consume()",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6764,
          "asker": {
            "courseId": 102,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra i diversi tipi di listeners?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": "Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6799,
          "asker": {
            "courseId": 102,
            "askerId": 985,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa ha portato alla creazione di classi interne anonime?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6769,
          "asker": {
            "courseId": 102,
            "askerId": 1029,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste una classe interna anonima e qual'è la sua utilità?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6820,
          "asker": {
            "courseId": 102,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè viene utilizzato il Listener? Che differenza c'è nell'utilizzo di quello esterno o di quello interno? Come posso capire qual'è meglio utilizzare?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6760,
          "asker": {
            "courseId": 102,
            "askerId": 1046,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono i Listeners?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6759,
          "asker": {
            "courseId": 102,
            "askerId": 963,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Ad un bottone viene associato un EventHandler<KeyEvent> nel quale è implementato che alla pressione della lettera 'u' della tastiera venga visualizzato un messaggio sulla Console con scritto il nome del target. Nel caso in cui il fuoco sia spostato su un altro oggetto nella form, cosa accadrà una volta premuta la lettera 'u'?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": "JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6730,
          "asker": {
            "courseId": 102,
            "askerId": 1073,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilizzo del fireEvent?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7253,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 988,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Esegue l'evento specificato. Di default l'evento viaggerà attraverso la gerarchia dallo stage al node. Qualsiasi filtro di eventi incontrato sarà notificato e potrà terminare l'evento. Se ciò non accade, i gestori dell'evento saranno notificati. Se anche questi non consumano l'evento, allora questo viaggerà indietro per lo stesso percorso con il quale è arrivato al nodo. Tutti j gestori dell'evento che vengono incontrati saranno chiamati e potranno consumare l'evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10653,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10500,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10806,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7234,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "fireEvent, letteralmente \"spara un evento\", è un metodo che genera e lancia (da codice) eventi sull'oggetto su cui viene chiamato, esattamente come se questi venissero generati da un mouse, da tastiera o in altra maniera. Gli eventi generati dal comando fireEvent verranno poi catturati e trattati come specificato nella rispettiva implementazione di handle.\r\n\r\nL'utilizzo di fireEvent trova applicazione in un contesto in cui si hanno diverse tipologie di eventi (ad esempio KeyEvent e ActionEvent) e si vuole trattarli alla stessa maniera: attraverso fireEvent, si riconduce il trattamento di un evento al trattamento dell'altro, evitando una ripetizione di codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10654,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10499,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10810,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7266,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1085,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un fireEvent si utilizza nella creazione di eventi generati dalla tastiera",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10496,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10809,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10650,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7278,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 946,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Tramite il fireEvent ho la possibilità di invocare l'evento associato all'oggetto chiamato in causa; in particolare:\r\npublic static void fireEvent(EventTarget eventTarget, Event event);\r\nDove i parametri indicano:\r\n- eventTarget: il target dell'evento\r\n- event: l'evento vero e proprio da invocare",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10808,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10652,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10498,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7273,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1045,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il fireEvent viene utilizzato per generare un evento che verrà gestito al relativo listener, se presente.\r\nUn esempio è utilizzare fireEvent su di un nodo Button generando un ActionEvent, così che venga simulata la pressione del tasto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10651,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10807,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10497,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6802,
          "asker": {
            "courseId": 102,
            "askerId": 945,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un'event chain in JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": " JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6808,
          "asker": {
            "courseId": 102,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In quanti e quali modi posso implementare un listener?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " JavaFX"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7314,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1001,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Un listener può essere implementato in 3 modi diversi: può essere creata una classe esterna, e in questo caso si parla di listener esterno; può essere implementato all'interno della classe stessa come classe aggiuntiva, e si parla di listener interno; oppure può essere implementato come listener interno anonimo, cioè creando la nuova classe solo dove serve, senza darle un nome e senza poterla usare nuovamente (dato che non si hanno riferimenti a quella classe).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10785,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10606,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10743,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7308,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1086,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "E' possibile definire un Listener, in cui abbiamo la classe ascoltatore associata a un button, e un multiListener in cui possiamo associare più classi a un button.\r\nInoltre, il Listener può essere interno, interno anonimo ed esterno.\r\nNel primo caso, il Listener sta dentro alla classe al cui servizio si trova. Ha accesso ai metodi e alle varibili della classe che lo ospita.\r\nNel secondo caso, abbiamo interno poichè sta all'interno di un'altra classe e anonimo poichè si crea un'istanza che serve in un punto particolare e al contempo la si definisce.\r\nNel terzo caso, il Listener è esterno e si fa comunicare le due parti tramite un costruttore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10786,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10605,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10744,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6751,
          "asker": {
            "courseId": 102,
            "askerId": 960,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come faccio a fare in modo che un bottone venga premuto nel caso prema la lettere p?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi "
            },
            {
              "keyword": "JavaFX event chain "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6786,
          "asker": {
            "courseId": 102,
            "askerId": 1085,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "in con che logica javaFX crea le scene?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Java FX"
            },
            {
              "keyword": " scene"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6773,
          "asker": {
            "courseId": 102,
            "askerId": 979,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale differenza c'è tra l'usare un EventFilter oppure un EventHandler?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX event chain"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7279,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 982,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La prima differenza è che EventFilter viene eseguita prima di EventHandler. \r\n\r\nUna seconda differenza è che EventFilter gestisce l'evento durante la fase di cattura, mentre EventHandler lo gestisce durante la fase di bubbling.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10612,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10565,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10676,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10701,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10849,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7304,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 956,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "L'EventFilter viene eseguito prima dell'EventHandler.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10702,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10851,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10675,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10613,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10567,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7231,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1028,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Per poter gestire la giusta cattura dell?evento lungo la catena di contenimento, dobbiamo distinguere due agenti. Con l?agente Filter si percorre la catena di ?andata?, ovvero quella che va dal contenitore radice fino all'oggetto a cui l?evento appartiene. Invece con l?agente Handler si percorre la catena di ?ritorno?, ovvero quella che va dall'oggetto ascoltatore, fino al contenitore radice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10850,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10566,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10703,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10611,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10677,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6738,
          "asker": {
            "courseId": 102,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il Listener interno anonimo è chiamato così e perché è utile nella gestione di eventi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6725,
          "asker": {
            "courseId": 102,
            "askerId": 956,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando devo ridimensionare una finestra, come faccio a mantenere gli elementi al centro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": "JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7251,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1012,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Per mantenere un gruppo di elementi al centro di una finestra è conveniente inserirli in un \"layout pane\" dotato del metodo \"setAlignment\" (da chiamare con il parametro Pos.CENTER) come ad esempio FlowPane, GridPane, HBox, VBox oppure TilePane.\r\n\r\nEsempio:\r\n\r\n...\r\nHBox hbox = new HBox();\r\nhbox.setAlignment(Pos.CENTER);\r\nhbox.getChildren().addAll(...); // Aggiungo i miei elementi\r\n...\r\nprimaryStage.setScene(new Scene(hbox));\r\n...",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10779,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10550,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10442,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10854,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10685,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10835,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7258,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1043,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "basta utilizzare il metodo setAlignment(<oggetto>,Pos.CENTER); del contenitore, il valore di Pos.CENTER  rappresenta l' allineamento in centro sia in verticale che in orrizzontale",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10687,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10836,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10778,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10548,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10440,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10855,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7236,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 955,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "creando un GridPane o un BorderPane si possono impostare gli oggetti che devono stare al centro della finestra e quindi loro rimarranno in quella posizione anche se la si ridimensiona.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10688,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10547,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10441,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10852,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10780,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10837,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7235,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Utilizzando Java FX, se si ha una finestra con dentro uno StackPane come root e vengono mantenute le impostazioni di default, allora il contenuto rimarrà sempre al centro, nel caso in cui si debba ridimensionare la finestra.\r\nIn generale i layout, ad esempio lo StackPane, supportano l'alignment. Quindi, attraverso il metodo\r\n\r\nsetAlignment(Pos.CENTER)\r\n\r\nsi può esplicitamente dire al layout di mantenere il proprio contenuto al centro della finestra.\r\nUn altro layout più avanzato che supporta la possibilità di settare il posizionamento del contenuto è il Border Pane. Si può mettere del contenuto nell'area centrale con il metodo setCenter().",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10777,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10853,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10549,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10439,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10686,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10834,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6824,
          "asker": {
            "courseId": 102,
            "askerId": 1103,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità dell' Event Chain in JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "event chain"
            },
            {
              "keyword": " javafx"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6827,
          "asker": {
            "courseId": 102,
            "askerId": 1023,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il vantaggio di gestire gli eventi in java sia con il filter che con l'handler",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": "JavaFX event chain "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7255,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1099,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In java estendo gli eventi sia con filter che con handler si ha una miglior gestione delle eccezioni",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10782,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10657,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10428,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10632,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10873,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7274,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 984,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "servono per gestire l'ordine di comunicazione degli eventi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10784,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10429,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10659,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10875,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10633,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7238,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 975,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "Gestire gli eventi con i filter e handler offre maggiore flessibilità all'utente.\r\nIn pratica permette ti intercettare gli eventi in entrata (filter) o in uscita (handler) indirizzati all'oggetto grafico, o a i suoi figli, al quale è stato aggiunto l'evento secondo le regole di \"Event chain\".\r\n\r\nPS.\r\nGli oggetti grafici possono essere: scene, stage, ecc",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10874,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10781,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10658,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10630,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10427,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7275,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1014,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Gestendo gli eventi sia con il filter che con l'handler abbiamo la possibilità di intercettare un evento durante la fase di cattura (ad esempio nell'istante in cui sto premendo il tasto) e quando effettivamente è avvenuto (quando ho premuto il tasto e l'ho rilasciato).\r\nQuesto ci torna utile ad esempio quando abbiamo la necessità che l'handler di un nodo sia eseguito solo quando una codizione è verificata. Prendiamo il caso della calcolatrice, dove l'handler del click di un operando dovrebbe essere eseguito solo quando entrambe le caselle di input contengono dei numeri. Possiamo gestire questo problema impostando un filter al bottone, dove implementeremo questo controllo: nel caso in cui entrambi i numeri non sono inseriti, l'evento click non verrà processato dall'handler ma verrà \"consumato\" nel filter. Il vantaggio di ciò è l'ottimizzazione dell'applicazione che, in caso di errore, esegue un solo metodo anzichè due.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10631,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10876,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10660,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10783,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10430,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6722,
          "asker": {
            "courseId": 102,
            "askerId": 955,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si fa a inserire degli oggetti nella finestra del programma in modo che occupino tutto lo spazio a disposizione? Per esempio 4 bottoni che diventino lunghi come una casella di testo, senza modificare manualmente la dimensione di ogni bottone.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6831,
          "asker": {
            "courseId": 102,
            "askerId": 1055,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'utilizzo del metodo consume()?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7220,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 932,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo consume() in JavaFX è un metodo della classe AWTEvent.\r\nTale metodo permette di eseguire un evento in modo che questo non sarà trattato in modo predefinito dalla sorgente che ha originato.\r\nAd esempio : Se voglio costruire un campo di testo (textfield) in modo tale che non superi, ad esempio, i 6 caratteri, devo attribuire al mio campo di testo\r\nun keyTyped che ha come parametro un keyEvent. Quando la lunghezza della stringa nel textfield supera 6, c'è il metodo consume() del keyEvent che blocca ogni ulteriore inserimento. Vediamolo.\r\nvoid textfield_keyTyped(KeyEvent e)\r\n{\r\nif(textfield.getText().length()>5)\r\ne.consume();\r\n}\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10573,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10639,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10621,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10582,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10870,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10880,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7207,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 987,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con consume () si può bloccare la catena degli eventi a qualsiasi punto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10619,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10869,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10574,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10580,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10638,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10881,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7237,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1003,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Il metodo \"consume()\" viene usato per \"consumare\" un evento ovvero, impedire che esso si propaghi attraverso la event-chain, se esso viene richiamato mediante un EventFilter (cioè mentre l'evento sta scendendo la gerarchia), l'evento verrà distrutto e gli EventHandler (che gestiscono gli eventi che risalgono la gerarchia) non riceveranno notificheranno alcun evento, questo può essere utile nel caso in cui vogliamo gestire un'azione all'interno del programma e vogliamo evitare che alcune componenti siano notificate dell'avvenire di alcuni eventi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10879,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10572,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10640,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10868,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10620,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10581,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6727,
          "asker": {
            "courseId": 102,
            "askerId": 939,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra una TilePane e una GridPane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7254,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1070,
                "courseId": 102,
                "courseFinalScore": 10
              },
              "answerText": "Entrambi questi due layout permettono di creare delle tabelle (o griglie). \r\nIl layout TilePane crea una tabella con celle regolari, tutte della stessa dimensione. Il layout GridPane,  invece, crea una tabella con righe e colonne di dimensione variabile dando quindi la possibilità di lavorare con una tabella flessibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10724,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10877,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10398,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10741,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10759,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10690,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7286,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 966,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "TilePane permette di creare una \"tabella\" dove le colonne (o le righe) hanno una dimensione massima costate, che viene definita nel codice.\r\nGridPane invece offre una gestione più flessibile delle colonne e delle righe: basta indicare la posizione dell'oggetto attraverso le coordinate x e y e, anche se la finestra viene ridimensionata, la posizione degli oggetti non cambia.\r\nGeneralmente GridPane viene utilizzato di più, in quanto è uno dei tipi di layout più potenti e flessibili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10397,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10878,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10689,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10758,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10725,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10742,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6785,
          "asker": {
            "courseId": 102,
            "askerId": 1012,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in JavaFX esistono due metodi distinti (\"addEventFilter\" e \"addEventHandler\") per registrare un'istanza di un EventHandler?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7316,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1002,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Esistono perchè hanno due logiche di funzionamento diverso, cioè il metodo eventFilter passa dalla classe padre alle figlie, invece eventHandler il contrario.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10596,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10830,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10458,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7289,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1015,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Per gestire l'ordine di esecuzione tra le varie azioni compiute al verificarsi di un evento all'interno di un'Event Chain",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10459,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10599,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10831,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7240,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 991,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Perché così posso intercettare l'evento a qualsiasi livello; l'EventFilter permette di gestire gli eventi \"all'andata\", quando l'evento percorre la catena partendo dalla stage e arriva fino all'ultimo nodo, l'Event Handler al \"ritorno\" (l'esatto opposto).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10597,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10832,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10456,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7249,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1017,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Handler contiene il codice che verrà eseguito quando l'evento associato al filtro sarà ricevuto dal nodo che registra il filtro.\r\nFilter invece serve per registrare il filtro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10598,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10457,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10833,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6733,
          "asker": {
            "courseId": 102,
            "askerId": 949,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra EventHandler e EventFilter?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX event chain "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7297,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 940,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "La risposta è nelle docs di Oracle: https://docs.oracle.com/javafx/2/events/processing.htm",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10571,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10539,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10751,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10387,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10773,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10437,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7233,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1065,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Di base un EventFilter verrà chiamato prima di un EventHandler. Inoltre un EventFilter verrà fatto partire dai componenti padre a quelli figli mentre un EventHandler verrà fatto partire dai componenti figli a quelli padre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10438,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10389,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10750,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10537,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10776,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10568,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7317,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1067,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Sono entrambi implementazioni dell'interfaccia EventHandler, quindi registrano gli eventi che accadono. EventFilter viene eseguito prima di EventHandler, infatti EventFilter viene eseguito dal parent più in alto fino agli eventi considerati, mentre EventHandler parte dagli eventi e risale la catena figlio-padre.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10540,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10749,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10435,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10569,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10775,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10390,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7294,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 993,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "EventFilter permette di gestire un evento durante la fase di cattura dell'evento stesso mentre invece l'EventHandler permette di gestire gli eventi solo durante la fase di bubbling.\r\n\r\nQuindi EventFilter viene eseguito prima di EventHandler.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10570,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10538,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10436,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10388,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10752,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10774,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6813,
          "asker": {
            "courseId": 102,
            "askerId": 946,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché devo usare un contenitore per aggiungere oggetti ad una finestra?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFx"
            },
            {
              "keyword": " Events"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6828,
          "asker": {
            "courseId": 102,
            "askerId": 971,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Te'l gai el mulet?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "mulet"
            },
            {
              "keyword": " pomi"
            },
            {
              "keyword": " malta"
            },
            {
              "keyword": " sablon"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6844,
          "asker": {
            "courseId": 102,
            "askerId": 983,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Da quali elementi è composto lo stage ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6748,
          "asker": {
            "courseId": 102,
            "askerId": 527,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di utilizzare un Listener interno (o una classe interna anonima), rispetto ad un Listener esterno?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6765,
          "asker": {
            "courseId": 102,
            "askerId": 1040,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si implementano (o si usano) le classi interne anonime?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6779,
          "asker": {
            "courseId": 102,
            "askerId": 940,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "EventHandler a=new EventHandler(){\r\n  int counter=0;\r\n  public void handle(Event t) {\r\n  updateText(++counter);\r\n }};\r\n\r\n'EventHandler' è un'interfaccia. Com'è possibile che venga istanziata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7247,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 990,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Non e' corretto dire che la sintassi mostrata istanzi un'interfaccia.\r\nLa sintassi mostrata e' una notazione che serve per la creazione di un'istanza di una classe anonima, cioe' per *DICHIARARE* e *ISTANZIARE* allo stesso momento una classe locale senza nome (anonima appunto) che estende l'interfaccia EventHandler. Estendendo l'interfaccia EventHandler ovviamente questa classe dovra' eseguire l'override di tutti i metodi dichiarati dall'interfaccia come fatto nell'esempio mostrato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10455,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10468,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10884,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7232,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1018,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Perchè questo codice crea un'istanza di una inner class anonima e di fatti non istanzia un oggetto di tipo EventHandler, ma crea invece una istanza di un nuovo implementatore anonimo di EventHandler.\r\n\r\nLa riga:\r\n\r\nEventHandler a=new EventHandler(){..}\r\n\r\nandrebbe letta come: \"dichiara una reference di tipo EventHandler a un oggetto di una classe che implementa l'interfaccia EventHandler e, dato che non abbiamo una classe che effettivamente implementa EventHandler, la sua definizione sarà quella contenuta tra le due parentesi graffe\".\r\n\r\nRicapitolando, non è possibile instanziare interfacce eccetto nei casi di inner class anonime: la seguente riga infatti non sarebbe permessa:\r\n\r\n    EventHandler a=new EventHandler();\r\n\r\nmentre le successive sono permesse in quanto si sta instanziando un implementatore anonimo dell'interfaccia EventHandler:\r\n\r\n    EventHandler a=new EventHandler(){\r\n    int counter=0;\r\n      public void handle(Event t) {\r\n      updateText(++counter);\r\n     }};",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10467,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10452,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10883,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7225,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1019,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il fatto che EventHandler venga instanziata deriva dal fatto che esso è una classe anonima e di conseguenza la sintassi di Java per definire una classe anonima e proprio quello di dichiararlo come interface e poi istanziarla come una classe normale. Per questo motivo posso istanziarlo.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10454,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10465,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10882,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7293,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 958,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Grazie per non avermi fatto una domanda, così io non devo rispondere :-D",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10469,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10453,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10886,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7224,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 951,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "In questo caso EventHandler può essere istanziato perchè nell'istanziazione viene anche fatto override del metodo handle(Event t) definito nell'interfaccia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10466,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10885,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10451,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6757,
          "asker": {
            "courseId": 102,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra listener interno e listener esterno, e quando vengono usati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listeners"
            },
            {
              "keyword": " listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6758,
          "asker": {
            "courseId": 102,
            "askerId": 1028,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza dei metodi ?getTarget()? e ?getSource()??",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7302,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1030,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza sta nel fatto che il metodo getTarget() ritorna l'oggetto, quale ad esempio il bottone, che è il destinatario finale dell'evento mentre il metodo getSource() ritorna l'oggetto sul quale si è verificato inizialmente l'evento che corrisponde all'oggetto su cui è registrato il listener che sta intercettando l'evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10554,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10601,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10614,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7219,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodi getTarget() viene ereditato dalla classe javafx.event.Event e restituisce il target dell'evento di questo evento. Il target dell'evento specifica il percorso attraverso il quale l'evento si sposterà al momento della pubblicazione.\r\n\r\nIl metodo getSource() viene ereditato dalla classe java.util.EventObject e  restituisce l'oggetto su cui inizialmente si è verificato l'evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10615,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10552,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10602,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7226,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "getSource() ritorna l'oggetto in cui l'evento avviene inizialmente, invece getTarget() ritorna il path attraverso il quale l'evento viaggerà ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10553,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10617,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10603,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7282,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1054,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo getTarget() restituisce l'evento chiamante, mentre getSource() restituisce l'oggetto chiamante.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10616,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10555,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10600,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7325,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 943,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo getSource() ci restituisce la sorgente dell'evento (ovvero l'oggetto su cui si è inizialmente generato l'evento), mentre getTarget() ci restituisce l'oggetto per il quale è stato generato l'evento. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10618,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10551,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10604,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6830,
          "asker": {
            "courseId": 102,
            "askerId": 1075,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si possono aggiungere più elementi Node al Parent radice? Posso passarle per parametro o serve un metodo apposito?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Layout"
            },
            {
              "keyword": " JavaFX Layout"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7268,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1098,
                "courseId": 102,
                "courseFinalScore": 14
              },
              "answerText": "JavaFX mette a disposizione il metodo getChildren().add(node) per aggiungere nodi al parebt dove passiamo come parametro di add il nodo da aggiungere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10795,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10865,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10423,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10461,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10712,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7227,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 992,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Per inserire più elementi al Parent è necessario creare i singoli oggetti e poi aggiungerli con la funzione:\r\nparent.getChildren().addAll(oggetti1, oggetto2);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10793,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10716,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10861,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10463,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10424,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7265,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1035,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il costruttore del Parent può essere il costruttore vuoto oppure può avere come parametro un solo Node, che verrà aggiunto al Parent.\r\nDunque se si deve aggiungere più di un nodo bisogna usare un metodo specifico:\r\nnomeParent.getChildren().add(Node n);\r\nIn questo modo si può aggiungere l'elemento specificato al Parent, e add accetta un solo Node come parametro. \r\nSe si devono aggiungere molti elementi si può fare un add per ogni Node oppure si può usare il metodo addAll e specificare come parametri tutti i Node da aggiungere al Parent:\r\nnomeParent.getChildren().addAll(Node n1, Node n2, Node n3);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10713,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10462,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10422,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10796,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10864,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7228,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 979,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per aggiungere un Node ad un Parent si utilizza l'istruzione parent.getChildren().add(node).\r\nSe invece si vogliono aggiungere diversi Node è necessaria l'istruzione parent.getChildren().addAll(node1, node2, ...).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10426,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10797,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10464,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10714,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10862,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7221,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1031,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si può usare il metodo radice.getChildren().add(Node) o radice.getChildren().addAll(Collection<Node>)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10425,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10863,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10460,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10715,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10794,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6783,
          "asker": {
            "courseId": 102,
            "askerId": 1096,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come sono relazionati fra di loro questi 4 elementi: stage, root, scene, button?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout "
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6801,
          "asker": {
            "courseId": 102,
            "askerId": 975,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra handler e filter? Come mai per addEventFilter e addEventHandler possiamo usare lo stesso Eventhandler?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6818,
          "asker": {
            "courseId": 102,
            "askerId": 1086,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa succede a un evento, se non viene usato nessun listener? E cosa succede se invece viene utilizzato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "listener"
            },
            {
              "keyword": " evento"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6803,
          "asker": {
            "courseId": 102,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve un listener? Quali differenze vi sono tra i vari modi di implementarli?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Listener"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6736,
          "asker": {
            "courseId": 102,
            "askerId": 977,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "che cos'è una classe interna anonima?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi interne anonime"
            },
            {
              "keyword": " classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6734,
          "asker": {
            "courseId": 102,
            "askerId": 1014,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa intendiamo quando parliano di listener interno anonimo e quando ci conviene usarlo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6752,
          "asker": {
            "courseId": 102,
            "askerId": 961,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quali tipi di applicazioni è utile il BorderPane ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "BorderPane "
            },
            {
              "keyword": " JavaFX "
            },
            {
              "keyword": " utilità"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6809,
          "asker": {
            "courseId": 102,
            "askerId": 980,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali benefici comporta l'utilizzo dei listener interni anonimi e in quali casi conviene utilizzarli? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listener interni anonimi"
            },
            {
              "keyword": " Listener interni anonimi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6719,
          "asker": {
            "courseId": 102,
            "askerId": 1045,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il metodo setPrefSize dei nodi di JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7319,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1055,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Questo metodo dovrebbe venire chiamato per settare al meglio il layout della regione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10642,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10721,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10609,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7277,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 983,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Innanzitutto la classe nodo non possiede il metodo setPrefSize, ma lo contengono la classe Region e le sue sottoclassi.\r\nIl metodo setPrefSize serve a modificare l'altezza e larghezza predefinite dal computer per un oggetto di tipo Region.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10608,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10641,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10723,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7310,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 967,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Serve per settare le preferenze di altezza e larghezza del nodo sul quale viene chiamato il metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10722,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10643,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10610,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7267,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1064,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Tale metodo serve ad impostare le dimensioni predefinite di un layout.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10644,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10607,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10720,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6731,
          "asker": {
            "courseId": 102,
            "askerId": 948,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità dell'AnchorPane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX Layout"
            },
            {
              "keyword": " JavaFX Layout"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7299,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 952,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "L'AnchorPane permette a qualunque elemento che viene inserito al suo intero (può essere un Node o a sua volta un altro Pane) di essere ancorato ad uno dei lati di questo Pane. Solitamente si usa per far si che un determinato oggetto stia in un determinato posto/lato quando ridimensiono la finestra o il Pane.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10693,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10505,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10379,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7241,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1013,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Il layout \"AnchorPane\" permette di ancorare i vari elementi presenti al suo interno ai bordi del layout stesso. È possibile specificare un eventuale margine che ogni elemento deve avere dai bordi dell'AnchorPane.\r\nRisulta utile se si vogliono inserire oggetti che, anche se la finestra verrà ridimensionata in seguito, rimangano ancorati ai bordi del layout.\r\nAd esempio, se si vuole inserire una \"firma\" all'interno dell'applicazione, ossia una semplice Label che rimanga posizionata nell'angolo in basso a destra della finestra, risulta utile utilizzare un AnchorPane: in questo modo, anche se la finestra verrà ridimensionata in seguito, grazie all'AnchorPane la Label rimarrà fissa nell'angolo in basso a destra. Es.:\r\n\r\nAnchorPane layout = new AnchorPane();\r\nLabel firma = new Label(\"@miaFirma\");\r\nlayout.getChildren().add(firma);\r\nAnchorPane.setBottomAnchor(firma, 10.0); // 10.0 = margine dal bordo inferiore \r\nAnchorPane.setRightAnchor(firma, 15.0); // 15.0 = margine dal bordo destro",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10378,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10503,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10695,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7257,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1029,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "AnchorPane permette ai bordi del nodi figlio di essere ancorati a un offset dai bordi del riquadro di ancoraggio. Se il riquadro di ancoraggio ha una serie di confine, gli offset saranno misurati dal bordo interno di questi inserti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10501,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10691,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10377,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7271,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1046,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "AnchorPane permette ai bordi del nodo figlio di ancorarsi ai bordi dell'offset. Se il riquadro ha un bordo più spesso l'offset verrà misurato dall'interno dei bordi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10502,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10380,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10694,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7300,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1071,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "L'AnchorPane permette di definire una dimensione per i bordi di un oggetto, che sarà il child dell'AnchorPane stesso. Consente in sostanza di definire una \"cornice\" attorno ad un oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10381,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10504,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10692,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6763,
          "asker": {
            "courseId": 102,
            "askerId": 1098,
            "courseFinalScore": 14
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra una classe interna e una classe interna anonima?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7217,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1022,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi interne sono la soluzione che da java alle classi annidate. Offrono una maggiore chiarezza al programma e rappresentano una possibile soluzione al problema dell?eredità multipla. Le classi anonime sono particolari classi interne senza un nome assegnato, si tratta di una classe definita e instanziata un?unica volta attraverso una singola espressione caratterizzata da una versione estesa della sintassi dell?operatore new. In tal modo si può sovrapporre qualche metodo di una superclasse senza dover creare una vera e propria classe. Quindi, mentre le classi intere sono definite in tutto e per tutto in maniera identica a come si definiscono le comuni classi, con la classica dichiarazione che fa uso della keyword class, le classi anonime sono definite ed istanziate in un?unica espressione. In altre parole, le classi interne posso essere richiamate più volte nella classe stessa, mentre le classi interne anonime sono utili se dobbiamo usare la classe una sola volta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10858,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10393,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10726,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10823,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10699,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10760,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7312,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1044,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe interna è una classe dichiarata all'interno di un'altra classe.\r\nUna classe interna anonima è si una classe interna ad un altra, ma in più è priva di nome;\r\nsi tratta di una classe definita e istanziata un?unica volta attraverso una singola espressione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10698,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10860,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10763,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10729,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10821,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10394,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7218,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1091,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La classe interna è una classe che viene definita all'interno di un altra classe, ogni istanza della classe interna fa riferimento alla classe a cui appartiene e può essere \r\nrichiamata un numero arbitrario di volte all'interno della classe esterna.\r\nUna classe anonima invece è un costrutto che permette contemporaneamente di dichiarare e istanziare una classe è simile  una classe locale ma non presenta un nome.\r\nUna classe interna anonima quindi è una classe interna che viene creata quando è necessaria richiamarla una volta sola.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10395,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10761,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10728,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10857,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10700,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10822,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7248,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1007,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "In java è possibile dichiarare una classe all'interno di un'altra classe, questa implementazione è usata  quando la classe interna risulta strettamente legata a quella che la contiene. Es: public class Esterna \r\n{//.... class Interna {//implementazione di metodi}..}. Java permette inoltre di definire e istanziare una classe senza definire alcun tipo di riferimento ad essa, inserendola in un blocco di codice. Es button.addEventHandler(ActionEvent.ACTION, new EventHandler(){//implementazione della classe});. La differenza principale tra i due costrutti è il fatto che la classe interna è definita in ogni aspetto come una classe normale mentre le classi interne anonime sono istanziate nel codice senza il classico costrutto \"class\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10730,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10764,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10392,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10856,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10824,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10696,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7287,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 953,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": ".Una le classi locali e le classi anonima sono costrutti che permette di istanziare una clsse al momento della sua dichiarazione. La classe anonima, a differenza della classe interna non presenta alcun nome e viene utilizzata generalmente quando si vuole creare una classe locale soltanto una volta. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10859,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10396,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10697,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10762,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10727,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10825,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6720,
          "asker": {
            "courseId": 102,
            "askerId": 969,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'e la differenza fra l'oggetto Pane e StackPane?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Javafx"
            },
            {
              "keyword": "layout"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7252,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 944,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "La classe Pane rappresenta un generico pannello: nonostante sia istanziabile, e dunque non abstract, costituisce più che altro una base per diversi altri layout; numerose sono infatti le sottoclassi, fra le quali è presente proprio Stack Pane. Un pannello di quest'ultimo tipo, per la precisione, consente di disporre diversi elementi l'uno sull'altro, generando una struttura a pila di cui sono visibili l'ultimo componente inserito ed eventualmente parte dei sottostanti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10401,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10588,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10546,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7291,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 945,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "Il Pane utilizza un metodo di posizionamento secondo le coordinate assolute ed è quindi compito del programmatore fare in modo che i nodi che apparengono al pane non siano sovrapposti e fare in modo che questo si adatti al ridimensionamento della finestra.\r\nIl StackPane è un tipo particolare di Pane che gestisce in modo automatico il posizionamento dei nodi figli  e in particolare li posiziona uno sopra l'altro e quindi l'elemento inserito per ultimo si vedrà completamente mentre gli altri potrebbero vedersi parzialmente o affatto. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10404,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10585,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10541,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7313,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 942,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Pane è un pannello generico più che altro atto a contenere altri pannelli facendo da base per questi. Non è una classe abstract, bensì istanziabile. StackPane è una classe figlia di Pane, che organizza i suoi nodi \"Children\" l'uno sopra l'altro, in una struttura a stack. Con lo StackPane è visibile solo l'ultimo nodo aggiunto posizionato sopra agli altri aggiunti precedentemente, i quali possono sporgere ai bordi risultando quindi in parte visibili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10402,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10391,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10542,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10587,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7239,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1025,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza principale è che la classe StackPane è una sottoclasse di Pane che dispone sulla scena gli oggetti con disciplina LIFO come avviene nello stack. StackPane inoltre implementa alcuni metodi per settare la posizione e la dimensione degli oggetti che contiene.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10543,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10403,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10584,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7307,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1047,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "La classe Pane è un layout di base, superclasse di StackPane, che posiziona i nodi senza occuparsi della loro posizione, ovvero è responsabilità dell'applicazione decidere la posizione dei nodi.\r\nStackPane invece è il layout che posiziona i nodi, in posizione centrale, uno sopra l'altro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10544,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10586,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10399,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7223,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con l'oggetto Pane è possibile utilizzare riquadri di layout per gestire facilmente l'interfaccia utente.\r\nL'oggetto StackPane è una \"sottoclasse\" di Pane, che inserisce tutti i nodi in un unico stack con ogni nuovo nodo aggiunto sopra il nodo precedente. Questo modello di layout fornisce un modo semplice per sovrapporre il testo su una forma o immagine o sovrapporre forme comuni per creare una forma complessa.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10583,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10545,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10400,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6726,
          "asker": {
            "courseId": 102,
            "askerId": 941,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Se ho un evento t, t.consume() come funziona precisamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6737,
          "asker": {
            "courseId": 102,
            "askerId": 962,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e a cosa servono i Listeners?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6825,
          "asker": {
            "courseId": 102,
            "askerId": 58,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e a cosa serve una classe anonima? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6843,
          "asker": {
            "courseId": 102,
            "askerId": 1005,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale implementazione del Listener scegliere? Motiva la tua risposta.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "LISTENERS"
            },
            {
              "keyword": " LISTENERS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6798,
          "asker": {
            "courseId": 102,
            "askerId": 1048,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Da che cosa è composto lo spazio grafico di lavoro di JavaFX?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Spazio grafico JavaFX"
            },
            {
              "keyword": " Spazio grafico JavaFX"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6794,
          "asker": {
            "courseId": 102,
            "askerId": 1053,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come evitare la propagazione degli eventi in una applicazione JavaFX?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6741,
          "asker": {
            "courseId": 102,
            "askerId": 982,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono e come funzionano i listeners? Portare degli esempi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6790,
          "asker": {
            "courseId": 102,
            "askerId": 993,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare il concetto di fuoco.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6787,
          "asker": {
            "courseId": 102,
            "askerId": 1044,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo, nell'implementazione della classe EventHandler per la gestione di eventi da tastiera è necessario fare il generics <KeyEvent> ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6810,
          "asker": {
            "courseId": 102,
            "askerId": 1064,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza sostanziale tra un filter ed un'event handler? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Java Fx eventi"
            },
            {
              "keyword": " Java Fx eventi "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7322,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1081,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza sta sostanzialmente nel fatto che un 'filter' non è altro che un'implementazione dell'interfaccia 'EventHandler', creata con lo scopo di consentire la gestione di un evento durante la fase di acquisizione ed elaborazione degli eventi. Possiamo dunque diversificare i due elementi definendo un 'filter' come un'implementazione di un'interfaccia, ed 'event handler' come l'interfaccia stessa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10590,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10771,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10805,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10489,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10848,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7270,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 977,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "la differenza è che il codice di un event filter viene eseguito prima rispetto a un event handler, con tutte le impicazioni che ne seguono se si vuole programmare codice efficiente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10492,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10845,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10589,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10803,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10770,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7285,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 978,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Gli EventFilter vengono chiamati durante la fase di cattura degli eventi e vengono apputo utilizzati per filtrare gli stessi ad esempio modificandoli o bloccandoli prima che possano essere catturati dagli EventHandler.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10802,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10772,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10491,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10846,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10591,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7295,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "La differenza sostanziale sta nel momento in cui vengono chiamati: un filter viene chiamato durante la capturing phase dell'evento, mentre un handler viene chiamato durante la bubbling phase dell'evento.\r\nEvent filter e event handler sono entrambi implementazioni dell'interfaccia EventHandler ma agiscono in momenti diversi. Ricordando che la capturing phase è antecedente alla bubbling phase, un filter può consumare un evento impedendo che esso arrivi al target e che venga processato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10490,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10804,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10847,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10592,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10769,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6814,
          "asker": {
            "courseId": 102,
            "askerId": 984,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra VBox e HBox?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6772,
          "asker": {
            "courseId": 102,
            "askerId": 1079,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo le interfacce grafiche utilizzano spesso uno o più Listeners?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6735,
          "asker": {
            "courseId": 102,
            "askerId": 996,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "quali sono i vantaggi delle classi interne anonime?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi interne anonime"
            },
            {
              "keyword": " Classi interne anonime"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6822,
          "asker": {
            "courseId": 102,
            "askerId": 1089,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile poter cambiare il formato e il layout di un HBox? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6800,
          "asker": {
            "courseId": 102,
            "askerId": 1072,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Utilizzando la definizione di classe, come si può definire un evento nel contesto di Java FX? Che sottoclassi potrebbe avere una ipotetica sottoclasse MouseEvent? \r\nQual'è la differenza fra un EventHandler e un EventFilter? \r\n\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFXeventi"
            },
            {
              "keyword": " javaFXEventChain"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6789,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché un qualsiasi evento generico percorre 2 volte (in direzioni opposte) la event chain?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX event chain"
            },
            {
              "keyword": " JavaFX event chain"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7327,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando viene lanciato (fired) l?evento viene inviato dal nodo principale dell'applicazione, tramandato attraverso la event dispatch chain fino il nodo di destinazione. L?evento infatti viaggia dal nodo stage al nodo di destinazione, durante la fase di cattura degli eventi. Se qualsiasi nodo della catena ha un filtro evento registrato per il tipo di evento verificatosi, quel filtro viene chiamato. Dopo che il target dell'evento è raggiunto e tutti i filtri registrati hanno elaborato l'evento, l'evento ritorna lungo la dispatch chain dalla destinazione al nodo principale, percorrendo quindi di nuovo in risalita la chain. Se nessun gestore consuma l'evento, il nodo principale alla fine riceve l'evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10735,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10444,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10448,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7324,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 58,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè l'evento segue due fasi. Nella prima fase, quella di \"event capturing\", l'evento passa dal nodo root fino al nodo target dove viene processato passando per eventuali event filter. Nella seconda, \"event bubbling\", l'evento risale l'event chain seguita nella prima fase fino a tornare al nodo root eseguendo gli event handler registrati per quel tipo di evento.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10446,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10450,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10736,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7214,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè un nodo può registrare più di un evento. L'ordine in cui è chiamato ogni evento si basa sulla gerarchia dei tipi di eventi . Gestori per uno specifico tipo di evento vengono eseguiti prima di gestori per i tipi di eventi generici . Ad esempio, un gestore per l'evento KeyEvent.KEY_TYPED viene chiamato prima il gestore per l'evento InputEvent.ANY . L'ordine in cui vengono eseguiti due gestori allo stesso livello non è specificato ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10738,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10443,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10449,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7259,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1034,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Un evento percorre il tutto due volte per permetterci attraverso gli handler di filter di bloccare la propagazione di un evento (solitamente), mentre attraverso gli handler di listener possiamo far agire vari elementi della gerarchia dei componenti grafici allo stesso input. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10447,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10445,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10737,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6837,
          "asker": {
            "courseId": 102,
            "askerId": 995,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere, molto sinteticamente (con un elenco puntato, per esempio) vantaggi e svantaggi di listeners interni o esterni, soffermandosi possibilmente su dove sia piu' vantaggioso l'uno rispetto all'altro.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": "Listeners"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7242,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 949,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Un listener interno, sia esso implementato come metodo anonimo o inner class consente di definire un gestore \"al volo\", ovvero solo nel momento in cui serve. Ad esempio se abbiamo un applicazione che deve gestire un solo bottone, con una logica applicativa molto semplice, può essere superfluo creare una classe separata ed è sufficiente implementare un metodo anonimo o una inner class.\r\nViceversa se abbiamo un'applicazione con molti elementi il cui funzionamento è molto simile e differisce per uno o più parametri (ad esempio una calcolatrice con i pulsanti numerici) è conveniente implementare l'ascoltatore in una classe separata instanziata ogni volta nel ciclo di costruzione dei bottoni. Se invece abbiamo molti elementi differenti (ad esempio listbox, bottoni e radiobutton) allora può essere preferibile implementare metodi anonimi o, se vi sono molti oggetti dello stesso tipo, classi esterne dedicate a un certo tipo di oggetti (ad esempio una per i bottoni e una per i radiobutton).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10818,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7311,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1042,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Vantaggi listener esterni:\r\n- Riutilizzabilità del codice (è possibile instanziarlo più volte)\r\n- miglior leggibilità nel caso in cui bisogna scrivere molto codice\r\n              \r\nVantaggi listener interni (con una propria classe):\r\n- Riutilizzabilità del codice (è possibile instanziarlo più volte)\r\n- il listener vede le variabili dichiarate \"final private\" appartenenti alla classe contenente la classe in cui viene definito\r\n- non serve creare un altro file\r\n\r\nVantaggi listener interni anonimi:\r\n- velocità di implementazione\r\n- miglior leggibilità (nel caso in cui bisogna scrivere poco codice) perché è definita dove è utilizzata\r\n- il listener vede le variabili dichiarate \"final private\" appartenenti alla classe in cui viene istanziato\r\n- non serve creare un altro file",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10819,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7296,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1032,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "LISTENER ESTERNO\r\n-Conviene quando ci sono più finestre che utilizzano li stessi ascoltatori.\r\nAd esempio quando abbiamo un'applicazione che ha diversi bottoni allora, poichè ciascuno dei bottoni richiede un ascoltatore, diventa più semplice avere più classi di servizio  ciascuna associata con uno dei bottoni.\r\n-Svantagio:codice non localizzato:per vedere l 'azione devo aprire un altro file e vedere cosa succede\r\nLISTENER INTERNO\r\n-Quando è tutto localizzato allora conviene localizzare anche il codice e quindi utilizzare listener interno.\r\n-Vantaggio:codice tutto localizzato nello stesso file, ha immediatamente accesso ai metodi e alle variabili della classe che lo sta ospitando\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10820,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6755,
          "asker": {
            "courseId": 102,
            "askerId": 1047,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si gestiscono eventi relativi alla pressione di tasti su tastiera, perchè bisogna prestare particolare attenzione al Focus sui vari nodi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7326,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 939,
                "courseId": 102,
                "courseFinalScore": 30
              },
              "answerText": "Quando viene eseguito un programma di JavaFX e viene creata la schermata del relativo programma, viene automaticamente settato il Focus su uno dei nodi presenti nella schermata stessa (come per esempio un bottone). Ciò può creare molti problemi nel settaggio di eventi da tastiera: se infatti applico il metodo addEventHandler assegnando l'evento \"pressione del tasto\" ad uno dei nodi presenti nello Stage e il nodo in questione durante l'esecuzione del programma non è nel Focus, l'azione non viene eseguita. Per ovviare a questo problema basta semplicemente settare l'addEventHandler non nei singoli nodi, ma nell'intero Stage che li contiene: tramite una funzione switch si setta poi l'azione dei vari bottoni (usando la funzione getCode() per comprendere quale tasto è stato pressato) e, in particolare, se ad un pulsante da tastiera deve corrispondere l'azione di un nodo basta richiamare sul nodo stesso il metodo fireEvent( new ActionEvent() ).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10811,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10488,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10669,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10839,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7260,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1066,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "perché ci possono essere conflitti tra l'ereditarietà e gestione del focus",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10813,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10483,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10666,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10842,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7283,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1052,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Il focus serve a comunicare al programma a runtime quale degli elementi dell'interfaccia grafica deve ricevere gli eventi, quindi non ci si può aspettare che un elemento non in focus riceva l'evento della pressione di un tasto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10484,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10841,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10667,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10815,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7244,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 962,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Bisogna prestare attenzione al Focus perché altrimenti l'utente, digitando con la tastiera, andrebbe a scrivere non soltanto nel campo desiderato ma anche altrove, non ottenendo il risultato sperato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10665,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10838,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10812,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10486,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7309,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 964,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Bisogna prestare particolare attenzione al focus perchè se il listener e l'evento handler è stato applicato ad un oggetto specifico presente nella scena allora la pressione del tasto verrà \"ascoltata\" e processata solo se il focus sarà su quel determinato oggetto. \r\n\r\nSe il listener invece lo applichiamo alla scena o allo stage il focus non sarà più un problema in quanto l'evento verrà chiamato indipendentemente dal focus.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10844,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10671,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10817,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10482,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7298,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1009,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Bisogna controllare su quale nodo sia attivo il focus, in quanto l'evento, generato dalla pressione di un tasto, può propagarsi soltanto attraverso il percorso specificato dal target dell'evento(ovvero il nodo).\r\n\r\nIn questo modo ogni nodo riceverà il focus a seconda del tasto premuto, e potrà lanciare il proprio evento.\r\nPer spostare il focus su un nodo si usa la funzione \"nome_nodo.fireEvent(nome_evento);\"\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10843,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10485,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10668,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10814,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7305,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1037,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè bisogna specificare i vari eventi a quali nodi riguardano altrimenti ci si focalizza su di un nodo solo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10487,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10816,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10670,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10840,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6842,
          "asker": {
            "courseId": 102,
            "askerId": 1021,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile aggiungere più ascoltatori a un singolo bottone?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6775,
          "asker": {
            "courseId": 102,
            "askerId": 1065,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega cos'è un evento in JavaFX e fornisci un breve esempio. ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX eventi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6743,
          "asker": {
            "courseId": 102,
            "askerId": 970,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché un Parent eredita da Node e allo stesso tempo contiene dei Node?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JavaFX layout"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7290,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 980,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I Node si suddividono in due tipi, quelli che possono avere come figli altri Node, ossia i Parent (o meglio dei suoi sottotipi, essendo Parent astratto), e quelli che invece non possono, e sono le foglie di uno scene graph.\r\nParent eredita quindi da Node perché è un elemento grafico.\r\nLa radice di quasi ogni applicazione grafica è un sottotipo di Parent, perché altrimenti non si potrebbero avere dei nodi sottostanti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10710,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10412,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10768,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10624,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10664,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7210,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 981,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché in questo modo un elemento può essere sia un elemento foglia sia un nodo; potendo quindi contenere a sua volta altri elementi oppure essere un elemento finale nella catena di appartenenza",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10711,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10411,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10623,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10765,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10663,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7276,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 986,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Un parent è utilizzato per disporre dei Node ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10625,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10661,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10709,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10413,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10767,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7208,
              "task": {
                "taskId": 199,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1079,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La relazione \"ricorsiva\" tra Parent e Node può essere descritta nel modo seguente: Parent rappresenta un contenitore, mentre Node è un contenuto. E' quindi facile capire il motivo per cui un Parent contiene dei Node. Parent eredità da Node perchè esso deve avere tutte le caratteristiche di un Node, in quanto un certo Parent può essere a sua volta il contenuto di un altro Parent. Il fine di tutto ciò è fornire una semplificazione alla progettazione di interfacce grafiche. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10766,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10662,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10410,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10708,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10622,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 199,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6750,
          "asker": {
            "courseId": 102,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona un evento in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFxEvents"
            },
            {
              "keyword": " JavaFxEvents"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6753,
          "asker": {
            "courseId": 102,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i pro e i contro di usare JavaFX",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "JavaFX eventi"
            },
            {
              "keyword": " JavaFX layout"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6724,
          "asker": {
            "courseId": 102,
            "askerId": 1078,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo può essere effettuata la gestione degli eventi di un widget JavaFX? \r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6821,
          "asker": {
            "courseId": 102,
            "askerId": 1018,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 198,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali diverse tipologie di Listeners abbiamo studiato? Illustrane le principali caratteristiche e differenze.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "LISTENERS"
            },
            {
              "keyword": " LISTENERS"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 70,
      "lectureTitle": "Static,Generics,Listeners",
      "questions": [
        {
          "questionId": 6647,
          "asker": {
            "courseId": 102,
            "askerId": 958,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Le Generics possono essere utilizzate per la creazione di qualsiasi oggetto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6638,
          "asker": {
            "courseId": 102,
            "askerId": 948,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa comporta l'iscrizione/rimozione da un listener?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Publish/subscribe"
            },
            {
              "keyword": " Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6706,
          "asker": {
            "courseId": 102,
            "askerId": 1023,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché preferiamo utilizzare generics al posto di fare cast successivamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": "Generic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7176,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1076,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè dato che permette di definire delle astrazioni sui tipi di dati che possono essere definiti, utilizzando generics si aggirano molti errori o disguidi che possono essere causati da un semplice cast e inoltre vengono risparmiate anche righe di codice e seguenti complicazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10243,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10222,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10281,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10042,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9849,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7147,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1059,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "E' più sicuro,più veloce da scrivere e usare e il codice risulta più leggibile",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10221,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10244,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10280,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10043,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9846,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7078,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 970,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè con i generics siamo sicuri di non avere nessun problema di compatibilità dei tipi di dato, cosa non garantita con un cast tra oggetti diversi. Per esempio se utilizziamo una Collection di <Integer>, stiamo effettivamente lavorando con degli Integer, non con altri oggetti, che per quanto simili non sono Integer, e che quindi potrebbero non avere tutti i metodi o gli attributi di un Integer",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10224,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10245,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10278,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10046,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9845,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7150,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 983,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Perché se inserissimo un tipo diverso da quello di cui abbiamo bisogno il cast non darebbe necessariamente errore, mentre inserendo la specifica con generics abbiamo un errore se utilizziamo un tipo diverso da quello specificato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10279,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10220,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10242,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10045,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9850,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7139,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1086,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Utilizzare il costrutto generics, invece che un successivo cast, è vantaggioso poiché è possibile avere il fail quick. Se ad esempio si utilizza una collezione, supponendo sia solo di stringhe, nel caso in cui si trovasse un qualsiasi altro oggetto, l'errore verrebbe rilevato nel momento in cui si tenta di estrarre quell'oggetto; invece, con generics, è possibile rilevare l'errore nel momento in cui si tenta di inserire un oggetto differente da string, evitando di rilevare la problematica troppo tardi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9847,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10044,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10225,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10282,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10240,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7170,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1044,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Utilizzando i generics abbiamo un fail quick a compile time al punto esatto in qui è stato commesso l'errore nella progettazione del software.\r\nInfatti, per esempio se noi avessimo istanziato e riempito una collection di interi e poi estraendo facessimo un cast a stringhe l'errore risulterebbe a runtime sul punto di estrazione.\r\nTramite i generics il compilatore è in grado di verificare a compile time la compatibilità dei tipi.\r\nAll'estrazione non serve fare cast.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10041,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10241,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10283,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10223,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9848,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6684,
          "asker": {
            "courseId": 102,
            "askerId": 1054,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali situazioni non possono essere usati i Generic?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6718,
          "asker": {
            "courseId": 102,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il meccanismo di \"Publish and Subscribe\" è molto utile nella gestione di un gruppo di utenti e dei messaggi a loro indirizzati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Listeners"
            },
            {
              "keyword": " Listeners"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7164,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1075,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Chi pubblica il messaggio non si deve preoccupare di chi è interessato a riceverlo. Chi è interessato basta che si iscriva al gruppo per ricevere imessaggi di cui ha bisogno. Questo meccanismo facilita molto la comunicazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10068,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10374,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10059,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7124,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1008,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Il meccanismo \"Publish and Subscribe\" è utile nella gestione di sistemi di messaggistica di gruppo in quanto chi pubblica il messaggio non si deve preoccupare di quanti e quali siano i suoi \"listeners\" (ascoltatori). Ciò permette di rendere il meccanismo di pubblicazione indipendente da quello di ascolto e rende il programma più modulare, quindi più semplice da mantenere/modificare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10067,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10058,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10376,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7168,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1030,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il meccanismo di publish and subscribe è molto utile perchè in questo modo ogni programma può indicare mediante l'installazione di oggetti ricevitori di eventi (\"eventi listener\"), quali eventi gradisce ricevere. Un oggetto che funge da ricevitore di eventi va aggiunto alle sorgenti di evento appropriate in modo che quando si genera l'evento che ci interessa la sua sorgente invoca gli opportuni metodi di tutti i ricevitori ad essa connessa. Inoltre l'utilità del paradigma publish and subscribe sta nel fatto che è possibile avere zero o molti ascoltatori e posso usarli, aggiungerli e rimuoverli come e quando voglio. Si dice anche che i publisher sono \"debolmente accoppiati\" ai subscriber e non hanno quindi bisogno di sapere della loro esistenza. Questo significa dunque che ognuno dei due può operare normalmente senza preoccuparsi del meccanismo di funzionamento dell'altro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10375,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10057,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10066,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6693,
          "asker": {
            "courseId": 102,
            "askerId": 1089,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è il corretto utilizzo di Javadoc? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javadoc"
            },
            {
              "keyword": " Javadoc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6621,
          "asker": {
            "courseId": 102,
            "askerId": 992,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando viene utilizzata la parola chiave 'static'?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6671,
          "asker": {
            "courseId": 102,
            "askerId": 944,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consistono l'autoboxing e l'autounboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": "Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6713,
          "asker": {
            "courseId": 102,
            "askerId": 1073,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è più comodo usare i Generic in caso ci sia un errore nel codice?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6636,
          "asker": {
            "courseId": 102,
            "askerId": 985,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste l'autoboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": " autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6663,
          "asker": {
            "courseId": 102,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando si utilizzano le autoboxing e quando bisogna utilizzarle?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "AUTOBOXING"
            },
            {
              "keyword": " AUTOBOXING"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6690,
          "asker": {
            "courseId": 102,
            "askerId": 1086,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi di usare il costrutto generics per le collections?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": "vantaggi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6672,
          "asker": {
            "courseId": 102,
            "askerId": 949,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quanto vale ris al termine del seguente frammento di codice e perché?\r\nInteger x=3;\r\nInteger y=3;\r\nboolean ris = (y==x);",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6614,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è l'utilità delle variabili e dei metodi static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6669,
          "asker": {
            "courseId": 102,
            "askerId": 1068,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve realmente l'Autoboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "autoboxing "
            },
            {
              "keyword": " autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6666,
          "asker": {
            "courseId": 102,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "long number = new Long(10); --> è un caso di autoboxing valido? Perchè?\r\n\r\nString ciao = \"Ciao?; --> è autoboxing? Perchè?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7199,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1009,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il primo non è un autoboxing,bensì un unboxing (l'operazione contraria all'autoboxing), in quanto castiamo un oggetto Long nel corrispettivo dato primitivo long e non viceversa.\r\n\r\nIl secondo non è autoboxing in quanto, in Java , String è un oggetto e non un dato primitivo, quindi non vi è nessun cast.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10133,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10308,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9894,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9945,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7159,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 965,
                "courseId": 102,
                "courseFinalScore": 17
              },
              "answerText": "Il primo esempio non è nulla, ed non è valido. Sarebbe un esempio di boxing valido: \"Long number = new Long(10);\" oppure un esempio di autoboxing: \"Long number = 10;\", l'autoboxing serve a scrivere codice più leggibile, garantendo la chiamata alla classe wrapper indirettamente. Anche il secondo esempio non è nulla. Sarebbe autoboxing se fosse scritto: String ciao = \"Ciao\"; in quanto da Java 1.5 equivale all'operazione di boxing: String ciao = new String(\"Ciao\"); ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9947,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10311,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9893,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10136,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7149,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1033,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "No, non è un caso di autoboxing! È invece il caso contrario, autounboxing: number è definito come long (tipo primitivo) e inizializzato come Long(classe wrapper del tipo primitivo long). L'autoboxing è valido e viene effettuato in java per tutti i tipi primitivi (ad esempio per i tipi float, int, char). Un esempio di autoboxing sarebbe Long a= 10.\r\nNel secondo caso (String ciao = \"ciao\") è semplicemente la dichiarazione e inizializzazione di una stringa. Non è autoboxing.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9943,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10132,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10309,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9890,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7151,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 951,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "L'autoboxing è il processo per il quale il compilatore riesce a interscambiare il dato primitivo (per esempio int,long,...) con il suo oggetto corrispondente (per esempio Integer,Long,... cioè le classi wrapper dei tipi di dati primitivi).\r\nQuindi nel primo caso l'autoboxing è corretto, nel secondo caso ciao è di tipo String che non è un dato primitivo quindi quello che avviene non è autoboxing ma semplicemente una inizializzazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10135,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10312,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9946,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9892,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7074,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 957,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il primo esempio non è un caso di autoboxing, in quanto la variabile number non è un oggetto. Si tratta quindi di unboxing.\r\nIl secondo esempio è un caso di autoboxing perché assegna una variabile ad un oggetto String senza usare la \"new\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9944,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9891,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10310,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10134,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6697,
          "asker": {
            "courseId": 102,
            "askerId": 945,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dati dall'utilizzo dei Generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6702,
          "asker": {
            "courseId": 102,
            "askerId": 1035,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il modificatore Static e perchè il metodo main è dichiarato static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": "Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6635,
          "asker": {
            "courseId": 102,
            "askerId": 1066,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'uso delle generics e quali invece sono le limitazioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6626,
          "asker": {
            "courseId": 102,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e come vengono usati i generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": "Generic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7128,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1050,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I Generics sono degli strumenti del linguaggio Java che permettono di creare strutture dati costituite da elementi di tipo diverso specifico, a seconda delle necessità. Usando i Generics infatti si può specificare quali tipi di dato possono essere attribuiti agli elementi di una struttura al momento della scrittura del codice (tipo determinato quindi a compile-time, il compilatore darà infatti un messaggio di errore se vengono inseriti tipi non compatibili). Questo strumento permette di definire metodi più specifici e più efficienti per le necessità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10369,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9932,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10170,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9988,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7188,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1089,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I generics sono degli strumenti che permettono la definizione di un parametro esplicitato durante la compilazione. I generics forniscono un migliore type checking nella compilazione \r\ned evitano il casting",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10370,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10173,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9990,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9936,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7173,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 967,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I generics sono un concetto logico che ti permette di parametrizzare gli oggetti. Per esempio, nel momento in cui si istanzia una collection, è possibile istanziarla utilizzando i generics, ovvero: collection<string> c = new Collection(); Questo aiuta la leggibilità del codice, in quanto definisce che la collection è una collection di stringhe. In più evita l'utilizzo di cast aggiuntivi. L'utilizzo di generics facilità il fail quick. In più si possono riscrivere molte classi utilizzando un parametro generico <T>, il quale verrà sostituito da <string><int><double> ecc in fase di scrittura del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10172,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10373,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9934,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9987,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7205,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 994,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un tipo generico è un reference type che ha uno o più parametri di tipo.Nella definizione del tipo generico, la sezione dei parametri tipo segue il nome del tipo. La lista di identificatori è separata da una virgola e delimitata da parentesi angolari <>. I generics permettono  il fail quick (cioè falliscono al momento giusto, per esempio quando tento di aggiungere  a una collection qualcosa che non è compatibile con questa) e di non utilizzare il cast.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10372,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9986,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9933,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10174,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7125,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1071,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "I generics sono dei \"segnaposti\" che verranno rimpiazzati da un tipo. Vengono utilizzati per rendere una funzione piu generica, e non legata ad un tipo in particolare. \r\nSe abbiamo una funzione \"Compare\", per esempio, a cui passiamo due parametri generic, non sarà necessario definirla più volte con firme diverse (una volta per int, una per float, etc.). Questo rende molto piu gestibile e mantenibile il codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9989,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9935,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10171,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10371,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6681,
          "asker": {
            "courseId": 102,
            "askerId": 1095,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "a che cosa servono i listener? e come si utilizzano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "utilizzo"
            },
            {
              "keyword": "listener"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7187,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1070,
                "courseId": 102,
                "courseFinalScore": 10
              },
              "answerText": "I listener servono ad implementare un meccanismo di notifica flessibile, secondo il paradigma di publish & subscribe. \r\nDato un insieme di oggetti interessati ad uno stesso evento, li inseriamo (subscribe) in un gruppo e comunichiamo poi l'evento di interesse comune solo ad un mediatore, il quale ha il compito di notificarlo (publish) a tutti i membri del gruppo (listener). Evitiamo così di dover notificare lo stesso evento ad ogni singolo oggetto del gruppo (es: i giocatori del Lotto sono tutti interessati ai numeri estratti). \r\nUno dei vantaggi di questo meccanismo è che ci possiamo disinteressare delle dimensioni (variabili nel tempo) del gruppo stesso: è il mediatore che tiene traccia dei membri del gruppo in ogni istante. \r\nI principali metodi di gestione del gruppo sono addListener, removeListener, per aggiungere o rimuovere un membro, ed il metodo notifyAllListeners, che, tramite l'uso di un Iterator, notifica tutti gli elementi al momento iscritti. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9860,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9900,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9939,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9964,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7177,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1038,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I listener vengono utilizzati secondo il paradigma \"publish & subscribe\", cioè le notifiche vengono mandate al gruppo (publish), e se si è interessati alle notifiche di un gruppo ci si iscrive ad esso, in modo che tutte le volte che ci sarà una notifica la si riceve (subscribe). I listener sono gli ascoltatori, cioè coloro che ricevono le notifiche. Essi servono quindi per vedere quante persone sono interessate a quel dato evento, per notificare uno stesso evento a più persone diverse contemporaneamente. Inoltre è un meccanismo di notifica flessibile in quanto non si parla più ai singoli individui, ma si parla con un'entità, che è un mediatore, che tiene traccia delle persone interessate e si preoccupa lui di avvisarle delle nuove notifiche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9896,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9864,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9941,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9960,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7110,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1022,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un listener (ascoltatore=ricevitore di eventi) è un interfaccia contenente metodi relativi a un evento che si vuole intercettare.Tali meccanismi permettono di interagire con l'utente. Una volta creata una implementazione dell'interfaccia basta installarla nel controllo grafico da cui vogliamo intercettare gli eventi e sarà quest'ultimo infine a notificarci le azioni invocate su di esso. In altre parole è un oggetto che riceve una notifica quando si verifica un evento ed esegue un azione in risposta.Diamo ora un esempio per intercettare eventi generati da un JButton.\r\npublic class Frame {\r\n private class Button implements Listener {\r\n  public void actionPerformed(ActionEvent e) {\r\n   //codice che specifica l'azione che vogliamo al click del mouse\r\n  }\r\n }\r\n}\r\nPoi installiamo il listener nella GUI\r\nJButton button = new JButton(\"Cliccami\");\r\nButton listener = new Button;\r\nbutton.addActionListener(listener);\r\nAll'azione del click viene richiamato il nostro metodo che abbiamo implementato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9859,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9959,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9940,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9898,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7185,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1091,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un Listener è un oggetto che riceve una notifica ogni volta che si verifica un evento, quando questo evento si verifica il listener compie un'azione in risposta.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9897,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9961,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9862,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9937,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7193,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1007,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "I listener sono interfacce che, una volta implementate, permettono di eseguire azioni sulla base dell'avvenimento di determinati eventi. Quindi, ad esempio, la classe: class Mouse implements MouseListener{public void mousePressed(MouseEvent event){System.out.println(\"Mouse premuto\");}} scriverà su terminale ogni volta che verrà premuto un tasto del mouse. I listener seguono una politica \"publish and subscribe\", ovvero solo le classi interessate vengono informate sull'avvenimento di determinati eventi. Affinché un oggetto di una classe venga informato, è necessario che questo venga inserito nella lista degli \"ascoltatori\". Quindi, utilizzando l'esempio precedente: public void start(Stage stage){...Mouse m = new Mouse(); addMouseListener(m);...}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9863,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9942,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9963,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9899,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7195,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1012,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Un listener (ascoltatore) è un oggetto che aspetta il verificarsi di un evento (come ad es. un click del mouse o la pressione di un tasto) e quando ciò accade compie un azione in risposta. \r\nServe, quindi, da mezzo di comunicazione tra il nostro programma e ciò che genera l'evento, come ad es. il sistema operativo, un framework per la gestione della GUI come JavaFX o una libreria.\r\nQuesto meccanismo è anche conosciuto come \"Observer pattern\" e si basa sull'idea generale che uno o più oggetti (subscribers) registrino il loro \"interesse\" nel ricevere notifiche circa i cambiamenti che avvengono in un altro oggetto (publisher), da qui il termine \"Publish-Subscribe\".\r\nPer comunicare secondo questo pattern quindi occorre:\r\n1. creare un listener per l'evento d'interesse (solitamente implementando un'interfaccia appositamente predisposta)\r\n2. aggiungere il listener al componente che genera l'evento che verrà poi notificato, mediante meccanismi di callback, a tutti i listeners registrati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9962,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9895,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9861,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9938,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6627,
          "asker": {
            "courseId": 102,
            "askerId": 1007,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo il metodo \"main\" è definito come public static void?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7117,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1064,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il void è un suffisso appostovi in quanto è un metodo che non prevede nessun valore di ritorno, il suffisso public è invece dovuto alla necessità di rendere il metodo main accessibile al di fuori della classe, mentre il suffisso static è dovuto al fatto che il main è un metodo che si chiama una sola volta all'interno del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10291,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9923,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9809,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10129,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7162,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 928,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "public: il metodo può essere chiamato anche al di fuori della classe in cui si trova\r\nstatic: il metodo si riferisce ad una sola classe, quindi tutte le istanze di quella classe avranno un solo main che sarà in comune tra tutti\r\nvoid: il main non restituisce nessun risultato\r\nstring[] args: l'argomento del main è un vettore di stringhe di caratteri di nome \"args\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10292,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9921,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10131,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9806,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7137,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1098,
                "courseId": 102,
                "courseFinalScore": 14
              },
              "answerText": "Il \"main\" è dichiarato public per essere sempre visibile, static per poter essere chiamato anche senza avere variabili di istanza infatti il \"main\" deve poter essere invocato anche quando ancora non è stato definito l'oggetto che altrimenti dovrebbe essere stanziato nel corpo di una qualche altra funzione main, che però affinché sia eseguibile dovrebbe essere invocata senza dover a sua volta istanziare l?oggetto altrimenti si andrebbe avanti all?infinito. Ed infine è definito void perché non restituisce alcun valore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10290,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9808,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9920,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10130,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7092,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1074,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il \"main\" è il primo metodo che la java virtual machine esegue, è obbligatorio definirlo con la sintassi: \"public static void main()\", public indica che il metodo può essere chiamato da qualunque classe del codice, static indica che non appartiene ad uno oggetto specifico, void indica che non ritorna nessun valore, e main è il nome della funzione di inizio programma, non può essere cambiato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9922,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9807,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10128,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10289,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6631,
          "asker": {
            "courseId": 102,
            "askerId": 981,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un framework? Perché possiamo dire che viene utilizzato il metodo publish/subscribe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": " Publish/subscribe"
            },
            {
              "keyword": " Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6642,
          "asker": {
            "courseId": 102,
            "askerId": 882,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa succede quando si usa il modificatore static con una variabile di istanza? e con un metodo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6623,
          "asker": {
            "courseId": 102,
            "askerId": 58,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e come funziona l'Autoboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6689,
          "asker": {
            "courseId": 102,
            "askerId": 1040,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi conviene (o si devono) utilizzare commenti \"JavaDoc\" piuttosto che commenti normali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Javadoc"
            },
            {
              "keyword": " Javadoc"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7200,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1067,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "I commenti normali sono per spiegare il codice, i commenti JavaDoc sono pensati per descrivere funzionalità e principi di pacchetti, classi, interfacce o metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10064,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10341,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10075,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9827,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9773,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7184,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 939,
                "courseId": 102,
                "courseFinalScore": 30
              },
              "answerText": "I commenti \"JavaDoc\" hanno fondamentale importanza poiché permettono di documentare un programma in Java direttamente tramite il file sorgente stesso e non tramite l'uso di file ausiliari. In particolare è quindi altamente consigliato usare questo tipo di commenti nella dichiarazione di:\r\n\r\n- Packages\r\n- Classi\r\n- Interfacce\r\n- Metodi e/o attributi pubblici\r\n\r\nIn questo modo i suddetti commenti possono essere estrapolati dal programma \"javadoc\" e convertiti in un file di consultazione di formato PDF e/o HTML; inoltre tramite l'utilizzo dei vari tags previsti dai commenti Javadoc è possibile organizzare in modo ottimale la documentazione. \r\nE' importante sottolineare che i commenti Javadoc non devono essere usati come commenti a frammenti di codice: in questo caso il programma \"javadoc\" infatti non estrapola e non inserisci i commenti nel file di documentazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9826,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10063,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10074,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9774,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10343,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7119,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 999,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nei casi in cui si vogliono spiegare classi, metodi, costruttori, etc..\r\nL'obiettivo della documentazione javadoc è quello di descrivere le specifiche di una certa API.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9775,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9825,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10073,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10065,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10342,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6619,
          "asker": {
            "courseId": 102,
            "askerId": 1028,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Un metodo statico può agire solo su variabili statiche? E un metodo non statico può comunque operare con variabili statiche?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7086,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 981,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si, un metodo statico può agire solo su variabili statiche.\r\nSi, un metodo non statico può comunque operare con variabili statiche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9888,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10230,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9792,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7197,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1043,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si, tutti i metodi statici e non statici possono operare con variabili statiche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10234,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9885,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9788,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7077,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 947,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si alla prima domanda e no alla seconda. Un metodo non statico può agire sulle variabili di istanza mentre uno statico su queste ultime non può agire, potendo accedere solo alle variabili di tipo statico. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9887,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10233,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9789,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7100,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 996,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "No e si",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10231,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9791,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9889,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7111,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1031,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un metodo statico è un metodo associato alla classe stessa e non ad un singolo oggetto di essa. Di conseguenza un metodo statico può agire solo su variabili statiche che, anch'esse come per i metodi, sono associate alla classe.\r\nAl contrario, però, un metodo non statico può operare con variabili statiche, dato che esse son condivise tra tutti gli oggetti di quella classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9884,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10229,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9787,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7138,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 944,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Un metodo dichiarato static può essere invocato nonostante la classe considerata non sia stata ancora istanziata: di conseguenza non è in grado di agire su variabili di istanza (cioè non statiche), che sono allocate al momento della creazione di un oggetto, ma solamente su variabili statiche, a loro volta accessibili senza dover sfruttare alcuna istanza della classe. Le variabili statiche, inoltre, sono condivise fra le varie istanze della classe data, dunque qualunque metodo non statico vi potrà accedere tranquillamente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9886,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10232,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9790,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6717,
          "asker": {
            "courseId": 102,
            "askerId": 941,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste la \"Wildcard  instantiation\" ?\r\nEsempio delle slide:\r\n\r\npublic void printPair( Pair<?,?> pair) {\r\n  System.out.println(\"(\"+pair.getFirst()+\",?+pair.getSecond()+\")\");\r\n} \r\n\r\nPair<?,?> limit =  new Pair<String,Long> (\"maximum\",1024L); printPair(limit);   ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7130,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1013,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "La \"wildcard instantiation\" viene usata per creare una sorta di relazione tra classi Generic. Si può pensare come un fenomeno molto vicino al polimorfismo. Si ha spesso a che fare con essa quando si vogliono passare come parametri di un metodo oggetti di classi Generic. Ad esempio, il metodo descritto sopra funziona con oggetti Pair<String, Integer> ecc..., cioè funziona correttamente con qualsiasi oggetto Pair, indipendentemente dai tipi dichiarati all'interno delle parentesi angolari. Si parla quindi di \"Unbounded Wildcard\"\r\nSupponiamo ora di voler scrivere un metodo che lavori con un oggetto Pair dove il primo tipo deve essere una String o una classe figlia. Allora la dichiarazione del metodo sarà:\r\npublic void printPair(Pair<? extends String, ?>) { ...... }\r\nIn questo caso, parleremo di \"Upper Bounded Wildcard\". Al contrario:\r\npublic void printPair(Pair<? super String, ?>) { ...... }\r\nrichiede che il primo tipo sia una String o una super classe di String -> \"Lower Bounded Wildcard\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9907,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10035,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9882,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10338,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9927,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7122,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Utilizzare la Wildcard Instantiation significa settare il tipo della Generics ad un 'Unknown' rappresentato da '?'.\r\n'Unknown' rappresenta un tipo non definito.\r\n\r\nNell'esempio delle slide viene istanziata una variabile limit di tipo Pair, e il metodo 'printPair()' accetta un oggetto di tipo Pair in cui i due Generics non sono definiti. \r\nPer poter dire che Pair può contenere qualsiasi cosa si usa la Wildcard Instantiation. Nell'esempio i due parametri di limit vengono definiti di tipo String e Long, solo quando l'oggetto di tipo Pair viene istanziato.\r\n\r\nUtilizzare Object invece della Wildcard Instantiation non avrebbe lo stesso effetto, poiché non è permesso:\r\n\r\nPair<Object, Object> limit = new Pair<String, Long> (\"maximum\",1024L);",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10340,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10037,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9881,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9908,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9926,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7102,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1035,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo printPair consente di stampare un qualsiasi oggetto di tipo Pair <X,Y> grazie al carattere '?' che è un carattere jolly che in questo caso indica qualsiasi tipo di dato. Dunque potrò stampare oggetti di tipo Pair <String,Long> ma anche oggetti di tipo Pair <String,String>, Pair <Studente, Docente>,Pair < Pera,Mela> etc etc",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9905,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9925,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10036,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9883,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10337,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7145,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 976,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le espressioni contenenti i Wildcard vengono utilizzate quando non è conosciuto a priori il tipo di dato che si andrà ad implementare oppure non si vuole definire il dato. Sono molto utilizzate nelle classi Generic per permettere al programmatore di implementare facilmente diverse strutture dati senza la necessità di riscrivere il codice per ogni singola classe che si decide di implementare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10034,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9924,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9906,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10339,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9880,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6658,
          "asker": {
            "courseId": 102,
            "askerId": 1014,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve il modificatore static applicato ad un attributo o ad un metodo di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6678,
          "asker": {
            "courseId": 102,
            "askerId": 988,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè il main è solitamente dichiarato static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STATIC"
            },
            {
              "keyword": " STATIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6646,
          "asker": {
            "courseId": 102,
            "askerId": 1053,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Come agisce il modificatore static sulle variabili e sui metodi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STATIC"
            },
            {
              "keyword": " STATIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6650,
          "asker": {
            "courseId": 102,
            "askerId": 995,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo un metodo di una classe definito static, puo' agire su variabili che siano solamente definite static? Perche', per esempio non puo' accedere a una variabile \"normale\", della classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "STATIC"
            },
            {
              "keyword": "STATIC"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7181,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 991,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Perché sarebbe un'enorme fonte di errori, infatti i metodi static possono essere usati anche se non é ancora stata istanziata la classe (e quindi non sono ancora state allocate le variabili di istanza di tale classe) come, ad esempio, succede nel caso del main. Se fosse possibile manipolare anche le variabili normali si potrebbe incappare in situazioni di errore cone nel caso di variabili non ancora allocate o di non saper su quale variabile operare nel caso di istanze multiple dello stesso oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10335,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10366,
                  "rater": {
                    "raterId": 959,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10050,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10239,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9915,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10261,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7085,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1080,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In pratica visto che si  è messo lo static come visibilità del metodo, esso è accessibile anche senza instanziare un oggetto della classe(con la sintassi classe.metodo). Quindi esso deve lavorare su variabili che non siano delle istanze della classe ma delle variabili visibili in ogni momento(che si possono ottenere mettendo lo static alle variabili nella definizione della classe).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10049,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9916,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10264,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10367,
                  "rater": {
                    "raterId": 959,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10236,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10336,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7087,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1040,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Perché una classe static non può essere istanziata quindi non possiede queste variabili \"normali\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10260,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10051,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10237,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9917,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10364,
                  "rater": {
                    "raterId": 959,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10332,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7175,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1002,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché a differenza delle variabili \"normali\" i metodi static sono associati alla classi, e non ad una sua istanza. Questo significa che ogni volta che viene istanziata una classe un metodo viene associata una \"copia\" dei metodi non static, cosa che non avviene invece per quelli static. Cioè vuol dire che è comune a tutte le istanze, stessa cosa per le variabili static. Per questo motivo possono interagire solo tra di loro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10365,
                  "rater": {
                    "raterId": 959,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9918,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10263,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10048,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10333,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10235,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7174,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 956,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Perchè definendo una variabile a \"static\" avremo come risultato il definire una variabile globale accessibile quindi da tutta la classe. Le altre variabili invece saranno visibili solo nel blocco in cui sono state dichiarate ed utilizzate, quindi un metodo di tipo static non ci potrà accedere.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10262,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10238,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9919,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10047,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10334,
                  "rater": {
                    "raterId": 1086,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10368,
                  "rater": {
                    "raterId": 959,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6675,
          "asker": {
            "courseId": 102,
            "askerId": 940,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché il main di una classe Java è un metodo statico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6625,
          "asker": {
            "courseId": 102,
            "askerId": 982,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "cosa sono l'Unboxing e l'Autoboxing in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Autoboxing "
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7096,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 984,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'autoboxing e l'unboxing sono due zuccherini sintattici che permettono un codice più leggero e leggibile. Permettono associzione con conversione diretta tra tipi primitivi e le loro classi.\r\nes. autoboxing: Integer x = 5;\r\nes. unboxing: int x = 5; Integer y = x;",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10210,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9974,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7126,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1049,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le operazioni di Unboxing e Autoboxing sono operazioni di Boxing in Java il cui utilizzo permette una scrittura più veloce e corretta per il programmatore. Le due operazioni sono una l'inversa dell'altra e svolgono l'incapsulamento dell'oggetto dichiarato automaticamente senza il comando del programmatore. Ad esempio, dichiarando una variabile \"int x = 5\", Java creerà automaticamente, grazie all'autoboxing, un oggetto di tipo intero(Integer) \"x\"col valore 5 dandogli uno spazio in memoria salvandone l'indirizzo. L'unboxing farà il contrario, prenderà un oggetto integer e ne creerà il corrispettivo int. Questa operazione automatica velocizza il lavoro del programmatore, evitandogli anche fastidiosi errori di distrazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9972,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10214,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7112,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'Autoboxing non è altro che un cast automatico con cui il compilatore Java trasforma i tipi di dato primitivi nelle corrispettive classi di oggetti, come ad esempio, convertire un 'int' in un 'Integer'.\r\nSe la conversione avviene nel modo inverso, allora si chiama Unboxing.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10212,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9973,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7114,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 998,
                "courseId": 102,
                "courseFinalScore": 11
              },
              "answerText": "L' Autoboxing è una sorta di conversione automatica da un tipo primitivo alla sua classe corrispondente (ad esempio può essere effettuata una conversione da int a Integer). L' Unboxing è invece la stessa conversione sono che va nel verso opposto (ad esempio da Integer a int).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9975,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10213,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7143,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1019,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L' Unboxing è una caratteristica del java per la quale noi possiamo utilizzare tipi primitivi e i rispettivi wrapper senza preoccuparci di errori perchè il compilatore di bytecode di java si preoccuperà autonomamente ( attua l'autoboxing ) di gestire questi cambiamenti di dato, cioè se trattarli come tipi primitivi o come oggetti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10211,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9971,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6639,
          "asker": {
            "courseId": 102,
            "askerId": 1099,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa mi permette di fare una variabile di tipo generic?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Use"
            },
            {
              "keyword": " generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6680,
          "asker": {
            "courseId": 102,
            "askerId": 527,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per publish and subscribe quando riferito ad uno o più metodi di una classe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Publish/subscribe"
            },
            {
              "keyword": " Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6716,
          "asker": {
            "courseId": 102,
            "askerId": 971,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi si utilizzano le variabili \"static\" e per cosa si differenziano da quelle normali?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6641,
          "asker": {
            "courseId": 102,
            "askerId": 975,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo non è possibile creare un vettore con il tipo del generic come indica l'esempio sottostante? Ma bisogna fare il cast da un vettore di object?\r\n\r\nClasse <T> MyClass{\r\n    public void metodo(){\r\n         T array1[] = new T[3];   //errore \r\n         T array2[] = (T[]) (new Object[3]);\r\n    }\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Generics"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7182,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1052,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Perché il vettore è un primitivo, non una classe",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9833,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10161,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9836,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10033,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9904,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9976,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7084,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 941,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "In Java non è possibile creare un array in questa maniera \"T array1[] = new T[3];\" perché non si conosce il tipo T finché non si esegue questa funzione.\r\nL'errore viene generato durante la compilazione apposta per evitare problemi a runtime.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9832,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10162,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9835,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9903,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10031,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9977,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7190,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1096,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quest'operazione non è acconsentita perchè sì le generics permettono di trattare qualcunque tipo di dato, ma non è detto che si conosca la dimensione di T nel momento di allocazione dell'array quindi lo si crea di Object (che sicuramente conterrà T) e poi si effettua un casting all'oggetto di T.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9978,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9838,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9902,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9834,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10032,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10163,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7134,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 980,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché la creazione di array con i generics non è consentita da java, anzi è proprio il principale svantaggio che si ha nell'utilizzo dei generics.\r\nBisognerà quindi castare l'array (come fatto nella domanda), oppure utilizzare le collections per ovviare a questo problema.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9831,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10030,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10160,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9837,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9901,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9979,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6694,
          "asker": {
            "courseId": 102,
            "askerId": 977,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "in cosa consiste il javadoc?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javadoc"
            },
            {
              "keyword": " javadoc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6708,
          "asker": {
            "courseId": 102,
            "askerId": 979,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo l'utilizzo di generics (tipi generici) aumenta l'efficienza di un programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generics"
            },
            {
              "keyword": " autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6696,
          "asker": {
            "courseId": 102,
            "askerId": 1098,
            "courseFinalScore": 14
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché è utile Javadoc?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javadoc"
            },
            {
              "keyword": " Javadoc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6630,
          "asker": {
            "courseId": 102,
            "askerId": 535,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il vantaggio dell'uso dei generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6661,
          "asker": {
            "courseId": 102,
            "askerId": 1075,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è un tipo generico e quando può essere utilizzato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7180,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 943,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un tipo generico o Generics è uno strumento che ci permette di definire un tipo parametrizzato il cui tipo vero e proprio viene esplicitato a tempo di compilazione in base alle necessità. Un tipo generico si definisce mettendo i tipi che può assumere, separati dalle virgole e tra le parentesi \"<\" e \">\" dopo il nome. Ha due principali vantaggi: non richiede il cast e permette il fail quick (fallimento veloce, che rende molto più efficiente il codice). Può essere utilizzato praticamente sempre, tranne in un paio di casi: quando devo creare un array e quando istanziamo un espressione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9970,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10021,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10227,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10253,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7163,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1018,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Quando invochiamo un metodo che richiede degli argomenti, siamo soliti passarli all'interno di parentesi tonde. Nei tipi generici, invece, piuttosto che passare argomenti ai metodi, passeremo (scrivendoli all'interno di < e >) i tipi di dato che il metodo elaborerà in quella sua precisa invocazione.\r\n\r\nQuando andremo a scrivere una classe, nella sua definizione potremo essere \"generici\" riguardo i tipi dei dati elaborati (senza dunque specificare se una certa variabile sarà integer, string etc) ma l'utente dovrà specificare, durante l'instanziamento di un oggetto o invocazione di un metodo, che tipo vorrebbe che i dati definiti come generici assumino per quella precisa instanza o invocazione.\r\n\r\nUn esempio di quanto detto lo troviamo definendo questa classe su un tipo generico:\r\n\r\npublic class ListaArray<E> implements List<E> ... {...}\r\n\r\ne al momento dell'instanziamento di un oggetto si specificherà un tipo come:\r\n\r\nListaArray<Integer> lista = new ListaArray<Integer>();",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10019,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9968,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10226,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10251,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7098,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 972,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "È un tipo che viene definito in fase di compilazione, viene usato per una maggiore flessibilità ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10252,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10020,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10228,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9969,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6682,
          "asker": {
            "courseId": 102,
            "askerId": 1046,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'uso dei Generics e dove non possono essere usati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6613,
          "asker": {
            "courseId": 102,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il modificatore \"static\" e che effetto ha associato rispettivamente a variabili e metodi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6622,
          "asker": {
            "courseId": 102,
            "askerId": 1031,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Riassumi il paradigma publish & subscribe fornendo un esempio di una situazione reale in cui sarebbe preferibile utilizzarlo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Publish/subscribe"
            },
            {
              "keyword": " Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6660,
          "asker": {
            "courseId": 102,
            "askerId": 911,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè si dovrebbe utilizzare una classe \"generics\" a differenza di una classe normale?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7158,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "I vantaggi dell'uso dei generics sono:\r\n- un migliore controllo sui tipi di dato\r\n- più flessibilità nel codice, in quanto vengono eliminati i cast\r\n- una conseguente riduzione del codice\r\n- la possibilità di scrivere degli algoritmi generici, non limitati ad un determinato tipo di dato",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10257,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9910,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10005,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7095,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 964,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Per avere una classe \"astratta\" sui tipi di dati, dove è possibile a tempo di compilazione esplicitare il tipo dei parametrici generici dichiarati nella classe.\r\nNon si è più cosi vincolati al tipo di dato dichiarato nella classe normale.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10008,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9913,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10255,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7178,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 958,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè una classe \"generics\" permette di non utilizzare i cast e perchè da la possibilità al programmatore di creare metodi generics.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9912,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10258,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10006,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7094,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1026,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe Generics assolve la necessità del programmatore di avere uno stesso oggetto definito da parametri con tipi differenti.\r\nPer esempio potremmo volere una classe cubo il cui unico parametro è il lato, in alcuni casi potremmo volere che il parametro lato possa essere rappresentato sia come Integer, sia come Double e magari anche come String.\r\n\r\npublic class Cubo<T> {\r\n\r\n  private T lato;\r\n\r\n  public void add(T lato) {\r\n    this.lato = lato;\r\n  }\r\n\r\n  public T get() {\r\n    return lato;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n     Cubo<Integer> integerCubo = new Cubo<Integer>();\r\n     Cubo<Double> doubleCubo = new Cubo<Double>();\r\n     Cubo<String> stringCubo = new Cubo<String>();\r\n    \r\n     integerCubo.add(new Integer(10));\r\n     doubleCubo.add(new Double(2.0));\r\n     stringCubo.add(new String(\"5,0\"));\r\n  }\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10254,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10009,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9914,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7107,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1079,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'utilizzo di una classe generics permette un più forte type checking già in fase di compilazione, facilitando il debugging. Inoltre l'uso delle generics fa si che non si rendano più necessari i cast espliciti. Infine  un altro vantaggio che si ha nell'utilizzare una classe generics sta nel fatto che viene resa possibile l'implementazione di algoritmi generici che funzionano su collezioni di tipo diverso. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10256,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10004,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9909,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7203,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 58,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con l'utilizzo di una classe \"generics\" si elimina la necessità del cast esplicito e si ha un type check più rigoroso a compile time. Inoltre l'uso di generics permette una migliore riusabilità del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10007,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10259,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9911,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6667,
          "asker": {
            "courseId": 102,
            "askerId": 998,
            "courseFinalScore": 11
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In che cosa consiste il vantaggio nell' uso di Generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6705,
          "asker": {
            "courseId": 102,
            "askerId": 991,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè a pagina 4 della slide \"11Tombola.ppt.pdf\" invocando il garbage collector si invoca implicitamente anche il metodo finalize() della classe S?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Garbage Collector"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6670,
          "asker": {
            "courseId": 102,
            "askerId": 953,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve mettere \"static\" con visibilità \"public\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " public"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6632,
          "asker": {
            "courseId": 102,
            "askerId": 997,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e a cosa servono le variabili static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STATIC"
            },
            {
              "keyword": "STATIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6634,
          "asker": {
            "courseId": 102,
            "askerId": 1070,
            "courseFinalScore": 10
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "E' necessario che una class abbia un metodo main e che questo sia dichiarato static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "main"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7079,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 954,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Non è necessario ma se c'è dev'essere dichiarato static",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9856,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10071,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7131,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1082,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, una class non è necessario che abbia un metodo main",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9855,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10070,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7120,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1005,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si è necessario. Ogni classe può contenere uno o più metodi main con diversi parametri, cioè con firme diverse. Verrà eseguito quello di cui specifico l?esecuzione. Nel caso di overloading del metodo main verrà eseguito quello che ha come parametro un array di stringhe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10069,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9858,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7186,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 987,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "é necessario che abbia un metodo main ma non necessariamente deve essere dichiarato static",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10072,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9857,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6704,
          "asker": {
            "courseId": 102,
            "askerId": 1094,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche delle variabili e dei metodi definiti come \"static\"? Perchè il main è static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6700,
          "asker": {
            "courseId": 102,
            "askerId": 1096,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi portano le generic?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6709,
          "asker": {
            "courseId": 102,
            "askerId": 1000,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per generic?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " generic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7198,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1101,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Generic in Java è un tipo di classe che possiede dei parametri di tipo specifico.\r\n\r\nSi scrive nella formula generica di \"class A<X,Y,..>\".\r\n\r\nMi serve a definire famiglie di classi parametriche con caratteristiche particolari permettendomi di decidere da quali tipi sarà formata la mia classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10175,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10302,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10284,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10054,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10138,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7161,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1042,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "In Java per generic si intende uno strumento che permette la definizione di un tipo parametrizzato, che viene esplicitato in fase di compilazione. Il parametro deve essere inserito fra parentesi angolari (es. Collection<NomeParametro> c;). I generics vengono spesso utilizzati con liste o collezioni di dati, ma possono essere definiti in ogni classe. Il vantaggio dell'utilizzo dei generics nelle collezioni di dati è quello di costruire collezioni \"Type-Safe\", nelle quali potranno essere inseriti solo oggetti del tipo specificato dal parametro. Ciò permette di evitare in fase di lettura il casting dalla classe Object al tipo desiderato, in quanto nella collezione saranno contenuti solo oggetti del tipo parametrizzato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10141,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10287,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10179,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10055,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10301,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7104,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un elemento di tipo generic è un elemento che può avere uno o più parametri in modo da controllare a priori il tipo di una classe/collection per evitare di avere un fail più avanti nel programma (fail quick). Un altro vantaggio di usare generic su un metodo è il non uso di cast.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10056,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10177,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10285,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10137,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10304,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7099,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1020,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "con generic si intende un particolare tipo di dato che, questo operatore può essere attribuito sia alle classi che alle interfacce.\r\npermette di riutilizzare lo stesso codice per tipi di dati differenti, viene introdotto nell'intestazione della classe un nuovo tipo di parametro, per esempio: \r\n\r\npublic class scatola<oggetto>{  //questo codice aggiunge il tipo di dato oggetto\r\n\r\nquesto nuovo tipo di dato può assumere tutti i tipi non primitivi di dati.\r\nla stessa cosa può essere fatta per le interfacce.\r\nvi sono alcune convenzioni sul nome del tipo, esempio: N per i numeri, E per gli elementi ecc.\r\nper creare un'istanza di una classe che utilizza attributi generici bisogna procedere nel seguente modo:\r\n\r\nscatola<Integer> integerscatola = new scatola<Integer>();\r\n\r\nun'invocazione di un tipo generico viene generalmente definita come una parametrizzazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10052,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10288,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10176,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10303,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10139,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7141,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1032,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un generic è uno strumento che permette la definizione di un tipo parametrizzato, che viene esplicitato in fase di compilazione secondo le necessità. Ad esempio le Collections di default considerano gli Object, per avere una Collection di strighe possiamo utilizzare i generics che mi permettono di evitare il casting da Object. Un altro grande vantaggio dell'utilizzo dei generics è quello del fail quick, del  fornire quindi, una migliore gestione del type checking durante la compilazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10178,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10300,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10053,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10140,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10286,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6711,
          "asker": {
            "courseId": 102,
            "askerId": 974,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il modificatore static? Che differenza c'è tra l'applicazione dello static su un metodo o su una variabile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6714,
          "asker": {
            "courseId": 102,
            "askerId": 1081,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "La creazione di un'istanza è strettamente necessaria per l'utilizzo di un metodo \"static\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6712,
          "asker": {
            "courseId": 102,
            "askerId": 1047,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve l'utilizzo di generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6617,
          "asker": {
            "courseId": 102,
            "askerId": 986,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il tipo generic? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": "  Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6707,
          "asker": {
            "courseId": 102,
            "askerId": 1008,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi dell'uso dei Generics in una qualsiasi collezione di elementi implementata in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": "Generic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7157,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1014,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "I generics permettono la definizione di un tipo parametrizzato che verrà esplicato, in fase di compilazione, secondo le necessità. Prendiamo come esempio questo metodo e analizziamo i vantaggi:\r\nvoid stampaLunghezze(List<String> list){\r\nfor (Iterator<String> iter = list.iterator(); iter.hasNext(); ){\r\n    String tmp = iter.next();\r\n    System.out.println(tmp + \" : \" + tmp.length());\r\n  }\r\n}\r\n\r\n- un miglior controllo sul tipo(fail quick): questo metodo accetta come parametro solo liste di stringhe; se io tento di passargli una lista di interi il programma non viene compilato perchè il compilatore rileva l'incopatibilità fra List<String> e List<int>\r\n- non è più necessario il cast: infatti se avessi usato una lista generica, per ricavare la lunghezza della stringa avrei dovuto fare un cast da object e poi avrei potuto richiamare il metodo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9823,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10362,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10093,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10273,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7144,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1103,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Permette di cogliere errori dovuti all uso di tipi sbagliati in fase di compilazione. Non sei piu obbligato a fare cast espliciti. Puoi scrivere algoritmi che vadano bene con collezioni di qualsiasi tipo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10095,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10272,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10363,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9824,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7089,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 979,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'uso di Generics permette di ottenere errori che riguardano il tipo degli oggetti già a tempo di compilazione piuttosto che a tempo di esecuzione. Inoltre elimina la necessità di effettuare casting dalla classe Object.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10361,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10271,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10094,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9822,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6710,
          "asker": {
            "courseId": 102,
            "askerId": 1005,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa servono i Generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GENERICS"
            },
            {
              "keyword": " GENERICS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6620,
          "asker": {
            "courseId": 102,
            "askerId": 970,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'Autoboxing / Autounboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6687,
          "asker": {
            "courseId": 102,
            "askerId": 1083,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il meccanismo di autoboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": "Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6645,
          "asker": {
            "courseId": 102,
            "askerId": 1025,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene modificata la relazione tra Tombola, Banco, Giocatore e Cartella se introduciamo il paradigma \"publish and subscribe\" ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Publish/subscribe"
            },
            {
              "keyword": " Publish/subscribe "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6652,
          "asker": {
            "courseId": 102,
            "askerId": 1052,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Usando metodi static di un oggetto istanziato si applicano modifiche che possono estendersi solo all'interno di quell'oggetto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7129,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 940,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Anche se poco 'ortodosso', un metodo static (che per definizione viene chiamato direttamente sulla classe, ovvero in assenza di una istanza) può essere chiamato direttamente su una istanza. Tuttavia esso non potrà modificare in alcun modo membri dell'instanza, dal momento che un metodo statico può agire solamente all'interno del proprio scope statico, il quale non ha accesso, per così dire, alle variabili di istanza.\r\nNell'esempio qui proposto: http://pastebin.com/exXpNT8P, la chiamata al metodo statico \"staticFunction()\" sull'oggetto (istanza), funziona. Tuttavia, se togliessimo il commento dalla seconda istruzione nel corpo di \"staticFunction()\", non compilerebbe nemmeno, in quanto stiamo cercando di modificare una variabile non statica da un metodo statico.\r\n\r\nTL;DR: E' possibile (anche se sconsigliato) chiamare metodi static da una istanza della classe. Tuttavia un metodo statico non potrà mai accedere a/modificare variabili di istanza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9772,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9931,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10124,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10091,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7109,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 948,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "Posto che i metodi static possono modificare solo le variabili static o le variabili dichiarate all'interno di quel metodo, le modifiche fatte all'interno di quel metodo si estendono non solo all'interno di quell'oggetto, ma all'interno di tutte le istanze della classe da cui quell'oggetto deriva, poiché le variabili modificate se sono static sono variabili di classe, ovvero comuni a tutte le istanze di una determinata classe, se sono invece variabili dichiarate all'interno di quel metodo non influenzano ciò che sta fuori a quel metodo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9770,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10127,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10092,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9930,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7083,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 946,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si, perchè si.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10126,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9929,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10090,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9771,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7076,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1073,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I metodi static non sono associati ad un'istanza ma solo ad una classe",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9769,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9928,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10125,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10089,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6640,
          "asker": {
            "courseId": 102,
            "askerId": 1017,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Definire il significato di Static",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STATIC"
            },
            {
              "keyword": " STATIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6611,
          "asker": {
            "courseId": 102,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è e a cosa serve Javadoc?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "javadoc"
            },
            {
              "keyword": " javadoc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6703,
          "asker": {
            "courseId": 102,
            "askerId": 942,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono variabili e metodi statici in java? Presentare degli esempi pratici e illustrarne i possibili utilizzi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "static"
            },
            {
              "keyword": "static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6662,
          "asker": {
            "courseId": 102,
            "askerId": 984,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i tags da includere nel Javadoc?\r\nCosa succede se si scrivono due differenti @author nella stessa descrizione?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Javadoc"
            },
            {
              "keyword": " Javadoc"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7082,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In javadoc bisogna commentare tutto ciò che è possibile, in modo da rendere leggibile il codice al lettore. Una documentazione minima ai package, classe ed interfacce ciascun metodo e attributo pubblico. Icoomenti vengonoposti prima della stesura del codice e descrivere in modo sintetico lo scopo di quel pezzo di codice.\r\nOrdine tag: tag classi, tag metodi.\r\n- @ author <autore> : nome di chi ha scritto il programma, se ci sono più autori si metro o più tag su righe separate, appare solo se javadoc viene compilato con l'azione -author.\r\n\r\n- @version: versione del codice, viene visulazziato solo se javadoc viene compilato con l'azione -version.Il comando javadoc può produrre la documentazione in diversi formati, ciascuno dei quali può richiedere dei file di istruzione speciali, formato standard è html.\r\nTag metodi sono:@param descrizione parametro se più di uno rispettare l'ordine in cui sono dichiarati.@return descrizione di ciò che è tornato dal metodo. @exception lancio dell'eccezione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9997,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10096,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10012,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10293,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7118,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 985,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I tag che sono fondamentali (per convenzione) sono @param e @return (solo se il metodo non è un void). Il tag @author (che non è di importanza critica) può essere presente molteplicemente senza problemi. In questo modo più programmatori possono lavorare insieme.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9998,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10295,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10011,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10098,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7090,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 949,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "I principali tag di Javadoc sono:\r\n@author Descrive l'autore della classe/interfaccia/metodo\r\n@version Indica la versione della class/interfaccia\t\r\n@since Indica da quale versione è disponibile la classe/metodo/interfaccia\t\r\n@see Indica un link a altra documentazione\t\r\n@param Specifica l'uso di un parametro per i metodi \t\r\n@return Specifica cosa ritorna un metodo\r\n@exception/@throws Specifica che eccezione solleva un metodo e perchè\r\n@deprecated Spefica le motivazioni e da quale versione un metodo/classe/interfaccia è considerata obsoleta e cosa utilizzare al suo posto\r\n@inheritDoc per i metodi con Override, eredita la documentazione dal metodo padre\r\n@value NOME Indica il valore e l'uso di una costante statica\r\n\r\nSe si mettono 2 @author verranno considerati entrambi, nell'ordine in cui sono scritti. Il tag @author non è obbligatorio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10294,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9996,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10010,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10097,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6676,
          "asker": {
            "courseId": 102,
            "askerId": 1030,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di utilizzare collection di tipo parametrizzato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7071,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 955,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si tengono separate dagli oggetti le caratteristiche comuni come variabili o funzioni. Esempio nella collection università, le caratteristiche comuni possono essere nome, cognome e anno di nascita",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10147,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9818,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10080,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7115,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1066,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I vantaggi di usare generics in collection è quello di non dover ricorrere a cast in quanto i dati sono tipizzati e l'individuazione veloce di errori di compatibilità tra tipi prima che si propaghino.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10149,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10079,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9817,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7202,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1085,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I vantaggi di utilizzare collection di tipo parametrizzato consistono nel scrivere un codice più robusto",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9816,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10148,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10081,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6701,
          "asker": {
            "courseId": 102,
            "askerId": 993,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'uso di Generics in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6651,
          "asker": {
            "courseId": 102,
            "askerId": 1018,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile eseguire un cast su un tipo generic? Se si, ci sono delle restrizioni entro il quale è possibile farlo? Se no, perchè non è possibile effettuare il cast?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GENERIC"
            },
            {
              "keyword": " GENERIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6648,
          "asker": {
            "courseId": 102,
            "askerId": 952,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'autoboxing ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6618,
          "asker": {
            "courseId": 102,
            "askerId": 1032,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale circostanza vengono usati i generics e quali sono i vantaggi del loro utilizzo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " generic "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6691,
          "asker": {
            "courseId": 102,
            "askerId": 1002,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è Javadoc? E quali sono i suoi utilizzi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javadoc"
            },
            {
              "keyword": "Javadoc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6665,
          "asker": {
            "courseId": 102,
            "askerId": 963,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile implementare due metodi nella stessa classe che differiscono solo del modificatore static? Si o no? Perchè?\r\n\r\nes:\r\npublic void met1(int a){ ... }\r\npublic static void met1(int a){ ... }",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": "Static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7152,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1034,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Non è possibile in quanto la firma risulta uguale. La firma di un metodo è formata da il nome dello stesso ed i parametri in input.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9821,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9829,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10039,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9965,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9794,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10083,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7127,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1028,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "No, non è possibile definire due metodi aventi la stessa firma. La firma di un metodo, infatti, è composta dal nome che lo identifica e dal numero e tipo di parametri. Il modificatore \"static\" quindi non rientra nella firma e questo implica una presenza di errore, nel caso si definiscono i due metodi in questione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9820,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10082,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9793,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9967,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10038,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9828,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7097,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 982,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "No, perché i modificatori non influenzano la firma, quindi le due funzioni vengono riconosciute come la stessa funzione ed è causa di errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9795,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9830,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9819,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10084,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9966,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10040,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6659,
          "asker": {
            "courseId": 102,
            "askerId": 1036,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilità di aver introdotto le Generics nel linguaggio Java? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6628,
          "asker": {
            "courseId": 102,
            "askerId": 1091,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per Generics e perché sono molto utilizzati in Java? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7108,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Un Generic è uno strumento che permette la definizione di un tipo parametrizzato, che verrà esplicitato in fase di compilazione a seconda delle necessità. Il suo utilizzo permette una migliore gestione del type checking a compile time e l'eliminazione di cast: a ciò segue che, in caso di errore, questo verrà segnalato subito e dunque sarà più facilmente rintracciabile e correggibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9991,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10246,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10123,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10002,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10145,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7123,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1094,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un generic è uno strumento che permette di definire un tipo parametrizzato che non è conosciuto a priori, ma verrà esplicitato in fase di compilazione. I generics sono molto utilizzati in quanto forniscono una migliore gestione del type checking durante la compilazione e permettono di evitare il casting da Object",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10119,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10249,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9992,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10142,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10001,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7192,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 986,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Generics è un costrutto che permette di creare collezioni e classi senza definire a priori con quale tipo di variabile si lavorerà, dunque consentendo di utilizzare una sola classe/collezione per tutti i tipi di variabili. Inoltre, il tipo che specializzerà la collezione o la classe viene definito nella dichiarazione. Per esempio, Collection <String> c, è una collezione di stringhe, in questo modo si è sicuri che la collezione contiene solo elementi di tipo String.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9999,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10247,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9995,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10120,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10144,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7080,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1054,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per generics intendiamo la possibilità di dichiarare metodi \"generici\" che viene esplicitato secondo le necessità in fase di compilazione. Viene principalmente utilizzato per evitare il casting da Object, esempio lampante è nella dichiarazione delle liste.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9993,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10143,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10000,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10122,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10248,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7189,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1021,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Un tipo Generics definisce una famiglia di classi. Per poter utilizzare una classe Generics dobbiamo specificare il tipo di dato che verrà inserito in essa. Ciò oltre a rendere più chiaro il codice permette anche di prevenire errori dovuti da inserimenti di elementi non compatibili con il tipo di dato con cui vogliamo operare.\r\nPrendiamo per esempio il caso in cui vogliamo utilizzare una Collection assumendo implicitamente (quindi non scrivendo nel codice) di operare su interi e inseriamo erroneamente una stringa. In questo caso l'errore viene trovato solo nel momento dell'esecuzione (cioè quando cerchiamo di operare con la stringa) portando a situazioni di confusione mentre invece specificando di utilizzare una Collection di interi è il compilatore stesso a segnalare il problema e consentire una individuazione più precisa dell'errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10121,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10003,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10146,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10250,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9994,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6692,
          "asker": {
            "courseId": 102,
            "askerId": 946,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi mi comporta l'utilizzo del costrutto \"Generics\" e come posso usarlo per gestire array?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": "Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6633,
          "asker": {
            "courseId": 102,
            "askerId": 972,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il tipo generics? Quando si usa? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Generics "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6657,
          "asker": {
            "courseId": 102,
            "askerId": 1013,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando è bene dichiarare metodi o attributi statici all'interno di una classe?\r\nPerchè è buona norma utilizzare il seguente scheletro per le applicazioni:\r\nclass Applicazione{\r\n    public static void main (String args[]) {\r\n        Applicazione p= new Applicazione();\r\n    }\r\n    Applicazione() {\r\n        ........\r\n    }\r\n}\r\n\r\nanzichè il seguente:\r\nclass Applicazione{\r\n    public static void main (String args[]) {\r\n        ........................\r\n    }\r\n}\r\n\r\n?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6616,
          "asker": {
            "courseId": 102,
            "askerId": 990,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Nelle librerie standard Java si trovano spesso classi come Math che non e' possibile istanziare e che contengono unicamente metodi statici e costanti statiche.\r\nQuale e' il ruolo di tali classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7105,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 978,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Queste librerie contengono tanti metodi utili studiati per poter essere usati in qualsiasi situazione. Questo è utile perchè questa librerie possono essere implementate in qualsiasi programma con minimo sforzo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10109,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9875,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10166,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10350,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9869,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10198,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7075,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 969,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il ruolo è di fornire utilità matematiche al programmatore e sono riunite in una classe con metodi statici perchè non c'è bisogno di conservare uno stato interno della classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10348,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9865,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10165,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10195,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10111,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9878,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7201,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 971,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I metodi di questa classe possono essere richiamati senza dover creare un'istanza della classe",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10113,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10199,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9877,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9867,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10168,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10349,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7196,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1058,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'unico ruolo che hanno è solamente di utilità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9879,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10200,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10351,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10164,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9870,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10112,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7136,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1023,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il ruolo di classi come Math è appunto di fornire dei metodi o costanti senza dover istanziare un oggetto di tipo Math ; un esempio può essere la funzione radice quadrata oppure la costante pi greco , le quali possono utilizzate senza dover istanziare oggetti specifici, queste proprietà valgono per tutti i metodi e costanti dichiarati static. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10352,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10169,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9874,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10110,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9868,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10196,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7148,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1065,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Queste classi sono dette classi \"wrapper\": il loro ruolo è quello di fornire dei servizi senza essere in grado di creare istanze. Queste classi vengono utilizzate come supporto durante la creazione del programma fornendo strumenti preconfezionati al programmatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9876,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10108,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10347,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9866,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10167,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10197,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6608,
          "asker": {
            "courseId": 102,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi porta l'utilizzo di Generic?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": "Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6686,
          "asker": {
            "courseId": 102,
            "askerId": 960,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'uso delle Generics e come posso sfruttarli una classe da me definita?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " Generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6629,
          "asker": {
            "courseId": 102,
            "askerId": 1022,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'aspetto Generics in Java? Spiegare quali sono i vantaggi e come lavora in Java.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GENERICS"
            },
            {
              "keyword": " GENERICS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6649,
          "asker": {
            "courseId": 102,
            "askerId": 1065,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è una javadoc, a cosa serve e perchè è importante farne uso?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Javadoc"
            },
            {
              "keyword": " Javadoc"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6677,
          "asker": {
            "courseId": 102,
            "askerId": 1009,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa è il Javadoc e per quale motivo è consigliabile scriverlo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "JAVADOC"
            },
            {
              "keyword": " JAVADOC"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7091,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1029,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Javadoc è un tipo di commento il quale permette la generazione della documentazione relativa a quel codice automaticamente attraverso un determinato programma. Cosí facendo, se quel codice dovrà essere venduto (quindi non si darà la sorgente ma solo i file compilati) il programmatore non dovrà creare anche la documentazione ma potrà generarla automaticamente a partire dai commenti javadoc.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9804,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9812,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10185,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10326,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7135,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1025,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Javadoc è un tool, uno strumento, che permette di generare automaticamente una documentazione del codice sorgente scritto in java. Il Javadoc è molto importante in un progetto, specialmente se quest'ultimo è complesso e molto articolato, in quanto permette una più facile ed immediata comprensione del codice, considerando anche il fatto che esso venga letto da altri sviluppatori. Inoltre la documentazione che viene generata ha un aspetto professionale molto simile a quella ufficiale ed è quindi di facile lettura.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9815,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10330,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10181,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9805,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7160,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1046,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il Javadoc è uno strumento che permette di generare la documentazione di un programma attraverso l'inserimento di tag specifici nel codice stesso, la documentazione in Javadoc produce un insieme di pagine HTML, che contengono la documentazione del codice sorgente.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9814,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9801,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10182,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10327,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7073,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 962,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il Javadoc è uno strumento utilizzato per la generazione automatica della documentazione del codice sorgente ed è consigliato utilizzarlo per fornire all'utente finale delle istruzioni su come usare il programma e le sue funzioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9802,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9810,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10184,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10331,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7146,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 961,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Javadoc è un \"generatore di documentazione\" in grado di produrre documenti html partendo da una sorgente di codice JAVA.\r\nLa generazione non è del tutto automatica poichè gran parte della documentazione prodotta si basa sui commenti (con una sintassi particolare) inseriti dal programmatore che riguardano sopratutto :\r\n- spiegazioni riguardanti l'utilizzo (di classi , funzioni ,...)\r\n- informazioni sul programmatore (nome , ...)\r\n- versione e data modifica del codice ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9800,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10180,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10328,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9813,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 7179,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 974,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il Javadoc è la parte di codice in cui viene descritto cosa fa il codice. In particolare nella prima parte del codice viene scritto l'autore ed è consigliabile descrivere sommariamente le funzionalità del codice, poi ad ogni classe e/o funzione viene descritta la funzionalità del blocco di codice, i paameti da passare in input e il tipo di output che bisogna aspettarsi. Il Javaoc va preceduto da /** e seguito da */, se si segue questa regola è più veloce estrarre i file .txt o .html in caso di necessità.\r\nE' consigliabile scriverlo poichè in caso di rilettura in un secondo momento o da parte di un'altra persona permette di capire più facilmente il codice.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9811,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10183,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10329,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9803,
                  "rater": {
                    "raterId": 947,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6609,
          "asker": {
            "courseId": 102,
            "askerId": 1079,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi è conveniente utilizzare il modificatore static per una variabile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6656,
          "asker": {
            "courseId": 102,
            "askerId": 1034,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché si utilizza la tecnica \"publish & subscribe\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Publish/subscribe"
            },
            {
              "keyword": " Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7172,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 945,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "La tecnica publish and subscribe viene utilizzata perché permette, apportando modifiche \"minime\" al codice, di avere una \"infrastruttura\" molto flessibile infatti un ascoltore può aggiungersi o togliersi in qualsiasi momento, non impone nessun limite riguardante il numero massimo o minimo di ascoltatori e dal punto di vista della realizzazione del codice è ininfluente il numero degli ascoltatori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10203,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10087,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9955,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10029,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10157,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10296,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10318,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7142,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1099,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In questo schema mittenti e destinatari di messaggi dialogano attraverso un tramite, che può essere detto dispatcher o broker. Il mittente di un messaggio (detto publisher) non deve essere consapevole dell'identità dei destinatari (detti subscriber); esso si limita a \"pubblicare\" il proprio messaggio al dispatcher. I destinatari si rivolgono a loro volta al dispatcher \"abbonandosi\" alla ricezione di messaggi. Il dispatcher quindi inoltra ogni messaggio inviato da un publisher a tutti i subscriber interessati a quel messaggio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10317,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10085,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9958,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10202,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10297,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10027,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10159,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7191,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 997,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La tecnica di publish &subscribe è un pattern per implementare un sistema di messaggistica molti-a-molti tra un numero arbitrario di oggetti. ?Molti-a-molti? significa che ciascun oggetto può sia inviare messaggi a, sia ricevere messaggi da, potenzialmente tutti gli altri oggetti. Per raggiungere questo scopo, tutti gli oggetti interessati si rivolgono a un unico oggetto intermediario dei messaggi. L?intermediario mantiene al suo interno un elenco di tutti gli oggetti ?iscritti? al sistema, e riceve i messaggi di ciascuno di loro. Quando l?intermediario riceve un messaggio, lo inoltra a tutti gli oggetti del suo elenco. Se un oggetto vuole partecipare al sistema dei messaggi, si iscrive presso l?intermediario. Tutto ciò che i partecipanti hanno bisogno di conoscere, è l?intermediario.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9956,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10298,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10028,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10204,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10158,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10086,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10320,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7204,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 966,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il meccanismo di \"publish & subscribe\" viene utilizzato per facilitare le comunicazioni tra il mittente (publisher) di un messaggio e i numerosi destinatari (subscribers) del suddetto messaggio. Questa tecnica risulta efficiente in quanto il publisher deve mandare un solo messaggio, che verrà ricevuto contemporaneamente da tutti i subscribers. Inoltre questi ultimi potranno smettere di ricevere i messaggi in qualunque momento, qualora non più interessati al topic discusso.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10201,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9957,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10319,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10088,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10156,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10026,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10299,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6674,
          "asker": {
            "courseId": 102,
            "askerId": 1012,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi che ha portato l'introduzione dei generics a partire da Java 5?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GENERIC"
            },
            {
              "keyword": " GENERIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6637,
          "asker": {
            "courseId": 102,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa le due implementazioni della tombola (versione che ammette più giocatori) si differenziano? Che vantaggi da l'introduzione di un Listener?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6644,
          "asker": {
            "courseId": 102,
            "askerId": 1001,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Si possono inserire due argomenti quando si usano i generics (ad esempio per creare una lista di oggetti di due tipi diversi, e non uno solo)? In caso negativo, è possibile implementare una lista che funzioni in questo modo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6624,
          "asker": {
            "courseId": 102,
            "askerId": 1049,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'Autoboxing in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6653,
          "asker": {
            "courseId": 102,
            "askerId": 969,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra una attributo statico ed un attributo pubblico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "attributo"
            },
            {
              "keyword": "statico"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7101,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 988,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'attributo public permette di accedere alle istanze delle variabili e dei metodi delle classi in qualsiasi caso, ovvero non sono circostanziate al blocco, alla classe, o al pacchetto. \r\nL'attributo static invece permette di creare un'istanza di una variabile o di un metodo, che sia uguale per tutte le istanze della classe. Le variabili, e i metodi, dichiarati static potranno interagire solo con ciò che è stato dichiarato static a sua volta. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9852,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10315,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10106,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9951,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10353,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7194,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 993,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili dichiarate static sono variabili di classe, e non di istanza. Ciò vuol dire che l'utilizzo di static rende condivisa la variabile da ogni istanza della stessa classe. \r\n\r\nPer quanto riguarda i metodi, invece, l'utilizzo dell'attributo static permette di chiamare il metodo sulla classe stessa, ancor prima di crearne una istanza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10104,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10356,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9851,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9953,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10313,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7121,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1055,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una variabile di tipo static è una variabile visibile da tutte le istanze dell'oggetto in cui è presente. Questo tipo di variabile non può cambiare il proprio valore durante l'esecuzione del programma (occupa la memoria e la tiene sempre occupata).\r\nUna variabile dichiarata public invece potrà venire utilizzata in ogni parte del codice in cui sia presente una istanza di questa classe. \r\nLa differenza fondamentale è che static si riferisce al valore che assegnerò alla variabile, il quale sarà sempre uguale, mentre public si riferisce alla visibilità che questa mia variabile avrà all'interno del mio codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9954,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10355,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10107,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9853,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10314,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7155,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un attributo statico è condiviso da tutte le istanze della classe, quindi può essere utilizzato anche senza stanziare la classe. Il suo utilizzo provocherà il caricamento in memoria della classe contenente il membro in questione.\r\nUn attributo pubblico sarà accessibile da una qualsiasi classe situata in qualsiasi package.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9952,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9854,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10105,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10354,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10316,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6715,
          "asker": {
            "courseId": 102,
            "askerId": 956,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è l'autoboxing e a quali vantaggi porta?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "autoboxing"
            },
            {
              "keyword": "autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6654,
          "asker": {
            "courseId": 102,
            "askerId": 1064,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Come mai viene introdotta la metodologia di publish and subscribe nella gestione di un programma con più classi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Publish/subscribe"
            },
            {
              "keyword": "Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6615,
          "asker": {
            "courseId": 102,
            "askerId": 976,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "L'in che modo javadoc è utile al programmatore java e cosa c'è scritto di importante?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Javadoc"
            },
            {
              "keyword": "Javadoc"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7165,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Il javadoc è una funzionalità che serve per creare la documentazione del codice. Questa funzione è estremamente utile al programmatore perchè si autogenera attraverso il commento del codice tramite /** */ e l'utilizzo di alcuni parametri per riferirsi ad esempio agli argomenti delle funzioni o al valore di ritorno. Inoltre si integra in automatico all'IDE, permettendo quindi, durante la scrittura del codice, di avere suggerimenti o spiegazioni sulle 'funzionalità' che si stanno utilizzando.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10268,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9842,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10013,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9983,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10155,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10191,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9777,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7116,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 963,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Il Javadoc è un applicativo incluso nel JDK che permette la generazione automatica della documentazione del codice sorgente scritto in Java. Attraverso la corretta implementazione dei commenti, il programmatore può generare automaticamente la documentazione in formato html che descrive il funzionamento di ogni oggetto, variabile e metodo presente. Il Javadoc è gestito gerarchicamente in package, per ogni classe all'interno di esso è presente una descrizione generale, la lista dei costruttori, delle variabili e dei metodi presenti. Ognuno metodo è a sua volta illustrato nel dettaglio con relativa descrizione dei parametri, variabili di ritorno e descrizione sommaria.\r\nUn programmatore che utilizza librerie o framework altrui, attraverso il Javadoc riesce ad interpretarne la logica ed il funzionamento, oltre che a trovare i metodi che soddisfano le sue esigenze.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9844,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10153,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9984,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10190,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9780,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10015,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10270,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 7183,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1078,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Javadoc è uno strumento per generare documentazione per il proprio progetto. É utile documentare il proprio codice in modo da renderlo più leggibile e capibile",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9778,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10014,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10152,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9840,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9980,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10269,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10188,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7153,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Javadoc permette al programmatore di conoscere la firma e lo scopo di un metodo o di una classe che non ha mai visto prima, direttamente all'interno della classe. Javadoc è un commento strutturato, e per sua natura è di facile lettura. Per quanto riguarda i metodi Javadoc fornisce informazioni sui parametri, le eccezioni lanciate, il tipo di ritorno, la versione, e molti altri dettagli.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9839,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10017,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10265,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9985,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10187,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9781,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10151,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7093,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "il javadoc è utile perche aiuta a comprendere meglio il funzionamento di un codice. ci sono scritti informazioni su parametri, metodi, classi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10018,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10154,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9776,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9843,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9981,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10267,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10186,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7113,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 942,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Javadoc è utile la programmatore poichè gli permette di capire qual è il ruolo dei metodi, delle variabili e dei parametri che può trovare nell'utilizzare codice altrui (o anche suo).  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10016,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10266,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9841,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10150,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9779,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10189,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9982,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6655,
          "asker": {
            "courseId": 102,
            "askerId": 1033,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "L'operatore static influenza la firma di un metodo?\r\n\r\nPotete aiutavi rispondendo alla domanda: quali dei seguenti metodi hanno firme differenti...\r\na. public static void main (String[] args);\r\nb. public void main (Sring[] args);\r\nc. private static int main( int x);\r\nd. protected static int main (int x);\r\ne. protected static void main (String[] args);",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STATIC"
            },
            {
              "keyword": " STATIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6643,
          "asker": {
            "courseId": 102,
            "askerId": 1055,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè in Java dichiaro alcuni metodi Static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6610,
          "asker": {
            "courseId": 102,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa vuol dire quando dichiariamo una variabile STATIC?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6673,
          "asker": {
            "courseId": 102,
            "askerId": 1038,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo è utile l'autoboxing? Qual è l'operazione inversa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7171,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 952,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "L'autoboxing è molto utile in tutta quella serie di funzioni che richiedono un tipo wrapper come parametro formale. \r\nL'autoboxing permette al programmatore di passare, a questo tipo funzioni, tipi primitivi che poi saranno convertiti dal sistema in tipi\r\nwrapper (ovvero il sistema si accorge che la funzione vuole un tipo wrapper allora lo crea e ci inserisce il tipo primitivo che noi abbiamo passato) ! \r\nL'autounboxing è il concetto opposto: se io ho una funzione che ritorna un valore di un tipo wrapper e lo assegno ad un tipo primitivo, il sistema automaticamente mi estrarrà dal tipo wrapper il tipo primitivo e lo assegnerà alla variabile di tipo primitivo che gli ho indicato !",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9871,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10192,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10345,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7140,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 960,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Per Autoboxing si intende il processo automatico eseguito dal compilatore che aggiunge una serie di istruzioni che permettono di trattare le classi Wrapper come dati fondamentali e viceversa.\r\nPer esempio se una funzione A(Integer n), richiede un integer ma viene passato un int:\r\nint h=4; A(4); il compilatore aggiunge una serie di istruzioni che permettono al programmatore di eseguire tale codice. Aggiunge infatti: Integer o=new Integer(h); A(o);\r\nTutto questo è volto solo alla scrittura più immediata del codice ed evitare quindi inutili corbezzoli.\r\nIl processo esattamente contrario è detto Autounboxing.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9873,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10193,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10344,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 7081,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 975,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "L'autoboxing è uno zuccherino sintattico che permette di usare in automatico un tipo base come classe wrapper. \r\nL'operazione inversa è l'autounboxing e consosite nel poter usare un tipo di classe wrapper come tipo base.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9872,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10346,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10194,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6679,
          "asker": {
            "courseId": 102,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Vantaggi di generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GENERICS"
            },
            {
              "keyword": " VANTAGGI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6664,
          "asker": {
            "courseId": 102,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "a cosa servono le generic?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6685,
          "asker": {
            "courseId": 102,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale vantaggio offre l'uso dei generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "generic"
            },
            {
              "keyword": " generic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6683,
          "asker": {
            "courseId": 102,
            "askerId": 1101,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono i GENERICS? A cosa servono e come vengono utilizzati?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generic"
            },
            {
              "keyword": " Generics"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6698,
          "asker": {
            "courseId": 102,
            "askerId": 962,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per autoboxing?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Autoboxing"
            },
            {
              "keyword": " Autoboxing"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6699,
          "asker": {
            "courseId": 102,
            "askerId": 980,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è e come funziona all'interno di un programma il meccanismo publish and subscribe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "PUBLISH/SUBSCRIBE"
            },
            {
              "keyword": "PUBLISH/SUBSCRIBE"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7133,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il paradigma publish/subscribe si riferisce a un design pattern utilizzato per la comunicazione asincrona tra processi diversi (anche oggetti o altri agenti).\r\nMittenti e destinatari di messaggi dialogano attraverso un tramite (dispatcher), il mittente di un messaggio (publisher) non deve essere consapevole dell'identità dei destinatari (subscribers), esso si limita a \"pubblicare\"(publish) il proprio messaggio al dispatcher. I destinatari a loro volta si rivolgono al dispatcher \"abbonandosi\" (subscribe) alla ricezione di messaggi.\r\nIl dispatcher quindi inoltra ogni messaggio inviato da un publisher a tutti i subscriber interessati a quel messaggio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10208,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10218,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10321,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 10115,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 10102,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7132,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 990,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Il meccanismo \"publish and subscribe\" e' un pattern di programmazione, cioe' un modo tipico di strutturare interazioni tra un certo insieme di classi per risolvere un certo problema. E' meglio noto con il nome di \"Observer Pattern\".\r\n\r\nSi compone di due elementi:\r\n-Un SUBJECT che durante il suo funzionamento genera degli eventi che altre classi possono essere interessate a ricevere. Es. Il Banco genera un evento che e' l'estrazione di un numero\r\n-Un OBSERVER che e' interessato ad essere notificato degli eventi di un SUBJECT. Es. La Cartella vuole essere notificata all'estrazione di un numero\r\n\r\nUn Observer puo' iniziare a ricevere gli eventi di un Subject richiamando un metodo del subject chiamato subject.addListener(observer). Il Subject nel momento in cui si verifica un evento provvede a richiamare un certo metodo su tutti gli Observer ad esso registrati. Un Observer puo' smettere di ricevere gli eventi di un Subject richiamando un metodo chiamato subject.removeListener(observer).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10215,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10114,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10205,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10322,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10099,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7167,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1027,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il paradigma di publish and subscribe permette la creazione di un canale di comunicazione tra classi. Un client notifica i cambiamenti di determinati parametri che vengono notificati all'ascoltatore ad esso iscritto. L'ascoltatore (listener) riceve le notifiche del cambiamento di parametri se e solo se è nella lista degli ascoltatori di un client. Nel momento in cui l'ascoltatore decide di rimuoversi, non riceverà più le notifiche.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10209,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10118,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10100,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10325,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10219,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7072,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1072,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "È  un paradigma che permette di dare un'informazione a un gruppo di elementi, e poi solo gli elementi a cui interessa l'informazione ricevuta rispondono al \"messaggio\" inviato.  Un esempio del suo utilizzo è  nel programma \"tombola\".  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10116,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10216,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10206,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10101,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10324,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7156,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 977,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "il meccanismo di publish/subscribe serve ad inviare copie dello stesso messaggio a oggetti multipli senza dover mandare singolarmente il messaggio ad ogni elemento.\r\nogni oggetto, tramite l'azione di subscribe, può diventare un \"ascoltatore\" di una certa fonte di messaggi; quando questa pubblica un messaggio ogni \"ascoltatore\" riceve il messagio ( come accade ad esempio stando in un gruppo di whatsapp)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10323,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10207,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10217,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10103,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10117,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6607,
          "asker": {
            "courseId": 102,
            "askerId": 939,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra l'applicazione del modificatore static in un metodo e l'applicazione del modificatore static in una variabile di istanza?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " Static"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7106,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1017,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "una variabile statica, essendo condivisa da tutte le istanze della classe, assumerà lo stesso valore per ogni oggetto di una classe e modificandone un'istanza verranno modificate tutte.\r\n\r\ni metodi statici non sono associati ad una istanza ma solo ad una classe. Quindi non potranno interagire con le variabili di istanza, ma solamente con quelle statiche. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10022,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9799,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10276,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10358,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7103,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 992,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Le variabili statiche servono come singola variabile condivisa tra le varie istanze.\r\nI metodi static possono essere richiamati senza creare una istanza e hanno lo scopo di agire su variabili static.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9796,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10360,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10275,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10025,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 7088,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un metodo statico è condiviso da tutte le istanze della classe,quindi un metodo statico può essere utilizzato anche senza istanziare la classe. Il suo utilizzo provocherà il caricamento in memoria della classe contenente il metodo in questione.\r\nUn esempio di metodo statico è il metodo sqrt() della classe Math, che viene chiamato tramite la sintassi: Math.sqrt(numero);\r\n\r\nUna variabile statica, essendo condivisa da tutte le istanze della classe, assumerà lo stesso valore per ogni oggetto di una classe.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10023,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10274,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9797,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10359,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 7166,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1001,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Il modificatore static si utilizza per legare una variabile o un metodo  alla classe stessa piuttosto che ad una sua istanza. Perciò se si utilizza il modificatore static con un metodo, tale metodo sarà comune a tutte le istanze della classe e potrà essere usato nel main senza dover prima creare un istanza della classe, semplicemente usando: NomeClasse.nomeMetodo ();\r\nSe invece si usa il modificatore static su una variabile, tale variabile sarà indipendente dalle istanze, sarà allocata nel momento in cui viene caricata la classe e potrà essere usata semplicemente scrivendo NomeClasse.nomevariabile;\r\nUna metodo statico può usare soltanto variabili statiche, in quanto se si riferisse a variabili di istanza non statiche, queste potrebbero non essere state inizializzate. Invece una variabile statica può essere usata da un metodo statico così come da uno non statico.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10024,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10277,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10357,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9798,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6612,
          "asker": {
            "courseId": 102,
            "askerId": 957,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche e i vantaggi del modello \"Publish/subscribe\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Publish/subscribe"
            },
            {
              "keyword": " Publish/subscribe"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 7206,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le caratteristiche del modello publish/subscribe presentano un design per la comunicazione asincrona fra diversi oggetti. In questo pattern vi è un tramite fra mittente e ricettore, grazie a cui quest'ultimo riesce a precisare in maniera molto precisa al publisher quali messaggi inviare o meno.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10306,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 10061,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10078,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9950,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7154,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1053,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Il modello publish/subscribe consente lo scambio di messaggi tra mittenti e destinatari, attraverso un tramite. Questo permette al mittente di non conoscere quali siano i destinatari, ma si limita a specificare quali caratteristiche devono avere; in questo modo il tramite (che può essere broker o dispatcher) inoltrerà il messaggio a tutti i subscriber interessati.\r\nInoltre, consente ai subscriber di iscriversi solo a determinati publisher, così da ricevere i messaggi a lui interessati.\r\nTutto ciò garantisce grande scalabilità, in quanto mittenti e destinatari non sono noti l'uno all'altro.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 10305,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9949,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10060,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 10076,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 7169,
              "task": {
                "taskId": 196,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1003,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Il modello publish/subscribe viene utilizzato per trasmettere informazione, mantenendo un codice semplice. Invece di inviare un messaggio a più destinatari il mittente \"pubblica\" il messaggio su un \"gruppo\" e ogni destinatario viene notificato di tale azione, coloro interessati ai messaggi si iscriveranno a questo gruppo in modo da essere notificati. Uno dei vantaggi più grandi è che al mittente non importa se il gruppo varia (cresce o decresce), abbiamo quindi una maggiore astrazione",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9948,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10307,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 10062,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 10077,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 196,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6668,
          "asker": {
            "courseId": 102,
            "askerId": 996,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve dichiarare i generics?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "GENERIC"
            },
            {
              "keyword": " GENERIC"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6695,
          "asker": {
            "courseId": 102,
            "askerId": 1080,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Ma se io nella dichiarazione di una classe metto la generic <X>  e nel metodo costruttore metto X x =this.first; è necessario mettere nella definizione X x?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Generics"
            },
            {
              "keyword": " metodi costruttori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6688,
          "asker": {
            "courseId": 102,
            "askerId": 1044,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 195,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè è importante che i metodi delle classi di libreria siano dichiarati static?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Static"
            },
            {
              "keyword": " static"
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    },
    {
      "lectureId": 68,
      "lectureTitle": "Polimorfismo",
      "questions": [
        {
          "questionId": 6419,
          "asker": {
            "courseId": 102,
            "askerId": 981,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per dynamic binding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6881,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 980,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il binding, o legame, è la relazione che connette una qualsiasi variabile p al suo tipo.\r\nQuesto meccanismo in java ha due varianti,il dynamic binding e lo static binding.\r\nIn particolare il dynamic binding consente al programmatore di far decidere a che tipo associare la variabile in fase di esecuzione del programma (ossia a runtime), e non in fase di compilazione.\r\nQuesto ovviamente comporta una maggior flessibilità del tipo della variabile, che quindi potrà essere scelta dall'utente finale del programma nel momento in cui questo verrà eseguito; in seguito sarà la JVM a distinguere e chiamare il metodo corretto per il tipo di variabile utilizzata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8987,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8945,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8967,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9074,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8894,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6886,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 991,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Il dynamic binding è la creazione dinamica (in quanto avviene a run-time) del legame (bind) fra oggetto e tipo. Questo risulta particolarmente utile se combinato con il principio di sostituzione di Liskov (che mi consente di sostituire un tipo di oggetto con un suo sottotipo). In generale questo binding fornisce maggiore flessibilità al linguaggio (di default il C++ usa lo static binding ma, per non mancare di flessibilità, è comunque possibile effettuare un dynamic binding usando la keyword \"virtual\"), motivo per il quale in Java si usa esclusivamente dynamic binding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8988,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9076,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8893,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8966,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8946,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6922,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1012,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Il dynamic binding (o late binding) è un meccanismo attraverso il quale viene deciso a run-time il vero tipo di una variabile o quale implementazione di un metodo deve essere eseguita, differenziandosi quindi dallo static binding (o early binding) in cui questa decisione viene presa a compile-time.\r\nLa chiamata di un metodo \"sovrascritto\" nella classe figlia (overriding) rappresenta per eccellenza un esempio di dynamic binding in Java.\r\nMentre il C++ offre specifici meccanismi per decidere se utilizzare il dynamic binding (ad es. con il modificatore virtual), in Java le decisioni sono quasi sempre fatte a runtime dalla JVM (Java Virtual Machine), salvo quando ci sono le condizioni per decidere automaticamente (ad es. se il metodo è private, static, final oppure un costruttore).\r\nEseguire questi controlli a run-time non è efficiente per cui la JVM può calcolare in anticipo per ogni classe un method table che raccoglie tutte le firme e i metodi rendendo così queste operazioni più veloci.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8968,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8989,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8944,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8892,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9075,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6438,
          "asker": {
            "courseId": 102,
            "askerId": 1015,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Illustra in breve i concetti di overloading ed overriding",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading/overriding"
            },
            {
              "keyword": " Overloading/overriding "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6481,
          "asker": {
            "courseId": 102,
            "askerId": 954,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali vantaggi introduce il polimorfismo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Vantaggi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6847,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 996,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il polimorfismo ha essenzialmente due grossi vantaggi ovvero permette di avere una struttura ad oggetti:\r\n1) ESTENSIBILE, in quanto si può indurre il client ad invocare nuovi metodi personalizzati includendoli in una sottoclasse apposita;\r\n2) RESISTENTE, perché eventuali esigenze future nel programma o nella scrittura del codice potranno essere implementate fornendo ad un pacchetto software già scritto una nuova classe scritta ad hoc.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8722,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8995,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8774,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9192,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6809,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1018,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Il polimorfismo permette di ridefinire i metodi per le classi derivate in base ai tipi di dato presenti negli oggetti dichiarati.\r\n\r\nAl tempo di compilazione esso si manifesta tramite il method overloading mentre al tempo di esecuzione si manifesta tramite il method overriding.\r\n\r\nIl method overloading (il poter avere 2 o più metodi con stesso nome e firme ma con diversa implementazione) permette di accedere tramite un nome comune a metodi che eseguono operazioni simili (esempio: una funzione che accede a un array e questo array può essere di tipi differenti: interi, float, double...). \r\n\r\nIl method overriding (il poter avere 2 o più metodi con lo stesso nome ma con diverse firme) invece permette alle sottoclassi di usare tutte le definizioni più generali dei metodi che la classe padre gli fornisce e specializzarle.\r\n\r\nI vantaggi principali del polimorfismo sono dunque la generalizzazione del codice e il riuso di codice di classi già esistenti senza bisogno di ricompilazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8996,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8721,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8775,
                  "rater": {
                    "raterId": 1091,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9193,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6439,
          "asker": {
            "courseId": 102,
            "askerId": 970,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Se ho un'array di tipo A, e tutti i suoi elementi sono di tipo diverso l'uno dall'altro, ma tutti ereditanti da A, e su ogni istanza invoco un metodo definito solo in alcune sottoclassi, cosa succede?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Overloading/overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6784,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1045,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In generale, viene dato un errore a compile-time poichè non viene considerato compatibile l'oggetto di tipo A con i metodi definiti nelle sottoclassi.\r\nLa soluzione puó essere effettuare un cast sull'oggetto estratto dall'array, ma questa soluzione è potenzialmente pericolosa, infatti il cast va sempre a buon fine a compile-time (essendo tutte sottoclassi di A)  escludendo gli errori di incompatibilità, ma a run time si puó presentare un errore se sì è fatto un cast ad una sottoclasse che non è propriamente quella per cui era stata allocata la memoria nel particolare oggetto.\r\nInstanceof (<oggetto> instanceof <classe>) restituisce true se l'oggetto è un istanza di una classe per cui si puó utilizzare per sapere se è legittimo utilizzare il cast.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9096,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8815,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8974,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8731,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6905,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1001,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Ciò che succede dipende da quale metodo viene invocato e da dove è definito tale metodo. Analizzando singolarmente le chiamate al metodo, se nella sottoclasse il metodo è stato definito, allora ci troviamo in presenza di un errore del compilatore, il quale vede un oggetto dichiarato di tipo A su cui viene chiamato un metodo che su A non è stato definito. Per ovviare al problema basta effettuare un downcast durante la chiamata al metodo, nel seguente modo (ipotizziamo che la sottoclasse sia B e i sia un indice):\r\n((B)array[i]).metodo();\r\nSe invece nella sottoclasse non è stato definito il metodo, allora l'errore si presenta in quanto si cerca di eseguire un metodo di una classe su un'istanza di una classe diversa: infatti anche se la sottoclasse \"is a\" superclasse, non vale il contrario.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9094,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8730,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8813,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8975,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6914,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1020,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "se questo metodo viene richiamato per un elemento di A che però non ha tra i suoi metodi quello indicato (dato che non è presente in tutte le sottoclassi) avrò un errore di compilazione dato che non posso ottenere un risultato del genere neanche tramite casting esplicito\r\ndiversamente se il metodo è presente e viene utilizzato un casting corretto (dato che l'array è di tipo A mentre gli elementi sono di varie sottocalssi devo utilizzare il casting) allora non vi saranno errori",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8814,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8973,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8733,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9097,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6882,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 944,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Dato un programma del tipo in questione, senza alcuna forma di casting si genera un errore a livello di compilazione (compile-time). D'altra parte attuando un casting sugli elementi dell'array, a run-time, nel momento in cui il metodo è invocato su di un'istanza di una sottoclasse priva del metodo considerato, insorge un ulteriore errore. Un'alternativa, per evitare errori, potrebbe essere l'impiego dell'operatore \"instance of\" (indicando come argomento la prima sottoclasse avente il metodo dato). Ciò infatti consentirebbe di invocare il metodo (della sottoclasse effettiva, grazie al dynamic binding) solo se effettivamente lecito.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8816,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9095,
                  "rater": {
                    "raterId": 1076,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8976,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8732,
                  "rater": {
                    "raterId": 911,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6417,
          "asker": {
            "courseId": 102,
            "askerId": 1065,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Definisci il \"Liskov substitution principle\" ed illustralo con un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6810,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1067,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Il \"Liskov substitution principle\" sostiene che se S è un sottotipo di T, allora all'interno di un programma tutti gli oggetti di tipo T (genitore) possono essere sostituiti da oggetti di tipo S (figlio), senza causare alterazioni e senza bisogno di eccezioni.\r\nPer esempio un Cane è un Animale, uno Studente è una Persona, un Auto è un Veicolo: in tutti questi casi 'è un' prende il significato di 'può sostituire un'.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8758,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8999,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9159,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6865,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1089,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il \"Liskov substitution priciple\" è una definizione di sottotipo, ed è espresso dall' enunciato: \"Se q(x) è una proprietà valida  per gli oggetti x del tipo T, allora q(y) deve essere valida per gli oggetti y del sottotipo S di T\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8757,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9163,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9000,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6923,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 953,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": ".il principio di sostituzione di Liskov afferma che gli oggetti di una sottoclasse devono potere essere sostituiti ovunque siano usati oggetti della superclasse, senza influenzare il comportamento del codice che li usa. Significa quindi che il comportamento della sottoclasse deve essere ?compatibile? con la specifica della superclasse. Ad esempio ho una funzione f(Object a), chiamo la funzione f e posso passargli qualsiasi oggetto di qualunque classe (essendo sicuramente una sottoclasse di Object).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9161,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8756,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8998,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6873,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 983,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Il \"Liskov substitution principle\" dichiara che se B è un sottotipo di A,  allora oggetti di tipo A in un programma possono essere sostitituiti da oggetti di tipo B senza alterare alcuna proprietà desiderabile del programma.\r\n\r\nClass A;\r\nA oggetto = new A();\r\noggetto.ciao();\r\n\r\nClass A; Subclass B;\r\nA oggetto = new B();\r\noggetto.ciao();",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8997,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9162,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8755,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6819,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1023,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il \"Liskov substitution principle\" dice che dato un oggetto di tipo S il quale è un sottotipo di T allora tutti gli oggetti di tipo T possono essere sostituiti con oggetti di tipo S senza alterare la struttura del programma. \r\nEsempio.\r\nSupponiamo di avere una classe padre Veicolo e una classe figlio Auto allora la classe figlio (Auto) avrà tutti i metodi di Veicolo più alcuni suoi metodi caratteristici quindi nel momento in cui andremo a chiamarli i metodi saranno presenti anche nell'oggetto di tipo Auto.\r\n\r\nClass Veicolo(){\r\n      string targa;\r\n}\r\nClass Auto extends Veicolo(){\r\n       int num_porte;\r\n}\r\n\r\npublic static void main (string a[]){\r\n      veicolo p;\r\n      p = new Auto (); // è uguale a p = new Veicolo();\r\n      System.out.println(p.targa); //perché la classe auto ha il metodo targa ereditato\r\n                                               // da Veicolo e ciò non modifica la struttura del \r\n                                               //programma\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9001,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9160,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8759,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6423,
          "asker": {
            "courseId": 102,
            "askerId": 976,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è l'utilizzo delle classi Abstract e perché non è possibile istanziarle?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6816,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 949,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Il modificatore abstract, quando applicato a una classe, fa si che tale classe non possa essere istanziata direttamente ma solo dischiarata ed estesa.\r\nAd esempio se vogliamo rappresentare un insieme di auto possiamo creare una classe abstract Auto, con la quale potremo creare un'array (o una generica collezione) e inserire all'interno del suddetto elemento varie istanze di classi che estendono la classe Auto, ad esempio Cabriolet, Monovolume o Supersportiva.\r\nIn pratica una classe viene dichiarata abstract quando non ha senso così com'è ma lo hanno tutte le sue classi estese e ha senso inserirle all'interno di un struttura comune a tutte le classi derivate.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9022,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8693,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8717,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9135,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6798,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1049,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe Abstract ha come scopo quello di determinare dei valori comuni che verranno utilizzati poi dalle sue classi figlie. Per esempio, possiamo definire una classe abstract veicolo e delle sue classi figlie automobile e moto. Quando creeremo il costruttore di quest'ultime, utilizzeremo il comando super per richiamare il costruttore di veicolo per assegnare tali valori ai suoi figli. Questo perché Moto e Automobile hanno elementi comuni (per esempio una possibile variabile targa) e, grazie alla costruzione di una classe abstract che li contiene, non c'é bisogno di richiamarli ad ogni istanza di una nuova classe figlio. Quindi, il fatto che contengano valori comuni per altri classi figlio, ma non unici, vige la regola di non istanziare classi abstract perché inutile a livello pratico.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9023,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9134,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8695,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8716,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6875,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1079,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi Abstract sono classi aventi proprietà generali che vengono create per essere subclassate e al fine di scrivere codice polimorfo. Ciascuna delle sottoclassi sarà \"specializzata\" in quanto vengono definiti i metodi astratti della classe Abstract. Le classi Abstract non sono dunque finalizzate ad essere istanziate, ma evitano la riscrittura di codice e permettono una maggiore leggibilità del programma. Inoltre, se si potesse istanziare una classe Abstract, si ricaverebbe un oggetto poco utile proprio per le sue proprietà generali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9133,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8694,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9021,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8718,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6443,
          "asker": {
            "courseId": 102,
            "askerId": 990,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Secondo te perche' esiste un overload del metodo System.out.println che accetta come parametro un oggetto di tipo Object?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6779,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 981,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Esiste per permettere al programmatore di stampare un oggetto con maggiore comodità. Infatti, il metodo print richiama la funzione toString dell'oggetto, su cui può essere fatto l'overriding, personalizzando la stampa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8795,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8909,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8714,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9242,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9185,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6879,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1091,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché rende System.out.println un metodo molto utile, ad esempio se creassi un oggetto contenente una stringa il metodo System.out.println la stamperebbe direttamente senza creare funzioni ulteriori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8907,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8711,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9188,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8798,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9245,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6785,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 987,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Posso stampare un oggetto perchè con l'overload del metodo System.out.println viene fatta auotomaticamente una conversione toString dell'oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9244,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8797,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8910,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9184,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8712,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6849,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 998,
                "courseId": 102,
                "courseFinalScore": 11
              },
              "answerText": "Esiste un overload del metodo System.out.println, rappresentato dal metodo toString il quale, preso come parametro un oggetto di tipo Object, restituisce una stringa. Il metodo toString è utile se si vuole dare una rappresentazione testuale della classe che gli viene passata. Stampare una classe istanziata, significa infatti chiamare il metodo toString su quella classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8794,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8908,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9246,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8713,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9186,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6891,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 940,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Perché in questo modo è possibile chiamare implicitamente il metodo toString() su un *qualsiasi* tipo di dato (passato come parametro a System.out.println()), dal momento che di default ogni oggetto ha come classe padre 'Object'.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9243,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9187,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8715,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8911,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8796,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6441,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java avendo 2 classi (A e B) dove B è una sottoclasse di A, entrambe le classi hanno il metodo .toString() implementato in maniera diversa, quale metodo verrà richiamato con il seguente frammento di codice? (il metodo della classe A o quello della classe B)\r\n\r\nA a = new B();\r\na.toString();",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6780,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1068,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per il Polimorfismo se B è una sottoclasse di A, allora oggetti di tipo A in un programma possono essere sostituiti da oggetti di tipo B senza alterare alcuna proprietà desiderabile del programma.\r\nGrazie all'overriding, cioè la redifinizione di una funzione in una sottolclasse verrà utilizzato il metodo della classe B.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8764,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9062,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9247,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9088,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6817,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1010,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Anche se l'oggetto \"a\" viene istanziato come classe di tipo B esso è dichiarato come classe di tipo A, di conseguenza il metodo toString che verrà richiamato sarà quello della classe A e non quello della classe B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9250,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8766,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9061,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9087,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6904,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 995,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo che viene stampato e' quello della classe B, per via dell' overriding.\r\n\r\nPer rispondere completamente alla domanda pero' bisogna avere chiaro un concetto: nella riga \"A a = new B();\" l'oggetto a, cioe' l'istanza di A viene inizializzata come un'istanza di B, cosa possibile per via dell'ereditarieta' e dai vincoli presenti tra le due classi, che sono rispettivamente padre e figlia (quindi in una relazione \"diretta\").\r\n\r\nNonostante cio' sia possibile e' necessario ricordare che \"a\" resta un oggetto di tipo A, ma inizializzato come B. Infatti chiamando un metodo proprio della classe B, omettendo il downcast esplicito, il programma restituira' un errore.\r\n\r\nPero' non e' questo il nostro caso, infatti avendo entrambi il metodo .toString() (che erediterebbero comunque da Object) abbiamo la situazione in cui la classe B effettua un overriding sul metodo della classe padre, stampando il mteodo .toString di B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9248,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9065,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8765,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9089,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6877,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo chiamato con questo frammento di codice sarà il metodo della classe A",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9064,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8768,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9086,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9249,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6825,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 957,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nella dichiarazione della variabile a viene assegnato un nuovo oggetto di tipo \"B\", oggetto che utilizza i metodi della classe B. Di conseguenza, viene eseguito il metodo .toString() della classe B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9063,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9251,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9085,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8767,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6456,
          "asker": {
            "courseId": 102,
            "askerId": 1055,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega il principio di sostituizione di Liskov e se questo altera l'esecuzione del programma.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6473,
          "asker": {
            "courseId": 102,
            "askerId": 1066,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Si definisca cosa sono le classi abstract  e quali sono le regole d'uso per le classi cosi dichiarate.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " abstract "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6450,
          "asker": {
            "courseId": 102,
            "askerId": 1052,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Questo programmino in java è corretto? Perché?\r\n\r\npublic class padre {\r\n   // cose varie\r\n   public void metodo(int a) {\r\n       //operazioni varie\r\n   }\r\n}\r\nPublic class figlio extends padre{\r\n   //cose varie\r\n   public void metodo(int a, int b) {\r\n      // operazioni varie\r\n   }\r\n}\r\n\r\npadre a = new figlio();\r\na.metodo(2, 3);",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " overriding "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6431,
          "asker": {
            "courseId": 102,
            "askerId": 957,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "In quali casi conviene utilizzare classi \"abstract\" e in quali \"final\"? quali sono le principali differenze?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6911,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1011,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "- una classe abstract NON può essere istanziata: deve essere subclassata (da una classe non abstract se la voglio istanziare). Una classe abstract può contenere sia metodi abstract che non abstract; i metodi abstract  devono essere sovrascritti quando si vogliano passare ad una sottoclasse per l'istanziazione della stessa.\r\n- una classe final è una classe che NON può essere subclassata; come tutte le classi non abstract, NON può contenere metodi abstract. Se un metodo è dichiarato final NON può essere sovrascritto. Se una variabile è dichiarata final è costante.\r\nLe classi abstract forniscono un modello astratto per una serie di classi che hanno in comune alcune caratteristiche base. Conviene dunque usare classi abstract quando delle classi \"sono tutte allo stesso livello\" in termini di ereditarietà, ma hanno caratteristiche assai diverse(es. è utile creare una classe abstract per le figure geometriche). Le classi final servono quando NON voglio che una classe possa essere subclassata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9038,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8827,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9066,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8700,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8959,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6804,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 977,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "è preferibile utilizzare una classe abstract quando si vuole utilizzare data classe come \"base\" per la derivazione di altre classi da essa.\r\nUna classe final invece è utile se si vuole evitare che il codice venga visto o modificato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8825,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9037,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9068,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8961,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8701,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6906,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1094,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi \"abstract\" e le classi \"final\" sono molto diverse tra di loro. Le prime non possono essere istanziate (non è possibile creare un oggetto di queste classi) ma è possibile definire una classe che erediti da queste e che ne implementi o ne sovrascriva i metodi. Le classi \"final\", invece, possono essere istanziate ma non è possibile definire una classe che erediti da esse. Conviene usare una classe \"abstract\" per definire la struttura di una classe e alcuni comportamenti \"di default\", che poi dovrà essere implementata del tutto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8826,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9069,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9036,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8702,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8958,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6919,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1059,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Può essere conveniente quando dobbiamo usare un metodo che implementa diversamente il codice. Ad esempio avendo una classe astratta figura,che avrà una sua area...ma il calcolo dell'area viene fatto diversamente in base alla figura (quadrato,triangolo,cerchio,ecc) quindi definiremo abstract il metodo area.\r\nFinal invece lo potremmo usare quando abbiamo bisogno che una la classe non possa essere estesa.\r\nLe principali differenze sono che final non può essere sublassato mentre abstract deve per forza essere subclassata non potendo essere istanziata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9035,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8828,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8960,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8703,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9067,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6479,
          "asker": {
            "courseId": 102,
            "askerId": 1038,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere le differenze tra static binding e dynamic binding.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6453,
          "asker": {
            "courseId": 102,
            "askerId": 991,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Il principio di sostituzione di Liskov (enunciato nella settima slide) può essere applicato solo ad oggetti legati direttamente da una relazione (senza nodi intermedi) o a prescindere, a patto che T sia più in alto, nell'albero gerarchico, di S? Sarebbe possibile, in generale, applicarlo a due sotto-classi con super-classe comune?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6839,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il principio di Liskov può essere applicato solo ad oggetti legati direttamente da una relazione.\r\nSi sarebbe possibile applicare il principio a due sotto-classi con super-classe comune",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8985,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9100,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9099,
                  "rater": {
                    "raterId": 1084,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6833,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1035,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il principio di Liskov vale se S è sottoclasse di T, a prescindere da quanti 'nodi intermedi' ci siano. Per esempio supponiamo di avere la classe Spider sottoclasse di Auto che a sua volta è sottoclasse di Veicoli. In questo caso gli oggetti di tipo Veicoli possono essere sostituiti da oggetti di tipo Auto ma anche da oggetti di tipo Spider.\r\nNel caso invece due sotto-classi abbiano la super-classe in comune ma non abbiano una relazione tra loro non è possibile applicare Liskov (per esempio nel caso di Auto e Moto)\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9098,
                  "rater": {
                    "raterId": 1084,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9101,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8986,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6445,
          "asker": {
            "courseId": 102,
            "askerId": 1075,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali caratteristiche deve avere una funzione per essere definita polimorfa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6426,
          "asker": {
            "courseId": 102,
            "askerId": 1019,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che particolarità hanno le classi \"Abstract\"? Come possono essere utilizzate in un progetto? Spiegalo con un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6820,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 959,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe abstract è una classe che definisce gli elementi della stessa senza però implementarla completamente \r\n\r\npublic abstract class classe_astratta\r\n{\r\n    public abstract void stampa();\r\n}\r\n\r\npublic class Stampante extends classe_astratta \r\n{\r\n    public void stampa()\r\n    {\r\n        System.out.println(\"Ciao\");\t\r\n    }\r\n}\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9014,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9025,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8709,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9148,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6812,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 951,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Le classi abstract hanno la caratteristica di essere classi non istanziabili (cioè non posso definire una abstract class Programm e istanziare una variabile di tipo Programm: Programm x = new Programm() NO!!! ) e i cui metodi non sono implementati. Servono per evitare di ripetere metodi e variabili comuni alla sottoclassi anche se nelle sottoclassi i metodi non implementati devono essere implementati. Per esempio:\r\n\r\nabstarct class Pippo {\r\n             abstract void Pluto();  // dichiaro la classe Pluto senza definirla perchè è abstract\r\n             ......\r\n}\r\n\r\nclass Paperino extends Pippo {\r\n             void Pluto () {      //definisco la classe Pluto\r\n                     int x = 0;\r\n                     ......\r\n              }\r\n              ......\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9027,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9151,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9013,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8707,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6795,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi astratte in Java sono utilizzate per poter dichiarare caratteristiche comuni fra classi di una determinata gerarchia. Pur definendo il nome di un tipo, la classe astratta non può essere instanziata, analogamente a quanto accade per le interfacce; ma a differenza di una interfaccia può avere field non statici, metodi non pubblici, un costruttore, insomma una classe a tutti gli effetti ma non istanziabile.\r\n\r\nLa sua dichiarazione è caratterizzata dall?utilizzo della keyword abstract:\r\n\r\npublic abstract class A {\r\n    //campi \r\n    //metodi\r\n}\r\n\r\nUna classe astratta può contenere o meno metodi astratti, ma una classe che contiene metodi astratti deve necessariamente essere dichiarata come astratta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9015,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9149,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8708,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9024,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6920,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1044,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le calssi definite abstract NON possono essere istanziate ovvero non è possibile utilizzare l'operatore new per allocare nella mamoria la calsse.\r\nUna classe abstract è utilizzabile in tutti i casi in cui tale classe definisce metodi e oggetti, comuni ad altre sottoclassi, ma che se istanziata non è suffiscientementa esaustiva al fine di risolvere il nostro problema ( non ha senso da sola o non può vivere da sola).\r\nLe sottoclassi utilizzeranno i metodi e gli oggetti della classe abstract e in più aggiungeranno dell'altro (sempre metodi e oggetti) per completare i dati e i metodi necessari.\r\n\r\nES:\r\ncatena produttiva di microprocessori:\r\nclasse abstract: microP. , sottoclassi: nomi degli integrati.\r\n\r\nNon ha senso istanziare una classe microP perchè non potrà contenere tutti quei dati fondamentali che variano da microproc. a micoroproc. (piedinatura, dimensioni, tensione di alim., ...)\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9016,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9150,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9026,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8710,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6428,
          "asker": {
            "courseId": 102,
            "askerId": 977,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "fai un esempio pratico discorsivo ( non scritto in java) di come agisca il polimorfismo",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6434,
          "asker": {
            "courseId": 102,
            "askerId": 999,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che problemi possono essere legati all'overloading?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "OVERLOADING"
            },
            {
              "keyword": " OVERLOADING"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6449,
          "asker": {
            "courseId": 102,
            "askerId": 1012,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Data in Java una variabile così definita:\r\n\r\nObject animale_estratto = cappello_magico.estrai();\r\n\r\nCom'è possibile determinare se \"animale_estratto\" non è un'istanza di una classe chiamata \"Colomba\" ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6818,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1013,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "In questo caso, è utile usare l'operatore \"instanceof\".\r\nQuest?operatore indica se l?oggetto è un' ?istanza di? una determinata classe (o di una delle sue superclassi). La sintassi prevede la seguente dichiarazione:\r\n\r\n<identificatore_oggetto> instanceof <nome_classe>\r\n\r\nRestituisce true se l'oggetto in questione è un'istanza della classe di confronto specificata (o di una delle sue superclassi); false altrimenti.\r\nPotremo dunque verificare se \"animale_estratto\" è un'istanza della classe \"Colomba\" nel seguente modo:\r\n\r\nif(animale_estratto instanceof Colomba){\r\n   // Il programma entra ed esegue questo blocco solo se animale_estratto\r\n   // è un'istanza di \"Colomba\" o di una sua superclasse.\r\n}\r\nelse{\r\n   // altrimenti, il programma entra ed esegue questo blocco.\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9017,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8817,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8962,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8763,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9082,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6807,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 975,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "Per vedere se è un istanza della classe colomba si usa la parola chiave instanceof.\r\nAd esempio per vedere se non è un'istanza della classe Colomba si può scrivere:\r\n\r\nif (!(animale_estratto instanceof Colomba)) {\r\n//il codice\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9019,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8965,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8820,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9084,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8760,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6884,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1032,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Bisogna utilizzare l'operatore instanceof che chiamato su un oggetto mi dice se quell'oggetto è compatibile con una certa classe. Quindi nel nostro caso il comando sarà:\r\nSystem.out.println(animale_estratto instanceof Colomba);\r\nVerrà stampato true o false a seconda che animale_astratto sia o meno un'istanza di Colomba.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8819,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8963,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9020,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9083,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8761,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6916,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Grazie all'operatore binario \"instanceof\" è possibile testare a run time se il tipo di un oggetto (o un'istanza) è dello stesso tipo (o un suo sottotipo) del tipo dato. L'operatore restituisce true oppure false a seconda che l'oggetto sia o no un'istanza della classe di confronto (o di una delle sue superclassi). In questo caso specifico quindi si può testare se animale_estratto è oppure no dello stesso tipo di Colomba nel seguente modo:\r\n\r\nif (animale_estratto instanceof Colomba) { //è dello stesso tipo di Colomba}\r\nelse {//non è dello stesso tipo}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9081,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8818,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8762,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8964,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9018,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6472,
          "asker": {
            "courseId": 102,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende per polimorfismo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "polimorismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6424,
          "asker": {
            "courseId": 102,
            "askerId": 1008,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponiamo di avere una classe Class_A e una sua sottoclasse Class_B, che la estende. Quale tra le due seguenti sintassi è corretta e perché?\r\n\r\n1) Class_A a = new Class_B();\r\n2) Class_B b = new Class_A();",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6912,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 790,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La sintassi giusta è la (1) in quanto permette alle veriabile e ai metodi di A di essere usufruiti anche da B estendendoli, mentre la (2) porterebbe a problemi di estensibilità e di uso di variabili di A in B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9028,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8734,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8753,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8812,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6841,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1040,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "La prima è corretta perché Java utilizza una tecnica detta dynamic binding in cui la classe madre può contenere la classe figlia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9030,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8811,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8735,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8754,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6838,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1050,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La scrittura corretta è la 1). Infatti, allocando un nuovo spazio di memoria di dimensione necessaria a contenere un tipo Class_B, il compilatore mette a disposizione dell'oggetto \"a\" non solo i parametri e i metodi contenuti in un oggetto di tipo Class_A, ma lo spazio anche per utilizzare quelli contenuti in Class_B (nonostante sia un Class_A). Tuttavia per essere invocati/utilizzati questi ultimi necessitano di un cast di accesso sull'oggetto \"a\" per aggirare i problemi di visibilità in una sottoclasse (cast che viene reso possibile dalla relazione \"Class_B is-a Class_A\" poichè è una sua estensione). Con la seconda scrittura invece, allocando lo spazio per un Class_A, i metodi di Class_B non sarebbero accessibili nemmeno con un cast su \"b\", poichè la dimensione di Class_A è minore essendo una superclasse che contiene solo l'accesso ai propri metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8736,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8810,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9029,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8752,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6410,
          "asker": {
            "courseId": 102,
            "askerId": 1033,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene implementato in programmazione ad oggetti il concetto di polimorfismo? \r\nRispondi prendendo spunto da un esempio concreto (anche fra quelli presentati a lezione, e.g. Veicolo-Auto-Moto).",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "POLIMORFISMO"
            },
            {
              "keyword": " POLIMORFISMO"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6422,
          "asker": {
            "courseId": 102,
            "askerId": 1023,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché decidiamo di dichiarare una classe con il modificatore abstract, quali sono i vantaggi che ne derivano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6872,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1085,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "le classi astratte (abstract) sono classi create apposta per identificare nella su insieme un unico elemento o una serie di elementi eventi caratteristiche simili in C++ si possono identificare nelle struct.\r\nUn esempio può essere: un azienda vuole catalogare tutti i suoi programmatori in base al nome, cognome ed gli anni d'esperienza per far c'ho a bisogno un array, grande quanto il numero dei dipendenti, composto dalla classe astratta (struct) in seguito è sufficiente richiamare la casella dell'array dedicata a quel dipendente per sapere i suoi dati.\r\n\r\npublic abstract class Programmatore {\r\n  private String nome;\r\n  private String cognome;\r\n  private int anniEsperienza;\r\n\r\n  public Programmatore(String n, String c, int a){\r\n    nome=n;\r\n    cognome=g;\r\n    anniEsperienza=a;\r\n  }\r\n  public abstract void programma();\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8956,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9213,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8940,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6792,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 941,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "\"Classi dichiarate abstract non possono essere istanziate, e devono essere subclassate.\" (cit. Slide)\r\n\r\nI vantaggi nell'utilizzo delle classi abstract sono presenti se ti trovi in queste situazioni:\r\n- devi utilizzare lo stesso codice in molte sottoclassi della classe abstract.\r\n- ti aspetti che le classi che estendono la classe abstract abbiano molti metodi/campi/variabili in comune.\r\n\r\nES: \r\nLa classe abstract \"PoligonoGeometrico\" contiene la dichiarazione dei metodi \"CalcoloArea\" , \"CalcoloPerimetro\" , \"DisegnaPoligono\"...\r\nLe sottoclassi \"Quadrato\", \"Rettangolo\", \"Triangolo\"... richiamano questi metodi e li implementato con del codice relativo alle loro esigenze.\r\n\r\nUn esempio di codice:\r\nabstract class PoligonoGeometrico\r\n{\r\n   void DisegnaPoligono();\r\n   ...\r\n}\r\n\r\nclass Quadrato\r\n{\r\n   void DisegnaPoligono()\r\n   {\r\n      ...\r\n   }\r\n   ...\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8955,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9214,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8942,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6888,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 962,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Usando una classe con il modificatore abstract, si possono ereditare altri metodi (non-abstract). Con le interfacce invece non si può ottenere la stessa cosa, perché un'interfaccia non fornisce alcuna implementazione di metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8943,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8957,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9211,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6799,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 964,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Dichiarare una classe abstract permette di avere una classe base da estendere e implementando e definendo i metodi dichiarati nella classe abstract, di dare una specializzazzione alle classi. Le classi figlie vanno quindi ad ampliare la classe padre definendo e implementando tutte le funzioni astratte nella classe padre, che sono semplicemente dichiarate per dare alla classe un comportamento base. Un esempio può essere la classe padre Animale che viene estesa dalle varie tipologie di animale.\r\n\r\nNote: Tutte i metodi dichiarati astratti all'interno della classe abstract devono essere definiti e implementati nella classe figlio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8954,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9212,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8941,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6451,
          "asker": {
            "courseId": 102,
            "askerId": 1020,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "spiegare la differenza tra Static e Dynamic binding, utilizzando degli esempi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": "Binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6430,
          "asker": {
            "courseId": 102,
            "askerId": 1027,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Confrontare i meccanismi di dynamic binding e static binding illustrandone vantaggi e svantaggi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "BINDING"
            },
            {
              "keyword": " BINDING"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6409,
          "asker": {
            "courseId": 102,
            "askerId": 942,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Parlando di dynamic binding, perché c'è la necessità per la JVM di avere una method table? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6436,
          "asker": {
            "courseId": 102,
            "askerId": 969,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza fra lo static ed il dynamic binding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": "static"
            },
            {
              "keyword": "dynamic"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6476,
          "asker": {
            "courseId": 102,
            "askerId": 1096,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Come è possibile, in caso di necessità, fare un casting di un istanza x di una superclasse a una classe figlia? Per semplicità aiutati con un esempio che illustri una situazione generica.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6823,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1003,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Supponendo di avere una superclasse (A) ed una sottoclasse (B), ovvero relazione \"B is an A\"\r\nPer il principio di Liskov è sicuramente legale l'istruzione:\r\nA a = new B();\r\nIl problema è che non possiamo fare:\r\na.metodoDiB()\r\ne neanche\r\na.variabileDiB()\r\n\r\nIl compilatore ci segnalerà errori durante la compilazione dato che non sa che il riferimento \"a\" punta ad un oggetto di tipo \"B\".\r\nDobbiamo quindi effettuare il casting così:\r\n(B)a.metodoDiB()\r\nIn questo modo il compilatore ci consentirà di puntare all'area di memoria dove è memorizzato il metodo o la variabile specifica di B.\r\n\r\nSe però avessimo la seguente dichiarazione:\r\nA a = new A()     (invece della \"A a = new B()\" iniziale)\r\nEffettuando il casting e provando ad accedere al metodo di B otterremmo un errore a runtime, dato che l'area di memoria del metodo di B non esiste (visto che \"a\" è effettivamente di tipo A).",
              "notes": "-",
              "rating": 0,
              "coins": []
            }
          ]
        },
        {
          "questionId": 6477,
          "asker": {
            "courseId": 102,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa sono e a cosa servono i modificatori? Quali sono le loro differenze?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Final"
            },
            {
              "keyword": " Modificatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6858,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1053,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "I modificatori sono parole chiavi usate per cambiare il significato di un componente di un programma. Strettamente legati al concetto di polimorfismo, essi permettono di definire attributi a metodi, classi e variabili. Vengono chiamati anche modificatori di accesso, in quanto permettono di regolare l'accesso al componente cui si riferiscono. Alcuni di questi sono (in riferimento a Java):\r\n- public: il componente è accessibile a tutti le classi di tutti i package\r\n- protected: il componente è accessibile solo all'interno del suo stesso package ed in tutte le sotto classi della classe in cui è definito\r\n- private: il componente è accessibile solo all'interno della classe in cui è definito\r\n- final: applicato ad una variabile, non ne permette ulteriori assegnamenti; ad un metodo non permette la ridefinizione (overriding); ad una classe non permette estensioni di essa\r\n- static: un membro statico è condiviso tra tutte le istanze della stessa classe",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8728,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8889,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6788,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "I modificatori sono delle componenti del linguaggio capaci di cambiare il significato di un'applicazione Java. I modificatori trattati sono:\r\n-FINAL: usato per definire una variabile che diverrà una costante per l'istanza della classe.\r\n-STATIC: può essere applicato a metodi e a variabili di una classe. Un metodo/una variabile static è un metodo/una variabile comune a tutte le istanze della classe.\r\n-ABSTRACT: può essere applicato sia a metodi che alle classi. Una classe abstract non può essere istanziata e contiene metodi abstract che non conengono nessuna implementazione: sono una sorta di definizione in cui le classi devono necessariamente essere suclassate e i metodi sovrascritti.\r\n-MODIFICATORI DI ACCESSO: applicabile sia a classi che a metodi e attributi. Regolano la visibilità e l?accesso ad un componente Java.\r\n  -PUBLIC: visibilità globale.\r\n  -PROTECTED: visibile dalle sottoclassi.\r\n  -PRIVATE: nascosta a tutti. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8891,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8727,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6805,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 882,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I modificatori sono delle parole chiave che rappresentano degli aggettivi con cui andiamo a definire delle caratteristiche per i membri della nostra classe o per le classi stesse.\r\nPerciò essi sono in grado di cambiare \"il significato\" di un componente di un applicazione Java.\r\nCi sono vari tipi di modificatori, i principali sono:\r\nmodificatori d'accesso (public, protected, \"nessun modificatore\", private): questi modificatori regolano essenzialmente la visibilità e l'accesso ad un componente Java.\r\n\r\nmodificatore static: è forse il più potente modificatore in Java, perciò va usato con molta cautela; si potrebbe tradurre static con \"condiviso da tutte le istanze della classe\".\r\n\r\nmodificatore final: con questo modificatore si possono dichiarare le costanti in Java, ma può essere usato non solo con le variabili, ma anche con classi e metodi per influire sull'ereditarietà; potremmo tradurre final con \"non modificabile\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8890,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8729,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6408,
          "asker": {
            "courseId": 102,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono le interfacce e qual'è il loro legame con i metodi astratti?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract Binding"
            },
            {
              "keyword": " interfaces"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6444,
          "asker": {
            "courseId": 102,
            "askerId": 1017,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare la differenza tra overloading e overriding. Fornire un esempio per entrambi",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "OVERLOADING"
            },
            {
              "keyword": " OVERRIDING"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6454,
          "asker": {
            "courseId": 102,
            "askerId": 1007,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa afferma il \"Principio di sostituzione di Liskov\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6475,
          "asker": {
            "courseId": 102,
            "askerId": 1080,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'esempio del professore,- istance of -viene usato su un oggetto di tipo coda(sottoclasse), per vedere se esso era \"compatibile\" ad uno pila(classe) e dava vero; ma se si facesse l'inverso, ovvero usare - istance of - su un oggetto di tipo pila confrontato con la sua superclasse pila, cosa darebbe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "istance of"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6429,
          "asker": {
            "courseId": 102,
            "askerId": 1085,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende con una funzione polimorfica?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Funzioni"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6455,
          "asker": {
            "courseId": 102,
            "askerId": 1050,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che funzione ha il modificatore \"abstract\" in linguaggio Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6457,
          "asker": {
            "courseId": 102,
            "askerId": 1032,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Quale dei seguenti comandi è corretto? Giustificare la propria scelta.\r\nA) Persona x=new Studente();\r\nB) Studente y= new Persona();",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "polimorfismo"
            },
            {
              "keyword": " polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6413,
          "asker": {
            "courseId": 102,
            "askerId": 992,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra overloading e overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "overloading/overriding"
            },
            {
              "keyword": "overloading/overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6850,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 955,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'overloading consiste nel chiamare 2 metodi in classi diverse nello stesso modo ma con parametri diversi mentre l'overriding è riscrivere un metodo già presente in una classe in una sua sottoclasse",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8860,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8844,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8881,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6852,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1033,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Quando parliamo di metodi in java dobbiamo ricordarci due concetti fondamentali: overloading e overriding.\r\nPer overloading s'intende la possibilità che in una classe possano coesistere più metodi con lo stesso nome e diversa firma (lista di parametri)\r\nes. Class MyClass {\r\nvoid do (int x);\r\nvoid do (int x, float y);\r\n}\r\nPer overriding di funzioni si intende la possibilità di ridefinire una funzione in una sottoclasse( mantenendone immutata la firma)\r\nes. Class MyClass{\r\nvoid do (int x){\r\n   x++;\r\n    }\r\n}\r\nClass MyNewClass extends MyClass{\r\nvoid di (int x){\r\n    x+=2;\r\n   }\r\n}\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8846,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8879,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8859,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6802,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1027,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'overloadig permette di dichiarare e utilizzare funzioni con lo stesso nome, purché abbiano una diversa firma. Con firma intendiamo i tipi di dato dei paramentri passati alla funzione e l'ordine con qui tali parametri vengono trasmessi. void f (int i) e void f (char i) hanno una firma diversa e sono quindi due funzioni diverse.\r\nL'overriding permette invece di ridefinire una funzione di una classe padre in una qualsiasi classe figlio, come da noi fatto con il metodo estrai di pila e coda.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8845,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8858,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8882,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6869,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 942,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Con \"overloading\" s'intende la dichiarazione e definizione di una funzione il medesimo nome di un'altra, ma con diversa firma. Con \"overriding\" invece s'intende la dichiarazione e definizione di una funzione con firma identica ad una funzione già dichiarata, che tuttavia non sarà più accessibile direttamente poichè \"nascosta\" dalla nuova dichiarazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8847,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8861,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8880,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6404,
          "asker": {
            "courseId": 102,
            "askerId": 979,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo si ottiene, in C++, il dynamic binding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6460,
          "asker": {
            "courseId": 102,
            "askerId": 1030,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "A che cosa serve l'operatore instanceof?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6806,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 960,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "L'operatore istanceof serve per verificare se un oggetto è istanza di una determinata classe tramite la seguente sintassi: <riferimento> instanceof <tipo_riferimento>. Utilizzando questa keyword viene restituito un tipo Booleano che viene spesso utilizzato all'interno di istruzioni condizionali. Istanceof diventa molto utile quando si trattano tipi di dati che possono essere anche molto differenti fra di loro e non è noto in fase di compilazione ma può variare in fase di esecuzione come nel caso di coda/pila polimorfa.\r\nNel caso in cui l'oggetto <a> istanza una classe A che è sottoclasse B, la scrittura <a istanceof B> risulterà True in quando una sottoclasse è dello stesso tipo della sua superclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9210,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8862,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8770,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9045,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6917,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1043,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "con l' operatore istanceof si controlla se un oggetto è un istanza di una classe,\r\nad esempio con \"mario istanceof Persona\" restituisce un boolean in caso mario sia un istanza della classe persona.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9207,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8771,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9046,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8866,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6789,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1000,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Ritorna vero o falso se l'oggetto analizzato è del tipo cercato.\r\nes:\r\nPila p = new Pila();\r\n.....\r\n.....\r\nSystem.out.println(p istanceof Pila);//TRUE.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8769,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8864,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9043,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9208,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6897,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 974,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore instanceof permette di controllare la classe di appartenenza di un oggetto. La sintassi è <oggetto> instanceof <classe> (es. studente instanceof Universita) e restituisce true solo se <oggetto> è un'istanza di <classe>. Viene spesso usato come condizione di un if per esempio: \r\n\r\nif(a instance of integer) \r\n    a++;\r\nelse \r\n    System.out.println(\"Inserire un numero\"); . ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9206,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8863,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9047,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8772,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6876,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"instanceof\" serve per verificare il tipo di un oggetto, ossia per controllare di quale tipo l'oggetto considerato sia istanza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9209,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8773,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8865,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9044,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6464,
          "asker": {
            "courseId": 102,
            "askerId": 949,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè ha senso scrivere Persona p=new Studente(); mentre Studente s=new Persona(); è errato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6856,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché, se Studente è un sottotipo di Persona, allora oggetti di tipo Persona possono essere sostituiti da oggetti di tipo Studente, senza alterare alcuna proprietà del programma, in quanto Studente possiede tutti i metodi e le istanze di Persona. Il viceversa non è  corretto, poiché non è detto che Persona, in quanto superclasse, possieda tutti i metodi di Studente. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8687,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8740,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9260,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9008,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6918,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 58,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nel primo caso p è una variabile di tipo Persona e punta ad un'istanza di Studente, il che ha senso dato che studente estende persona, mentre nel secondo caso s è una variabile di tipo Studente e punta ad un'istanza di tipo Persona, questo provoca un errore a compile time poiché non è possibile istanziare una classe con il costruttore della superclasse, non avendo questo tutti i metodi della sottoclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9012,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8737,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8688,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9258,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6776,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1073,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "E' possibile scrivere Persona p=new Studente(); perchè Studente contiene tutti i campi necessari per la classe Persona mentre il contrario no; ad esempio Studente ha bisogno anche del campo \"N° matricola\" che non è presente nella classe Persona e noi non siamo in grado di aggiungerlo successivamente all'inizializzazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9009,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8686,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8739,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9261,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6796,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1022,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il problema risiede nel fatto che la classe Studente estende la classe Persona, infatti essendo una sua sottoclasse, è lecito affermare che tutti gli studenti sono delle persone, mentre è errato affermare che tutte le persone sono degli studenti. Pertanto potremmo usare studente (che è anche una persona) qualora sia richiesta una generica persona, ma non viceversa, in quanto mancherebbero degli attributi. Supponiamo che la classe Persona abbia le variabili di istanza \"nome\", \"età\", \"indirizzo\" e che la classe Studente, oltre a quelle della superclasse, abbia anche la variabile \"matricola\".\r\nCon l'assegnazione Persona p= new Studente() stiamo stanziando una zona di memoria più grande di quella che ci necessita ma che comunque contiene tutti gli attributi di persona (studente ==> persona).\r\nLa scrittura Studente s= new Persona() crea problemi perchè, per esempio, non è possibile richiamare l'attributo \"matricola\" che è proprio di studente ma non di persona (persona =/=> studente).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8689,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8738,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9259,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9011,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6845,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Ha senso scrivere 'Persona p=new Studente();' perché la Class Persona viene definita prima della Class Studente, si ha il problema che Persona non potrebbe accedere ai metodi di Studente per la regola dell'IS-A, ma abbiamo visto che è un problema risolvibile.\r\nAl contrario facendo 'Studente s=new Persona();' viene definita la Class Studente per prima e viene legata a Persona che in memoria non è ancora stata creata, questo causa un problema irrisolvibile, essendo Persona la Class padre di Studente. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8741,
                  "rater": {
                    "raterId": 969,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8685,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9010,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9262,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6405,
          "asker": {
            "courseId": 102,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il \"dynamic binding\" e come funziona?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6864,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "il dynamic binding è quando il bind di una variabile viene fatta a runtime, a differenza dello static binding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9140,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9220,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9111,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8789,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6840,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1065,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "IL dynamic binding è l'assegnazione di un tipo (int, float, char ecc...) ad una variabile durante l'esecuzione del programmaq (a runtime). Se il compilatore non riesce a chiamare il metodo appartenente all'oggetto preso in considerazione a runtime, delega il compito alla JVM (java virtual machine) che ne determina il metodo esattto analizzando l'oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8790,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9136,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9219,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9110,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6854,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1038,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il dynamic binding consiste nel decidere il vero tipo di una variabile a run-time.\r\nLeghiamo cioè un nome ad una implementazione in modo dinamico, ovvero a run-time (non a compile-time!) viene eseguita una cosa oppure un'altra.\r\nIl dynamic binding è utile in quanto rende il codice molto più flessibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9139,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8787,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9223,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9113,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6786,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1002,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il dynamic binding consiste nella determinazione automatica da parte della JVM dell'oggetto a cui un metodo è associato, questo perché a causa del polimorfismo il compilatore non è in grado di determinarlo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9222,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9112,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9137,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8791,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6880,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1052,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Il dynamic binding caratteristico del java, ma non solo, consiste nel determinare la classe di appartenenza di un oggetto a run time.\r\nGrazie al dynamic binding si evitano tanti errori riguardanti la chiamata di metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9221,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9109,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8788,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9138,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6412,
          "asker": {
            "courseId": 102,
            "askerId": 1013,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi la differenza tra \"dynamic binding\" e \"static binding\".",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6821,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 999,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La differenza tra \"dynamic binding\" e \"static binding\" consiste nel modo in cui viene specificato il tipo di un oggetto se a \"run-time\" o a \"compile-time\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8872,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9147,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9077,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9177,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6808,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Il binding è il processo con il quale in un linguaggio di programmazione viene deciso il tipo di ogni 'entità' e quindi la possibilità di utilizzare certi metodi su di essa. Questa decisione può essere presa in due momenti diversi: a run time o compile time.\r\nCon lo static binding, come suggerisce il nome, questa decisione viene presa dal compilatore in fase di compilazione del programma e questa associazione variabile-tipo non può essere più cambiata. Con il dynamic binding invece la decisione viene presa durante l'esecuzione del codice. Questo ci permette di essere molto più flessibili all'interno del nostro codice, permettendoci di utilizzare il Polimorfismo e fare scelte durante l'esecuzione del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8874,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9176,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9078,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9146,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6883,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 958,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nello static binding, si richiama un metodo presente solo nella classe figlia, nel dynamic binding questo metodo è presente sia nella classe padre che nella classe figlia,  richiamandolo il compilatore prende sempre in considerazione il metodo della classe figlia.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9178,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9080,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8871,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9145,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6907,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1063,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Parliamo di binding statico (o early binding) se la decisione riguardo l'attributo o il metodo da richiamare in un dato momento dell'esecuzione del programma può essere stata stabilità in anticipo in maniera fissa; mentre se essa può essere presa a tempo di esecuzione in maniera dinamica si parla di binding dinamico (o late binding).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9179,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8873,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9144,
                  "rater": {
                    "raterId": 1103,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9079,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6446,
          "asker": {
            "courseId": 102,
            "askerId": 1031,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Trova e motiva gli errori presenti nel seguente codice:\r\n\r\nclass Persona{\r\n   String nome;\r\n   String cognome;\r\n\r\n   public Persona(String n, String c){\r\n      nome = n;\r\n      cognome = c;\r\n   }\r\n}\r\n\r\nclass Studente extends Persona{\r\n   final int matricola;\r\n   \r\n   public Studente(String n, String c, int m){\r\n      matricola = m;\r\n      super(n, c);\r\n   }\r\n   public void CambiaMatricola(int nuovaMatricola){\r\n      matricola = nuovaMatricola;\r\n   }\r\n}\r\n\r\nclass App{\r\n   public static void main(String[] a){\r\n      new App();\r\n   }\r\n\r\n   public App(){\r\n      Persona p;\r\n      p = new Studente(\"Mario\", \"Rossi\", 123456);\r\n      p.CambiaMatricola(654321);\r\n\r\n      Studente s;\r\n      s = new Persona(\"Mario\", \"Rossi\");\r\n   }\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6425,
          "asker": {
            "courseId": 102,
            "askerId": 1025,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Siano Persona e Studente due classi, con Studente sottoclasse di Persona. Quale fra le seguenti espressioni ha senso e non produce errori irrimediabili: Persona x = new Studente () ; Studente x = new Persona () ?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6925,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1101,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per il principio di sostituzione di Liskov, se Studente è una sottoclasse di Persona, allora oggetti di tipo Persona possono essere sempre sostituiti da oggetti di tipo Studente, senza alterare le proprietà del programma. Pertanto l'espressione che ha senso e non produce errori è \"Persona x = new Studente();\" dove, a partire da un oggetto Persona, creo un oggetto Studente.",
              "notes": "-",
              "rating": 0,
              "coins": []
            }
          ]
        },
        {
          "questionId": 6420,
          "asker": {
            "courseId": 102,
            "askerId": 985,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Overriding e Overloading?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overriding"
            },
            {
              "keyword": " Overloading"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6414,
          "asker": {
            "courseId": 102,
            "askerId": 952,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il polimorfismo ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6418,
          "asker": {
            "courseId": 102,
            "askerId": 1014,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza fra overloading e overriding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading/overriding"
            },
            {
              "keyword": " Overloading/overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6474,
          "asker": {
            "courseId": 102,
            "askerId": 1035,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra dynamic binding e static binding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": "Binding "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6482,
          "asker": {
            "courseId": 102,
            "askerId": 1042,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è l'overloading di una funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Overloading/overriding"
            },
            {
              "keyword": " Overloading/overriding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6893,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1076,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con overloading si intende un gruppo di funzioni che hanno lo stesso nome, ma posso essere utilizzate con un numero diverso di argomenti (a seconda del numero di argomenti inseriti la funzione può cambiare anche il tipo di risultato)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8896,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8778,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8868,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8979,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6926,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1082,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'overloading di una funzione è la coesistenza di due funzioni con uguale nome e diversa firma. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8776,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8898,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8869,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8977,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6837,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 990,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "L'overloading e' uno strumento messo a disposizione da un linguaggio di programmazione che permette di definire piu' funzioni aventi lo stesso nome ma che differiscono tra loro per numero o tipo dei parametri.\r\n\r\nEs double somma(int, double);\r\n    double somma(double, double);\r\n\r\nIn Java e C++ al momento della chiamata ad una funzione il compilatore determina l'effettiva funzione da chiamare cercando tra le possibili alternative quella che meglio corrisponde al numero e tipo di parametri passati. In genere vengono preferite le funzioni che necessitano di poche conversioni dei parametri per essere chiamate\r\n\r\nNell'esempio precedente una chiamata del tipo\r\n\r\nsomma(2, 3);\r\n\r\nviene risolta dal compilatore richiamando double somma(int, double) perche' e' solamente necessario convertire il secondo parametro da int a double mentre una chiamata a double somma(double, double) richiederebbe la conversione da int a double di entrambi i parametri.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8978,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8777,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8895,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8870,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6924,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1081,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si definisce overloading di una funzione la possibilità di attribuire ad un unico nome di funzione due o più diversi significati, con la condizione che gli argomenti forniti ad essi siano diversi fra loro. Il suddetto nome di funzione può così essere utilizzato contemporaneamente per più funzioni. Il programma sarà in grado di eseguire automaticamente la funzione corretta fra quelle col medesimo nome basandosi sul tipo degli argomenti passatigli.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8867,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8897,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8779,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8980,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6458,
          "asker": {
            "courseId": 102,
            "askerId": 961,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo il Polimorfismo è importante nei linguaggi di programmazione? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "scopo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6815,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1096,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nei linguaggi di programmazione orientati ad oggetti il polimorfismo è molto importante perché permette di creare funzioni generiche, per quando nel momento di scrittura codice non si ha idea di cosa verrà sottoposto al programma. Il polimorfismo serve per gestire classi figlio attraverso opportuni casting delle classi padre e serve anche per creare un legame fra diversi figli di uno stesso padre (archivi come array, pile e code di istanze della classe padre).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8905,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8917,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8994,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9157,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6791,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il poliformismo nel contesto della programmazione orientata agli oggetti, si riferisce al fatto che una espressione il cui tipo sia descritto da una classe A può assumere valori di un qualunque tipo descritto da una classe B sottoclasse di A (polimorfismo per inclusione);\r\nSolitamente è legato alle relazioni di eredità tra classi, che garantisce che tali oggetti, pur di tipo differente, abbiano una stessa interfaccia: nei linguaggi ad oggetti tipizzati, le istanze di una sottoclasse possono essere utilizzate al posto di istanze della superclasse (polimorfismo per inclusione).\r\nI metodi che vengono ridefiniti in una sottoclasse sono detti polimorfi, in quanto lo stesso metodo si comporta diversamente a seconda del tipo di oggetto su cui è invocato. Il polimorfismo permette di avere una struttura ad oggetti estensibile, in quanto si può indurre il client ad invocare nuovi metodi personalizzati includendoli in una classe apposita; resistente, fornendo client scritto in una classe ad hoc.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8990,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8906,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9156,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8920,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6782,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 969,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perche non è necessario sapere il tipo esatto della classe bensì solamente la base e indipendentemente da questo si otterranno i risultati voluti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8904,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9155,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8919,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8991,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6890,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 993,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il Polimorfismo è importante perchè permette maggiore flessibilità nella programmazione di strutture dati, infatti la decisione del tipo viene effettuata a run time e non a compile time.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9154,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8916,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8902,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8992,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6898,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1071,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Il polimorfismo permette di implementare un solo metodo/funzione che viene poi utilizzata da oggetti di vario tipo. Questo rende il codice piu mantenibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8993,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9158,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8903,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8918,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6469,
          "asker": {
            "courseId": 102,
            "askerId": 1054,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra Overloading e Overriding ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading"
            },
            {
              "keyword": " Overriding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6411,
          "asker": {
            "courseId": 102,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "che Cos'è dynamic binding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "DYNAMIC"
            },
            {
              "keyword": " BINDING"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6908,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1099,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nei termini della programmazione a oggetti, la decisione circa l'attributo o il metodo da richiamare in un dato momento dell'esecuzione del programma viene effettuata grazie al binding (processo tramite cui viene effettuato il collegamento fra una entità di un software ed il suo corrispettivo valore). Tale decisione può essere stata stabilita in anticipo in maniera fissa, e in tal caso si parla di binding statico (o early binding); oppure può essere presa a tempo di esecuzione, in maniera dinamica, e in tal caso si parla di binding dinamico (o late binding).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8745,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8914,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9117,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9203,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9034,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6827,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1008,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Con \"dynamic binding\" si intende la capacità di decidere il tipo di un oggetto a runtime (durante l'esecuzione del programma): non possiamo dunque fare alcuna ipotesi nel momento della compilazione. Si contrappone allo static binding, in cui il tipo viene deciso a compile-time.\r\nIl dynamic binding è uno dei processi alla base del polimorfismo ed è quindi molto importante per la programmazione a oggetti.\r\nIn Java abbiamo solamente dynamic binding; in C++, dobbiamo utilizzare la keyword \"virtual\" per utilizzarlo, altrimenti avremmo static binding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8742,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9118,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9031,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8915,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9202,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6800,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1064,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il dynamic binding è una tecnica di binding che agisce in run time decretando il tipo di una variabile a seconda di una decisione presa dall'utente. In questo modo è possibile riferirsi ad un'oggetto, interagendo con esso, a prescindere dal suo tipo, sfruttando l'eriditarietà delle classi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9204,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8912,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9119,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8743,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9032,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6901,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1021,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Il dynamic binding è un modo attraverso il quale il compilatore decide il metodo da chiamare per un oggetto. In particolare ciò accade a runtime quando ci si trova in una situazione di overriding di metodi. Il compilatore ricaverà il tipo a cui è legato l'oggetto che stiamo considerando e chiamerà il primo metodo che trova seguendo la catena di ereditarietà.\r\nCreiamo per esempio una classe Umano da cui deriviamo una classe Donna che sovrascriverà il metodo cammina presente in Umano. Quando creeremo un oggetto di tipo Donna non importa se ci riferiamo a esso come se fosse un oggetto Umano, in ogni caso se invocheremo il metodo cammina il compilatore chiamerà il metodo cammina presente nella classe Donna in quanto l'oggetto a cui ci riferiamo è di tipo Donna. Questa operazione è logicamente eseguita durante l'esecuzione del programma e non durante la sua compilazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9033,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8913,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9120,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9205,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8744,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6435,
          "asker": {
            "courseId": 102,
            "askerId": 955,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "A cosa serve ad esempio dichiarare una persona X come nuovo studente quando si potrebbe dichiarare studente X come nuovo studente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "POLIMORFISMO"
            },
            {
              "keyword": " POLIMORFISMO"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6878,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1025,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se si dichiara X di tipo persona a X si può assegnare new persona oppure new studente, mentre se si dichiara X come studente si può assegnargli solo new studente. Ciò permette di decidere a run-time il vero tipo della variabile X (dynamic binding). Ciò serve dunque se si vuole permettere all'utente di scegliere se creare un nuovo studente o una nuova persona.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9231,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8935,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9238,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6775,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 992,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Serve per ottenere uno studente che , in più, eredita dati e funzioni da persona",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9241,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8938,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9232,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6822,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1055,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Potrebbe trattarsi di un esempio di polimorfismo, cioè di una dipendenza is-a tra la classe \"persona\" e \"studente\". Una delle due classi potrebbe essere una estensione di un'altra, cioè avere all'interno delle caratteristiche comuni \"estese\" con delle caratteristiche non comuni che definiscono in modo inequivocabile la classe. \r\nQuesto permetterà al programmatore di avere, non appena vista la classe dichiarata, una idea precisa delle caratteristiche e dei metodi che quest'ultima può utilizzare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9230,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8939,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9240,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6835,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Perchè creando un sottotipo studente al tipo persona, per il principio della sostituzione di Liskov ho il vantaggio di poter sostituire in un programma oggetti di tipo persona con oggetti di tipo studente senza alterare alcuna proprietà del programma",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8937,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9237,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9229,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6828,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1070,
                "courseId": 102,
                "courseFinalScore": 10
              },
              "answerText": "In generale serve ad avere un codice più flessibile e permettere che alcune scelte vengano fatte a run-time (e non a compile-time) direttamente dall'utente che utilizza l'applicativo java che stiamo scrivendo. Ad esempio, nel caso in cui si volgia decidere a runtime a quale sottoclasse persona X appartiene (docente o studente ?).\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9228,
                  "rater": {
                    "raterId": 928,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9239,
                  "rater": {
                    "raterId": 955,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8936,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6415,
          "asker": {
            "courseId": 102,
            "askerId": 1039,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Una classe abstract non la posso istanziare, e deve avere sottoclassi, ma una sottoclasse può anche essere dichiarata abstract, per cui non la posso istanziare",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "abstract"
            },
            {
              "keyword": " sottoclassi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6437,
          "asker": {
            "courseId": 102,
            "askerId": 984,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "In java, se un oggetto è isatanziato come una sottoclasse della classe dell'oggetto\r\nes. classe A, sottoclasse B, A oggetto = new B();\r\nnel momento in cui viene chiamato un metodo presente sia nella classe sia nella sottoclasse, per l'oggetto viene utilizzato il metodo della classe o della sottoclasse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6851,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 978,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Viene utilizzato il metodo della sottoclasse B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9102,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8950,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8854,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9200,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6887,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1030,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In Java il meccanismo di identificazione del metodo appropriato in un'invocazione è detto ricerca dinamica del metodo. La macchina virtuale Java identifica il metodo corretto guardando per prima cosa alla classe dell'oggetto effettivamente utilizzato nell'invocazione, invocando quindi il metodo avente quel nome e definito in quella classe o nella più vicina superclasse (dal momento che non sappiamo a priori se il metodo è stato ridefinito nella classe corrente). Quindi se all'interno della sottoclasse B è stato ridefinito il metodo ereditato dalla classe A allora verrà invocato il metodo definito nella classe B. Invece se non vi è stata alcun overriding allora verrà invocato il metodo definito all'interno della classe A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8953,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9105,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9198,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8857,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6895,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 968,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se un oggetto è istanziato come una sottoclasse della classe dell'oggetto, quando verrà chiamato il metodo, l'oggetto utilizzerà il metodo della classe di appartenenza ossia quello della sottoclasse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9103,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8856,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9199,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8951,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6842,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1046,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In Java esite il binding dinamico, si tratta dell'associazione fatta a run-time guardando la classe dell'oggetto contenuto nella variabile, quindi viene chiamata l'implementazione di B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8855,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9201,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9104,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8952,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6403,
          "asker": {
            "courseId": 102,
            "askerId": 988,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che caratteristiche deve avere la classe per poter essere dichiarata abstract?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ABSTRACT"
            },
            {
              "keyword": " ABSTRACT"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6811,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1019,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe abstract ha la caratteristica che non verrà mai instanziata. Infatti si creeranno oggetti solo di sue sottoclassi. Un esempio può essere quello di una gestione di una scuola: è bene creare una classe persona per avere campi comuni quali il nome ecc. Ma alla fine verranno istanziate soltanto sue sotto classi come studente o professore, perciò la classe persona si può tranquillamente dichiararla abstract.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8851,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9143,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6892,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 966,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi astratte in Java sono utilizzate per poter dichiarare caratteristiche comuni fra classi di una determinata gerarchia.\r\nUna classe deve essere dichiarata astratta quando al suo interno è presente almeno un metodo astratto.  Inoltre è possibile dichiarare una classe come astratta pur in assenza di metodi astratti, in tal caso il compilatore ne impedisce l'istanziazione diretta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9141,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8852,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6783,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Una delle principali caratteristiche di una classe astratta è che essa non può in alcun modo essere istanziata. Infatti il suo ruolo è quello di fare da superclasse ad altre classi. Tutti i suoi metodi dichiarati abstract devono essere sovrascritti, perché gli abstract methods all'interno della classe astratta vengono solamente dichiarati (la firma è definita ma non l'implementazione). \r\nUna classe non astratta non può contenere metodi astratti, mentre una classe astratta può contenere metodi che non siano astratti. Quindi, una classe che ha almeno un metodo astratto deve essere dichiarata astratta.\r\nUna classe astratta viene utilizzata per poter dichiarare variabili e metodi comuni tra una gerarchia di classi; viene utilizzata per condividere la stessa struttura fra più classi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9142,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8853,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6468,
          "asker": {
            "courseId": 102,
            "askerId": 958,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cosa si intende quando si parla di polimorfismo di una funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo "
            },
            {
              "keyword": " Polimorfismo "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6797,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1039,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "secondo il principio di Liskov, una funzione può comportarsi in maniera diversa a seconda del tipo che gli viene passato o del tipo di dati su cui è chiamata. Perciò posso dichiarare un oggetto di tipo T, sostituendolo in run-time con un oggetto di tipo S(purchè sia omogeneo).\r\nIn java avviene tramite il dynamic-binding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8692,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8899,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9257,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6832,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 963,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Una classe che estende un'altra classe con modificatore abstract dovrà obbligatoriamente eseguire l'overriding dei metodi astratti, mantenendone immutata la firma. La funzione risulta polimorfa perchè ogni sua implementazione può essere differente per codice e il tipo di dato di ritorno sarà concorde con quello della firma nel caso di un metodo non void). Questo permette al programmatore di richiamare tale metodo senza dover porre attenzione sul tipo oggetto preso in considerazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8690,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9255,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8900,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6778,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1072,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "È la possibilità di una funzione di implementare in maniere diverse una stessa funzionalità. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8901,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8691,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9256,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6427,
          "asker": {
            "courseId": 102,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per classe abstract e questa denominazioni si può applicare solo alle classi oppure anche alle variabili e nel caso che operazione effettuano quando sono \"abstract\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6826,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una classe abstract è una classe che non può essere instanziata (ma può contenere metodi sia implementati che no e variabili), molto simile alle interfacce.\r\nSi possono avere metodi abstract ma non variabili abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9107,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8835,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8751,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6790,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Il modificatore abstract può essere applicato solo a classi e metodi, ma non a variabili. Quanto una classe viene dichiarata abstract tutti i suoi metodi sono abstract ed è necessario subclassarla, mentre un metodo abstract dev'essere sovrascritto per poter essere utilizzato. Quando la sottoclasse di una classe abstract viene creata deve sovrascrivere tutti i metodi abstract della superclasse, altrimenti anche la sottoclasse stessa è abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8749,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9106,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8833,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6868,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 985,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le classi astratte rappresentano insiemi costituiti esclusivamente da sottoinsiemi e non possono essere applicati alle variabili, perchè non avrebbe nessun senso logico.\r\nVengono utilizzate per gestire il comportamento delle classi che la derivano.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8750,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9108,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8834,
                  "rater": {
                    "raterId": 1026,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6459,
          "asker": {
            "courseId": 102,
            "askerId": 1082,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il polimorfismo? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " polimorfismo "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6871,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 984,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il polimorfismo consiste nella possibilità di una funzione di comportarsi in maniera diversa a seconda del tipo di dato con cui è stata chiamata e del tipo di dato che è stato passato",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9268,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9254,
                  "rater": {
                    "raterId": 1108,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9006,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9053,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8799,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6781,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1078,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per polimorfismo si intende il fatto che una funzione può comportarsi in maniera diversa a seconda del tipo di parametri che gli vengono passati o a seconda del tipo di dato su cui viene chiamata",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9266,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9252,
                  "rater": {
                    "raterId": 1108,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8800,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9005,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9051,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6896,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1084,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il termine polimorfismo si riferisce al fatto che una espressione il cui tipo sia descritto da una classe A può assumere valori di un qualunque tipo descritto da una classe B sottoclasse di A. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9052,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9267,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8801,
                  "rater": {
                    "raterId": 1032,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9007,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9253,
                  "rater": {
                    "raterId": 1108,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6466,
          "asker": {
            "courseId": 102,
            "askerId": 1034,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa significa la parola chiave \"abstract\"?  A cosa serve? Fornisci un paio di casi di utilizzo",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6813,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 946,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il modificatore abstract è l'antitesi del modificatore final.\r\nAbstract può essere applicato sia a metodi che alle classi, ma non a variabili in quanto dichiarare una variabile astratta non avrebbe nessun senso logico. Un metodo astratto si definisce nel seguente modo:\r\nvisibilità abstract tipoDiRitorno nomeMetodo();\r\nQuindi come possiamo vedere un metodo astratto non implementa nessun pezzo di codice, ma si limita ad essere una sorta di definizione, come un prototipo in C++.\r\nSe all'interno di una classe dichiariamo un metodo astratto, anche la classe dovrà essere definita come tale. Una classe, se definita astratta, non può essere in alcun modo stanziata. Ovviamente, se la classe non può essere istanziata, non sarà nemmeno possibile richiamare uno dei suoi metodi astratti, ma sarà possibile utilizzare l'override dei metodi nelle sotto classi che derivano dalla classe astratta. In poche parole queste classi astratte servono da \"stampi\" alle classi che le estenderanno!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8949,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8809,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8886,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6913,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In java possiamo dichiarare \"abstract\" sia classi che metodi, una classe astratta non potrà essere istanziata, potrà contenere o meno metodi astratti ma, questi ultimi dovranno essere necessariamente contenuti in una classe astratta.\r\nEsse vengono utilizzate per definire caratteristiche comuni fra classi di una determinata gerarchia o come base di riferimento per la costruzione di altre classi più concrete.\r\nAd esempio possiamo definire una classe astratta \"Figura\" e dei metodi generici astratti come setBase, getBase, setAltezza, getAltezza; questi saranno privi di implementazione (sono semplici definizioni). Dopo aver creato 2 sottoclassi Triangolo e Rettangolo dovrò quindi in ognuna creare dei metodi analoghi a quelli della super classe andando però a fornire un'implementazione (non dobbiamo necessariamente aggiungere solo i metodi della classe madre).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8808,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8888,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8948,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6862,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 965,
                "courseId": 102,
                "courseFinalScore": 17
              },
              "answerText": "Il modificatore \"abstract\" assume diversi significati:\r\n(1) Nel caso in cui si riferisse ad una classe, indica che non può essere istanziata, tuttavia può essere subclassata, cioè possono esistere classi che ereditano da una classe abstract\r\n(2) Nel caso in cui si riferisse ad un metodo, nel caso in cui effettuiamo un subclass della classe che lo contiene, andremo OBBLIGATORIAMENTE a fare un overriding del metodo.\r\nUNICO esempio esemplificativo ed esauriente dell'utilizzo di \"abstract\"; NON CE NE STANNO DUE.\r\n\"Secchio.java\"\r\npublic abstract class Secchio{\r\n   //campi della classe\r\n   //metodi non abstract\r\n   abstract void printContenuto(){\r\n      System.out.println(\"contenuto-abstract\");\r\n   }\r\n}\r\n\"Secchio2000.java\"\r\npublic class Secchio200 extends Secchio {\r\n   //campi della classe\r\n   //metodi non abstract, costruttori\r\n  void printContenuto(){\r\n    System.out.println(\"contenuto\");\r\n  }\r\n}",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8887,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8807,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8947,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6433,
          "asker": {
            "courseId": 102,
            "askerId": 972,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il polimorfismo? Come lo si può applicare in Java? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "POLIMORFISMO"
            },
            {
              "keyword": " POLIMORFISMO "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6899,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1029,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Riferendoci ad un sistema software ad oggetti, il polimorfismo indicherà l?attitudine di un oggetto a mostrare più implementazioni per una singola funzionalità.\r\n\r\nPer esempio, supponiamo di voler costruire un sistema software in grado di disegnare delle figure geometriche. Per tale sistema avremo definito una classe padre chiamata FiguraGeometrica dalla quale avremo fatto derivare tutte le classi che si occupano della gestione di una figura geometrica ben precisa. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9153,
                  "rater": {
                    "raterId": 971,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8720,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8792,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6910,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1054,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il polimorfismo è un concetto fondamentale della programmazione ad oggetti permettendo a un dato metodo di avere più forme, ovvero di poter accettare parametri differenti e processarli di conseguenza. Per poterlo implementare in Java bisogna utilizzare l'overload dei metodi. Questo ci permette di avere all'interno di una classe più metodi con lo stesso nome inserendo prima della dichiarazione del metodo la dicitura \"@Overload\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8793,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9152,
                  "rater": {
                    "raterId": 971,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8719,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6465,
          "asker": {
            "courseId": 102,
            "askerId": 945,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è il polimorfismo? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6416,
          "asker": {
            "courseId": 102,
            "askerId": 993,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi dell'utilizzo del polimorfismo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6866,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 945,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "Grazie all'utilizzo del polimorfismo possiamo definire una classe padre che ha dei metodi abstract che poi verranno sovrascritti dai metodi delle subclassi(ad esempio: cane può sovrascrivere i metodi di animale).\r\nQuesto ci permette creare una \"interfaccia\" unica per più classi e quindi ci permette di prendere decisioni a runtime in base alle necessità senza preoccuparci dei cast.\r\nAd esempio possiamo creare una classe Contenitore e delle sub-classi Pila e Coda e scegliere a runtime quale usare usando all'interno del nostro codice i metodi della classe Contenitore che a runtime verranno sostituiti dai metodi della classi Pila o Coda.\r\nInoltre questo ci permette di creare insiemi eterogenei di oggetti che possiamo manipolare usando i metodi definiti nella superclasse senza doverci preoccupare di quale sia la \"vera\" classe, dandoci i risultati prodotti dai metodi della \"vera\" classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8824,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9182,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9234,
                  "rater": {
                    "raterId": 764,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8839,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6814,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 948,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "Il principale vantaggio del polimorfismo è quello di poter creare una lista di oggetti di tipo diverso. Ad esempio poniamo di voler creare una lista di veicoli di diverso tipo tramite un array, possiamo dichiarare un array:\r\n            Veicolo lista[] = new Veicoli[size];\r\ne supponendo che la classe Veicolo abbia due sottoclassi 'Auto' e 'Moto' è possibile inizializzare due elementi dell'array in questo modo:\r\n            lista[0]=new Auto; \r\n            lista[1]=new Moto; \r\nCosì abbiamo inizializzato due elementi di un array di oggetti Veicolo, uno con un oggetto Auto e uno con uno Moto. Ciò è possibile perché tra le classi Auto/Moto e la loro superclasse Veicolo c'è una relazione \"is a\" che determina che Auto e Moto sono anche di tipo Veicolo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8823,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9235,
                  "rater": {
                    "raterId": 764,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9180,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8837,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6777,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 972,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il polimorfismo permette di collegare oggetti diversi tra loro, in modo da rispondere in modo differente allo stesso tipo di messaggio. Permette di avere un programma estensibile e di facile manutenzione ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8821,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9181,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9233,
                  "rater": {
                    "raterId": 764,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8836,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6921,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1024,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Grazie al polimorfismo un oggetto in Java ha la capacita di assumere forme diverse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9183,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9236,
                  "rater": {
                    "raterId": 764,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8822,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8838,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6461,
          "asker": {
            "courseId": 102,
            "askerId": 527,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Variabili, Metodi e Classi definiti Abstract e quelli definiti Final?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6793,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 961,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il modificatore Abstract può essere applicato solamente a Metodi e Classi. Usare abstract con  le variabili non avrebbe nessun senso logico.La classe astratta non potrà mai essere istanziata ma per essere usata dovrà essere ereditata da un altra classe.Definire un metodo di tipo astratto implica che siano ridefiniti (tramite override) nella sottoclasse.\r\nDefinire una variabile come Final significa che quella variabile non potrà essere modificata e di conseguenza sarà una costante.Il modificatore final può essere applicato anche ai metodi e classi.Nel caso dei metodi implica che nel caso in cui la classe sia ereditata quel metodo non potrà essere ridefinito.\r\nUna classe definita come final non potrà essere estesa da altre classi. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8848,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8746,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9055,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9050,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9115,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6903,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 956,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Le variabili non possono essere definite abstract (è illogico), mentre possono essere definite final (si comportano poi come delle costanti). Classi e metodi poi possono essere solamente dichiarati (andranno poi definiti) con il metodo abstract. Se su di essi invece utilizziamo il \"final\" non sarà possibile l'override.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9054,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8850,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9049,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8747,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9116,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6889,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 986,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Una classe abstract non può essere istanziata, DEVE essere ereditata da almeno una classe figlio e può contenere metodi abastract( se la classe non è abstract, allora essa non può contenerli), i quali devono essere sovrascritti dalle sottoclassi. Invece, una classe final non può avere sottoclassi.\r\nI metodi final non possono essere sovrascritti, mentre quelli abstract devono esserlo.\r\nLe variabili final sono costanti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8849,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9048,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9114,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8748,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9056,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6447,
          "asker": {
            "courseId": 102,
            "askerId": 953,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per ereditarietà multipla?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ereditarietà"
            },
            {
              "keyword": " classi"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6829,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1009,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Per ereditarietà multipla si intende la possibilità di comporre classi derivando da più di una classe padre.\r\nQuesta tecnica non è consentita da alcuni linguaggi come il Java, mentre è implementabile in altri come il C++.\r\nL'ereditarietà multipla complica molto la gestione della gerarchia di classi. \r\nInfatti ,mentre con l'ereditarietà singola si può rappresentare la gerarchia di classi tramite un albero in cui i rami sottostanti sono figli del ramo superiore,con l'ereditarietà multipla bisogna utilizzare un grafo per poter dare un'esatta rappresentazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8723,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9174,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8972,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9060,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6830,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1036,
                "courseId": 102,
                "courseFinalScore": 31
              },
              "answerText": "Con ereditarietà multipla si intende quando una classe (detta sottoclasse) eredita variabili e metodi da più di una classe (dette superclassi). Sebbene apparentemente possa sembrare molto utile per quanto riguarda flessibilità e riutilizzo del codice, essa porta con sé due problemi prinicipali che l'ereditaretà semplice invece non ha. In primo luogo un problema è l'ambiguità dei nomi, cioè quando sono definiti metodi diversi ma con lo stesso nome all'interno delle superclassi. In secondo luogo è meno efficiente rispetto all'ereditarietà semplice per quanto riguarda la ricerca di variabili e metodi definiti nelle superclassi. Infatti nell'ereditarietà multipla la gerarchia tra classi è strutturata come un grafo e non più come un albero, e quindi la ricerca necessita di molte più operazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9059,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8724,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8969,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9173,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6853,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Si ha ereditarietà multipla quando una classe eredita contemporaneamente da più classi distinte. \r\nIn Java non è permessa ereditarietà multipla tra classi (in altri linguaggi può essere permessa); una classe può invece implementare più interfacce.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9058,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9175,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8725,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8970,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6824,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 952,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "L'ereditarietà multipla permette di creare nuovi modelli sulla base di altre classi/entità già create in precedenza (o importate da una qualche libreria). Nello specifico permette di estendere le caratteristiche di un certo numero di classi alla nuova classe, generando una nuova classe specifica. La nuova classe quindi avrà un'ereditarietà multipla.\r\n\r\nEs: Ho due classi A e B in cui ho rispettivamente delle caratteristiche x e y. Ora creo una terza classe C che estende/eredita A e B. Questa nuova classe quindi avrà tutte le caratteristiche di A e di B cioè x e y.\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8726,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9057,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8971,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9172,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6406,
          "asker": {
            "courseId": 102,
            "askerId": 1028,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Nelle classi che estendono una classe \"abstract\" è possibile scrivere dei metodi (o delle proprietà) in più che non sono stati dichiarati nella classe superclasse?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract "
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6861,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1080,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Assolutamente sì, infatti la classe abstract serve proprio da base per creare altre classi, queste essendo sottoclassi, devono avere o variabili o metodi in più, altrimenti se hai bisogno di un oggetto che sia identico a quello della classe abstract a quel punto basta che togli l'abstract dalla sua definizione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8921,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9171,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9215,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6859,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1098,
                "courseId": 102,
                "courseFinalScore": 14
              },
              "answerText": "Le classi abstract per essere usate devono essere obbligatoriamente estese quindi si, è possibile definire dei metodi non presenti nella classe abstract.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9168,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8923,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9216,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6902,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1058,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Certamente , le classi astratte sono progettate in modo che le sottoclassi che ereditano da esse ne estenderanno le funzionalità implementando nuovi metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9218,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9170,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8922,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6867,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1034,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Le super classi abstract definiscono solamente una lista di metodi e proprietà che la sottoclasse deve implementare obbligatoriamente, questo però non limita l'aggiunta di altre proprietà o metodi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9217,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9169,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8924,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6452,
          "asker": {
            "courseId": 102,
            "askerId": 987,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Fornire un esempio di una funzione soggetta a polimorfismo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6471,
          "asker": {
            "courseId": 102,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le caratteristiche principali dei modificatori \"abstract\"? Indicare brevemente i loro effetti su classi e metodi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Abstract"
            },
            {
              "keyword": " Abstract"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6432,
          "asker": {
            "courseId": 102,
            "askerId": 1068,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "In cosa consiste l'overloading?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Overloading/overriding "
            },
            {
              "keyword": " Overloading/overriding "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6467,
          "asker": {
            "courseId": 102,
            "askerId": 963,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "In programmazione ad oggetti in Java se una classe B estende la classe A perchè è sbagliato scrivere: \"B nome = new A();\" ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6855,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 967,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La classe figlia B, come sappiamo, contiene tutte le variabili e tutti i metodi della classe padre A. Però B, in aggiunta, contiene metodi e variabili non presenti nella classe A.\r\nNel momento nel qualche chiamiamo \"B nome=new A();\" allochiamo in memoria lo spazio per le variabili e i metodi di A. Quindi, nel momento in cui proviamo a modificare una variabile \"x\" appartenente solo alla classe B, non troviamo lo spazio in memoria in cui questa variabile è allocata, poichè abbiamo allocato memoria solo per variabili e metodi di A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8699,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9123,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8843,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8930,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9167,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6844,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1005,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La scrittura \"B nome = new A()\" è scorretta poiché non c'è omogeneità da entrambi i lati. La classe B avrà tutte le caratteristiche della classe A, in quanto sua figlia, e questo soddisfa la relazione B is a A. La relazione nel senso opposto è scorretta in quanto la classe A non può avere tutte e solo le caratteristiche della classe B, e in definitiva la relazione A is a B non è soddisfatta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8931,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9124,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9166,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8841,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8698,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6834,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1075,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché non verrebbe allocata sufficiente memoria per tutti i metodi e le variabili presenti nella classe B ma non nella classe A. Essendo B un'estensione della classe A è chiaro che un oggetto del tipo B occupi più spazio di un oggetto del tipo A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9121,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8697,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9165,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8929,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8840,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6863,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 989,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché si corre il rischio (qualora vengano chiamati metodi/attributi che sono implementati in B ma non in A) di andare a leggere dati inesistenti e/o casuali.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8928,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9164,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8842,
                  "rater": {
                    "raterId": 1010,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8696,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9122,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6478,
          "asker": {
            "courseId": 102,
            "askerId": 941,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "La classe \"NamedPoint\" deriva dalla classe \"Point\".\r\nLa classe \"NamedPoint\" può utilizzare le variabili e i metodi public/protected della classe Point.\r\n\r\nQuindi è possibile avere questo genere di situazione?\r\n   NamedPoint nP = new Point();\r\n\r\nMa avere una situazione cosi:\r\n   Point p = new NamedPoint();\r\nvorrebbe dire che la classe Point può utilizzare variabili e metodi delle sue sottoclassi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ereditarietà"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6448,
          "asker": {
            "courseId": 102,
            "askerId": 1071,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale modo il polimorfismo rende il mantenimento del codice piu gestibile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6462,
          "asker": {
            "courseId": 102,
            "askerId": 764,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi brevemente cosa si intende con polimorfismo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " descrizione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6421,
          "asker": {
            "courseId": 102,
            "askerId": 1022,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Dire quali delle seguenti affermazioni sono vere o false in Java, motivando brevemente la scelta.\r\n1- Le classi abstract hanno costruttori.\r\n2- Una classe abstract può essere anche final.\r\n3- Una classe abstract deve necessariamente contenere metodi abstract.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ABSTRACT"
            },
            {
              "keyword": " ABSTRACT"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6860,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 982,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "1) Vero, le classi abstract hanno costruttori, se non sono interfacce\r\n2) Falso, perché le classi abstract esistono per espandere i metodi, sovrascrivendoli, e final blocca sto procedimento \r\n3) Vero ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8934,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9263,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9189,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8704,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8885,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6857,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1014,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "1 - Vero: le classi abstract possono avere i costruttori i quali hanno hanno come unica utilità quella di inizializzare le variabili relative alla classe-base (astratta) quando vengono richiamati da una delle classi derivate; infatti non verranno mai richiamati in fase di istanziazione in quanto un oggetto di una classe abstract, per definizione, non può essere instanziato.\r\n2 - Falso: una classe abstract non può essere final in quanto deve essere per forza derivata, cosa che non sarebbe possibile dichiarandola final.\r\n3 - False: una classe abstract non deve necessariamente contenere metodi abstract; se però una classe contiene metodi abstract allora deve obbligatoriamente essere definita abstract",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9191,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8883,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8932,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8705,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9265,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6885,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1047,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "1---VERO: questi costruttori hanno senso, infatti potrebbero inizializzare campi private definiti nella classe abstract e possono essere invocati da costruttori di classi figlie. Tuttavia non possono essere utilizzati per istanziare un oggetto della classe abstract.\r\n\r\n2---FALSO: va contro il senso di una classe abstract! Infatti ci si aspetta che una classe abstract prima o poi venga resa concreta nel suo albero di ereditarietà . Associare final e abstract genera errore in compilazione\r\n\r\n3---FALSO: Una classe abstract può anche non avere alcun metodo abstract, tuttavia non può comunque essere istanziata dal suo costruttore. I metodi abstract in ogni caso devono per forza essere contenuti in classi astratte.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9264,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8884,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9190,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8706,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8933,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6463,
          "asker": {
            "courseId": 102,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funzionano static e dynamic binding?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "binding"
            },
            {
              "keyword": " binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6848,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1066,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "dynamic e static binding avvengono quando si applica un metodo ad un oggetto, ora se i metodi sono final, private, static o il costruttore il compilatore può trovare il metodo da applicare (static binding), ma se la classe non è definita a tempo di compilazione, sarà la jvm a dover interpretare la classe del oggetto durante l'esecuzione cosi da chiamare il metodo corretto. \r\nJava usa principalmente il dynamic binding, mentre il c++ usa lo static binding se non diversamente indicato.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9091,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8832,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9132,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9195,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6900,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1103,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In Java lo static binding avviene durante il compile time mentre il dynamic binding avviene nel runtime. I metodi private, static, final e le variabili sono risolti usando static binding il quale rende la loro esecuzione più veloce poichè non c'è tempo sprecato a trovare il corretto metodo a runtime. Dynamic binding il metodo dipende da qual?è la classe a cui obj appartiene a runtime ed il compilatore deve delegare alla JVM la determinazione del metodo a run time.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9197,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9129,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8831,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9093,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6787,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 979,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La creazione del legame tra la chiamata di un metodo e il suo contenuto effettivo è detta binding e può avvenire a compile-time oppure a run-time. Quando il legame viene determinato a compile-time (dal compilatore) si dice static binding; quando, invece, viene determinato a run-time si dice dynamic binding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8829,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9196,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9131,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9090,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6843,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1028,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Il \"dynamic binding\" è un meccanismo nella quale quando viene invocato un metodo sovrascritto, viene chiamato il metodo dell?oggetto allocato in memoria; questo accade perchè il nome del metodo da cercare è associato in run-time, ovvero durante l'esecuzione. In Java è presente solo il \"dynamic binding\". Il C++ invece, (linguaggio volto a migliorare l'efficienza e che affida al programmatore la scelta) esegue i controlli in compile-time, ovvero prima dell'esecuzione. Accade perciò, che se dobbiamo indicare al compilatore che la risoluzione del metodo sovrascritto da chiamare sarà quello allocato in memoria (dynamic), dobbiamo definire il metodo da ereditare come virtuale. Se omettiamo la parola ?virtual? stiamo utilizzando uno ?static binding?, ovvero, in caso di polimorfismo, viene invocato il metodo della super classe che non accetta overriding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9130,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8830,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9194,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9092,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6470,
          "asker": {
            "courseId": 102,
            "askerId": 944,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza fondamentale tra static e dynamic binding (riporta un breve esempio)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": "Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6831,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 970,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Supponiamo di avere una classe Auto, con un metodo accendi(), e nel main avere il seguente pezzo di codice:\r\nAuto a = new Auto();\r\na.accendi();\r\nIn questo caso il tipo di dato è determinato a tempo di compilazione, quindi si parla di static binding.\r\nSupponiamo invece di avere una classe Veicolo, con un metodo accendi(), e una classe Auto che eredita da Veicolo, anch'essa con il suo metodo Accendi() overrided, e nel main questo pezzo di codice:\r\nVeicolo v = new Auto();\r\nv.accendi();\r\nIn questo caso il tipo di dato è determinato a run-time, perchè l'istanza di Auto è anche un'istanza di Veicolo. In questo esempio si parla di dynamic binding\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8981,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 9127,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9072,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8784,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6874,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1042,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "La principale differenza è che lo static binding avviene in fase di compilazione(a compile-time), mentre il dynamic binding avviene in fase di esecuzione (a runtime). Dunque il dynamic binding potrebbe rallentare il programma in quanto rappresenta un'ulteriore operazione da svolgere mentre il programma viene eseguito.\r\nInoltre il dynamic binding viene utilizzato sui metodi che potrebbero essere stati sovrascritti(override) da sottoclassi, mentre lo static binding viene utilizzato sui metodi che sono stati definiti private, static o final (e che quindi non possono essere sovrascritti).\r\n\r\nP.S. Il compito che ti è stato assegnato consisteva nel formulare UNA sola domanda. Non ti è mai stato assegnato il compito di formulare due richieste di cui una da inserire tra parentesi per non farla apparire come un'ulteriore domanda.\r\nA me è stato assegnato l'incarico di rispondere ad una sola domanda e dunque mi limiterò a rispondere ad una sola domanda.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8786,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9070,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8983,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9125,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6915,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 994,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il binding è il processo grazie al quale viene effettuato il collegamento tra una chiamata del metodo e il corpo del metodo stesso. La fondamentale differenza tra static binding e dynamic binding è che nel primo caso le decisioni vengono prese a compile time, nel secondo a runtime.\r\nIn particolare se il metodo è private, static, final o un costruttore, il compilatore sa esattamente che metodo chiamare (static binding), altrimenti il metodo dipende da qual è la classe a cui obj appartiene a runtime ed il compilatore deve delegare alla JVM la determinazione del metodo a runtime (dynamic binding).\r\n\r\nUn esempio è: \r\npublic static void main (String a[])\r\n{ \r\n    Point p;\r\n    if (k==1)\r\n       p=new Point(2,2);\r\n    else\r\n       p=new NamedPoint(3,3,\"A\");\r\n    if (p instanceof NamedPoint)\r\n       ((NamedPoint)p).get Name();\r\n}\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9128,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8982,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 9071,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8783,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6836,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1007,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "La differenza fondamentale tra static e dynamic binding è il fatto che lo static viene sviluppato a compile time mentre il dynamic a run time. Questa differenza è dovuta dal fatto che nel primo caso è possibile sapere a priori tutte le informazioni riguardo alla classe che deve essere utilizzata mentre, nel secondo caso, non è possibile sapere a tempo di compilazione a quale tipo di oggetto si sta facendo riferimento.\r\nAd esempio: public class Veicolo { void sterza() {...} //...} public class Auto extends Veicolo { void sterza() {...} //...} public static void main (String args []) { Auto a = new Auto(); a.sterza(); Veicolo b = new Auto(); b.sterza(); //...} L'istruzione a.sterza viene gestita in modo static in quanto si conosce a tempo di compilazione che la funzione sterza è riferita alla classe auto. Al contrario l'istruzione b.sterza deve essere gestita a compile time dal momento che b è definito come Veicolo e non è quindi possibile sapere a quale metodo \"sterza\" si riferisce.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9073,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8984,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9126,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8785,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6440,
          "asker": {
            "courseId": 102,
            "askerId": 1073,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Non mi è ben chiaro l'utilizzo del polimorfismo, cioè io non potrei fare semplicemente dei metodi con nome diverso invece di creare classi diverse con metodi con lo stesso nome? Ad esempio nelle slide invece che fare le classi OP, somma e sottrazione, fare dei metodi chiamati somma e sottrazione invece che tutti f.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": " Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6442,
          "asker": {
            "courseId": 102,
            "askerId": 943,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si comportano Java e C++ nei confronti del Dynamic Binding e come vengono gestite le 'decisioni al volo'?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": " Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6794,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 939,
                "courseId": 102,
                "courseFinalScore": 30
              },
              "answerText": "Per ciò che riguarda Java, quando si deve associare il tipo ad un oggetto o ad un metodo, il linguaggio ricorre quasi sempre al Dynamic Binding (creando così un?associazione a runtime prendendo delle 'decisioni al volo'). Si ha eccezione quando gli oggetti o i metodi vengono caratterizzati dalle keywords ?static?, ?private? o ?final?: in queste occasioni si ha l?attivazione dello Static Binding, generando così un'associazione tra tipi a compile time.\r\nPer ciò che riguarda C++ il processo funziona più o meno all?opposto: solitamente infatti l?associazione tra le entità richiamate e il suo tipo avviene ricorrendo allo Static Binding; qualora la funzione o l?entità in generale sia però preceduta dalla keyword ?virtual?, allora in questo caso l?associazione avviene in Dynamic Binding.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9040,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8875,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 9224,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6909,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1083,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il c ++ offre la possibilità al programmatore di scegliere se usare il dynamic binding(decisioni prese a run-time) o lo static bynding(decisioni prese a compile-time). Java adotta una politica differente utilizza sempre il dynamic binding tranne nel caso sia possibile decidere automaticamente in tempo di compilazione. Ad esempio se B è una sottoclasse di A java decide \"al volo\"(a run-time) se trattare un oggetto dichiarato di tipo B come un'istanza di A o un' istanza di B.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9041,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8878,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9227,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6803,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1037,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il c++ permette di utilizzare sia lo static che il dynamic binding mentre Java solo il dynamic binding, infatti le decisioni in java vengono fatte al volo. Il dynamic binding si tratta di quando un metodo viene chiamato da un oggetto e viene deciso a runtime il metodo di quale classe utilizzare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9225,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8877,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9042,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6870,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1017,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In C++ il dynamic binding avviene tramite il polimorfismo, in java tramite overriding/overloading.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8876,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 9039,
                  "rater": {
                    "raterId": 943,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 9226,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6407,
          "asker": {
            "courseId": 102,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i rischi di usare il polimorfismo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Polimorfismo"
            },
            {
              "keyword": "Polimorfismo"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6480,
          "asker": {
            "courseId": 102,
            "askerId": 956,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 186,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra static binding e dynamic binding e in quali casi Java e C++ preferiscono l'uno all'altro?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Binding"
            },
            {
              "keyword": "Binding"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6801,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1031,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con lo static binding il tipo di variabile viene deciso a compile-time, mentre con il dynamic binding a run-time. Naturalmente lo static binding è più performante, visto che viene eseguito una sola volta in fase di compilazione e, ogni qualvolta la variabile verrà utilizzata in esecuzione, si saprà già a priori il suo tipo e di conseguenza a quali suoi metodi\\attributi affidarsi. Non è però sempre possibile utilizzare questa tipologia di binding perchè, con lo static binding, si perde il concetto di polimorfismo per il quale è essenziale definire il tipo della variabile a runtime con il dynamic binding.\r\n\r\nIn Java lo static binding avviene per tutte le variabili\\metodi dichiarati static, final e private e per i tipi primitivi, mentre per tutti gli altri casi viene eseguito il dynamic binding. \r\nIn C++ invece verrà utilizzato automaticamente lo static binding, se non per tutto ciò che è stato dichiarato con modificatore virtual.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8926,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8781,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 9002,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6894,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1095,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In java : 1)lo static binding avviene a compile time e il dynamic binding avviene a runtime. 2) le variabili e i metodi private, final, static usano lo static binding che è legato al compilatore mentre i metodi virtuali vengono a runtime e sono legati a oggetti a runtime. 3) static binding usano type Class mentre dynamic binding usa Object. 4) i metodi overloaded  sono usati dagli static binding mentre i metodi overridden sono usati dal dynamic binding. \r\nIn c++: static binding avviene a compile time permettendo al compilatore di identificare univocamente ciascuna funzione a seconda dei parametri passati a tali funzioni, pur avendo lo stesso nome. dynamic binding avviene a runtime ed è realizzato utilizzando le funzioni virtuali.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9003,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8782,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8927,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6846,
              "task": {
                "taskId": 190,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 943,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": ".La differenza tra static e dynamic binding sta nel momento in cui viene determinato quale metodo deve essere invocato in base alla classe di appartenenza dell'oggetto. Nel caso dello static binding, esso sarà stabilito durante la compilazione, mentre nel dynamic viene stabilito a tempo di esecuzione (risultando però più lento). Non sempre il compilatore riesce a stabilire il tipo della variabile e quindi nel caso dello static binding segnalerà un errore durante la compilazione, mentre con il dynamic non vi saranno problemi.\r\nC++ normalmente preferisce lo static binding per restare coerente nella sua ottica di essere un linguaggio di programmazione efficiente. Per usare il dynamic binding devo forzarlo usando la keyword \"virtual\" prima del metodo. \r\nJava invece per essere più flessibile prevede solitamente il dynamic binding, rinunciando però ad essere efficiente, tranne quando vi sono le condizioni per stabilire le decisioni a tempo di compilazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 9004,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8925,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8780,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 190,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "lectureId": 66,
      "lectureTitle": "Richiami di C++",
      "questions": [
        {
          "questionId": 6175,
          "asker": {
            "courseId": 102,
            "askerId": 1066,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Sia m la matrice  di c colonne e r righe allocata dinamicamente, individuare le criticità e gli eventuali errori della seguente funzione e riportarne una possibile correzione:\r\n// La funzione \"cerca\" prende un array di stringhe e ritorna un array contenente solo le stringhe che iniziano con un determinato carattere, ad esempio, date le stringhe {cane, gatto, foto, macchina, gioco} e dato il carattere `g` l'output dovrà essere {gatto, gioco}\r\ntypedef char** matrice;\r\nmatrice cerca(matrice m, int c, char iniziale)\r\n{\r\n  bool uscita=false;\r\n  for(int i=0; (i<=c)&&(uscita==false);i++)\r\n  {\r\n    if(m[0][i]==iniziale)\r\n           uscita=true;\r\n    else delete[] m[0][i]\r\n   }\r\nreturn m;\r\n}\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6211,
          "asker": {
            "courseId": 102,
            "askerId": 942,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponendo di avere una variabile t di tipo struct s. Si passano ad una funzione i PUNTATORI ad alcuni campi, ma non a tutti: è possibile cercare di accedere in lettura anche agli altri campi della variabile t tramite l'aritmetica dei puntatori? In che problemi si rischia di incorrere nell'eseguire una funzione che implementa un meccanismo di lettura in questo senso?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6599,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1018,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Certo, è possibile e questo ne è un esempio in C:\r\n\r\n#include <stdio.h>\r\nstruct test {char a;char b;};\r\nvoid main() {   \r\n    struct test prova = {'A', 'B'};\r\n    printf(\"\\nIndirizzo di a = %u\", &prova.a );\r\n    printf(\"\\nIndirizzo di b = %u\", &prova.b);\r\n    printf(\"\\nValore di b ottenuto dal puntatore ad a = %c\\n\", *(&(prova.a)+1) );\r\n    return; \r\n}\r\n\r\nCome si vede da questo esempio, il valore di 'b' è ottenuto scorrendo la memoria a partire dall'indirizzo di 'a', l'unico puntatore effettivamente passato all'ultima printf.\r\nGli ovvi problemi in cui è possibile incappare utilizzando questo meccanismo di lettura, sono quelli derivanti dai tentativi d'accesso a locazioni di memoria non correttamente inizializzate per errori implementativi, input non validato, overflows etc.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7995,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7998,
                  "rater": {
                    "raterId": 1048,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7929,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7905,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6590,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1071,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Si, si potrebbe accedere alle altre variabili utilizzando l'aritmetica dei puntatori. Si potrebbe incorrere in problemi di indici oltre i limiti definiti dalla new eseguita su s.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7906,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7992,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7999,
                  "rater": {
                    "raterId": 1048,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7928,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6579,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1070,
                "courseId": 102,
                "courseFinalScore": 10
              },
              "answerText": "Supponendo che si conosca come è fatto il tipo struct s (come è composto, int susseguito da int, double e ancora int per esempio), è possibile accedere ai campi della variabile t dello stesso tipo di quelli a cui abbiamo i puntatori in ingresso (se passo un puntatore ad uno qualsiasi dei campi int di t, posso accedere agli altri campi di tipo int). Leggento i campi della variabile t in questo modo è però possibile accedere e leggere celle di memoria non relative alla struct; ovvero è possibile incappare in errori di lettura (confondere il valore di una cella adiacente ad una occupata da un campo della variabile t per una cella essa stessa relativa ad un campo della variabile t, e dunque attribuire il valore sbagliato a quel campo di t) e anche accedere a celle non relative alla variabile t in questione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7991,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7996,
                  "rater": {
                    "raterId": 1048,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7932,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7904,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6567,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1065,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'aritmetica dei puntatori permette di accedere ad aree di memoria precedenti o successive all'indirizzo di memoria a cui il puntatore sta puntando. In questo modo possiamo andare a leggere anche ad altri campi della variabile t. Nel farlo però bisogna essere estremamente sicuri di come la macchina ed il compilatore gestiscono le aree di memoria: infatti eseguendo una funzione che implementa un meccanismo di lettura in questo senso, corriamo il rischio di far puntare il nostro puntatore ad altre variabili del programma o, ancora peggio, a zone di memoria destinate ad altri processi, andando ad intaccare valori e parametri diversi da quelli che si intendevano modificare.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8000,
                  "rater": {
                    "raterId": 1048,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7993,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7930,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7907,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6536,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 980,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sì, è possibile accedervi tramite l'aritmetica dei puntatori,ovviamente a patto di conoscere le posizioni reciproche dei puntatori (ossia di fatto i loro indirizzi), proprio questo infatti è ciò che può causare vari errori: la mancanza di certezza riguardo alla variabile a cui si sta accedendo e che si sta modificando.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7903,
                  "rater": {
                    "raterId": 942,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7931,
                  "rater": {
                    "raterId": 1074,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7997,
                  "rater": {
                    "raterId": 1048,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7994,
                  "rater": {
                    "raterId": 462,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6121,
          "asker": {
            "courseId": 102,
            "askerId": 1009,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella versione 6 dell'implementazione della Pila in C++, sono stati utilizzati gli indicatori di visibilità ( public e private) e sono stati associati a variabili e metodi della classe Pila. Qual è il loro significato e il loro compito?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6170,
          "asker": {
            "courseId": 102,
            "askerId": 1036,
            "courseFinalScore": 31
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Come si dichiara un vettore in modo statico? E come si dichiara dinamicamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6176,
          "asker": {
            "courseId": 102,
            "askerId": 1035,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi di usare le classi rispetto alle struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6243,
          "asker": {
            "courseId": 102,
            "askerId": 1092,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali differenze ci sono tra classe e struct in c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Classi"
            },
            {
              "keyword": " Classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6125,
          "asker": {
            "courseId": 102,
            "askerId": 952,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella presentazione \"Richiami C++\" (slide 40) c'è un esercizio in cui, in una funzione definita come g(), si modifica l'indirizzo di un puntatore associato ad una variabile con l'operatore ++. In questo caso, quindi, l'indirizzo non è il primo di una sequenza di celle (punt. ad array) ma bensì l'indirizzo di una sola celletta.\r\nIl pezzo di codice descritto poco sopra è questo:\r\n    \r\n    int main(){\r\n        int k = 5;\r\n        g(&k);\r\n    }\r\n    \r\n    void g(int* m){ \r\n        m++; \r\n    }\r\n    \r\nLa mia domanda è questa: questo codice ha sempre un output definito ? E' possibile che avvenga una violazione di memoria (quando si fa il ++) ed otteniamo un output indeterminato ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6149,
          "asker": {
            "courseId": 102,
            "askerId": 946,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Se istanzio qualche oggetto (variabile) tramite allocazione dinamica sono \"obbligato\" a ricordarmi di liberarne la memoria altrimenti ricado nel memory leak. La memoria occupata però rimane tale solo durante il tempo di vita dell'eseguibile o anche dopo fintanto che non interviene il Garbage Collector?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6184,
          "asker": {
            "courseId": 102,
            "askerId": 985,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Che funzione svolge un cosiddetto \"Marker\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Marker"
            },
            {
              "keyword": " Marker"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6161,
          "asker": {
            "courseId": 102,
            "askerId": 976,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "che tipo di dati sono salvati rispettivamente nello stack e nel heap?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "allocazione"
            },
            {
              "keyword": " memoria"
            },
            {
              "keyword": " stack"
            },
            {
              "keyword": " heap"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6484,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 967,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nello stack vengono salvate le variabili locali e i parametri formali delle funzioni (N.B. Non le variabili globali o static).\r\nIn heap, invece, vengono salvate la variabili allocate dinamicamente dal programmatore durante l'esecuzione del programma.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7623,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7693,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7893,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7718,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7706,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6469,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1002,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nel heap sono salvayi dati relativi alle allocazioni dinamiche, invece lo stack contiene i record di attivazione delle procedure/funzioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7694,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7719,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7624,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7890,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7707,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6548,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 956,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "Lo stack e la heap vengono utilizzati da alcuni programmi (per es. da C++) per tenere in memoria dei dati durante l'esecuzione di un programma. La memoria libera che il programma potrà utilizzare si trova tra questi due: ogni volta che il programma dovrà allocare staticamente una variabile (ad esempio una variabile locale di una funzione) farà crescere lo stack, viceversa se il programma dovrà allocare dinamicamente una variabile lo farà nella heap. Questi due tipi di memoria crescono colmando lo spazio che si trova tra i due e, in caso di collisione, il programma terminerà con un errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7894,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7716,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7704,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7691,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7621,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6559,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 984,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nello stack vengono salvati i dati allocati staticamente o a \"compile-time\", nello heap i dati allocati dinamicamente o a \"run-time\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7688,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7713,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7892,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7701,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7618,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6573,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1096,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nell'area heap sono salvati tutti i tipi di dati allocati dinamicamente quali: int, char, puntatori, struct ma anche array di cui non si conosce la dimensione nel momento della compilazione.\r\nMentre nell'area stack sono salvati i tipi di dati allocati staticamente.\r\nEsiste una fondamentale differenza fra dati statici e dinamici, i primi vengono deallocati nel momento in cui si esce dal blocco in cui sono stati creati, salvo comandi  per prolungarne la vita. Diversamente i dati dinamici non solo vengono interamente gestiti tramite puntatori, ma è compito del programmatore deallocarli tramite l'apposita funzione delete, se ciò non accade si incorre nel grave problema del memory leak.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7689,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7619,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7702,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7891,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7714,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6494,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1078,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nello stack sono salvati dati di tipo statico, mentre nella heap sono presenti dati di tipo dinamico(dei quali non si conosce la loro dimensione a tempo di compilazione). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7889,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7622,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7692,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7705,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7717,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6518,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 928,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nello stack vengono salvati i dati che vengono allocati automaticamente dalle funzioni: lo stack viene utilizzato per le funzioni che, una volta restituito il valore, possono liberare lo spazio che occupavano precedentemente).\r\n\r\nNello heap vengono salvati i dati allocati dinamicamente dal programmatore: queste sono utili nel caso in cui al programmatore occorra che il valore memorizzato non si cancelli alla fine della funzione (es: \"char *a = new char[10]\" verrà cancellata dal programmatore con la parola chiave \"delete\" che provvederà a pulire la memoria quando il valore memorizzato non servirà più - bisogna fare attenzione ai memory leak - ).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7895,
                  "rater": {
                    "raterId": 1039,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7620,
                  "rater": {
                    "raterId": 945,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7703,
                  "rater": {
                    "raterId": 976,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7715,
                  "rater": {
                    "raterId": 1082,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7690,
                  "rater": {
                    "raterId": 988,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6122,
          "asker": {
            "courseId": 102,
            "askerId": 493,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa avviene nello stack quando viene chiamata una funzione ricorsiva?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6535,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1054,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando viene chiamata una funzione ricorsiva nello stack viene creato un record di attivazione per ogni volta che la funzione ricorsiva viene chiamata, cioè più la funzione ricorsiva richiede passaggi per essere completata più occupa spazio nello stack.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7165,
                  "rater": {
                    "raterId": 1061,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7877,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7465,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7816,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7218,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7758,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6610,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1081,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Lo stack cresce progressivamente, espandendosi nello spazio di memoria adiacente allo stack stesso, ad ogni chiamata ricorsiva. Raggiunto il caso base della funzione ricorsiva, i vari blocchi di memoria utilizzati dallo stack vengono rilasciati progressivamente al termine di ogni funzione chiamata ricorsivamente. Lo spazio in memoria utilizzato durante l'esecuzione della funzione ricorsiva sarà dunque proporzionale al numero di chiamate ricorsive, ma verrà in buona parte rilasciato al termine della funzione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7754,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7214,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7461,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7872,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7166,
                  "rater": {
                    "raterId": 1061,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7814,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6565,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 986,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Quando una funzione viene chiamata, nello stack si crea uno spazio apposito utilizzato per allocare le variabili usate dal metodo chiamato. Quando la funzione termina, lo spazio occupato dalla funzione viene liberato(non deallocato, poichè la deallocazione si presenta a fine programma).\r\nLa funzione ricorsiva continua a chiamare sé stessa finché non soddisfa una certa condizione, dunque lo stack per ogni metodo ricorsivo chiamato continuerà ad allocare le variabili fino a che non verifica la condizione per uscire dalla ricorsione. Quando la ricorsione è terminata lo stack si libera passando per tutte le funzioni chiamate, ovvero l'ultima funzione libererà lo stack per prima e il primo metodo chiamato libererà la memoria per ultimo. \r\nSi può presentare un problema con le funzioni ricorsive, ovvero può capitare che lo stack sia pieno e l'allocazione di una variabile non vada a buon fine.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7216,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7874,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7756,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7817,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7463,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7163,
                  "rater": {
                    "raterId": 1061,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6462,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 485,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando viene chiamata una funzione ricorsiva nello stack, esso si allunga ed anche lo scope della funzione si allunga ad ogni chiamata di essa, mentre lo stack si accorcia quando la funzione ritorna un valore ed allo stesso modo si accorcia lo scope.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7755,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7818,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7462,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7215,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7876,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7161,
                  "rater": {
                    "raterId": 1061,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6537,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 944,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Al momento della chiamata di una funzione ricorsiva, nello stack viene innanzitutto allocato un blocco di memoria destinato a contenere i parametri formali e le variabili automatiche della funzione. Quindi, ad ogni chiamata successiva, ne viene allocato un altro identico al precedente, creando così una struttura a pila. Questo processo si ripete sino a quando non si raggiunge la condizione di terminazione della funzione ricorsiva, momento in cui i blocchi cominciano ad essere deallocati in sequenza, dall'ultimo al primo, liberando così la memoria occupata in precedenza.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7873,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7219,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7466,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7164,
                  "rater": {
                    "raterId": 1061,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7759,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7819,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6560,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 962,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Con la ricorsione lo stack viene occupato per un numero di istanze pari alle chiamate della funzione che è necessario effettuare per risolvere il problema. La ricorsione è quindi sconsigliata se l'obiettivo primario sono le prestazioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7815,
                  "rater": {
                    "raterId": 1017,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7875,
                  "rater": {
                    "raterId": 493,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7757,
                  "rater": {
                    "raterId": 856,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7464,
                  "rater": {
                    "raterId": 980,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7217,
                  "rater": {
                    "raterId": 998,
                    "courseId": 102,
                    "courseFinalScore": 11
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7162,
                  "rater": {
                    "raterId": 1061,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6137,
          "asker": {
            "courseId": 102,
            "askerId": 860,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè nel seguente esempio della Pila le funzioni crea e copia vengono richiamate con un puntatore?\r\n\r\nPila * crea(int initialSize) ;\r\nvoid distruggi(Pila * s) ;\r\nPila * copia(Pila * from) ;\r\nvoid cresci(Pila *s, int increment); ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6186,
          "asker": {
            "courseId": 102,
            "askerId": 1058,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra l'heap e lo stack di una memoria? Che cosa accade quando definiamo dei dati dinamici senza poi deallocarli? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA "
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6131,
          "asker": {
            "courseId": 102,
            "askerId": 966,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché all?interno della funzione ?estrai? è necessario utilizzare la funzione ?assert?? Cosa potrebbe accadere se non fosse inclusa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6557,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 955,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La funzione assert è una funzione di controllo che è necessario usare perché altrimenti non sarebbe verificata la condizione di stack vuoto. Nel caso che non fosse inclusa la funzione \"estrai\" andrebbe ad estrarre un valore che non appartiene all'array allocato dallo stack.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7982,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7341,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8058,
                  "rater": {
                    "raterId": 934,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7479,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7916,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8062,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6511,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 464,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "La funzione assert si occupa di asserire un'affermazione. Il comportamento è simile a quello dell'if, ma si occupa solitamente delle sezioni critiche. \r\nSe la condizione all'interno dell'assert viene valutata a vero non succede nulla. Invece, se la condizione all'interno delle parentesi di assert viene valutata a falso durante l'esecuzione, il codice verrebbe terminato.\r\nNel caso della funzione estrai quindi, se marker è uguale o minore di 0 (comportando quindi che la condizione sia falsa) la funzione assert non da il permesso al sistema di estrarre un elemento dalla pila. \r\nSe la funzione assert non fosse presente all'interno del codice e si rientrasse nel caso critico in cui marker <= 0, non verrebbe ritornato l'ultimo elemento della pila (perché inesistente), e la funzione avrebbe un comportamento non definito ritornando una locazione di memoria che potrebbe sforare la memoria allocata al processo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7481,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8060,
                  "rater": {
                    "raterId": 934,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7343,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8063,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7912,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7983,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6586,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1052,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Certo, la funzione \"assert\" è necessaria a controllare che la pila non sia vuota.\r\nNel caso in cui non ci fosse, la funzione \"estrai\" ritornerebbe il valore presente nella cella di memoria immediatamente precedente al primo elemento dell'array, che non è di competenza della pila e che avrebbe un valore del tutto imprevedibile.\r\nTutto questo senza la visualizzazione di alcun messaggio d'errore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8057,
                  "rater": {
                    "raterId": 934,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7480,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7342,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7981,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7914,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8065,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6525,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1028,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Alla funzione assert viene inviato un valore booleano (true o false), ovvero la valutazione della condizione \"marker > 0\". Essendo marker un intero che indica la posizione del prossimo elemento della pila, potremo estrarre un elemento dalla pila solo se marker è positivo. Se non fosse invocata la funzione assert, non ci sarebbe stato alcun controllo e restituirebbe un valore presente in parti di memoria non definite dal programmatore senza alcuna avvertenza da parte del compilatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8064,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7344,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7482,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7915,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8056,
                  "rater": {
                    "raterId": 934,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7985,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6507,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 972,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Assert valuta l'espressione passata come parametro e in caso la valutazione sia false scrive l'errore nello standard output ed esce dal programma. Viene utilizzata nella funzione estrai per controllare che ci sia almeno un elemento nello stack, se non fosse fatto verrebbe decrementato il marker che andrebbe in negativo causando errori. \r\nIl controllo poteva essere effettuato anche tramite un if, ma questo metodo è preferibile per effettuare il debug.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8059,
                  "rater": {
                    "raterId": 934,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7478,
                  "rater": {
                    "raterId": 953,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7340,
                  "rater": {
                    "raterId": 966,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8061,
                  "rater": {
                    "raterId": 1062,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7913,
                  "rater": {
                    "raterId": 1095,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7984,
                  "rater": {
                    "raterId": 860,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6144,
          "asker": {
            "courseId": 102,
            "askerId": 1007,
            "courseFinalScore": 16
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo il linguaggio di programmazione C riesce a sopperire alla mancanza di un tipo primitivo \"string\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "string"
            },
            {
              "keyword": "string"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6504,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1063,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In C esiste il char, un tipo di dato primitivo che rappresenta un singolo carattere. C tratta quindi le stringhe come degli array di caratteri in questo modo: viene creato un array di char di lunghezza massima N, e viene considerata stringa il vettore di caratteri terminante con l'elemento contenente il carattere '\\0', indicato anche come NULL.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7282,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7600,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7383,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7837,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7133,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7315,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6554,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 982,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Tramite un array di char e tramite alcune librerie specializzate",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7281,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7314,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7833,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7382,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7135,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7599,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6482,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 948,
                "courseId": 102,
                "courseFinalScore": 22
              },
              "answerText": "In C si sopperisce a questo problema mediante l'utilizzo di array di char.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7378,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7132,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7595,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7310,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7832,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7277,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6523,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1098,
                "courseId": 102,
                "courseFinalScore": 14
              },
              "answerText": "Questo problema si risolve creando un array di char, riconosciuto dal linguaggio che in automatico mette come ultimo carattere dell'array  \"/0\" per indicare la fine della stringa. Questo comporta che la reale dimensione della stringa sia la dimensione-1.  ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7836,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7379,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7596,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7278,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7311,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7130,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6513,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 471,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Il linguaggio C sopperisce a questa mancanza trattando in modo particolare gli array di caratteri: in primo luogo una stringa avrà come ultimo carattere un terminatore, '\\0', che servirà a delimitare la stringa. Questo comporta che un array di N caratteri potrà contenere una stringa al massimo lunga N-1 caratteri, l'ultima cella è infatti destinata al carattere di terminazione. Inoltre, diversamente dai normali array, gli array di caratteri possono essere inizializzati in maniere differente, come 'char s[5]=\"ciao\"; in questo caso il carattere terminatore verrà aggiunto in automatico, attenzione però alla dimensione, potrebbe uscire dalla locazione riservata all'array. Infine anche le funzioni delle librerie standard, come le operazioni per l'input/output, trattano in modo particolare gli array di caratteri.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7134,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7597,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7312,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7279,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7380,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7838,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6530,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 963,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Le variabili di tipo \"string\" nel linguaggio C sono definite come array di caratteri. Questo vettore contiene la sequenza di caratteri che forma la stringa, seguita dal carattere terminatore '\\0'. Ad esempio per definire la stringa \"ciao\" bisognerà inizializzare un array di minimo 5 elementi. Per inizializzare esplicitamente la stringa, il valore deve essere racchiuso tra doppi apici.\r\nIn C è presente inoltre la libreria \"string.h\" che permette la manipolazione delle stringhe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7834,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7381,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7313,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7131,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7280,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7598,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6475,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 993,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In C per sopperire alla mancanza del tipo \"String\" si utilizzano array di caratteri. La stringa si considera terminata quando all'interno dell'array si incontra il carattere '\\0'. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7594,
                  "rater": {
                    "raterId": 946,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7309,
                  "rater": {
                    "raterId": 1007,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7276,
                  "rater": {
                    "raterId": 1064,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7377,
                  "rater": {
                    "raterId": 997,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7129,
                  "rater": {
                    "raterId": 1081,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7835,
                  "rater": {
                    "raterId": 961,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6167,
          "asker": {
            "courseId": 102,
            "askerId": 1073,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi dell'allocazione dinamica? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Allocazione_memoria"
            },
            {
              "keyword": " allocazione_memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6209,
          "asker": {
            "courseId": 102,
            "askerId": 464,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Dato il riferimento ad una variabile, c'è un modo (a run time) per capire se è stato chiamato l'operatore delete su quella variabile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6218,
          "asker": {
            "courseId": 102,
            "askerId": 914,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si intende per \"allocazione di memoria statica\" e \"allocazione di memoria dinamica\"? In cosa differiscono i due tipi di allocazione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "memoria"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6233,
          "asker": {
            "courseId": 102,
            "askerId": 870,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè dato uno stream di input di dimensione n caratteri, la stringa risultante avrà lunghezza n+1? Spiegare con un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STRINGHE"
            },
            {
              "keyword": " STRINGHE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6112,
          "asker": {
            "courseId": 102,
            "askerId": 951,
            "courseFinalScore": 15
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Passando per parametro ad una funzione una struct viene duplicata l'intera struct o viene passato solamente un puntatore a quella struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "classi"
            },
            {
              "keyword": "classi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6245,
          "asker": {
            "courseId": 102,
            "askerId": 943,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Non mi è chiaro perchè nella dichiaranzione di una variabile globale è sconsigliabile l'uso del define (es: #define N 100), mentre è preferibile utilizzare la sintassi: 'const int N=100'.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6242,
          "asker": {
            "courseId": 102,
            "askerId": 940,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Si analizzi il seguente frammento di codice e se ne determini l'output. Se si ritiene che il codice contenga degli errori, specificarli nella risposta.\r\n\r\nNota: si considerino anche eventuali errori che impediscano la compilazione del programma.\r\n\r\n#include <iostream>\r\n#include <cstring>\r\n\r\nusing namespace std;\r\n\r\nconst int DIM = 30;\r\n\r\nclass Person {\r\n\tchar name[DIM+1];\r\n\tint age;\r\n\tchar address[DIM+1];\r\n\tpublic:\r\n\t\tPerson(char aname[DIM+1], int anage, char anaddress[DIM+1]);\r\n};\r\n\r\nPerson::Person(char aname[DIM+1], int anage, char anaddress[DIM+1]) {\r\n\tstrcpy(name, aname);\r\n\tage = anage;\r\n\tstrcpy(address, anaddress);\r\n}\r\n\r\nint main() {\r\n\tPerson* pippo = new Person(\"Pippo\", 20, \"Via Sommarive, 8, TN\");\r\n\tcout << pippo->name << '\\n'\r\n\t        << pippo->age << '\\n'\r\n\t\t<< pippo->address << '\\n';\r\n\treturn 0;\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6163,
          "asker": {
            "courseId": 102,
            "askerId": 441,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In C/C++ non esiste il tipo di dato primitivo \"stringa\"; spiegare come vengono allora \"distinte\" dagli altri array e qual'è la lunghezza massima di una stringa contenuta in un array di lunghezza N.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stringhe"
            },
            {
              "keyword": " Array"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6207,
          "asker": {
            "courseId": 102,
            "askerId": 1048,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Deallocando un'area di memoria, il suo contentuo viene immediatamente cancellato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Memoria"
            },
            {
              "keyword": " Memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6152,
          "asker": {
            "courseId": 102,
            "askerId": 1075,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è il memory leak e quali accorgimenti è necessario attuare per evitarlo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6463,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 947,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il memory leak è la situazione nella quale ci si trova quando la memoria allocata nel corso del programma non viene deallocata mentre essa non ha più una funzione all'interno del programma stesso. Per evitare il memory leak bisogna stare attenti a deallocare, appunto, la memoria usata quando finito di utilizzarla, sovrascrivendo per esempio puntatori o altri oggetti allocati dinamicamente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7516,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8051,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7138,
                  "rater": {
                    "raterId": 1060,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7831,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7270,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7541,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6491,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 978,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il memory leak è il particolare fenomeno che avviene quando all'interno di un programma che cicla più volte il programmatore si dimentica di deallocare delle variabili dinamiche.\r\nDifatti, lo spazio in memoria occupato da delle variabili allocate dinamicamente rimane occupato fino a quando il programmatore decide di deallocarle. Nel caso in cui ciò accade lo spazio della memoria occupata da esse viene liberato e quindi può essere riutilizzato per altre variabili.\r\nTuttavia, se ci si dimentica di deallocare le variabili si corre il rischio di riempire la memoria e quindi incappare in errori che possono avvenire in qualsiasi punto del programma.\r\nPer evitare questo problema basta stare attenti a tutte le variabili dinamiche che si creano e ricordarsi di deallocarle di volta in volta.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7545,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8053,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7136,
                  "rater": {
                    "raterId": 1060,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7520,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7826,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7274,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6611,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1029,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il memory leak è un particolare tipo di consumo indesiderato di memoria causato dalla mancata deallocazione di variabili/dati non più utilizzati da parte dei processi.Può essere diagnosticato solo da un programmatore che ha accesso al codice sorgente. \r\nGli accorgimenti che si possono attuare per evitare il memory leak sono le revisioni del codice sorgente per identificare dove non è stata deallocata la memoria, rimediando al precedente errore.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7271,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7141,
                  "rater": {
                    "raterId": 1060,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7828,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8055,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7542,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7517,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6601,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1036,
                "courseId": 102,
                "courseFinalScore": 31
              },
              "answerText": "Con memory leak si intende della memoria che è stata allocata ma non liberata, anche se non viene più utilizzata. Per evitarlo è necessario ricorrere alla funzione delete(*p) che va a deallocare la memoria puntata dal puntatore p.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7830,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7544,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8052,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7140,
                  "rater": {
                    "raterId": 1060,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7519,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7273,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6509,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 535,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Con memory leak si intende una situazione in cui la memoria disponibile nella heap non è sufficiente per poter immagazzinare le informazioni necessarie per l'esecuzione di un programma; ciò comporta un errore e l'interruzione del programma. \r\nÈ necessario, poiché la gestione della memoria in heap è affidata al programmatore, che la memoria non più utilizzata venga rilasciata, così da permetterne il riutilizzo. In questo modo si evitano problemi di memory leak.\r\nIn particolare, programmando in C++, ogni volta che si usa l'operatore new è necessario porre un delete per rilasciare la memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8054,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7272,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7518,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7543,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7827,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7137,
                  "rater": {
                    "raterId": 1060,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6609,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1074,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il memory leak è un errore che viene dato da un eccesso consumo della memoria, causato soprattutto dal mancato deallocamento delle variabili/dati non piu' utilizzate dai processi. Per evitare questo errore bisogna ricordarsi di deallocare tutte le variabili.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7546,
                  "rater": {
                    "raterId": 1075,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8050,
                  "rater": {
                    "raterId": 996,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7829,
                  "rater": {
                    "raterId": 1019,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7139,
                  "rater": {
                    "raterId": 1060,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7275,
                  "rater": {
                    "raterId": 986,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7521,
                  "rater": {
                    "raterId": 1008,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6241,
          "asker": {
            "courseId": 102,
            "askerId": 1055,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa viene restituito quando uso l'operatore \"new\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6465,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1062,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La new ritorna un puntatore all'oggetto creato. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7935,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7785,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7506,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7841,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7188,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6617,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1067,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "L'operatore new costruisce uno o più oggetti nell'area heap e restituisce un puntatore alla base della memoria allocata.\r\nSintassi: new   tipo   [dimensione]   (valore iniziale)\r\n(dimensione e valore iniziale possono essere non inseriti, in questi casi la dimensione sarà di un elemento e non ci sarà inizializzazione)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7783,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7191,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7509,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7844,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7936,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6497,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 465,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "mi restituisce il nuovo indirizzo allocato dinamicamente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7504,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7186,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7938,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7842,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7787,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6466,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 941,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Tramite l'operatore \"new\" viene restituita una nuova istanza di un oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7508,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7937,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7190,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7839,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7786,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6592,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 953,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "l'operatore new \"costruisce\" uno o più oggetti nell'area heap e ne restituisce l'indirizzo. In caso di errore (nel caso in cui la memoria fosse esaurita) restituisce NULL.  La sintassi dell'operatore è la seguente:\r\n\r\nnew tipo_variabile [dimensione](valore iniziale)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7784,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7934,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7187,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7843,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7505,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6470,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 949,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "L'operatore new viene usato per istanziare oggetti e strutture dinamiche.\r\nRestituisce sempre un puntatore all'entità creata, sia essa un oggetto, una struct o un tipo di dato elementare.\r\nDi default, in C++, solleva un errore quando non riesce ad allocare la memoria (nello heap), applicando l'operatore nothrow, invece, restituisce un puntatore nullo.\r\nIl suo funzionamento può essere modificato mediante la definizione di un costruttore personalizzato all'interno dell'oggetto o della struct, in modo da non rendere necessario l'invocazione di una specifica funzione che allochi e inizializzi le variabili interne.\r\nIn C++, a differenza di altri linguaggi, come Java, è necessario deallocare tutta la memoria allocata mediante l'uso dell'operatore delete, onde evitare memory leaks e errori del programma.\r\nIn Java questo non è necessario perchè è presente il garbage collector, uno strumento che elimina automaticamente la memoria non più necessaria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7507,
                  "rater": {
                    "raterId": 983,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7840,
                  "rater": {
                    "raterId": 1055,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7189,
                  "rater": {
                    "raterId": 1059,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7933,
                  "rater": {
                    "raterId": 951,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7782,
                  "rater": {
                    "raterId": 962,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6224,
          "asker": {
            "courseId": 102,
            "askerId": 1082,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Come vengono gestite le stringhe in c++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STRINGHE"
            },
            {
              "keyword": "STRINGHE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6115,
          "asker": {
            "courseId": 102,
            "askerId": 939,
            "courseFinalScore": 30
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa si definisce in informatica con \"array circolare\"? Dare una definizione esaustiva, sottolineando quale sia il suo stretto rapporto con il concetto di operazione modulo (%) e fornendo un esempio di una sua possibile applicazione nella vita di tutti i giorni.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6200,
          "asker": {
            "courseId": 102,
            "askerId": 1076,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Supponendo di avere una parte di codice come nella pagina 23 delle slides Richiami di C++, è possibile definire a come array invece che semplice variabile e trattarlo come un puntatore?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": "PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6232,
          "asker": {
            "courseId": 102,
            "askerId": 1071,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra Stack e Heap? Come vengono gestiti dal sistema operativo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6166,
          "asker": {
            "courseId": 102,
            "askerId": 992,
            "courseFinalScore": 18
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Che cos'è ,da cosa è causato e come si può evitare un memory leak?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6182,
          "asker": {
            "courseId": 102,
            "askerId": 1021,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Considerando il C++ come linguaggio di programmazione di riferimento quali sono i file che compongono una libreria in modo da poter essere esportata e utilizzata efficacemente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6575,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1006,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I file che compongono una libreria sono solitamente a coppie:\r\n-un file \".h\" contiene gli header (dichiarazioni) delle funzioni di libreria più eventuali struct, costanti, ridefinizioni di tipo ed altri dati di possibile interesse all'utilizzatore della libreria.\r\n-un file \".cc\" (o \".cpp\", \".C\" etc...) invece contiene le definizioni complete delle funzioni, includendo anche funzioni static, ovvero funzioni richiamabili solo dall'interno della stessa libreria, ma anche algoritmi segreti che non si vogliono divulgare.\r\nInfatti della coppia di file solo il file header deve essere in chiaro, mentre il file sorgente può essere offuscato e/o compilato in una forma intermedia (file oggetto) utilizzabile dal linker ma illeggibile da un umano.\r\nDella coppia di file, solo il file sorgente è compilato o linkato insieme agli altri file che appartengono ad un progetto: i file header sono inclusi dal preprocessore prima della compilazione, previo utilizzo del pragma \"#include\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7370,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7640,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7327,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7552,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7400,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7203,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6527,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1009,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Una libreria in C++ è composta da due file: un file .cc nel quale si scriveranno le definizioni delle funzioni di libreria e altre funzioni ausiliarie(che servono da supplemento per le funzioni di libreria vere e proprie, ma rimarranno inaccessibili all'esterno e quindi dichiarate \"static\"), e un file .h( header file) il quale contiene le dichiarazioni delle funzioni di libreria e la definizione di eventuali strutture dati, tipi, ecc.\r\nIl file .h deve utilizzare le cosiddette \"guardie di compilazione\" (#ifndef FILE_H #define FILE_H  ... #endif) per evitare che esso venga caricato ripetutamente durante l'esecuzione del programma.\r\nIl file .cc dovrà includere il file.h col comando #include \"file.h\".\r\nLo stesso dovrà esser fatto in qualunque altro file nel quale si voglia utilizzare qualche funzione della libreria.\r\nL'utente riceverà il file.h che funge da 'manuale' per comprendere il funzionamento delle funzioni, e un file .o (ottenuto compilando il .cc) che nasconde le funzioni stesse.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7639,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7369,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7202,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7326,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7551,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7399,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6595,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1012,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "I file che compongono una libreria in C++, pronta per essere utilizzata efficacemente e distribuita, comprendono: \r\n\r\n- file di intestazione (header files): dovrebbero contenere solo e soltanto le dichiarazioni delle componenti (come funzioni, classi o variabili) che vogliamo siano utilizzate, accompagnandole inoltre con commenti adeguati a descriverne scopo ed utilizzo;\r\n\r\n- file con codice sorgente (source files): possono essere pre-compilati (in modo statico o dinamico), in uno o più file, per ogni piattaforma/architettura in cui intendiamo utilizzare la nostra libreria oppure distribuiti open-source;\r\n\r\n- documentazione (ed eventualmente tutorials) che descriva il corretto utilizzo della libreria affinchè possa essere utilizzata efficacemente anche da terzi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7200,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7324,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7549,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7637,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7397,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7367,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6600,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1047,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "In C++ per poter usare una libreria si necessita del file header (.h), che contine le dichiarazioni delle funzioni e delle strutture dati, e del file oggetto(.o) che realizza quanto dichiarato nello header. Chi utilizza la libreria non ha quindi bisogno del file con il codice sorgente che contiene le definizini delle varie funzioni e strutture dati della libreria. In questo modo si rispetta il principio di incapsulamento (information hiding) in modo tale che i vari programmatori che si servono di una stessa libreria conoscano solo il funzionamento ma non la realizzazione di questa.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7325,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7201,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7368,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7398,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7550,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7638,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6514,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 957,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I file di header contenenti le dichiarazioni delle funzioni e i file contenenti il codice vero e proprio delle funzioni di libreria (?)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7395,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7635,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7198,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7365,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7547,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7322,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6480,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 782,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "file .dll compilati ed eseguibili",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7366,
                  "rater": {
                    "raterId": 1021,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7396,
                  "rater": {
                    "raterId": 1023,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7548,
                  "rater": {
                    "raterId": 1040,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7636,
                  "rater": {
                    "raterId": 963,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7323,
                  "rater": {
                    "raterId": 992,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7199,
                  "rater": {
                    "raterId": 985,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6236,
          "asker": {
            "courseId": 102,
            "askerId": 953,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra ambiente non locale e ambiente globale (in uno specifico blocco)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Ambiente"
            },
            {
              "keyword": " blocchi"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6157,
          "asker": {
            "courseId": 102,
            "askerId": 1047,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali vantaggi che riguardano l'allocazione dinamica di un array rispetto all'utilizzo di array statici? Elencarne almeno tre argomentando in maniera breve ma chiara.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6165,
          "asker": {
            "courseId": 102,
            "askerId": 1049,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Dopo aver interiorizzato il meccanismo di sviluppo di uno stack in c/c++ implementato a lezione, studiare più approfonditamente la funzione 'cresci'. Fino a che punto è possibile accrescere la pila senza rallentare/bloccare il calcolatore? In caso avessimo una pila di un numero elementi superiore al milione, varrebbe ancora la pena implementare la funzione in questo modo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6177,
          "asker": {
            "courseId": 102,
            "askerId": 1019,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In C++ quali sono le principali differenze tra una classe e una struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6246,
          "asker": {
            "courseId": 102,
            "askerId": 943,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Non mi è chiaro perchè nella dichiaranzione di una variabile globale è sconsigliabile l'uso del define (es: #define N 100), mentre è preferibile utilizzare la sintassi: 'const int N=100'.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6110,
          "asker": {
            "courseId": 102,
            "askerId": 948,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Le classi e le struct in java hanno le stesse caratteristiche che hanno in C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6113,
          "asker": {
            "courseId": 102,
            "askerId": 967,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Domanda tipo esame:\r\n\r\nCome si potrebbe reimplementare il seguente codice (situato alla slide 23 del file \"richiami c++\") utilizzando sempre una funzione void ma evitando l'uso dei puntatori?\r\n\r\nvoid incrementa(int *px)\r\n{\r\n    *px=*px+1;\r\n}\r\n\r\nmain(void)\r\n{\r\n    int a=1;\r\n    incrementa(&a);\r\n    cout << a << endl;\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6127,
          "asker": {
            "courseId": 102,
            "askerId": 1013,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi le funzionalità degli operatori new e delete. Qual'è un errore insidioso che si verifica in seguito a uno scorretto uso degli operatori new e delete?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6619,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 870,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In c++ gli operatori new e delete sono dediti alla gestione della memoria dinamica. In particolare il primo serve ad allocare un quantitativo di memoria adatto a contenere una variabile di tipo specificato, mentre il secondo è riservato alla deallocazione di una variabile dinamica precedentemente dichiarata tramite new. \r\nUn uso scorretto di questi due operatori (ad esempio un mancato utilizzo di delete) può portare a problemi relativi a memory leak. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7415,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7649,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7583,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7285,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7247,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6490,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 764,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"new\" serve per l'allocazione di memoria ovvero per una prenotazione all'interno dello heap di una determinata quantità di memoria, dipendente dal tipo, l'operatore \"delete\" invece serve per deallocare quello che è stato allocato tramite new, serve quindi a cancellare una parte di memoria all'interno dello heap che precedentemente era stata prenotata.\r\nCi possono essere due errori nell'utilizzo di questi operatori, il più frequente è quello di allocare della memoria senza poi deallocarla causando un memory leak ovvero uno spreco della memoria, ciò è causato dall'uso di new dimenticandosi di usare delete, il secondo errore è causato dall'utilizzo di variabili allocate dinamicamente all' esterno dello scope di visibilità dell' allocazione stessa quindi all' esterno degli operatori new e delete.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7652,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7288,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7250,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7418,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7586,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6551,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1001,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "L'operatore ?new? alloca dinamicamente un?entità di tipo T specificato nello heap e, se l'operazione è andata a buon fine, ritorna l'indirizzo della memoria appena allocata. In caso contrario viene lanciata l'eccezione bad_alloc e il programma termina, a meno che non si usi il \"nothrow\", che restituisce un puntatore a NULL in caso di fallimento.\r\nL?operatore ?delete\" invece dealloca l?entità precedentemente allocata all?indirizzo di memoria indicato da un puntatore passato nella chiamata all?operatore. Il suo comportamento è definito solo se il puntatore passato è un puntatore a NULL oppure un puntatore ottenuto attraverso l?operatore new.\r\nL?entità creata dall?espressione new persiste finché non viene deallocata con l?operatore delete. Se il valore originale del puntatore viene perso prima della deallocazione, l?entità diventa irraggiungibile e non può più essere deallocata: in tal caso si crea un memory leak, ovvero quell'area di memoria diventa inutilizzabile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7248,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7650,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7416,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7584,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7286,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6564,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1022,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Gli operatori new e delete sono usati per l'allocazione di memoria dinamica. L'operatore new (new type) alloca uno spazio di memoria pari a sizeof(type) bytes nella memoria heap e ne restituisce un puntatore della memoria, cioè l'indirizzo della memoria allocata. Se la memoria disponibile non è sufficiente per la richiesta, restituisce NULL o genera un'eccezione. La memoria allocata in modo dinamico dall'operatore new può essere liberata mediante l'operatore delete. In altre parole l'operatore delete(*p) dealloca la memoria puntata dal puntatore p. L'operatore delete non ritorna niente e richiama inoltre il distruttore della classe qualora fosse presente. Il mancato uso dell'operatore delete provoca un errore chiamato memory leak, cioè \"perdita di memoria\" dovute al fatto che la memoria allocata dall'operatore new nell'archiviazione disponibile non viene mai liberata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7284,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7648,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7414,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7582,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7246,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6464,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 911,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L' operatore new alloca spazio in memoria per un nuovo oggetto con il suo corrispondente tipo di dato.\r\nL'operatore delete invece serve per deallocare la memoria allocata per quel dato oggetto con l'operatore new. Uno scorretto uso di questi operatori, come allocare memoria e non deallocarla in seguito è il memory leak. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7413,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7647,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7283,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7581,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7245,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6598,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1030,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Gli operatori new e delete permettono di gestire l?allocazione dinamica ovvero permettono di gestire la memoria durante l?esecuzione del programma. L?accesso avviene tramite puntatori. L?operatore new alloca un?area di memoria nello heap adatta a contenere un oggetto (o dimensione oggetti) del tipo specificato. Questo ritorna poi un indirizzo che è l?indirizzo della prima celletta di tale area di memoria al quale verrà poi associato un puntatore. L?operatore delete ha come argomento un indirizzo, il quale deve essere un indirizzo di una celletta precedentemente allocata da una chiamata a new. Il suo compito è quello di deallocare l?area di memoria indicata dall?indirizzo, quindi quell?area di memoria non sarà più riservata e potrà essere ri-allocata. L?errore insidioso dell?allocazione dinamica è il memory leak ovvero dello spreco di memoria. Per evitare questo errore quindi è necessario che ad ogni chiamata di new sia associata, prima o poi, una delete.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7289,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7653,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7419,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7251,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7587,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6501,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 462,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L?operatore ?new? in C++ viene utilizzato per allocare in modo dinamico la memoria. Questo operatore permette la costruzione di un oggetto in un'area della RAM chiamata Heap e restituisce un puntatore al relativo indirizzo in memoria. In caso di errore o esaurimento di memoria restituisce NULL. L?operatore ?delete? viene invece usato per deallocare la memoria dinamica, quella allocata attraverso l'operatore ?new?. La ?delete? da un risultato di tipo void e quindi non restituisce un valore. Nel caso in cui si voglia deallocare un array, bisogna specificarlo con ?delete[]?. Una variabile che non viene deallocata con l?operatore ?delete?, rimane allocata fino alla terminazione del programma, anche nel caso in cui non venisse più referenziata. Dimenticarsi di deallocare una cella non più referenziata comporta un \"memory leak\", ovvero un insidioso errore che crea un?occupazione involontaria della memoria senza la possibilità di liberarne.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7651,
                  "rater": {
                    "raterId": 1013,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7287,
                  "rater": {
                    "raterId": 1043,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7585,
                  "rater": {
                    "raterId": 957,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7249,
                  "rater": {
                    "raterId": 1009,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7417,
                  "rater": {
                    "raterId": 944,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6181,
          "asker": {
            "courseId": 102,
            "askerId": 1012,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Data la seguente classe in C++:\r\n\r\nclass MiaClasse {\r\n    int foo;\r\npublic:\r\n    MiaClasse(int _foo) {\r\n        foo = _foo;\r\n    }\r\n    int A(int foo) {\r\n        return foo;\r\n    }\r\n    int B(int foo) {\r\n        return this->foo;\r\n    }\r\n};\r\n\r\n\"int MiaClasse::A(int)\" e \"int MiaClasse::B(int)\" sono due metodi equivalenti? Motivare la risposta.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6111,
          "asker": {
            "courseId": 102,
            "askerId": 485,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "All'interno di una Struct, se voglio dichiarare una funzione che precedentemente era esterna la riscrivo nello stesso modo oppure devo cambiare il passaggio dei parametri?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "struct"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6140,
          "asker": {
            "courseId": 102,
            "askerId": 1027,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "La mia domanda riguarda l'efficienza delle ripetute allocazioni di memoria e delle ripetute copie degli array che vengono effettuate nell'implementazione della pila da lei proposta a lezione. Come è possibile che la pila sia gestita in modo efficiente se, all'esaurimento dello spazio di memoria allocata, tutto l'array viene spostato in una nuova area di memoria?\r\nNon è un'azione dispendiosa che incide pesantemente nell'esecuzione, data l'illimitata (teoricamente possibile) grandezza dell'array? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6188,
          "asker": {
            "courseId": 102,
            "askerId": 941,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cito \"RichiamiCpp2016.ppt.pdf\":\r\n\"In C e C++ non esiste il tipo di dato primitivo \"stringa\". Tuttavia le funzioni di libreria di I/O trattano in modo speciale le regioni di memoria contenenti dei \"char\" (arrays di caratteri).\"\r\n\r\nTuttavia io ricordo di aver utilizzato il tipo di dato 'string' in vari programmi in C++ , e si trovano molti esempi anche in Internet.\r\nQuindi deduco che il tipo di dato 'string' esista, allora la mia domanda è questa: \r\nin C++ il tipo di dato 'string' è \"rischioso\" da usare (per problemi di compatibilità, leggibilità...)? Oppure non viene usato solo ai fini didattici (per non confondere le idee)?\r\n\r\n\r\nGrazie.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STRINGHE"
            },
            {
              "keyword": " STRINGHE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6160,
          "asker": {
            "courseId": 102,
            "askerId": 1020,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Come viene gestita la memoria heap quando vi è una richiesta di allocazione tramite operatore 'new' e come viene gestita dal sistema dopo l'operatore 'delete'?\r\nspiegare attraverso degli esmpi utilizzando:\r\n   s->contenuto=new int[initialSize];\r\ne\r\n   delete [](s->contenuto);\r\n   delete s;\r\nspezzoni di codice presi dalle slide dell'ultima lezione\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6156,
          "asker": {
            "courseId": 102,
            "askerId": 1053,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi nell'allocare dinamicamente o staticamente una variabile?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6603,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 968,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In generale l'allocazione dinamica viene usa quando si hanno programmi che gestiscono database, o programmi che gestiscono elenchi e quindi hanno bisogno di spazi variabili. Però l'allocazione dinamica è svantaggiosa perche rischia di creare memory leak, ossia perdite di memoria, legate alla non deallocazione della memoria riservata. L'allocazione statica viene usata quando si devono gestire un numero di elemento ben definiti, che non variano nel tempo, quindi si sa che hanno bisogno solo di un determinato spazio, inoltre un vantaggio di questa allocazione è che non ha bisogno di essere deallocata. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7721,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7523,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7241,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7953,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7170,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7942,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7178,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6577,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1000,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Allocando staticamente una variabile lo spazio di memoria è gestito dal sistema e non dal programmatore come nel caso dell' allocazione dinamica quindi il programmatore non deve preoccuparsi di de-allocare la memoria lo svantaggio è che per esempio non si può modificare la grandezza di un array mentre allocando dinamicamente si.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7243,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7168,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7525,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7176,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7941,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7951,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7723,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6561,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1079,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il vantaggio nell'allocazione statica di una variabile sta nel fatto che la memoria allocata è gestita automaticamente dal sistema; cioè durante l'esecuzione, non appena si esce dal blocco di visibilità di una certa variabile allocata staticamente, la memoria riservata per tale variabile viene deallocata dal sistema e resa disponibile. Tuttavia, se una variabile contiene dei dati, per esempio vettori, la cui dimensione sarà nota solo a runtime, occorre ipotizzare quale sarà il massimo spazio occupato dai dati e allocare una tale quantità di memoria: questo comporta spesso uno spreco di memoria.\r\nPer l'allocazione dinamica valgono le considerazioni simmetriche: è più difficile da gestire perchè la memoria riservata a una variabile allocata dinamicamente deve essere deallocata esplicitamente dal programmatore quando non la si utilizza più, altrimenti tale memoria rimane indisponibile fino al termine del programma. Vantaggio: la dimensione di un vettore può essere definita a runtime.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7167,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7724,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7940,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7952,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7175,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7244,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7526,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6607,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 536,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Allocazione statica: la memoria viene allocata all'avvio del programma ed essa esisterà finché il programma non termina;\r\nAllocazione dinamica: avviene all'interno di un blocco e, nel caso del c++, esisterà finché non chiamiamo la delete.\r\nVANTAGGI E SVANTAGGI: \r\nA. Statica: \r\n- Consente un accesso più rapido ai dati in quanto non si passa attraverso operatori di dereferenziazione, non vi possono essere memory leaks.\r\nA. Dinamica: Nel caso in cui abbiamo bisogno di molta memoria è meglio allocarla dinamicamente in modo da utilizzarla e liberarla nel momento del bisogno; \r\nla memoria allocata dinamicamente sopravvive anche dopo la fine di una determinata funzione, al di fuori del proprio \"scope\"; \r\nci permette di creare strutture di grandezza variabile richiedendo altra memoria se necessario es. Pila e Coda .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7169,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7720,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7950,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7522,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7943,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7177,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7240,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6542,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1008,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "ALLOCAZIONE STATICA\r\nVantaggi:\r\n-Avviene in automatico\r\n-Variabili deallocate automaticamente al termine del blocco in cui sono definite\r\nSvantaggi:\r\n-Variabili/dimensione array definiti a compiler-time\r\n-Necessario modificare il codice per cambiare ad es. la dimensione di array\r\n\r\nALLOCAZIONE DINAMICA\r\nVantaggi:\r\n-Variabili/dimensione array definiti a run-time\r\n-Possibile implementare strutture dati dinamiche\r\nSvantaggi:\r\n-Avviene manualmente (almeno in C/C++)\r\n-Possibili segmentation fault e memory leak (allocazione/deallocazione scorretta)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7179,
                  "rater": {
                    "raterId": 1005,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7954,
                  "rater": {
                    "raterId": 987,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7171,
                  "rater": {
                    "raterId": 882,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7524,
                  "rater": {
                    "raterId": 941,
                    "courseId": 102,
                    "courseFinalScore": 20
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7939,
                  "rater": {
                    "raterId": 1054,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7722,
                  "rater": {
                    "raterId": 1083,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7242,
                  "rater": {
                    "raterId": 1053,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6183,
          "asker": {
            "courseId": 102,
            "askerId": 950,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste un qualche modo in C/C++ per generalizzare il concetto di puntatore ad una qualsiasi area di memoria, slegato dal tipo di contenuto?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Puntatori"
            },
            {
              "keyword": " Area di memoria"
            },
            {
              "keyword": " basso livello"
            },
            {
              "keyword": " generalizzazione"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6234,
          "asker": {
            "courseId": 102,
            "askerId": 1043,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivere brevemente quali potenziali vantaggi offre l' utilizzo di puntatori nello sviluppo di Software nel linguaggio C++ e quali sono invece alcune problematiche che possono sorgere dal loro utilizzo.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "puntatori"
            },
            {
              "keyword": "puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6226,
          "asker": {
            "courseId": 102,
            "askerId": 1044,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Operatore THIS\r\n\r\nAlloco staticamente (nello stack) una struttura Pila (del tipo visto a lezione).\r\nAll'interno della struttura dichiaro una funzione propria della pila nominata estrai.\r\nDefinisco la funzione estrai nel seguente modo:\r\n\r\nint Pila::estrai() {\r\n    //estrai l?ultimo valore\r\n    cout<<\"entro in estrai\"<<endl;\r\n    assert(this.marker>0);\r\n    return this.contenuto[--(this.marker)];\r\n}\r\n\r\nDal main la funzione estrai viene chiamata con s.estrai (dove s è la pila allocata nello stack).\r\nIl compilatore termina riportando un errore. \r\n\r\nUtilizzando invece l'allocazione dinamica e usando this->....  funziona tutto.\r\n\r\nSembra che this sia un operatore utilizzabile solamente con una struttura allocata dinamicamente.\r\n\r\n\r\n\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STRUCT"
            },
            {
              "keyword": "STRUCT"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6239,
          "asker": {
            "courseId": 102,
            "askerId": 997,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Durante la costruzione dello stack, nell'esempio visto a lezione, abbiamo scritto la funzione \"Crea\". Perché è necessario fare una copia della pila in uno spazio più grande per poter aggiungere elementi, anziché allocare memoria per tanti elementi quanti indicati dal DefaultGrowSize?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6119,
          "asker": {
            "courseId": 102,
            "askerId": 999,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra <endl> e <\"\\n\">? Perchè accade ciò?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "endl"
            },
            {
              "keyword": " "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6178,
          "asker": {
            "courseId": 102,
            "askerId": 1085,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è il funzionamento della memoria stack?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Memoria"
            },
            {
              "keyword": "stack"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6225,
          "asker": {
            "courseId": 102,
            "askerId": 1052,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "(Possibile domanda d'esame) è più efficiente effettuare la copia di un array di stringhe o effettuare la copia dei puntatori di un array di puntatori a stringhe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": " stringhe"
            },
            {
              "keyword": " puntatori"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6231,
          "asker": {
            "courseId": 102,
            "askerId": 1067,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Come funziona l'accrescimento della pila?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Allocazione_memoria"
            },
            {
              "keyword": " allocazione_memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6248,
          "asker": {
            "courseId": 102,
            "askerId": 1101,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra JAVA e C?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "java"
            },
            {
              "keyword": " c"
            },
            {
              "keyword": " differenze"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6173,
          "asker": {
            "courseId": 102,
            "askerId": 1001,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "C'è differenza tra int *a[5] e int (*a)[5]?\r\nSe si, spiegarla attraverso un semplice programma che li utilizzi entrambi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6237,
          "asker": {
            "courseId": 102,
            "askerId": 965,
            "courseFinalScore": 17
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "La corretta gestione della memoria in c/c++ è un'abilità fondamentale di un buon programmatore. \r\nPunto uno: Illustrare con un esempio in c o c++, commentando, un corretto utilizzo dello stack. \r\nPunto due: Uno degli errori più diffusi in progetti di grandi dimensioni, sono i MEMORY LEAK, in cosa consistono? Quali tecniche utilizzerebbe per evitarli?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6196,
          "asker": {
            "courseId": 102,
            "askerId": 1078,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In quale tipo di memoria vengono salvate le variabili all interno di un programma che richiama funzioni? Come è strutturato tale tipo di memoria? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": " Funzioni"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6213,
          "asker": {
            "courseId": 102,
            "askerId": 1068,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Che differenza c'è tra un'allocazione in heap rispetto ad un'allocazione in stack?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Allocazione_Memoria "
            },
            {
              "keyword": " Allocazione_Memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6123,
          "asker": {
            "courseId": 102,
            "askerId": 981,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i pericoli che si rischiano utilizzando i puntatori in un programma?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6533,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 999,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I pericoli che si corrono sono: memory leaks, ottenere output completamente errati e segmentation fault, oltre ad un mantenimento del codice più difficoltoso. Un puntatore e' una variabile contenente un indirizzo di memoria. Ad esempio se un puntatore e' stato definito come puntante ad un tipo char, e si copia in una variabile int, sara' trasferito solo 1 byte (non 2) nella variabile int, dall'indirizzo a cui puntava il puntatore. Mentre se puntava un dato di tipo float avrebbe copiato troppo, 4 bytes. Questi errori portano a malfunzionamenti seri dei programmi e di tutto il sistema operativo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7573,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7495,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7145,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7172,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7142,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7561,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6553,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1049,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I rischi portati dall'utilizzo dei puntatori in c/c++ sono soprattutto dovuti ad errori di sintassi del programmatore, ancora alle prime armi con il linguaggio. Un programma che utilizza svariati puntatori, con relative operazioni tra loro, crea spesso confusione e può renderne difficile la lettura. Un altro rischio è dovuto alla mancanza di distruttore. I puntatori vengono utilizzati, nella maggior parte dei casi, in coppia con l'allocazione dinamica, allocando uno spazio di memoria in heap con il comando new e dando tale indirizzo al puntatore. L'errore del programmatore sta nel dimenticarsi di chiamare il distruttore (delete) a fine programma creando memory leaking. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7574,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7147,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7144,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7174,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7496,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7562,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6594,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1017,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I pericoli più frequenti consistono nell'incappare in un'assegnazione indiretta illegale oppure nell'utilizzare un puntatore prima di assegnarlo",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7494,
                  "rater": {
                    "raterId": 1027,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7173,
                  "rater": {
                    "raterId": 972,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7560,
                  "rater": {
                    "raterId": 1050,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7146,
                  "rater": {
                    "raterId": 1035,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7572,
                  "rater": {
                    "raterId": 981,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7143,
                  "rater": {
                    "raterId": 441,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6174,
          "asker": {
            "courseId": 102,
            "askerId": 974,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "\"In c++ un array statico viene solitamente indicato con nomeArray[dimensioneArray] (es. a[5]). Questa sintassi è in realtà uno zucchero sintattico che nasconde un puntatore.\" \r\nSpiega cosa si intende con questa frase e fai un esempio.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6467,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 856,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "A livello computazionale l'array è un puntatore alla prima locazione di memoria occupata dal contenuto dell'array stesso. Poiché i puntatori sono notoriamente anti-intuitivi e complessi è più efficace per il programmatore passare un array a una funzione utilizzando la sintassi nomeArray[dimensioneArray] in modo da \"autoannotare\" il codice, rendendo esplicito l'uso di un array (e non di un puntatore qualsiasi), e la dimensione dell'array stesso (in modo da controllare più efficacemente i vincoli sull'indice).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7696,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7589,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7820,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7511,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7576,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7372,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6563,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 493,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Infatti, quando definiamo un array statico di questo tipo è come definire un puntatore che punta all'inizio dell'array, cioè al primo elemento. Ad esempio, a[5] possiamo vedere come un puntatore che punta alla elemento a[0] e man mano che ci spostiamo all'interno di questo array, si sposta il puntatore, se vogliamo accedere al secondo elemento dell'array, il puntatore va avanti finche non trova la cella a[1] e si ferma li.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7513,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7578,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7374,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7591,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7698,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7822,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6510,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1020,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "quando dichiariamo un array di dimensione 'n' in realtà richiediamo una porzione di memoria contigua che può contenere 'n' variabili del tipo prestabilito e otteniamo un puntatore al primo elemento di questo blocco di memoria.\r\nquindi quando scriviamo a[0] in realtà stiamo utilizzando un puntatore al primo elemento del blocco di memoria riservato per l'array.\r\nesempio:\r\nint a[2];\r\na[0]=0;\r\na[1]=1;\r\n\r\ncon 'int a[4];' riservo in memoria uno spazio per poter 2 variabili intere.\r\ncon 'a[0]=0'; punto all'indirizzo di memoria (ipoteticamente 0146FA14) del primo elemento del vettore e gli assegno il valore di 0\r\nla stessa cosa con 'a[1]=1;' che punterà ipoteticamente all'indirizzo di memoria 0146FA18",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7824,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7590,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7697,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7373,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7577,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7512,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6472,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1055,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Dichiarare un array è paragonabile a dichiarare un puntatore che punta alla prima casella dell'array dichiarato.\r\nESEMPIO: v[5]: dichiarazione di un vettore con 5 caselle (=dimensione)\r\nche si può rappresentare come: |0|1|2|3|4| indici da 0 a 4 = dimensione 5.\r\n*v cioè il puntatore nascosto dallo zucchero sintattico della dichiarazione sopra; questo puntatore punterà alla casella dove l'indice è 0.\r\nQuesto significa che ci si può muovere all'interno di un vettore anche con l'aritmetica dei puntatori.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7376,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7700,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7515,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7593,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7823,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7580,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6477,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 976,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La scritta \"tipo nome_array[dimensione]\" è un costrutto creato per facilitare la programmazione allo sviluppatore, il computer invece vede \"tipo *nome_array; nome_array=new tipo[dimensione]\".\r\nlo sviluppatore accede ad una variabile del array utilizzando la scritta \"nome_array[indice]\", ma viene tradotta come \"*(nome_array+indice)\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7821,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7575,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7588,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7371,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7510,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7695,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6583,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1007,
                "courseId": 102,
                "courseFinalScore": 16
              },
              "answerText": "L'array statico è definito come una sequenza di elementi dello stesso tipo disposti nello stack consecutivamente. Quindi, ad esempio, se viene dichiarata una variabile \"int a[5]\" questa indica un array che può contenere 5 numeri interi. È possibile affermare che questa sintassi è uno zucchero sintattico in quanto 'a' contiene l'indirizzo di memoria del primo elemento dell'array (a[0]) ed è quindi, di fatto, un puntatore ad intero. Di conseguenza l'assegnazione \"a[3]=1;\" può essere facilmente riscritta  come \"*(a+3)=1;\". In questo ultimo caso viene utilizzata l'aritmetica dei puntatori: a+3 indica l'indirizzo di a[0] a cui vengono aggiunti 3*(sizeof(int)) bytes; viene applicato successivamente l'operatore di dereference * per poter accedere al contenuto della variabile da modificare.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7825,
                  "rater": {
                    "raterId": 1014,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7375,
                  "rater": {
                    "raterId": 1052,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7579,
                  "rater": {
                    "raterId": 485,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7592,
                  "rater": {
                    "raterId": 58,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7699,
                  "rater": {
                    "raterId": 1072,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7514,
                  "rater": {
                    "raterId": 974,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6134,
          "asker": {
            "courseId": 102,
            "askerId": 1022,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiegare a cosa servono e come sono gestite le aree di memoria denominate stack e heap.\r\nIllustrare inoltre in modo chiaro cosa si intende per allocazione statica e allocazione dinamica, specificandone differenze e metodi implementativi.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6117,
          "asker": {
            "courseId": 102,
            "askerId": 1008,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa intendiamo per \"gestione dinamica della memoria\" e cosa la differenzia dalla gestione statica?\r\nDove vengono salvate di solito le variabili allocate dinamicamente?\r\nQual è la sintassi utilizzata in C++ per allocare/deallocare dinamicamente?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6222,
          "asker": {
            "courseId": 102,
            "askerId": 958,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa può succedere se si inseriscono dei dati (che siano interi, float o caratteri) in un array, andando oltre la sua dimensione (oltre N, o con un indice negativo) ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6503,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 987,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "A run time si va in una situazione di errore del tipo Segmentation fault se vado oltre la sua dimensione. Se invece pongo un indice negativo non ottengo nessuna segnalazione di errore però tutte le opreazioni svolte su questi indici non vengono eseguite.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8001,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7805,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7355,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7491,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7628,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6499,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 527,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Succede che vengono scritti in una zona di memoria che non appartiene all'array stesso, sovrascrivendo quindi aree di memoria in cui non so esattamente cosa vi sia memorizzato.\r\nIn c++ questo non da errore, quindi può portare a situazioni catastrofiche, ad esempio se vengono sovrascritte aree di memoria utilizzate da altre funzioni.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7801,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7356,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7492,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8003,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7629,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6543,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 991,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Il problema si pone se si stà programmando in C/C++ poiché non viene effettuato alcun controllo sugli indici degli array (questo perché il linguaggio punta a valorizzare l'efficienza del codice); sia nel caso di indici negativi che in quello di indici che superano la dimensione dell'array, il programma accede alle aree di memoria indicate e può liberamente leggerne il contenuto e modificarle (si potrebbe quindi creare un conflitto con un altro processo che sta utilizzando quell'area).\r\nQuesto accade perché un array, una volta definito, è paragonabile ad un puntatore. Infatti, considerato l'array A, la scrittura A[i] è analoga ad *(A+i); in particolare se i è negativo accederò ad un'area di memoria posta prima dell'indirizzo puntato da A.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7803,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8005,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7354,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7490,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7627,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6500,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 41,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I dati vengono inseriti in una locazione di memoria che è fuori dall'array (out of bounds) e può sovrascrivere dati di altre variabili o funzioni o, nella migliore delle ipotesi, scrivere su una zona di memoria non utilizzata. In ogni caso può solo causare problemi.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7489,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7804,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8004,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7353,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7626,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6614,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1046,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per quanto riguarda il c++: se si inseriscono dati oltre la dimensione dell'array (sia in positivo che in negativo) si rischia di andare a sovrascrivere zone di memoria che non sono proprie dell'array, che quindi potrebbero contenere altre informazioni",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7802,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8002,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7357,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7630,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7493,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6541,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1021,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "In C++ non è presente alcun tipo di controllo per quanto riguarda l'inserimento di dati in un array. È quindi compito del programmatore evitare di sovrascrivere parti della memoria a cui non dovrebbe avere accesso. Nel caso si presentasse la situazione proposta dalla domanda il programma andrebbe semplicemente a scrivere nella cella di memoria corrispondente ignorando il fatto che potrebbe essere utilizzata da un'altra variabile e causando possibili errori e malfunzionamenti.\r\nJava d'altro canto effettua controlli rispetto all'indice utilizzato impedendo la modifica di dati al di fuori dell'array e bloccando l'esecuzione del programma per segnalare l'errore. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7806,
                  "rater": {
                    "raterId": 958,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8006,
                  "rater": {
                    "raterId": 1068,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7352,
                  "rater": {
                    "raterId": 968,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7488,
                  "rater": {
                    "raterId": 1063,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7625,
                  "rater": {
                    "raterId": 977,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6193,
          "asker": {
            "courseId": 102,
            "askerId": 782,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa sono e che differenza c'è tra stack e heap? Fornire un esempio di variabili allocate in heap e stack.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "Stack"
            },
            {
              "keyword": " heap"
            },
            {
              "keyword": " memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6162,
          "asker": {
            "courseId": 102,
            "askerId": 1017,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Fornire un esempio di codice che generi uno stack overflow",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6135,
          "asker": {
            "courseId": 102,
            "askerId": 1034,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nell'esempio di pila presentato a lezione in c++ viene deallocato prima l'array del contenuto rispetto alla pila stessa?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6203,
          "asker": {
            "courseId": 102,
            "askerId": 1042,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In c/c++, qual'è la differenza tra \"#define N 100\" e \"const int N = 100;\"? Se esistono, come si scrivono le corrispondenti istruzioni in java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6212,
          "asker": {
            "courseId": 102,
            "askerId": 1045,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché i linguaggi C/C++, ogni qualvolta si dichiara un puntatore,  richiedono al programmatore di specificare il tipo dell'elemento contenuto nella cella di memoria puntata  invece che utilizzare un tipo universale \"Puntatore\" o \"Indirizzo\" ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": "PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6521,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 990,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "Principalmente per due motivi:\r\n\r\n1. TYPE SAFETY: C\\C++ sono linguaggi detti fortemente tipizzati il che significa che il compilatore necessita di effettuare un check statico dei tipi al momento della compilazione per garantire che le espressioni scritte dal programmatore siano coerenti dal punto di vista dei tipi coinvolti. Se esistesse un tipo universale di puntatore non sarebbe possibile in alcun modo per il compilatore determinare il tipo di un espressione del tipo (*ptr) rendendo impossibile un check statico dei tipi.\r\n\r\n2. DETERMINAZIONE DIMENSIONI OGGETTO PUNTATO: grazie a questo e' possibile determinare le dimensioni dell'oggetto a cui un puntatore fa riferimento. Questo permette di implementare operazioni aritmetiche come ad esempio ++ptr, utili per scorrere gli elementi di un array, che altrimenti non sarebbero implementabili non conoscendo a priori la quantità di cui e' necessario incrementare un puntatore per farlo puntare al prossimo oggetto in memoria dello stesso tipo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7501,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7764,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7978,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7557,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7867,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7882,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7927,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6597,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 966,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Quando si dichiara un puntatore è necessario specificare il tipo dell'elemento \"puntato\" in quanto, nei linguaggi C/C++, non tutti gli oggetti occupano lo stesso spazio nella memoria (e spesso anche lo stesso tipo di elemento può occupare una quantità di memoria diversa su macchine diverse). Se così non fosse potrebbero verificarsi problemi di allocazione della memoria come \"Segmentation Fault\" o \"Memory Leaks\". Inoltre, specificando il tipo degli oggetti puntati, miglioriamo la lettura e la chiarezza del codice.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7975,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7871,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7502,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7558,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7765,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7879,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7922,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6588,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1095,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nei linguaggi c e c++ quando si dichiara un puntatore è obbligatorio associarlo ad un tipo particolare di dato, esempio: è possibile assegnare l'indirizzo di un int ad un int ma non è possibile assegnare l'indirizzo di un int ad un float o di uno short int ad un long int ecc...\r\nEsiste un puntatore generico (\"universale\") nei casi in cui ottenere una coerenza non è molto semplice per esempio nei casi in cui vogliamo puntare a una procedura/funzione o nei casi in cui vogliamo accedere ad un numero di n byte(il tipo byte non esiste), in questi casi utilizziamo il puntatore generico void che ha massima compatibilità con tutti i puntatori e può contenere qualsiasi indirizzo.\r\nPertanto non avrebbe senso usare sempre un puntatore \"universale\" quando sappiamo di che tipo è.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7497,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7553,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7760,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7870,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7883,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7976,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7926,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6531,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1035,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il puntatore punta a un indirizzo in memoria e riserva il blocco di memoria necessario a quel tipo di elemento; ma  la dimensione del tipo di dato dipende dalle caratteristiche del processore della macchina, dunque per sapere quanta memoria riservare per un dato elemento c'è bisogno di specificarne il tipo.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7925,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7866,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7884,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7980,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7500,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7763,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7556,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6532,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 945,
                "courseId": 102,
                "courseFinalScore": 26
              },
              "answerText": "Conoscere il tipo dell'elemento contenuto nella cella di memoria puntata è necessario per sapere il tipo risultante dalla sua dereferenziazione e in quanto influenza l'aritmetica legata al puntatore infatti qualunque sia il tipo del puntatore, se al puntatore viene sommato 1, il puntatore assumerà l'indirizzo originario + sizeof(tipo puntato). In particolare questo è importante nel caso di un array in cui incrementando di 1 l'indirizzo del puntatore, il puntatore punterà automaticamente all'indirizzo dell'elemento seguente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7878,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7921,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7559,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7974,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7766,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7865,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7503,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6552,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 985,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché il compilatore deve essere in grado di decodificare il contenuto del puntatore e non accetta un tipo di dato generico.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7761,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7880,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7554,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7869,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7498,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7979,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7923,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6528,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 988,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perchè in questo modo il programma sa quanta memoria deve leggere ed evita così di accedere a memoria non utilizzata da quell'oggetto o di terminare la lettura prima della fine.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7762,
                  "rater": {
                    "raterId": 1015,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7924,
                  "rater": {
                    "raterId": 1099,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7881,
                  "rater": {
                    "raterId": 1006,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7555,
                  "rater": {
                    "raterId": 1045,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7499,
                  "rater": {
                    "raterId": 1030,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7977,
                  "rater": {
                    "raterId": 995,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7868,
                  "rater": {
                    "raterId": 1044,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6240,
          "asker": {
            "courseId": 102,
            "askerId": 1006,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nel passaggio per riferimento di un array multidimensionale ad una funzione solo la prima dimensione può essere tralasciata mentre le altre devono essere specificate nella dichiarazione della funzione?\r\nApplica le tue conoscenze sul funzionamento della memoria per rispondere a questo quesito, ponendo particolare attenzione sulla suddivisione dello stack e sui suoi meccanismi di protezione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6247,
          "asker": {
            "courseId": 102,
            "askerId": 943,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Non mi è chiaro perchè nella dichiaranzione di una variabile globale è sconsigliabile l'uso del define (es: #define N 100), mentre è preferibile utilizzare la sintassi: 'const int N=100'.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6141,
          "asker": {
            "courseId": 102,
            "askerId": 977,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "la funzione  strcmp(a,b) restituisce un valore positivo, nullo o negativo a seconda dei valori di a,b. Tuttavia com'è che opera effettivamente il confronto tra due stringhe? vengono convertite tutte le lettere nel corrispettivo valore numerico e poi confrontati i valori? tra \"hello\" e \"world\", qual'è la stringa maggiore delle due?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STRINGHE"
            },
            {
              "keyword": "STRINGHE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6139,
          "asker": {
            "courseId": 102,
            "askerId": 462,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze che caratterizzano gli array usati in C++ e quelli usati in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAY"
            },
            {
              "keyword": " ARRAY"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6179,
          "asker": {
            "courseId": 102,
            "askerId": 959,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Le funzioni ricorsive sono più \"rapide\" o più \"lente\" rispetto ad una funzione iterativa o ad un ciclo, la memoria viene gestita nello stesso modo in entrambe?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6145,
          "asker": {
            "courseId": 102,
            "askerId": 1059,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "come funziona esattamente la funzione string to integer? se nel codice viene detto di prendere in input una stringa e poi trasformarla in un intero,cosa succede se l'utente digita delle lettere invece che numeri oppure se digita un misto alfanumerico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": "stringhe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6118,
          "asker": {
            "courseId": 102,
            "askerId": 983,
            "courseFinalScore": 23
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché nella dichiarazione di un array statico non è possibile utilizzare una variabile per specificare la dimensione dell'array ?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6191,
          "asker": {
            "courseId": 102,
            "askerId": 1037,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste il tipo stringa in c++? Se no spiega come si trattano le stringhe.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STRINGHE"
            },
            {
              "keyword": "STRINGHE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6172,
          "asker": {
            "courseId": 102,
            "askerId": 1064,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "[DOMANDA TIPO ESAME]\r\nQuali sono i vantaggi e gli svantaggi dell'uso dei puntatori nel linguaggio c++? A quali problemi danno risposta e quali sono le particolari attenzioni che il programmatore deve avere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": "PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6227,
          "asker": {
            "courseId": 102,
            "askerId": 980,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Nell'implementazione dei metodi all'interno di una classe, come si comporta esattamente il costrutto this all'interno di questi? Qual è il suo metodo di utilizzo e qual è il suo comportamento?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6164,
          "asker": {
            "courseId": 102,
            "askerId": 993,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "All'interno di una classe è consigliabile specificare come public un metodo o sarebbe preferibile evitarlo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6558,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1011,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Dipende dalla funzionalità che si assegna al metodo in questione: se si tratta di un metodo che opera \"internamente\" alla classe, nel senso che non è necessario (o non è voluto) che il destinatario del codice conosca e usi il metodo, allora è bene evitare di specificarlo come public (in accordo con i principi di Parna). Se invece si tratta di un metodo che il destinatario deve conoscere e deve poter utilizzare, allora è bene specificarlo come public; altrimenti l'utente non potrà accedervi ed usufruirne (Nota: se non si specifica il modificatore di visibilità, il metodo è comunque visibile all'interno del package in cui si trova la classe cui afferisce).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7645,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7320,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7256,
                  "rater": {
                    "raterId": 1041,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7262,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7616,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7949,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7729,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6519,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1023,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "All'interno di una classe è necessario specificare come public un metodo se lo si vuole rendere tale, altrimenti il sistema imposta in automatico il metodo a private. Se sia consigliabile mettere un metodo in public o in private dipende se deve poter essere usato all'esterno della classe o meno, nel caso in cui deve poter essere usato all'esterno lo metto in public altrimenti no.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7613,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7317,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7945,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7253,
                  "rater": {
                    "raterId": 1041,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7259,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7642,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7726,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6529,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1013,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Dipende dalla visibilità che il programmatore vuole dare a quel metodo. Se si vuole che il metodo in questione possa venire richiamato anche dall'esterno, allora deve essere specificato come public. Altrimenti, se si vuole che il metodo possa essere richiamato solo all'interno della classe che lo dichiara, deve essere dichiarato come private. In C++, se un metodo non viene specificato nè come public nè come private all'interno di una classe, viene considerato di default come private.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7261,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7615,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7319,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7728,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7644,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7255,
                  "rater": {
                    "raterId": 1041,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7948,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6545,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 940,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "In generale, non c'è una risposta corretta.\r\nLa scelta tra i modificatori di visibilità 'public' e 'private' dipende da qual è il metodo che andiamo ad implementare. Se stiamo definendo una interfaccia pubblica per la classe, allora useremo 'public', nel caso contrario, invece, useremo 'private'.\r\nIn altre parole, se prevediamo che un certo metodo debba essere accessibile all'esterno della classe (tramite una invocazione del metodo stesso su di una istanza della classe), allora useremo la keyword 'public'. Se invece stiamo definendo un metodo che non vogliamo (o non è necessario) sia invocabile sulla istanza della classe (es: funzioni ausiliarie), allora useremo 'private'.\r\nRiprendendo l'esempio della pila visto a lezione:\r\n\r\nclass Pila {\r\n  \r\n  private:\r\n    int size;\r\n    int defaultGrowthSize;\r\n    int marker;\r\n    int * contenuto;\r\n    void cresci(int increment);\r\n\r\n[ Continua a leggere: http://pastebin.com/LkSCTD9U ]",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7641,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7612,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7258,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7316,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7252,
                  "rater": {
                    "raterId": 1041,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7944,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7725,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6540,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1066,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per il principio di Parna è necessario, obbligatorio, specificare se i metodi sono \"public\" o \"private\" in quanto definiscono quali sono i metodi che possono essere usati da chi usufruisce della libreria e quali no. Ad esempio il metodo \"cresci\" è definito \"private\" in quanto è utilizzato nel metodo cresci solo in caso di necessità e non si vuole che l'utente possa usufruirne. Invece l'utente deve essere libero di usare altri metodi quali il costruttore, estrai e il cresci e che quindi devono essere indicati come \"public\".\r\nDunque non è solo consigliabile ma è bensì necessario specificare lo stato \"public\" o \"private\" dei metodi a seconda che debbano essere usufruibili o meno dall'utente che usa la libreria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7257,
                  "rater": {
                    "raterId": 1041,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7617,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7263,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7946,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7321,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7646,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7730,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6495,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 979,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un metodo deve essere dichiarato \"public\" se si vuole accedervi da una zona esterna alla classe (utilizzato dall'utente finale). Se il nome del metodo non è preceduto dalla parola chiave \"public\" è implicito che il metodo sia privato e che quindi non sia accessibile dall'esterno (utilizzo interno alla classe).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7254,
                  "rater": {
                    "raterId": 1041,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7318,
                  "rater": {
                    "raterId": 1033,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7727,
                  "rater": {
                    "raterId": 465,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7260,
                  "rater": {
                    "raterId": 993,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7947,
                  "rater": {
                    "raterId": 1037,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7643,
                  "rater": {
                    "raterId": 1036,
                    "courseId": 102,
                    "courseFinalScore": 31
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7614,
                  "rater": {
                    "raterId": 1085,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6220,
          "asker": {
            "courseId": 102,
            "askerId": 1011,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Sia dato il seguente codice, scritto in linguaggio C++:\r\nint s=3;\r\nint g(int s) {\r\ns++;\r\nreturn s;\r\n}\r\nint f(int k) {\r\n    s++;\r\n    k=s;\r\n    return s;\r\n}\r\nmain(void) {\r\nint s=0;\r\ns=g(s);\r\ncout << \"s=\"<< f(s)<< \"\\n\";\r\ncout << \"s=\" << s << \"\\n\";\r\n}\r\n\r\nEseguire le seguenti consegne:\r\n- dire qual è l'OUTPUT del programma;\r\n- produrre uno schema di come viene allocata la memoria stack nel corso dell'esecuzione del programma;\r\n- utilizzare lo schema ricavato dal punto precedente per giustificare l'output del programma",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6130,
          "asker": {
            "courseId": 102,
            "askerId": 1023,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "L'allocazione degli array tramite il costrutto new in java indica che essi sono dinamici come in c++ o non ci sono differenze tra dinamici e statici?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6159,
          "asker": {
            "courseId": 102,
            "askerId": 1018,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Dato un vettore tridimensionale v, qual è un modo equivalente, utilizzando l'aritmetica dei puntatori, per visualizzare il valore dell'elemento v[1][2][3]?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": "PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6478,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 950,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Questa domanda puo' essere intesa in 2 modi:\r\n-1 il vettore tridimensionale è inteso come un vettore di matrici, quindi dichiarato come segue:\r\ntipo v[n][m][k];\r\nquindi per accedere all'elemento v[1][2][3] occorre:\r\ntipo* element = v + 3 + k*2 + 1*m;\r\nQuesto perché in un vettore tridimensionale dichiarato in questo modo è allocato sequenzialmente in ram\r\n\r\n-2 Il vettore tridimensionale è inteso come puntatore di puntatore, quindi dichiarato e inizializzato come segue:\r\ntipo*** pv;\r\npv = new tipo**[n]; //n >=3\r\n\r\nfor(int i=0; i<n; i++)\r\n  pv[i] = new int*[m]; //m>=3\r\n   for(int j=0; j<n; j++)\r\n    pv[i][j] = new int[k]; //k>=3\r\n\r\nin questo modo per accedere a v[1][2][3] bisogna:\r\nlocation = *(*(pv+3)+2)+1\r\nIn questo modo il vettore non è allocato sequenzialmente, ma in modo sparso nello heap ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8014,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7428,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7972,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7798,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7152,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6571,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1101,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "In C++ userò:\r\n[...]\r\ncout << v[1][2][3] << endl;\r\n[...]\r\n\r\nIn JAVA invece:\r\n[...]\r\nSystem.out.println(v[1][2][3]);\r\n[...]",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7151,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7426,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8015,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7799,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7969,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6485,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1083,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Un espressione equivalente che fa uso dell'aritmetica dei puntatori è la seguente:\r\n*(*(*(v+1)+2)+3)\r\nDove v come sappiamo è il puntatore all'indirizzo del primo elemento dell' array.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8018,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7425,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7800,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7971,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7148,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6546,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 932,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Per visualizzare in modo equivalente il valore dell'elemento v[1][2][3] si può scrivere *( *( *(v +1) +2) +3) .\r\n\r\nSupponendo che il vettore sia stato dichiarato int ( int v[1][2][3];) e sapendo che l'associatività dell'operatore di indice '[]' è a sinistra (ovvero che ciascun operatore '[]' si applica a tutto ciò che vi è alla sua sinistra) si ha :\r\n\r\nv[1][2][3] =>(v[1]) [2][3]    ->conversione di un identificatore array in un puntatore   dello stesso tipo ;\r\n\r\n                =>( *(v +1)) [2][3]   ->ciascun elemento dell'array v[1] è un puntatore il cui valore è l'indirizzo di memoria del primo degli array di dimensione 4 di tipo int \r\novverosia *(v +1) = v[1] \r\n\r\n                => ( *( *(v +1) +2) [3]  -> *(v +1) +2 è il puntatore al terzo elemento dell'array di dimensione 4 di tipo int , secondo elemento dell'array di dimensione 3 di tipo array di dimensione 4 di tipo int\r\n\r\n                => *( *( *(v +1) +2) +3)\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8016,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7429,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7970,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7797,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7149,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6473,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1041,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Usando l'aritmetica dei puntatori si ha \r\nv[1][2][3] = (*(v+1))[2][3] = (*(*(v+1)+2))[3] = *(*(*(v+1)+2)+3)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7795,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7968,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7153,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7427,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8019,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6615,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1044,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "utilizzando l'aritmetica dei puntatori è possibile estrarre il valore desiderato nel seguente modo:\r\n\r\n*((*(*(v+1))+2)+3)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7796,
                  "rater": {
                    "raterId": 41,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7973,
                  "rater": {
                    "raterId": 982,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7430,
                  "rater": {
                    "raterId": 1065,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8017,
                  "rater": {
                    "raterId": 1071,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7150,
                  "rater": {
                    "raterId": 1018,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            }
          ]
        },
        {
          "questionId": 6198,
          "asker": {
            "courseId": 102,
            "askerId": 1029,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le differenze tra la gestione (dinamica) della memoria in C/C++ e in Java?\r\nE' necessario l'utilizzo di metodi \"distruttori\" in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6214,
          "asker": {
            "courseId": 102,
            "askerId": 1089,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella programmazione con il linguaggio Java il passaggio parametri tramite puntatori avviene con lo stesso metodo della programmazione con il linguaggio C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6143,
          "asker": {
            "courseId": 102,
            "askerId": 990,
            "courseFinalScore": 29
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Considera l'implementazione di una Pila presentata in classe e il seguente codice.\r\n\r\nPila *pila = crea(10);\r\nfor(int i = 0; i < 1000; ++i) {\r\n\tinserisci(pila, i);\r\n}\r\n\r\nQuante riallocazioni dell'array interno alla pila sono necessarie per completare l'operazione?\r\n\r\nConsidera ora la seguente variante della funzione inserisci:\r\n\r\nvoid inserisci(Pila *s, int k) {\r\n\t//inserisci un nuovo valore\r\n\tcout<<\"entro in inserisci\"<<endl;\r\n\tif (s->size==s->marker)\r\n\t\t//cresci(s,s->defaultGrowthSize); //RIMUOVERE\r\n\t\tcresci(s,s->size); //AGGIUNGERE\r\n\ts->contenuto[s->marker]=k;\r\n\ts->marker++;\r\n}\r\n\r\nQuante riallocazioni dell'array interno alla pila sono ora necessarie per completare l'operazione?\r\nDiscuti pro e contro di ciascun approccio.\r\n\r\nConsidera ora la seguente nuova funzione:\r\n\r\nvoid reserve(Pila *s, int requestedSize) {\r\n\tif(requestedSize > s->size) {\r\n\t\tcresci(s, requestedSize - s->size);\r\n\t}\r\n}\r\n\r\nIn che casi trovi sia utile usare questa funzione?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6205,
          "asker": {
            "courseId": 102,
            "askerId": 1000,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra 'char *string1 =\"pippo\";' e 'char *string2;'?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "STRINGHE"
            },
            {
              "keyword": "STRINGHE"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6512,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 998,
                "courseId": 102,
                "courseFinalScore": 11
              },
              "answerText": "La prima espressione alloca una stringa nello stack, la seconda invece definisce semplicemente un puntatore a char senza allocare nulla in memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7349,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7442,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7777,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7531,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7679,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7807,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7605,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6581,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1025,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nel secondo caso viene definito un puntatore a char string2 ma non viene allocato spazio in memoria. Anche nella prima espressione viene definito un puntatore a char string1 ma viene anche inizializzato con \"pippo\" allocando in tal modo memoria nello stack.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7811,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7678,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7441,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7775,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7348,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7530,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7604,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6585,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1038,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Nella prima, 'char *string1 =\"pippo\";' oltre ad dichiarare un puntatore si sta anche assegnando ad esso un valore, mentre nella seconda 'char *string2;' si sta solo dichiarando la variabile puntatore.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7675,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7345,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7813,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7527,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7438,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7601,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7779,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6493,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 964,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Il primo esempio è un puntatore a char inizializzato a \"pippo\", quindi una stringa.\r\nIl secondo è un semplice puntatore di tipo char dichiarato ma non ancora inizializzato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7780,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7440,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7529,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7677,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7812,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7603,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7347,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6578,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 961,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il primo codice è un puntatore di tipo char che punta alla stringa \"pippo\".Questa operazione è sbagliata in quanto i puntatori devono essere inizializzati con un indirizzo di una cella di memoria , che la stringa \"pippo\" non ha.\r\nTramite il secondo codice si definisce un puntatore di tipo char.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7443,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7778,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7809,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7350,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7532,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7606,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7680,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6620,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1084,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La prima assegnazione indica che il puntatore a char string1 (il quale viene memorizzato nello stack) punta al primo elemento del vettore di caratteri (memorizzato nella heap).\r\nCon la seconda dichiarazione invece si riserva uno spazio di memoria (nello stack) ad un puntatore string2 al quale deve essere ancora assegnato un indirizzo di memoria a cui puntare",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7351,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7681,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7444,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7808,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7533,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7781,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7607,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6526,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 939,
                "courseId": 102,
                "courseFinalScore": 30
              },
              "answerText": "Analizziamo prima il caso 'char *string1=\"pippo\";'. In questo caso viene definito un puntatore a char e, tramite la dichiarazione effettuata, si ha che il compilatore esegue implicitamente vari passaggi: in particolare viene allocata dinamicamente memoria (nel caso in questione sarà necessario allocare in memoria 6 bytes) ed ad ognuno dei bytes viene assegnata una lettera della stringa \"pippo\"; l'ultima cella di memoria viene occupata dal terminatore di stringa '\\0'. Se si prova ad effettuare il cout di string1, esso andrà a buon fine e stamperà a video la stringa \"pippo\".\r\nNel secondo caso invece vi è semplicemente la dichiarazione di un puntatore a char ma, effettivamente, non viene allocato alcuno spazio in memoria. \r\nSe si prova ad effettuare il cout di string2, esso non andrà a buon fine e, non a caso, si genererà un problema di \"Segmentation fault\".\r\n\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7602,
                  "rater": {
                    "raterId": 1046,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7676,
                  "rater": {
                    "raterId": 1000,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7346,
                  "rater": {
                    "raterId": 979,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7439,
                  "rater": {
                    "raterId": 1101,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7528,
                  "rater": {
                    "raterId": 999,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7776,
                  "rater": {
                    "raterId": 1080,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7810,
                  "rater": {
                    "raterId": 870,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6221,
          "asker": {
            "courseId": 102,
            "askerId": 1040,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un \"Memory Leak\"? Come si provoca? Come si risolve? E attraverso quali meccanismi Java elimina la presenza di questo tipo di bug?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6132,
          "asker": {
            "courseId": 102,
            "askerId": 471,
            "courseFinalScore": 19
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo viene utilizzata una dichiarazione di tipo 'int * a' per definire un puntatore invece di un tipo base 'address'? Quali vantaggi comporta questa scelta?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Puntatori"
            },
            {
              "keyword": " Puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6568,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1089,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Viene preferito il tipo 'int * a' per riferirsi al puntatore anziché il tipo base 'address' poiché 'int * a' interpreta la variabile come un indirizzo e fornisce il valore contenuto nella cella puntata, il quale può anche essere modificato. Inoltre esso spreca meno memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7610,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7733,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7886,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7454,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7769,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7773,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6486,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 981,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Viene usata la dichiarazione di tipo int* anziché address poiché in questo modo è possibile sapere a che tipo di dato si punta e tutto ciò che ne deriva",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7608,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7731,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7772,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7452,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7767,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7885,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6596,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 860,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Operatore &a fornisce l?indirizzo della variabile a  \r\nOperatore *p invece interpreta la variabile p come un puntatore  (indirizzo) e fornisce il valore contenuto nella cella di memoria puntata.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7770,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7774,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7888,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7734,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7455,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7611,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6549,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1027,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La definizione di un puntatore come '*' permette di prescindere dal tipo precedentemente definito. Un puntatore a int o a float o a char occupa sempre lo stesso spazio di memoria. La definizione di un tipo address invece dipende dal tipo di dato che stiamo manipolando.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7771,
                  "rater": {
                    "raterId": 1029,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7732,
                  "rater": {
                    "raterId": 1067,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7887,
                  "rater": {
                    "raterId": 471,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7453,
                  "rater": {
                    "raterId": 952,
                    "courseId": 102,
                    "courseFinalScore": 19
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7768,
                  "rater": {
                    "raterId": 1096,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7609,
                  "rater": {
                    "raterId": 1024,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6124,
          "asker": {
            "courseId": 102,
            "askerId": 1003,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perché ad ogni chiamata dell'operatore \"new\" dobbiamo far corrispondere una chiamata dell'operatore \"delete\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6471,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1059,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché l'operatore \"new\" alloca dinamicamente lo necessario nella heap di conseguenza usiamo \"delete\" per deallocare al termine dell'operazione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7402,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8042,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7329,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7743,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7385,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7457,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7291,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6572,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 994,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "L'operatore \"new\" costruisce uno o più oggetti nell'area heap e ne restituisce l'indirizzo. L'operatore \"delete\" invece dealloca la memoria dell'area heap puntata dall'operando obbligatorio. Ad ogni chiamata dell'operatore \"new\" è necessario far corrispondere una chiamata dell'operatore \" delete \" perché questo è l'unico modo che abbiamo per liberare memoria puntata e renderla disponibile per ulteriori allocazioni, in modo che il programma non vada in memory leak: infatti se la memoria heap non venisse deallocata, sopravvivrebbe fino al termine del programma, anche quando non sarebbe  più raggiungibile.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7403,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7744,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7292,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7458,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7386,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7330,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8041,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6508,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1037,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Perché con l' operatore \"new\" si alloca qualcosa in memoria che ci resterá finchè non viene deallocata con l' operatore \"delete\", quindi per evitare che venga utilizzata memoria inutilmete è meglio deallocare ció che non serve piú",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7742,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7328,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7456,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7290,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7384,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8044,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7401,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6476,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 992,
                "courseId": 102,
                "courseFinalScore": 18
              },
              "answerText": "Poiché l'operatore \"new\" comporta l'occupazione di memoria (heap) e in caso di mancata deallocazione, si potrebbe incorrere in un memory leak, ovvero nella mancanza di spazio libero in memoria.\r\nGrazie all'operatore \"delete\" è possibile liberare la memoria occupata.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8043,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7459,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7293,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7745,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7404,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7331,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7387,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6605,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 914,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Dopo ogni chiamata è dell'operatore \"new\" è necessario far corrispondere una chiamata dell'operatore \"delete\" al fine di evitare il verificarsi di un \"memory leak\". L'operatore \"new\" alloca infatti uno spazio di memoria in heap che può essere reso nuovamente disponibile solo in seguito ad una chiamata dell'operatore \"delete\".",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7405,
                  "rater": {
                    "raterId": 536,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7332,
                  "rater": {
                    "raterId": 970,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7388,
                  "rater": {
                    "raterId": 1003,
                    "courseId": 102,
                    "courseFinalScore": 27
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8040,
                  "rater": {
                    "raterId": 1058,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7746,
                  "rater": {
                    "raterId": 967,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7460,
                  "rater": {
                    "raterId": 535,
                    "courseId": 102,
                    "courseFinalScore": 23
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7294,
                  "rater": {
                    "raterId": 1092,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6120,
          "asker": {
            "courseId": 102,
            "askerId": 1025,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando assegno una struct ad un'altra entrambe contenenti un array statico (allocato nello stack) come campo, tale array viene copiato per intero ottenendo come risultato due array indipendenti oppure i due campi delle struct si riferiscono allo stesso array?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ARRAYS"
            },
            {
              "keyword": " ARRAYS"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6195,
          "asker": {
            "courseId": 102,
            "askerId": 1095,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa avviene all'interno dello stack quando una funzione è ricorsiva?\r\ne cosa sono i side effects? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stack "
            },
            {
              "keyword": "ricorsiva"
            },
            {
              "keyword": " side"
            },
            {
              "keyword": " effects"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6129,
          "asker": {
            "courseId": 102,
            "askerId": 1079,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Ho un dubbio riguardante il seguente frammento di codice che si trova alla slide 43:\r\n\r\nmain() {\r\n int *pa;\r\n pa=new int;\r\n cout<<*pa<<endl; //NO!\r\n *pa=3;\r\n cout<<*pa<<endl;\r\n delete(pa);\r\n cout<<*pa<<endl; //NO!\r\n} \r\n\r\nPoichè dopo la delete non è presente nessuna istruzione(per esempio una definizione di variabile) che potrebbe modificare la zona di memoria puntata da *pa, per quale motivo l'output del terzo cout non è 3?\r\n",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6146,
          "asker": {
            "courseId": 102,
            "askerId": 988,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Esiste un modo per vedere se la deallocazione (delete[]) è andata a buon fine? Se sì quale?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6128,
          "asker": {
            "courseId": 102,
            "askerId": 960,
            "courseFinalScore": 25
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Un puntatore e un array potrebbero sembrare la stessa cosa, c'è tuttavia una semplice ma sostanziale differenza, esprimila tra questi due elementi:\r\n   -int * a;\r\n   -int * a[10];",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Array"
            },
            {
              "keyword": " Puntatori"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6487,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 946,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Come abbiamo visto, la memoria in un computer può essere divisa logicamente in \"blocchi\". Se prendiamo in considerazione il secondo caso e gli applichiamo questa logica, notiamo che cosi facendo istanziamo un array statico di Int di 10 elementi, ovvero vengono riservati 10 blocchi di memoria ciascuna di dimensione standard di un Int (4 byte); in totale abbiamo riservato uno spazio di circa 10*4 = 40byte.\r\nNel primo caso invece ci limitiamo a dichiarare un puntatore ad un blocco che conterrà degli Int; ciò significa che stiamo riservando solo 1 blocco ovvero 4 byte che non contiene un valore me bensì un puntatore. Nel caso io volessi inserire qualche valore al suo interno dovrei istanziare e quindi riservare quanto spazio necessito tramite il comando \"new\" (es. int* a = new int[10]). In questo modo ottengo un array dinamico, devo solo ricordarmi di liberare la memoria occupata alla fine tramite il comando delete, altrimenti potrei incorrere nel Memory Leak (Spreco di Memoria).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7182,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7684,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7194,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7391,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7847,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8034,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6506,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 996,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "int *a è essenzialmente un puntatore a un'area di memoria dinamica (heap) che è riservata a contenere un valore di tipo intero (considerando l'opportuna dimensione)\r\n\r\nint *a[10] invece è un array di 10 puntatori a tipo intero, ciò significa che abbiamo 10 celle di memoria di tipo \"puntatore ad intero\" allocate in stack che riservano spazio ad indirizzi di valori interi salvati dinamicamente",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7685,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7848,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8038,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7195,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7183,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7392,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6538,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1043,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "con -int * a; si definisce un puntatore a tipo intero mentre con int * a[10]; si definisce un array di puntatori ad interi",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7682,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7180,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7845,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7192,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8035,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7389,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6569,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1058,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il puntatore è una variabile sulla quale possiamo eseguire svariate operazioni, mentre un array è un insieme di oggetti ( nel senso lato , senza alcun riferimento alla programmazione ad oggetti ) dello stesso tipo .",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7181,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7849,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7683,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8039,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7390,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7193,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6539,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1031,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Suppongo che il secondo elemento dato sia stato erroneamente definito come array di puntatori ad interi, perchè per combaciare alla parte testuale della domanda dovrebbe essere un semplice array di interi (int a[10];)\r\n\r\nUn array per definizione è una collezione sequenziale di elementi omogenei, e a livello di memoria non è altro che un puntatore costante al primo elemento della sequenza. Differisce da un puntatore qualsiasi proprio per il suo essere costante. \r\nSupponendo un puntatore \"int* a\" e un array \"int b[10]\":\r\na = b; // è valido!\r\nb = &a; // NO! è costante!\r\n\r\nE' differente anche la fase di allocazione della memoria: dichiarando un puntatore verranno allocati generalmente 32-64bit (valore dipendente dalla dimensione degli indirizzi assegnati alle celle di memoria) per il salvataggio dell'indirizzo puntato dal puntatore stesso, dichiarando un array verrà invece anche allocato lo spazio necessario al contenimento dei valori dell'array, che in questo caso è 10*sizeof(int).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8037,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7393,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7846,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7184,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7686,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7196,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6602,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1033,
                "courseId": 102,
                "courseFinalScore": 21
              },
              "answerText": "Un puntatore è una variabile in cui viene memorizzato un indirizzo ed alla quale si associato un tipo (esclusi alcuni casi, i puntatori void); il tipo andrà a definire che tipologia di dato il puntatore troverà all'indirizzo in esso salvato. Quando si definisce un puntatore si alloca solamente lo spazio necessario per salvare l'indirizzo, NON lo spazio per salvare i dati. \r\nUn array è invece un puntatore al quale viene anche allocata una quantità di memoria di celle adiacenti, determinata dal programmatore e da altri fattori, nelle quali andranno a essere inseriti i dati; tale puntatore \"punterà\" alla prima cella di memoria contigua. \r\nNell'esempio sopra citato definiamo int* a come un puntatore a intero(viene allocato solo lo spazio per un indirizzo); nel secondo caso int a[10] allochiamo un puntatore e dieci celle di memoria di grandezza sizeof(int). nella domanda int* a[10] è una svista, in questo caso stiamo definendo un array di puntatori!!!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7687,
                  "rater": {
                    "raterId": 1098,
                    "courseId": 102,
                    "courseFinalScore": 14
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7185,
                  "rater": {
                    "raterId": 1002,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7197,
                  "rater": {
                    "raterId": 939,
                    "courseId": 102,
                    "courseFinalScore": 30
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8036,
                  "rater": {
                    "raterId": 956,
                    "courseId": 102,
                    "courseFinalScore": 16
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7850,
                  "rater": {
                    "raterId": 954,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7394,
                  "rater": {
                    "raterId": 960,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            }
          ]
        },
        {
          "questionId": 6114,
          "asker": {
            "courseId": 102,
            "askerId": 758,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In Java in quale parte della memoria vengono salvari gli array?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "array"
            },
            {
              "keyword": "memoria"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6201,
          "asker": {
            "courseId": 102,
            "askerId": 963,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Perchè la ricorsione (not tail-recursive) più risultare inefficiente per quanto riguarda l'uso della memoria e quale problema può generare?\r\n\r\nes. funzione not tail-recursive:\r\nint fattoriale(int n)\r\n{\r\n  if (n == 0) return 1;\r\n  else return n*fattoriale(n-1);\r\n}",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6217,
          "asker": {
            "courseId": 102,
            "askerId": 955,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Riguardo Java, come mai si devono inserire le parole \"String[] args\" nelle parentesi tonde dopo la dichiarazione del main?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "STRINGHE"
            },
            {
              "keyword": " STRINGHE"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6206,
          "asker": {
            "courseId": 102,
            "askerId": 932,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra l'uso di variabili globali e l'uso di variabili automatiche?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Variabili"
            },
            {
              "keyword": " globali"
            },
            {
              "keyword": " automatiche"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6576,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1050,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una variabile globale è una variabile che viene definita in un blocco esterno divenendo visibile anche in tutti i sottoblocchi e quindi utilizzabile in essi (a meno che dentro uno di questi sottoblocchi non sia definita un'altra variabile locale con lo stesso nome, che allora va a mascherare la precedente dichiarazione).\r\nUna variabile automatica è invece una variabile locale definita in un blocco interno, la cui dichiarazione è valida solo fino all'uscita da tale blocco (dopo la quale essa diventa inaccessibile).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7468,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7227,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7662,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7966,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7535,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7864,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6481,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 942,
                "courseId": 102,
                "courseFinalScore": 20
              },
              "answerText": "Mentre le variabili automatiche vengono dichiarate all'interno di un blocco di istruzioni e sono accessibili solamente da quel blocco (a meno di essere passate per puntatore e/o reference), quelle globali sono dichiarate all'esterno di ogni blocco di istruzioni e sono accessibili da qualunque punto del codice, a condizione che non vengano create altre variabili locali con il medesimo nome. Inoltre, la posizione di memoria nella quale vengono salvate le variabili globali è diversa da quella nella quale vengono allocate le variabili automatiche, poichè mentre le prime vengono allocate in una specifica area di memoria dedicata, mentre le altre vengono salvate all'interno dell'area stack.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7471,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7538,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7863,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7230,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7665,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7964,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6606,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1092,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Le variabili globali sono allocate nel data segment, sono accessibili da ogni punto del codice e la loro durata è pari a quella del programma. Quelle automatiche ovvero locali di una funzione, sono allocate nello stack. Si può accedere solo dall'interno del blocco di codice in cui sono state dichiarate e vengono deallocate al termine di quel blocco.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7860,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7667,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7540,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7232,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7965,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7473,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6474,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1069,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Le variabili locali sono visibili e accessibili in qualsiasi punto del programma, mentre le variabili automatiche hanno uno scope limitato al blocco di codice in cui sono dichiarate. Le prime possono causare problemi, soprattutto se a lavorare sullo stesso progetto sono gruppi diversi di persone, quindi il loro utilizzo è fortemente sconsigliato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7470,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7537,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7664,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7963,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7861,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7229,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6489,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1039,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "le variabili globali sono visibili a tutte le funzioni del programma, mentre le variabili automatiche sono utilizzate solo all'interno dello scope che le ha create.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7536,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7469,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7228,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7858,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7961,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7663,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6566,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 965,
                "courseId": 102,
                "courseFinalScore": 17
              },
              "answerText": "Una variabile globale è visibile in tutto il programma ed ha un \"tempo di vita\" che coincide con tutta la durata dell'esecuzione del codice. Mentre le variabili automatiche hanno un \"tempo di vita\" che coincide con l'esecuzione di un determinato blocco di codice, eg. una funzione; infatti alla fine dell'esecuzione di tale blocco, viene deallocata la memoria assegnata alle variabili automatiche (per esempio lo sono quelle locali). ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7666,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7967,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7231,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7862,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7539,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7472,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6616,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 952,
                "courseId": 102,
                "courseFinalScore": 19
              },
              "answerText": "Le variabili automatiche, o più comunemente chiamate locali, si utilizzano per mantenere un certo information hiding all'interno del programma. Utilizzando questo tipo di variabili, inoltre, si evitano confusioni all'interno del codice sapendo precisamente dove quella variabile vive, viene modificata e deallocata. Se utilizziamo variabili locali sarà più facile mantenere il codice perchè non dobbiamo preoccuparci di conoscere l'intero codice, ma soltanto il blocco isolato dove quella variabile è visibile. Quindi variabili locali: + leggibilità del codice, + manutenibilità del codice e - rischi di incorrere in bug non voluti o modifiche indesiderate. L'uso delle variabili globali invece dovrebbe essere ridotto all'osso perchè, appunto, innalzano la percentuale di errori nel programma e riducono la leggibilità/manutenibilità del codice. Queste sarebbero le differenze a livello \"utente - programmatore\" ma anche la gestione della memoria delle due è differente.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7467,
                  "rater": {
                    "raterId": 908,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7534,
                  "rater": {
                    "raterId": 1012,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7661,
                  "rater": {
                    "raterId": 1049,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7226,
                  "rater": {
                    "raterId": 1001,
                    "courseId": 102,
                    "courseFinalScore": 25
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7859,
                  "rater": {
                    "raterId": 932,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7962,
                  "rater": {
                    "raterId": 1070,
                    "courseId": 102,
                    "courseFinalScore": 10
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6219,
          "asker": {
            "courseId": 102,
            "askerId": 947,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "C'è un limite massimo alla quantità di puntatori da usare all'interno di un singolo blocco di istruzioni?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6169,
          "asker": {
            "courseId": 102,
            "askerId": 1046,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Come lavora l'operatore \"new\"? E l'operatore \"delete\"? Che problematica sorge se non viene utilizzato \"delete\"?  ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6133,
          "asker": {
            "courseId": 102,
            "askerId": 1065,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenze tra le aree di memoria \"stack\" ed \"heap\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6238,
          "asker": {
            "courseId": 102,
            "askerId": 1030,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual e' la differenza tra una classe pubblica e una privata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6250,
          "asker": {
            "courseId": 102,
            "askerId": 1060,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il \"memory leak\", da cosa viene causato e perché è un errore scomodo da risolvere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "allocazione dinamica"
            },
            {
              "keyword": " memory leak"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6116,
          "asker": {
            "courseId": 102,
            "askerId": 970,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Curiosità sull'allocazione della memoria in Java: nelle slide c'è scritto che i boolean occupano un solo bit in memoria. Ma effettivamente viene allocato interamente un registro di memoria? O soltanto il singolo bit (non mi capacito di come possa accadere quest'ultima cosa)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6228,
          "asker": {
            "courseId": 102,
            "askerId": 1081,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le conseguenze a breve ed a lungo termine della mancata deallocazione della memoria allocata dinamicamente? La deallocazione, per quanto relativo al linguaggio C++, deve sempre avvenire in modo esplicito?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6151,
          "asker": {
            "courseId": 102,
            "askerId": 1084,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Descrivi cosa succede in memoria quando è in esecuzione una funzione ricorsiva. Quali problematiche possono verificarsi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6593,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1015,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Le chiamate ricorsive di una funzione occupano spazio nello stack; più in particolare, ogni chiamata effettuata alloca nello stack spazio per la funzione stessa, aumentando sempre di più lo spazio occupato ad ogni chiamata, e riducendolo solo quando non vengono più effettuate ulteriori chiamate (ovvero quando si arriva alla fine dell'ultima funzione chiamata)\r\nCiò può risultare problematico qualora si effettuassero molteplici chiamate ricorsive, occupando tutto lo spazio disponibile per lo stack.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7223,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7267,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7956,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6492,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 959,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La ricorsione occupa lo stack in base a quante chiamate esegue, occupando una grande quantità di memoria. Nel caso ci sia poca memoria o un di un processore poco potente è meglio non usare la ricorsione in quanto potrebbe non eseguire il programma o andare in overflow. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7268,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7955,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7224,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6547,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1073,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si ha un aumento di memoria utilizzata ogni volta che la funzione effettua la ricorsione perché abbiamo una continua allocazione di nuove variabili, quindi la problematica principale è non avere più memoria libera",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7220,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7264,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7957,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6591,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 958,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Una funzione ricorsiva richiama se stessa, quindi ad ogni richiamo viene salvata in memoria la chiamata alla funzione, queste accumulandosi possono portare all'assenza di spazio libero in memoria.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7221,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7265,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7960,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6580,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 960,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Nella memoria stack del programma si sovrappongono, formando un \"pila\" appunto, gli spazi di memoria dedicati alla funzione contenenti per esempio le variabili. La problematica più frequente è verificata quando una funzione esegue la ricorsione un numero elevato di volte, accrescendo lo stack a dismisura, andando così in stack overflow.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7958,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7222,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7266,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6502,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1085,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Durante una funzione ricorsiva viene occupata la memoria Steck a seconda della quantità ed il tipo di variabili sono presenti al suo interno, in oltre l'utilizzo della memoria dipende dal fatto che se in un determinato momento durante l'esecuzione del programma la funzione venga utilizzata o meno.\r\nL'utilizzo di funzioni ricorsive può causare un indesiderato aumento di occupazione di memoria fino a saturarla.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7959,
                  "rater": {
                    "raterId": 914,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7225,
                  "rater": {
                    "raterId": 758,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7269,
                  "rater": {
                    "raterId": 464,
                    "courseId": 102,
                    "courseFinalScore": 18
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "questionId": 6138,
          "asker": {
            "courseId": 102,
            "askerId": 978,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Spiega che cos'è il costruttore di una classe e a cosa serve.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6483,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1014,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "Il costruttore è una particolare funzione che viene invocata ogni volta che viene creato un oggetto della classe e serve appunto a creare una istanza dell'oggetto che la classe descrive, riservando per esso la memoria di cui necessita. Il costruttore, inoltre, ha sempre il nome della classe e deve essere dichiarato public.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7570,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7909,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7633,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7476,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7919,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7206,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6505,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1061,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il costruttore è un metodo speciale che riserva spazio in memoria (heap) e inizializza tale spazio.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7631,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7908,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7474,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7918,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7204,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7568,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6556,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1068,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il costruttore è quel metodo di una classe il cui compito è quello di creare nuove istanze, è anche il punto del programma in cui un nuovo elemento viene creato ed è reso disponibile per l?interazione con il resto del sistema.\r\nEsistono due tipi speciali di costruttori: i default constructor e i copy constructor; la differenza viene riconosciuta dal fatto che nel primo non viene passato alcun parametro invece nel secondo vengono copiate tutte le proprietà dell'istanza che viene passata. \r\nInoltre il costruttore può essere implicito o privato in base alla visibilità rispetto alle altri classi. Il costruttore implicito crea e istanzia le variabili ma non viene descritto nel codice sorgente. Il costruttore privato non è visibile alle altre classi, per creare \r\nl'oggetto viene creato un metodo statico con tipo di ritorno, in questo modo non vengono creati oggetti non utilizzati o con caratteristiche non idonee.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7475,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7910,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7205,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7569,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7632,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7920,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6574,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 983,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "Il costruttore di una classe è un metodo senza tipo di ritorno e definito con lo stesso nome della classe.\r\nIl metodo costruttore viene automaticamente chiamato ogni volta che si crea un nuovo oggetto della classe associata tramite new, ad esempio \" cerchio = new figura() \" chiamerà il metodo costruttore della classe figura, nell'esempio il metodo non ha argomenti, ma può averne come un qualsiasi altro metodo.\r\nSe il metodo costruttore per una particolare classe non è stato creato l'oggetto verrà creato come se ci fosse un metodo costruttore vuoto(senza nessun comando), ciò tipicamente significa che l'oggetto non avrà nessun campo inizializzato.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7634,
                  "rater": {
                    "raterId": 1042,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7917,
                  "rater": {
                    "raterId": 1073,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7571,
                  "rater": {
                    "raterId": 1034,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7911,
                  "rater": {
                    "raterId": 1031,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7207,
                  "rater": {
                    "raterId": 1020,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7477,
                  "rater": {
                    "raterId": 978,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6171,
          "asker": {
            "courseId": 102,
            "askerId": 41,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual'è la differenza tra stack e heap?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6126,
          "asker": {
            "courseId": 102,
            "askerId": 1033,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "A lezione abbiamo visto alcuni metodi per implementare una pila (inglese stack); in particolare, è stata illustrata in dettaglio la realizzazione di una pila tramite array dinamico. \r\nDescrivi brevemente i vantaggi e gli svantaggi di una tale implementazione (ad esempio rispetto all'utilizzo di un array statico!). Conosci altri modi di implementare una pila (*Programmazione1)?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6223,
          "asker": {
            "courseId": 102,
            "askerId": 536,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è il preprocessore e quale funzione ha nel C++?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "preprocessore"
            },
            {
              "keyword": " c++"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6154,
          "asker": {
            "courseId": 102,
            "askerId": 972,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Domanda da esame: quali sono i vantaggi derivanti dall'usare una pila e quali sono le funzioni che dovrebbero essere implementate? Come le implenteresti in modo che il costo computazionale per ogni operazione rimanga costante?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6150,
          "asker": {
            "courseId": 102,
            "askerId": 986,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra stack e heap? Qual è il loro utilizzo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6199,
          "asker": {
            "courseId": 102,
            "askerId": 984,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra scope statico e scope dinamico?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "  ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6204,
          "asker": {
            "courseId": 102,
            "askerId": 58,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "E' possibile che lo stack cresca fino a sovrapporsi all'heap o viceversa? Se sì, cosa succede?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6244,
          "asker": {
            "courseId": 102,
            "askerId": 943,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Non mi è chiaro perchè nella dichiaranzione di una variabile globale è sconsigliabile l'uso del define (es: #define N 100), mentre è preferibile utilizzare la sintassi: 'const int N=100'.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6197,
          "asker": {
            "courseId": 102,
            "askerId": 908,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza tra allocazione statica e allocazione dinamica della memoria?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6192,
          "asker": {
            "courseId": 102,
            "askerId": 465,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In C++ esiste un tipo specifico per dichiarare le stringhe? Se no, come vengo dichiarate?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": " stringhe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6208,
          "asker": {
            "courseId": 102,
            "askerId": 1050,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Nella creazione di una Coda in Java, analoga all'esempio seguito per la creazione di una Pila, è possibile definire una grandezza massima per creare una lista circolare (dunque senza funzione \"cresci\")? O basta creare una Coda lineare FIFO che cresce man mano vengono aggiunti elementi?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6194,
          "asker": {
            "courseId": 102,
            "askerId": 856,
            "courseFinalScore": 20
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quale motivo il tipo \"stringa\" in c++ non è implementato come un tipo primitivo?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "stringhe"
            },
            {
              "keyword": " stringhe"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6155,
          "asker": {
            "courseId": 102,
            "askerId": 979,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Data una variabile \"int a\" qual è la differenza tra un'istruzione che contiene \"a++\" e un'istruzione che contiene \"++a\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "incrementare"
            },
            {
              "keyword": " variabili"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6216,
          "asker": {
            "courseId": 102,
            "askerId": 996,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Un il nome di una variabile puntatore può essere usato anche per definire una variabile comune (int, float, ecc.) senza che le due interferiscano?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6235,
          "asker": {
            "courseId": 102,
            "askerId": 1002,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile definire funzioni ricorsive all'interno di una funzione ricorsiva?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6215,
          "asker": {
            "courseId": 102,
            "askerId": 1005,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual é la differenza tra class e struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6185,
          "asker": {
            "courseId": 102,
            "askerId": 949,
            "courseFinalScore": 28
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In che modo gli oggetti e le struct rispettano i principi di Parna?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6498,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 970,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Parte fondamentale della programmazione ad oggetti é il nascondere dall'esterno della classe (o della struct) tutto ciò che non è necessario per il suo utilizzo. Tra oggetti e struct c'è però una differenza fondamentale: in un oggetto tutto é \"nascosto\" (private) se non esplicitamente dichiarato pubblico; in una struct invece tutto é pubblico, bisogna quindi andare a \"nascondere\" tutti gli elementi che non si vuole rendere visibili esternamente (come \"attributi\" e eventuali \"metodi\" [ho abusato di una nomenclatura tipica della programmazione ad oggetti, per questo ho virgolettato questi ultimi due termini])",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8029,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7298,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7750,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8007,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7671,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6584,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 908,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Secondo i principi di Parna, il committente e l'implementatore di una funzione devono dare tutte le informazioni necessarie a realizzare e usare quella specifica funzione, e nulla i più.\r\nQuesto significa che gli oggetti e le struct che vengono \"creati\" per realizzare la funzione vengono utilizzati senza tenere conto di quello che succede al di fuori di quella funzione.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7751,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8030,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7299,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7672,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8009,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6515,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1003,
                "courseId": 102,
                "courseFinalScore": 27
              },
              "answerText": "In maniera diversa: negli oggetti (che sono istanze delle classi) tutti i campi (detti \"dati\") sono di default privati, ovvero possono essere modificati solo all'interno della classe stessa ma NON possono essere modificati dall'esterno, se non con l'utilizzo di funzioni (detti \"metodi) forniti dalla classe. Al contrario nelle struct tutti i campi e le funzioni sono pubblici per default, ovvero accessibili direttamente da qualsiasi parte del programma.\r\nPossiamo quindi dire che le classi rispettano maggiormente i principi di Parna anche se lo stesso risultato può essere raggiunto dalle struct mediante l'utilizzo di modificatori quali \"private\".\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8028,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7674,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8011,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7301,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7753,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6517,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 951,
                "courseId": 102,
                "courseFinalScore": 15
              },
              "answerText": "Negli oggetti e nelle struct è possibile assegnare ai metodi una valenza \"private\" in modo che non siano visibili ad altri programmatori, mentre ad altri la valenza \"public\" che permettono di essere visibili e utilizzabili da tutti!! Inoltre dentro una struct/oggetto sono visibili solo le dichiarazioni delle funzioni e non le definizioni delle stesse che si trovano anche il file diversi!!",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7300,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7752,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8027,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7673,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8008,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6516,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1019,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "I dati e metodi delle strutture e delle classi possono essere resi non visibili ai programmatori che dovranno utilizzare il codice: è perciò buona norma fare in modo di fornire solo i dati veramente necessari per l' utilizzo e tenere per noi tutte le procedure interne al funzionamento del codice. In questo senso classi e struct possono rispettare i principi di Parna.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7749,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8031,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7297,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7670,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 8012,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6612,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1082,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Si parla di principi di Parna quando un implementatore deve ricevere solo le informazioni necessarie per svolgere il suo compito e deve dare solo le informazioni necessarie all'utente per usare la funzione da lui creata.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7296,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8010,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7748,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 8032,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7669,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6534,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1048,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Gli oggetti e le strutture possono dar vita a quello che si chiama Object Oriented Programming, ovvero un tipo di programmazione orientata agli oggetti. Questo permette di creare varie strutture con dettagli implementativi nascosti all'utente, come appunto dichiara uno dei principi di Parna. Inoltre quando il codice sorgente è composto da strutture ed oggetti indipendenti, o per meglio dire, utilizzabili da più programmi, esso può essere modificato più facilimente e in modo più specifico, permettendo allo sviluppatore di modificare solo ed esclusivamente la parte del programma che gli è stata assegnata senza venire a conoscenza delle altre componenti.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7747,
                  "rater": {
                    "raterId": 991,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8033,
                  "rater": {
                    "raterId": 1094,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7295,
                  "rater": {
                    "raterId": 948,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8013,
                  "rater": {
                    "raterId": 949,
                    "courseId": 102,
                    "courseFinalScore": 28
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7668,
                  "rater": {
                    "raterId": 1047,
                    "courseId": 102,
                    "courseFinalScore": 26
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6168,
          "asker": {
            "courseId": 102,
            "askerId": 944,
            "courseFinalScore": 21
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Per quanto riguarda le classi, i campi privi di uno specificatore (public/private) sono considerati automaticamente public o private?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6148,
          "asker": {
            "courseId": 102,
            "askerId": 1014,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la differenza fra la parte di memoria denominata stack e la parte di memoria denominata heap?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6202,
          "asker": {
            "courseId": 102,
            "askerId": 1051,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Nel caso in cui lo stack e lo heap hanno riempito tutta la memoria disponibile, se usassi la parola chiave \"nothrow\" per allocare una variabile, quest'ultima non viene allocata?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6153,
          "asker": {
            "courseId": 102,
            "askerId": 975,
            "courseFinalScore": 22
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cosa è \"this\" se usato all'interno di una funzione definita all'interno dello struct \"Persona\"?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6608,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 58,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "this è un puntatore che punta all'oggetto per cui è stata richiamata la funzione che lo contiene.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7852,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7237,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7435,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7788,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7898,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7410,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7449,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6618,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1099,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "this usato all'interno di un costruttore ti consente di ritornare la struttura tramite un passaggio per riferimento",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7431,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7899,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7445,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7793,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7233,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7406,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7856,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6544,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 758,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il riferimento this in Java viene utilizzato per fare riferimento, all?interno di un metodo o di un costruttore, agli attributi o metodi locali. Questo tipo di riferimento non fa altro che puntare all?oggetto a cui appartiene risolvendo possibili problemi di ambiguità.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7900,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7451,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7790,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7239,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7437,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7412,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7851,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6479,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 995,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "\"This\" all'interno di una funzione definita nella struct \"Persona\" indica l'oggetto (che prende il nome di \"istanza di classe\") sul quale la funzione deve agire.\r\nPiu' formalmente la funzione e' un metodo della classe \"Persona\" che, essendo tale, e' implementato per operare su una qualsiasi istanza di \"Persona\", percio' risulta necessario un modo per riferirsi all'istanza chiamante e proprio per questo il linguaggio ci offre la keyword \"this\".\r\n\r\nE' da notare che esso viene utilizzato tramite l'operatore \"->\", infatti \"this\" e' semplicemente un puntatore all'oggetto chiamante, che viene dichiarato (e poi inizializzato) implicitamente con la classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7896,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7794,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7434,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7853,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7409,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7448,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7236,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6496,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 441,
                "courseId": 102,
                "courseFinalScore": 23
              },
              "answerText": "E' un comando che richiama la struct \"Persona\"",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7902,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7789,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7408,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7433,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7854,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7235,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7447,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                }
              ]
            },
            {
              "answerId": 6488,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1064,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La parola chiave \"this\", se usata all'interno di una funzione interna ad una struct, costituisce un alias della struct stessa. Usando dunque \"this\" all'interno di una funzione contenuta in \"Persona\", la funzione potra' fare riferimento alla struct stessa, \"Persona\", accedendo alle sue variabili e le sue funzioni. ",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7791,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7436,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7901,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7855,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7411,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7450,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7238,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                }
              ]
            },
            {
              "answerId": 6550,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1080,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Se utilizzato in questa maniera, il this permette di intervenire su uno dei campi di persona, come ad esempio un eventuale nome o cognome.     Es. cin >> this->nome;  \r\nmi raccomando attento ad individuare dove va usato il dereference e dove il punto ;)",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7897,
                  "rater": {
                    "raterId": 1078,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7407,
                  "rater": {
                    "raterId": 975,
                    "courseId": 102,
                    "courseFinalScore": 22
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7432,
                  "rater": {
                    "raterId": 1104,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7792,
                  "rater": {
                    "raterId": 1038,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7857,
                  "rater": {
                    "raterId": 964,
                    "courseId": 102,
                    "courseFinalScore": 15
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7234,
                  "rater": {
                    "raterId": 782,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7446,
                  "rater": {
                    "raterId": 994,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            }
          ]
        },
        {
          "questionId": 6189,
          "asker": {
            "courseId": 102,
            "askerId": 945,
            "courseFinalScore": 26
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i principali rischi dell'utilizzo dell'allocazione dinamica?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA "
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA "
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6180,
          "asker": {
            "courseId": 102,
            "askerId": 962,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "È sempre possibile passare un parametro a una funzione per puntatore? Se no, quando non lo è?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "PUNTATORI"
            },
            {
              "keyword": " PUNTATORI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6230,
          "asker": {
            "courseId": 102,
            "askerId": 957,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quando implemento uno stack in c++ utilizzando uno struct, quali sono i rischi dal punto di vista della gestione della memoria in cui posso incorrere?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6142,
          "asker": {
            "courseId": 102,
            "askerId": 1031,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Cos'è un distruttore? Come si definisce un distruttore in Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": "CLASSI"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6147,
          "asker": {
            "courseId": 102,
            "askerId": 527,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Qual è la principale differenza tra class e struct?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "Class"
            },
            {
              "keyword": " Struct"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6520,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1042,
                "courseId": 102,
                "courseFinalScore": 29
              },
              "answerText": "In c++ la principale differenza fra classi e strutture consiste nel fatto che i membri di una classe sono di default privati, mentre quelli di una struttura sono di default pubblici.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7566,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7486,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7423,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7711,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7989,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8046,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6522,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 974,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Class e struct hanno due principali differenze: \r\n1) la prima è che se non è specificato diversamente le struct sono di default pubbliche mentre le class sono private. Questa differenza segue i Principi di Parna secondo cui l'utente deve sapere solo lo stretto indispensabile ad utilizzare il programma;\r\n2) la seconda differenza riguarda la memoria, infatti la struct è un tipo di valore ed è quindi allocata nello stack mentre la class è un tipo di riferimento ed è quindi allocata nella heap.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7485,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7422,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7710,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8047,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7990,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7565,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6468,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1072,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il livello di accesso di default di una struct è  public (e non se ne possono specificare altri ad essa) mentre quello di una class è  private.  Pere classi esistono i livelli di accesso public e private. Si può decidere così  a quali funzioni esterne o interne alla classe garanutire l'accesso al suo contenuto. Inoltre le classi sono un tipo di dato che include campi, variabili e metodi su di essa.  \r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7487,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7567,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7988,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8045,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7712,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7424,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6562,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1016,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "La principale differenza tra struct e class è che gli attributi appartenenti ad una struct sono di default pubblici mentre gli attributi di una class sono di default privati.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8048,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7987,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7484,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7564,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7709,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7421,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6587,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1076,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Sostanzialmente la differenza sta in come vengono memorizzati i dati. Quando viene creato un oggetto della classe, la variabile contenente l'oggetto in realtà è un riferimento alla zona di memoria dove sono salvati i dati (nel caso si cerchi di copiare in un altra variabile tale oggetto, le modifiche avvengono appunto in entrambe le variabili). Quando viene creata una struttura invece i dati sono effettivamente contenuti nella variabile alla quale è assegnata (infatti nel caso venga copiata in una nuova variabile e venga apportata una modifica, tale operazione avverrà solo nella variabile utilizzata).",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8049,
                  "rater": {
                    "raterId": 984,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7986,
                  "rater": {
                    "raterId": 1011,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7420,
                  "rater": {
                    "raterId": 1089,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7708,
                  "rater": {
                    "raterId": 940,
                    "courseId": 102,
                    "courseFinalScore": 21
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7563,
                  "rater": {
                    "raterId": 1025,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7483,
                  "rater": {
                    "raterId": 527,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            }
          ]
        },
        {
          "questionId": 6158,
          "asker": {
            "courseId": 102,
            "askerId": 1028,
            "courseFinalScore": 24
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "In una classe, a cosa serve il metodo distruttore? In che maniera viene invocato?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": true,
          "chosenForMultipleChoice": true,
          "keywords": [
            {
              "keyword": "CLASSI"
            },
            {
              "keyword": " CLASSI"
            }
          ],
          "notes": "-",
          "answers": [
            {
              "answerId": 6604,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1051,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "esattamente come il \"delete\" serviva per liberare la memoria da variabili allocate dinamicamente, il metodo distruttore serve liberare la memoria da eventuali oggetti della classe. Il metodo distruttore viene invocato direttamente alla distruzione dell'oggetto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 8026,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7654,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7735,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7358,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7302,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7158,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7333,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                }
              ]
            },
            {
              "answerId": 6582,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 943,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il distruttore è un particolare metodo invocato al termine della vita di un oggetto che (in contrapposizione al costruttore) serve a deallocare correttamente la memoria e le risorse dedicate all'oggetto durante la sua esecuzione.\r\n\r\nSi invoca con ~NomeClasse(); e viene solitamente eseguito dal Garbage Collector.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7155,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7304,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7656,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7360,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7737,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7335,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 8020,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6613,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1045,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo distruttore serve a liberare la memoria occupata dalla classe: sebbene la memoria sia gestita automaticamente dal garbage collector può esserci comunque la necessità di utilizzare il metodo distruttore, ad esempio per eliminare file temporanei generati dalla classe. Il metodo è chiamato \"finalize()\" e può essere invocato dal sistema. Non si è comunque certi che dopo una chiamata di System.gc() venga attivato il garbage collector, per questo è buona norma invocare con System.runFinalization(), ovvero la chiamata al metodo distruttore, immediatamente dopo la chiamata al garbage collector.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7154,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 8024,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7308,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7364,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7339,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7741,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7660,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                }
              ]
            },
            {
              "answerId": 6555,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1040,
                "courseId": 102,
                "courseFinalScore": 25
              },
              "answerText": "Il metodo distruttore \"public void finalize()\" di una classe serve a liberare la memoria allocata da un oggetto (e dai suoi metodi). Viene invocato dal garbage collector quando l'oggetto viene distrutto.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7740,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7659,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7307,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7159,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7363,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7338,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 8022,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6570,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 997,
                "courseId": 102,
                "courseFinalScore": 0
              },
              "answerText": "Il metodo distruttore serve per evitare il fenomeno di \"memory leak\", ossia un programma che continua ad allocare memoria senza mai liberarne; l'effetto è non trascurabile: il programma viene bruscamente arrestato. E' importante notare che prima va cancellato il contenuto, poi la pila, altriementi perdo l'informazione per arrivare al blocco di memoria e non riesco a cancellarlo.\r\n",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7305,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7657,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8023,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7361,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7738,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 0
                },
                {
                  "coinId": 7156,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 1
                },
                {
                  "coinId": 7336,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            },
            {
              "answerId": 6589,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1053,
                "courseId": 102,
                "courseFinalScore": 28
              },
              "answerText": "Il distruttore è un particolare metodo che viene richiamato alla distruzione dell'oggetto. Esso permette di liberare la memoria utilizzata dall'oggetto (allocata dal costruttore e da eventuali altre risorse allocate dinamicamente durante l'esecuzione). In Java si implementa tramite il metodo \"finalize()\". Viene richiamato anche dal Garbage Collector.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7362,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7337,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7658,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7157,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8021,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7306,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7739,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                }
              ]
            },
            {
              "answerId": 6524,
              "task": {
                "taskId": 181,
                "taskName": "Answer A Question"
              },
              "responder": {
                "responderId": 1034,
                "courseId": 102,
                "courseFinalScore": 24
              },
              "answerText": "Il metodo distruttore serve ad eseguire alcune operazioni prima della eliminazione di un oggetto. Nel caso particolare del c++, è assolutamente necessario deallocare nel distruttore eventuali elementi allocati dinamicamente all'interno della stessa classe, altrimenti si generano dei memory leak. L'invocazione avviene automaticamente quando si esegue ```delete``` di una istanza della classe.",
              "notes": "-",
              "rating": 0,
              "coins": [
                {
                  "coinId": 7736,
                  "rater": {
                    "raterId": 989,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 8025,
                  "rater": {
                    "raterId": 965,
                    "courseId": 102,
                    "courseFinalScore": 17
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 2
                },
                {
                  "coinId": 7655,
                  "rater": {
                    "raterId": 1066,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 5
                },
                {
                  "coinId": 7303,
                  "rater": {
                    "raterId": 990,
                    "courseId": 102,
                    "courseFinalScore": 29
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 4
                },
                {
                  "coinId": 7359,
                  "rater": {
                    "raterId": 1028,
                    "courseId": 102,
                    "courseFinalScore": 24
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7160,
                  "rater": {
                    "raterId": 1022,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                },
                {
                  "coinId": 7334,
                  "rater": {
                    "raterId": 1079,
                    "courseId": 102,
                    "courseFinalScore": 0
                  },
                  "task": {
                    "taskId": 181,
                    "taskName": "Answer A Question"
                  },
                  "value": 3
                }
              ]
            }
          ]
        },
        {
          "questionId": 6190,
          "asker": {
            "courseId": 102,
            "askerId": 995,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Riguardo all'allocazione in Java di un booleano, alla slide #37 di martedì 16 febbraio e' riportata come dimensione quella di 1 singolo bit. Se non erro le celle dei banchi di RAM sono suddivise in byte, quindi non capisco come sia possibile che un booleano occupi solo un bit.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6136,
          "asker": {
            "courseId": 102,
            "askerId": 954,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono le principali differenziazioni sintattiche di base del C++ rispetto a Java?\r\nCosa semplifica Java?",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "C++"
            },
            {
              "keyword": " differenza"
            },
            {
              "keyword": " java"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6229,
          "asker": {
            "courseId": 102,
            "askerId": 1038,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Illustrare le tecniche attraverso le quali Java elimina alcuni degli errori più\r\nfrequenti legati alla gestione della memoria, e spiegare perché sono state introdotte.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6210,
          "asker": {
            "courseId": 102,
            "askerId": 1015,
            "courseFinalScore": 27
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "È possibile implementare in c++ arrays virtualmente privi di dimensione massima (ovvero che si espandano automaticamente di quanto richiesto in caso si tenti di accedere ad un indice inesistente in fase di lettura/scrittura) cui si possa accedere solo tramite specifiche funzioni? \r\nSe si, spiegare concettualmente come procedere con l'implementazione.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA"
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6249,
          "asker": {
            "courseId": 102,
            "askerId": 1100,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Si considerino le seguenti funzioni:\r\nvoid sigma()\r\n{\r\n    sigma();\r\n}\r\nvoid gamma()\r\n{\r\n    while (true) \r\n\tmalloc(1024);\r\n}\r\nSi descriva il funzionamento delle funzioni \"sigma\" e \"gamma\", evidenziando in particolare l'effetto che hanno sulla memoria.",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "overflow"
            },
            {
              "keyword": " resource exhausting"
            }
          ],
          "notes": "-",
          "answers": []
        },
        {
          "questionId": 6187,
          "asker": {
            "courseId": 102,
            "askerId": 982,
            "courseFinalScore": 0
          },
          "task": {
            "taskId": 180,
            "taskName": "Ask A Question"
          },
          "questionText": "Quali sono i vantaggi e gli svantaggi dell'allocazione dinamica e di quella statica? ",
          "totalDifficultyLevel": 0,
          "totalInterestingnessLevel": 0,
          "totalRelevanceLevel": 0,
          "numEvaluators": 0,
          "chosenForAnswering": false,
          "chosenForMultipleChoice": false,
          "keywords": [
            {
              "keyword": "ALLOCAZIONE_MEMORIA "
            },
            {
              "keyword": " ALLOCAZIONE_MEMORIA "
            }
          ],
          "notes": "-",
          "answers": []
        }
      ]
    }
  ]
}
